{"ast":null,"code":"let fs = require('fs');\n\nlet Task = require('./task').Task;\n\nfunction isFileOrDirectory(t) {\n  return t instanceof FileTask || t instanceof DirectoryTask;\n}\n\nfunction isFile(t) {\n  return t instanceof FileTask && !(t instanceof DirectoryTask);\n}\n/**\n  @name jake\n  @namespace jake\n*/\n\n/**\n  @name jake.FileTask\n  @class`\n  @extentds Task\n  @description A Jake FileTask\n\n  @param {String} name The name of the Task\n  @param {Array} [prereqs] Prerequisites to be run before this task\n  @param {Function} [action] The action to perform to create this file\n  @param {Object} [opts]\n    @param {Array} [opts.asyc=false] Perform this task asynchronously.\n    If you flag a task with this option, you must call the global\n    `complete` method inside the task's action, for execution to proceed\n    to the next task.\n */\n\n\nclass FileTask extends Task {\n  constructor() {\n    super(...arguments);\n    this.dummy = false;\n\n    if (fs.existsSync(this.name)) {\n      this.updateModTime();\n    } else {\n      this.modTime = null;\n    }\n  }\n\n  isNeeded() {\n    let prereqs = this.prereqs;\n    let prereqName;\n    let prereqTask; // No repeatsies\n\n    if (this.taskStatus == Task.runStatuses.DONE) {\n      return false;\n    } // The always-make override\n    else if (jake.program.opts['always-make']) {\n      return true;\n    } // Default case\n    else {\n      // We need either an existing file, or an action to create one.\n      // First try grabbing the actual mod-time of the file\n      try {\n        this.updateModTime();\n      } // Then fall back to looking for an action\n      catch (e) {\n        if (typeof this.action == 'function') {\n          return true;\n        } else {\n          throw new Error('File-task ' + this.fullName + ' has no ' + 'existing file, and no action to create one.');\n        }\n      } // Compare mod-time of all the prereqs with its mod-time\n      // If any prereqs are newer, need to run the action to update\n\n\n      if (prereqs && prereqs.length) {\n        for (let i = 0, ii = prereqs.length; i < ii; i++) {\n          prereqName = prereqs[i];\n          prereqTask = this.namespace.resolveTask(prereqName) || jake.createPlaceholderFileTask(prereqName, this.namespace); // Run the action if:\n          // 1. The prereq is a normal task (not file/dir)\n          // 2. The prereq is a file-task with a mod-date more recent than\n          // the one for this file/dir\n\n          if (prereqTask) {\n            if (!isFileOrDirectory(prereqTask) || isFile(prereqTask) && prereqTask.modTime > this.modTime) {\n              return true;\n            }\n          }\n        }\n      } // File/dir has no prereqs, and exists -- no need to run\n      else {\n        // Effectively done\n        this.taskStatus = Task.runStatuses.DONE;\n        return false;\n      }\n    }\n  }\n\n  updateModTime() {\n    let stats = fs.statSync(this.name);\n    this.modTime = stats.mtime;\n  }\n\n  complete() {\n    if (!this.dummy) {\n      this.updateModTime();\n    } // Hackity hack\n\n\n    Task.prototype.complete.apply(this, arguments);\n  }\n\n}\n\nexports.FileTask = FileTask; // DirectoryTask is a subclass of FileTask, depends on it\n// being defined\n\nlet DirectoryTask = require('./directory_task').DirectoryTask;","map":{"version":3,"names":["fs","require","Task","isFileOrDirectory","t","FileTask","DirectoryTask","isFile","constructor","dummy","existsSync","name","updateModTime","modTime","isNeeded","prereqs","prereqName","prereqTask","taskStatus","runStatuses","DONE","jake","program","opts","e","action","Error","fullName","length","i","ii","namespace","resolveTask","createPlaceholderFileTask","stats","statSync","mtime","complete","prototype","apply","arguments","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jake/lib/task/file_task.js"],"sourcesContent":["let fs = require('fs');\nlet Task = require('./task').Task;\n\nfunction isFileOrDirectory(t) {\n  return (t instanceof FileTask ||\n          t instanceof DirectoryTask);\n}\n\nfunction isFile(t) {\n  return (t instanceof FileTask && !(t instanceof DirectoryTask));\n}\n\n/**\n  @name jake\n  @namespace jake\n*/\n/**\n  @name jake.FileTask\n  @class`\n  @extentds Task\n  @description A Jake FileTask\n\n  @param {String} name The name of the Task\n  @param {Array} [prereqs] Prerequisites to be run before this task\n  @param {Function} [action] The action to perform to create this file\n  @param {Object} [opts]\n    @param {Array} [opts.asyc=false] Perform this task asynchronously.\n    If you flag a task with this option, you must call the global\n    `complete` method inside the task's action, for execution to proceed\n    to the next task.\n */\nclass FileTask extends Task {\n  constructor(...args) {\n    super(...args);\n    this.dummy = false;\n    if (fs.existsSync(this.name)) {\n      this.updateModTime();\n    }\n    else {\n      this.modTime = null;\n    }\n  }\n\n  isNeeded() {\n    let prereqs = this.prereqs;\n    let prereqName;\n    let prereqTask;\n\n    // No repeatsies\n    if (this.taskStatus == Task.runStatuses.DONE) {\n      return false;\n    }\n    // The always-make override\n    else if (jake.program.opts['always-make']) {\n      return true;\n    }\n    // Default case\n    else {\n\n      // We need either an existing file, or an action to create one.\n      // First try grabbing the actual mod-time of the file\n      try {\n        this.updateModTime();\n      }\n      // Then fall back to looking for an action\n      catch(e) {\n        if (typeof this.action == 'function') {\n          return true;\n        }\n        else {\n          throw new Error('File-task ' + this.fullName + ' has no ' +\n            'existing file, and no action to create one.');\n        }\n      }\n\n      // Compare mod-time of all the prereqs with its mod-time\n      // If any prereqs are newer, need to run the action to update\n      if (prereqs && prereqs.length) {\n        for (let i = 0, ii = prereqs.length; i < ii; i++) {\n          prereqName = prereqs[i];\n          prereqTask = this.namespace.resolveTask(prereqName) ||\n            jake.createPlaceholderFileTask(prereqName, this.namespace);\n          // Run the action if:\n          // 1. The prereq is a normal task (not file/dir)\n          // 2. The prereq is a file-task with a mod-date more recent than\n          // the one for this file/dir\n          if (prereqTask) {\n            if (!isFileOrDirectory(prereqTask) ||\n                (isFile(prereqTask) && prereqTask.modTime > this.modTime)) {\n              return true;\n            }\n          }\n        }\n      }\n      // File/dir has no prereqs, and exists -- no need to run\n      else {\n        // Effectively done\n        this.taskStatus = Task.runStatuses.DONE;\n        return false;\n      }\n    }\n  }\n\n  updateModTime() {\n    let stats = fs.statSync(this.name);\n    this.modTime = stats.mtime;\n  }\n\n  complete() {\n    if (!this.dummy) {\n      this.updateModTime();\n    }\n    // Hackity hack\n    Task.prototype.complete.apply(this, arguments);\n  }\n\n}\n\nexports.FileTask = FileTask;\n\n// DirectoryTask is a subclass of FileTask, depends on it\n// being defined\nlet DirectoryTask = require('./directory_task').DirectoryTask;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}