{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = applyDecs;\n\nfunction old_createMetadataMethodsForProperty(metadataMap, kind, property, decoratorFinishedRef) {\n  return {\n    getMetadata: function (key) {\n      old_assertNotFinished(decoratorFinishedRef, \"getMetadata\");\n      old_assertMetadataKey(key);\n      var metadataForKey = metadataMap[key];\n      if (metadataForKey === void 0) return void 0;\n\n      if (kind === 1) {\n        var pub = metadataForKey.public;\n\n        if (pub !== void 0) {\n          return pub[property];\n        }\n      } else if (kind === 2) {\n        var priv = metadataForKey.private;\n\n        if (priv !== void 0) {\n          return priv.get(property);\n        }\n      } else if (Object.hasOwnProperty.call(metadataForKey, \"constructor\")) {\n        return metadataForKey.constructor;\n      }\n    },\n    setMetadata: function (key, value) {\n      old_assertNotFinished(decoratorFinishedRef, \"setMetadata\");\n      old_assertMetadataKey(key);\n      var metadataForKey = metadataMap[key];\n\n      if (metadataForKey === void 0) {\n        metadataForKey = metadataMap[key] = {};\n      }\n\n      if (kind === 1) {\n        var pub = metadataForKey.public;\n\n        if (pub === void 0) {\n          pub = metadataForKey.public = {};\n        }\n\n        pub[property] = value;\n      } else if (kind === 2) {\n        var priv = metadataForKey.priv;\n\n        if (priv === void 0) {\n          priv = metadataForKey.private = new Map();\n        }\n\n        priv.set(property, value);\n      } else {\n        metadataForKey.constructor = value;\n      }\n    }\n  };\n}\n\nfunction old_convertMetadataMapToFinal(obj, metadataMap) {\n  var parentMetadataMap = obj[Symbol.metadata || Symbol.for(\"Symbol.metadata\")];\n  var metadataKeys = Object.getOwnPropertySymbols(metadataMap);\n  if (metadataKeys.length === 0) return;\n\n  for (var i = 0; i < metadataKeys.length; i++) {\n    var key = metadataKeys[i];\n    var metaForKey = metadataMap[key];\n    var parentMetaForKey = parentMetadataMap ? parentMetadataMap[key] : null;\n    var pub = metaForKey.public;\n    var parentPub = parentMetaForKey ? parentMetaForKey.public : null;\n\n    if (pub && parentPub) {\n      Object.setPrototypeOf(pub, parentPub);\n    }\n\n    var priv = metaForKey.private;\n\n    if (priv) {\n      var privArr = Array.from(priv.values());\n      var parentPriv = parentMetaForKey ? parentMetaForKey.private : null;\n\n      if (parentPriv) {\n        privArr = privArr.concat(parentPriv);\n      }\n\n      metaForKey.private = privArr;\n    }\n\n    if (parentMetaForKey) {\n      Object.setPrototypeOf(metaForKey, parentMetaForKey);\n    }\n  }\n\n  if (parentMetadataMap) {\n    Object.setPrototypeOf(metadataMap, parentMetadataMap);\n  }\n\n  obj[Symbol.metadata || Symbol.for(\"Symbol.metadata\")] = metadataMap;\n}\n\nfunction old_createAddInitializerMethod(initializers, decoratorFinishedRef) {\n  return function addInitializer(initializer) {\n    old_assertNotFinished(decoratorFinishedRef, \"addInitializer\");\n    old_assertCallable(initializer, \"An initializer\");\n    initializers.push(initializer);\n  };\n}\n\nfunction old_memberDec(dec, name, desc, metadataMap, initializers, kind, isStatic, isPrivate, value) {\n  var kindStr;\n\n  switch (kind) {\n    case 1:\n      kindStr = \"accessor\";\n      break;\n\n    case 2:\n      kindStr = \"method\";\n      break;\n\n    case 3:\n      kindStr = \"getter\";\n      break;\n\n    case 4:\n      kindStr = \"setter\";\n      break;\n\n    default:\n      kindStr = \"field\";\n  }\n\n  var ctx = {\n    kind: kindStr,\n    name: isPrivate ? \"#\" + name : name,\n    isStatic: isStatic,\n    isPrivate: isPrivate\n  };\n  var decoratorFinishedRef = {\n    v: false\n  };\n\n  if (kind !== 0) {\n    ctx.addInitializer = old_createAddInitializerMethod(initializers, decoratorFinishedRef);\n  }\n\n  var metadataKind, metadataName;\n\n  if (isPrivate) {\n    metadataKind = 2;\n    metadataName = Symbol(name);\n    var access = {};\n\n    if (kind === 0) {\n      access.get = desc.get;\n      access.set = desc.set;\n    } else if (kind === 2) {\n      access.get = function () {\n        return desc.value;\n      };\n    } else {\n      if (kind === 1 || kind === 3) {\n        access.get = function () {\n          return desc.get.call(this);\n        };\n      }\n\n      if (kind === 1 || kind === 4) {\n        access.set = function (v) {\n          desc.set.call(this, v);\n        };\n      }\n    }\n\n    ctx.access = access;\n  } else {\n    metadataKind = 1;\n    metadataName = name;\n  }\n\n  try {\n    return dec(value, Object.assign(ctx, old_createMetadataMethodsForProperty(metadataMap, metadataKind, metadataName, decoratorFinishedRef)));\n  } finally {\n    decoratorFinishedRef.v = true;\n  }\n}\n\nfunction old_assertNotFinished(decoratorFinishedRef, fnName) {\n  if (decoratorFinishedRef.v) {\n    throw new Error(\"attempted to call \" + fnName + \" after decoration was finished\");\n  }\n}\n\nfunction old_assertMetadataKey(key) {\n  if (typeof key !== \"symbol\") {\n    throw new TypeError(\"Metadata keys must be symbols, received: \" + key);\n  }\n}\n\nfunction old_assertCallable(fn, hint) {\n  if (typeof fn !== \"function\") {\n    throw new TypeError(hint + \" must be a function\");\n  }\n}\n\nfunction old_assertValidReturnValue(kind, value) {\n  var type = typeof value;\n\n  if (kind === 1) {\n    if (type !== \"object\" || value === null) {\n      throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");\n    }\n\n    if (value.get !== undefined) {\n      old_assertCallable(value.get, \"accessor.get\");\n    }\n\n    if (value.set !== undefined) {\n      old_assertCallable(value.set, \"accessor.set\");\n    }\n\n    if (value.init !== undefined) {\n      old_assertCallable(value.init, \"accessor.init\");\n    }\n\n    if (value.initializer !== undefined) {\n      old_assertCallable(value.initializer, \"accessor.initializer\");\n    }\n  } else if (type !== \"function\") {\n    var hint;\n\n    if (kind === 0) {\n      hint = \"field\";\n    } else if (kind === 10) {\n      hint = \"class\";\n    } else {\n      hint = \"method\";\n    }\n\n    throw new TypeError(hint + \" decorators must return a function or void 0\");\n  }\n}\n\nfunction old_getInit(desc) {\n  var initializer;\n\n  if ((initializer = desc.init) == null && (initializer = desc.initializer) && typeof console !== \"undefined\") {\n    console.warn(\".initializer has been renamed to .init as of March 2022\");\n  }\n\n  return initializer;\n}\n\nfunction old_applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers) {\n  var decs = decInfo[0];\n  var desc, initializer, value;\n\n  if (isPrivate) {\n    if (kind === 0 || kind === 1) {\n      desc = {\n        get: decInfo[3],\n        set: decInfo[4]\n      };\n    } else if (kind === 3) {\n      desc = {\n        get: decInfo[3]\n      };\n    } else if (kind === 4) {\n      desc = {\n        set: decInfo[3]\n      };\n    } else {\n      desc = {\n        value: decInfo[3]\n      };\n    }\n  } else if (kind !== 0) {\n    desc = Object.getOwnPropertyDescriptor(base, name);\n  }\n\n  if (kind === 1) {\n    value = {\n      get: desc.get,\n      set: desc.set\n    };\n  } else if (kind === 2) {\n    value = desc.value;\n  } else if (kind === 3) {\n    value = desc.get;\n  } else if (kind === 4) {\n    value = desc.set;\n  }\n\n  var newValue, get, set;\n\n  if (typeof decs === \"function\") {\n    newValue = old_memberDec(decs, name, desc, metadataMap, initializers, kind, isStatic, isPrivate, value);\n\n    if (newValue !== void 0) {\n      old_assertValidReturnValue(kind, newValue);\n\n      if (kind === 0) {\n        initializer = newValue;\n      } else if (kind === 1) {\n        initializer = old_getInit(newValue);\n        get = newValue.get || value.get;\n        set = newValue.set || value.set;\n        value = {\n          get: get,\n          set: set\n        };\n      } else {\n        value = newValue;\n      }\n    }\n  } else {\n    for (var i = decs.length - 1; i >= 0; i--) {\n      var dec = decs[i];\n      newValue = old_memberDec(dec, name, desc, metadataMap, initializers, kind, isStatic, isPrivate, value);\n\n      if (newValue !== void 0) {\n        old_assertValidReturnValue(kind, newValue);\n        var newInit;\n\n        if (kind === 0) {\n          newInit = newValue;\n        } else if (kind === 1) {\n          newInit = old_getInit(newValue);\n          get = newValue.get || value.get;\n          set = newValue.set || value.set;\n          value = {\n            get: get,\n            set: set\n          };\n        } else {\n          value = newValue;\n        }\n\n        if (newInit !== void 0) {\n          if (initializer === void 0) {\n            initializer = newInit;\n          } else if (typeof initializer === \"function\") {\n            initializer = [initializer, newInit];\n          } else {\n            initializer.push(newInit);\n          }\n        }\n      }\n    }\n  }\n\n  if (kind === 0 || kind === 1) {\n    if (initializer === void 0) {\n      initializer = function (instance, init) {\n        return init;\n      };\n    } else if (typeof initializer !== \"function\") {\n      var ownInitializers = initializer;\n\n      initializer = function (instance, init) {\n        var value = init;\n\n        for (var i = 0; i < ownInitializers.length; i++) {\n          value = ownInitializers[i].call(instance, value);\n        }\n\n        return value;\n      };\n    } else {\n      var originalInitializer = initializer;\n\n      initializer = function (instance, init) {\n        return originalInitializer.call(instance, init);\n      };\n    }\n\n    ret.push(initializer);\n  }\n\n  if (kind !== 0) {\n    if (kind === 1) {\n      desc.get = value.get;\n      desc.set = value.set;\n    } else if (kind === 2) {\n      desc.value = value;\n    } else if (kind === 3) {\n      desc.get = value;\n    } else if (kind === 4) {\n      desc.set = value;\n    }\n\n    if (isPrivate) {\n      if (kind === 1) {\n        ret.push(function (instance, args) {\n          return value.get.call(instance, args);\n        });\n        ret.push(function (instance, args) {\n          return value.set.call(instance, args);\n        });\n      } else if (kind === 2) {\n        ret.push(value);\n      } else {\n        ret.push(function (instance, args) {\n          return value.call(instance, args);\n        });\n      }\n    } else {\n      Object.defineProperty(base, name, desc);\n    }\n  }\n}\n\nfunction old_applyMemberDecs(ret, Class, protoMetadataMap, staticMetadataMap, decInfos) {\n  var protoInitializers;\n  var staticInitializers;\n  var existingProtoNonFields = new Map();\n  var existingStaticNonFields = new Map();\n\n  for (var i = 0; i < decInfos.length; i++) {\n    var decInfo = decInfos[i];\n    if (!Array.isArray(decInfo)) continue;\n    var kind = decInfo[1];\n    var name = decInfo[2];\n    var isPrivate = decInfo.length > 3;\n    var isStatic = kind >= 5;\n    var base;\n    var metadataMap;\n    var initializers;\n\n    if (isStatic) {\n      base = Class;\n      metadataMap = staticMetadataMap;\n      kind = kind - 5;\n\n      if (kind !== 0) {\n        staticInitializers = staticInitializers || [];\n        initializers = staticInitializers;\n      }\n    } else {\n      base = Class.prototype;\n      metadataMap = protoMetadataMap;\n\n      if (kind !== 0) {\n        protoInitializers = protoInitializers || [];\n        initializers = protoInitializers;\n      }\n    }\n\n    if (kind !== 0 && !isPrivate) {\n      var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;\n      var existingKind = existingNonFields.get(name) || 0;\n\n      if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {\n        throw new Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \" + name);\n      } else if (!existingKind && kind > 2) {\n        existingNonFields.set(name, kind);\n      } else {\n        existingNonFields.set(name, true);\n      }\n    }\n\n    old_applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers);\n  }\n\n  old_pushInitializers(ret, protoInitializers);\n  old_pushInitializers(ret, staticInitializers);\n}\n\nfunction old_pushInitializers(ret, initializers) {\n  if (initializers) {\n    ret.push(function (instance) {\n      for (var i = 0; i < initializers.length; i++) {\n        initializers[i].call(instance);\n      }\n\n      return instance;\n    });\n  }\n}\n\nfunction old_applyClassDecs(ret, targetClass, metadataMap, classDecs) {\n  if (classDecs.length > 0) {\n    var initializers = [];\n    var newClass = targetClass;\n    var name = targetClass.name;\n\n    for (var i = classDecs.length - 1; i >= 0; i--) {\n      var decoratorFinishedRef = {\n        v: false\n      };\n\n      try {\n        var ctx = Object.assign({\n          kind: \"class\",\n          name: name,\n          addInitializer: old_createAddInitializerMethod(initializers, decoratorFinishedRef)\n        }, old_createMetadataMethodsForProperty(metadataMap, 0, name, decoratorFinishedRef));\n        var nextNewClass = classDecs[i](newClass, ctx);\n      } finally {\n        decoratorFinishedRef.v = true;\n      }\n\n      if (nextNewClass !== undefined) {\n        old_assertValidReturnValue(10, nextNewClass);\n        newClass = nextNewClass;\n      }\n    }\n\n    ret.push(newClass, function () {\n      for (var i = 0; i < initializers.length; i++) {\n        initializers[i].call(newClass);\n      }\n    });\n  }\n}\n\nfunction applyDecs(targetClass, memberDecs, classDecs) {\n  var ret = [];\n  var staticMetadataMap = {};\n  var protoMetadataMap = {};\n  old_applyMemberDecs(ret, targetClass, protoMetadataMap, staticMetadataMap, memberDecs);\n  old_convertMetadataMapToFinal(targetClass.prototype, protoMetadataMap);\n  old_applyClassDecs(ret, targetClass, staticMetadataMap, classDecs);\n  old_convertMetadataMapToFinal(targetClass, staticMetadataMap);\n  return ret;\n}","map":{"version":3,"mappings":";;;;;;;AAyBA,SAASA,oCAAT,CACEC,WADF,EAEEC,IAFF,EAGEC,QAHF,EAIEC,oBAJF,EAKE;EACA,OAAO;IACLC,WAAW,EAAE,UAAUC,GAAV,EAAe;MAC1BC,qBAAqB,CAACH,oBAAD,EAAuB,aAAvB,CAArBG;MACAC,qBAAqB,CAACF,GAAD,CAArBE;MAEA,IAAIC,cAAc,GAAGR,WAAW,CAACK,GAAD,CAAhC;MAEA,IAAIG,cAAc,KAAK,KAAK,CAA5B,EAA+B,OAAO,KAAK,CAAZ;;MAE/B,IAAIP,IAAI,KAAK,CAAb,EAA6B;QAC3B,IAAIQ,GAAG,GAAGD,cAAc,CAACE,MAAzB;;QACA,IAAID,GAAG,KAAK,KAAK,CAAjB,EAAoB;UAClB,OAAOA,GAAG,CAACP,QAAD,CAAV;QACD;MAJH,OAKO,IAAID,IAAI,KAAK,CAAb,EAA8B;QACnC,IAAIU,IAAI,GAAGH,cAAc,CAACI,OAA1B;;QACA,IAAID,IAAI,KAAK,KAAK,CAAlB,EAAqB;UACnB,OAAOA,IAAI,CAACE,GAALF,CAAST,QAATS,CAAP;QACD;MAJI,OAKA,IAAIG,MAAM,CAACC,cAAPD,CAAsBE,IAAtBF,CAA2BN,cAA3BM,EAA2C,aAA3CA,CAAJ,EAA+D;QACpE,OAAON,cAAc,CAACS,WAAtB;MACD;IArBE;IAuBLC,WAAW,EAAE,UAAUb,GAAV,EAAec,KAAf,EAAsB;MACjCb,qBAAqB,CAACH,oBAAD,EAAuB,aAAvB,CAArBG;MACAC,qBAAqB,CAACF,GAAD,CAArBE;MAEA,IAAIC,cAAc,GAAGR,WAAW,CAACK,GAAD,CAAhC;;MAEA,IAAIG,cAAc,KAAK,KAAK,CAA5B,EAA+B;QAC7BA,cAAc,GAAGR,WAAW,CAACK,GAAD,CAAXL,GAAmB,EAApCQ;MACD;;MAED,IAAIP,IAAI,KAAK,CAAb,EAA6B;QAC3B,IAAIQ,GAAG,GAAGD,cAAc,CAACE,MAAzB;;QAEA,IAAID,GAAG,KAAK,KAAK,CAAjB,EAAoB;UAClBA,GAAG,GAAGD,cAAc,CAACE,MAAfF,GAAwB,EAA9BC;QACD;;QAEDA,GAAG,CAACP,QAAD,CAAHO,GAAgBU,KAAhBV;MAPF,OAQO,IAAIR,IAAI,KAAK,CAAb,EAA8B;QACnC,IAAIU,IAAI,GAAGH,cAAc,CAACG,IAA1B;;QAEA,IAAIA,IAAI,KAAK,KAAK,CAAlB,EAAqB;UACnBA,IAAI,GAAGH,cAAc,CAACI,OAAfJ,GAAyB,IAAIY,GAAJ,EAAhCT;QACD;;QAEDA,IAAI,CAACU,GAALV,CAAST,QAATS,EAAmBQ,KAAnBR;MAPK,OAQA;QACLH,cAAc,CAACS,WAAfT,GAA6BW,KAA7BX;MACD;IACF;EApDI,CAAP;AAsDD;;AAED,SAASc,6BAAT,CAAuCC,GAAvC,EAA4CvB,WAA5C,EAAyD;EACvD,IAAIwB,iBAAiB,GAAGD,GAAG,CAACE,MAAM,CAACC,QAAPD,IAAmBA,MAAM,CAACE,GAAPF,CAAW,iBAAXA,CAApB,CAA3B;EACA,IAAIG,YAAY,GAAGd,MAAM,CAACe,qBAAPf,CAA6Bd,WAA7Bc,CAAnB;EAEA,IAAIc,YAAY,CAACE,MAAbF,KAAwB,CAA5B,EAA+B;;EAE/B,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,YAAY,CAACE,MAAjC,EAAyCC,CAAC,EAA1C,EAA8C;IAC5C,IAAI1B,GAAG,GAAGuB,YAAY,CAACG,CAAD,CAAtB;IACA,IAAIC,UAAU,GAAGhC,WAAW,CAACK,GAAD,CAA5B;IACA,IAAI4B,gBAAgB,GAAGT,iBAAiB,GAAGA,iBAAiB,CAACnB,GAAD,CAApB,GAA4B,IAApE;IAEA,IAAII,GAAG,GAAGuB,UAAU,CAACtB,MAArB;IACA,IAAIwB,SAAS,GAAGD,gBAAgB,GAAGA,gBAAgB,CAACvB,MAApB,GAA6B,IAA7D;;IAEA,IAAID,GAAG,IAAIyB,SAAX,EAAsB;MACpBpB,MAAM,CAACqB,cAAPrB,CAAsBL,GAAtBK,EAA2BoB,SAA3BpB;IACD;;IAED,IAAIH,IAAI,GAAGqB,UAAU,CAACpB,OAAtB;;IAEA,IAAID,IAAJ,EAAU;MACR,IAAIyB,OAAO,GAAGC,KAAK,CAACC,IAAND,CAAW1B,IAAI,CAAC4B,MAAL5B,EAAX0B,CAAd;MACA,IAAIG,UAAU,GAAGP,gBAAgB,GAAGA,gBAAgB,CAACrB,OAApB,GAA8B,IAA/D;;MAEA,IAAI4B,UAAJ,EAAgB;QACdJ,OAAO,GAAGA,OAAO,CAACK,MAARL,CAAeI,UAAfJ,CAAVA;MACD;;MAEDJ,UAAU,CAACpB,OAAXoB,GAAqBI,OAArBJ;IACD;;IAED,IAAIC,gBAAJ,EAAsB;MACpBnB,MAAM,CAACqB,cAAPrB,CAAsBkB,UAAtBlB,EAAkCmB,gBAAlCnB;IACD;EACF;;EAED,IAAIU,iBAAJ,EAAuB;IACrBV,MAAM,CAACqB,cAAPrB,CAAsBd,WAAtBc,EAAmCU,iBAAnCV;EACD;;EAEDS,GAAG,CAACE,MAAM,CAACC,QAAPD,IAAmBA,MAAM,CAACE,GAAPF,CAAW,iBAAXA,CAApB,CAAHF,GAAwDvB,WAAxDuB;AACD;;AAED,SAASmB,8BAAT,CAAwCC,YAAxC,EAAsDxC,oBAAtD,EAA4E;EAC1E,OAAO,SAASyC,cAAT,CAAwBC,WAAxB,EAAqC;IAC1CvC,qBAAqB,CAACH,oBAAD,EAAuB,gBAAvB,CAArBG;IACAwC,kBAAkB,CAACD,WAAD,EAAc,gBAAd,CAAlBC;IACAH,YAAY,CAACI,IAAbJ,CAAkBE,WAAlBF;EAHF;AAKD;;AAED,SAASK,aAAT,CACEC,GADF,EAEEC,IAFF,EAGEC,IAHF,EAIEnD,WAJF,EAKE2C,YALF,EAME1C,IANF,EAOEmD,QAPF,EAQEC,SARF,EASElC,KATF,EAUE;EACA,IAAImC,OAAJ;;EAEA,QAAQrD,IAAR;IACE,KAAK,CAAL;MACEqD,OAAO,GAAG,UAAVA;MACA;;IACF,KAAK,CAAL;MACEA,OAAO,GAAG,QAAVA;MACA;;IACF,KAAK,CAAL;MACEA,OAAO,GAAG,QAAVA;MACA;;IACF,KAAK,CAAL;MACEA,OAAO,GAAG,QAAVA;MACA;;IACF;MACEA,OAAO,GAAG,OAAVA;EAdJ;;EAiBA,IAAIC,GAAG,GAAG;IACRtD,IAAI,EAAEqD,OADE;IAERJ,IAAI,EAAEG,SAAS,GAAG,MAAMH,IAAT,GAAgBA,IAFvB;IAGRE,QAAQ,EAAEA,QAHF;IAIRC,SAAS,EAAEA;EAJH,CAAV;EAOA,IAAIlD,oBAAoB,GAAG;IAAEqD,CAAC,EAAE;EAAL,CAA3B;;EAEA,IAAIvD,IAAI,KAAK,CAAb,EAA4B;IAC1BsD,GAAG,CAACX,cAAJW,GAAqBb,8BAA8B,CACjDC,YADiD,EAEjDxC,oBAFiD,CAAnDoD;EAID;;EAED,IAAIE,YAAJ,EAAkBC,YAAlB;;EAEA,IAAIL,SAAJ,EAAe;IACbI,YAAY,GAAG,CAAfA;IACAC,YAAY,GAAGjC,MAAM,CAACyB,IAAD,CAArBQ;IAEA,IAAIC,MAAM,GAAG,EAAb;;IAEA,IAAI1D,IAAI,KAAK,CAAb,EAA4B;MAC1B0D,MAAM,CAAC9C,GAAP8C,GAAaR,IAAI,CAACtC,GAAlB8C;MACAA,MAAM,CAACtC,GAAPsC,GAAaR,IAAI,CAAC9B,GAAlBsC;IAFF,OAGO,IAAI1D,IAAI,KAAK,CAAb,EAA6B;MAClC0D,MAAM,CAAC9C,GAAP8C,GAAa,YAAY;QACvB,OAAOR,IAAI,CAAChC,KAAZ;MADF;IADK,OAIA;MAEL,IAAIlB,IAAI,KAAK,CAATA,IAA6BA,IAAI,KAAK,CAA1C,EAA0D;QACxD0D,MAAM,CAAC9C,GAAP8C,GAAa,YAAY;UACvB,OAAOR,IAAI,CAACtC,GAALsC,CAASnC,IAATmC,CAAc,IAAdA,CAAP;QADF;MAGD;;MAED,IAAIlD,IAAI,KAAK,CAATA,IAA6BA,IAAI,KAAK,CAA1C,EAA0D;QACxD0D,MAAM,CAACtC,GAAPsC,GAAa,UAAUH,CAAV,EAAa;UACxBL,IAAI,CAAC9B,GAAL8B,CAASnC,IAATmC,CAAc,IAAdA,EAAoBK,CAApBL;QADF;MAGD;IACF;;IAEDI,GAAG,CAACI,MAAJJ,GAAaI,MAAbJ;EA5BF,OA6BO;IACLE,YAAY,GAAG,CAAfA;IACAC,YAAY,GAAGR,IAAfQ;EACD;;EAED,IAAI;IACF,OAAOT,GAAG,CACR9B,KADQ,EAERL,MAAM,CAAC8C,MAAP9C,CACEyC,GADFzC,EAEEf,oCAAoC,CAClCC,WADkC,EAElCyD,YAFkC,EAGlCC,YAHkC,EAIlCvD,oBAJkC,CAFtCW,CAFQ,CAAV;EADF,UAaU;IACRX,oBAAoB,CAACqD,CAArBrD,GAAyB,IAAzBA;EACD;AACF;;AAED,SAASG,qBAAT,CAA+BH,oBAA/B,EAAqD0D,MAArD,EAA6D;EAC3D,IAAI1D,oBAAoB,CAACqD,CAAzB,EAA4B;IAC1B,MAAM,IAAIM,KAAJ,CACJ,uBAAuBD,MAAvB,GAAgC,gCAD5B,CAAN;EAGD;AACF;;AAED,SAAStD,qBAAT,CAA+BF,GAA/B,EAAoC;EAClC,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;IAC3B,MAAM,IAAI0D,SAAJ,CAAc,8CAA8C1D,GAA5D,CAAN;EACD;AACF;;AAED,SAASyC,kBAAT,CAA4BkB,EAA5B,EAAgCC,IAAhC,EAAsC;EACpC,IAAI,OAAOD,EAAP,KAAc,UAAlB,EAA8B;IAC5B,MAAM,IAAID,SAAJ,CAAcE,IAAI,GAAG,qBAArB,CAAN;EACD;AACF;;AAED,SAASC,0BAAT,CAAoCjE,IAApC,EAA0CkB,KAA1C,EAAiD;EAC/C,IAAIgD,IAAI,GAAG,OAAOhD,KAAlB;;EAEA,IAAIlB,IAAI,KAAK,CAAb,EAA+B;IAC7B,IAAIkE,IAAI,KAAK,QAATA,IAAqBhD,KAAK,KAAK,IAAnC,EAAyC;MACvC,MAAM,IAAI4C,SAAJ,CACJ,uFADI,CAAN;IAGD;;IACD,IAAI5C,KAAK,CAACN,GAANM,KAAciD,SAAlB,EAA6B;MAC3BtB,kBAAkB,CAAC3B,KAAK,CAACN,GAAP,EAAY,cAAZ,CAAlBiC;IACD;;IACD,IAAI3B,KAAK,CAACE,GAANF,KAAciD,SAAlB,EAA6B;MAC3BtB,kBAAkB,CAAC3B,KAAK,CAACE,GAAP,EAAY,cAAZ,CAAlByB;IACD;;IACD,IAAI3B,KAAK,CAACkD,IAANlD,KAAeiD,SAAnB,EAA8B;MAC5BtB,kBAAkB,CAAC3B,KAAK,CAACkD,IAAP,EAAa,eAAb,CAAlBvB;IACD;;IACD,IAAI3B,KAAK,CAAC0B,WAAN1B,KAAsBiD,SAA1B,EAAqC;MACnCtB,kBAAkB,CAAC3B,KAAK,CAAC0B,WAAP,EAAoB,sBAApB,CAAlBC;IACD;EAjBH,OAkBO,IAAIqB,IAAI,KAAK,UAAb,EAAyB;IAC9B,IAAIF,IAAJ;;IACA,IAAIhE,IAAI,KAAK,CAAb,EAA4B;MAC1BgE,IAAI,GAAG,OAAPA;IADF,OAEO,IAAIhE,IAAI,KAAK,EAAb,EAA6B;MAClCgE,IAAI,GAAG,OAAPA;IADK,OAEA;MACLA,IAAI,GAAG,QAAPA;IACD;;IACD,MAAM,IAAIF,SAAJ,CAAcE,IAAI,GAAG,8CAArB,CAAN;EACD;AACF;;AAED,SAASK,WAAT,CAAqBnB,IAArB,EAA2B;EACzB,IAAIN,WAAJ;;EACA,IACE,CAACA,WAAW,GAAGM,IAAI,CAACkB,IAApB,KAA6B,IAA7B,KACCxB,WAAW,GAAGM,IAAI,CAACN,WADpB,KAEA,OAAO0B,OAAP,KAAmB,WAHrB,EAIE;IACAA,OAAO,CAACC,IAARD,CAAa,yDAAbA;EACD;;EACD,OAAO1B,WAAP;AACD;;AAED,SAAS4B,kBAAT,CACEC,GADF,EAEEC,IAFF,EAGEC,OAHF,EAIE1B,IAJF,EAKEjD,IALF,EAMEmD,QANF,EAOEC,SAPF,EAQErD,WARF,EASE2C,YATF,EAUE;EACA,IAAIkC,IAAI,GAAGD,OAAO,CAAC,CAAD,CAAlB;EAEA,IAAIzB,IAAJ,EAAUN,WAAV,EAAuB1B,KAAvB;;EAEA,IAAIkC,SAAJ,EAAe;IACb,IAAIpD,IAAI,KAAK,CAATA,IAA0BA,IAAI,KAAK,CAAvC,EAAyD;MACvDkD,IAAI,GAAG;QACLtC,GAAG,EAAE+D,OAAO,CAAC,CAAD,CADP;QAELvD,GAAG,EAAEuD,OAAO,CAAC,CAAD;MAFP,CAAPzB;IADF,OAKO,IAAIlD,IAAI,KAAK,CAAb,EAA6B;MAClCkD,IAAI,GAAG;QACLtC,GAAG,EAAE+D,OAAO,CAAC,CAAD;MADP,CAAPzB;IADK,OAIA,IAAIlD,IAAI,KAAK,CAAb,EAA6B;MAClCkD,IAAI,GAAG;QACL9B,GAAG,EAAEuD,OAAO,CAAC,CAAD;MADP,CAAPzB;IADK,OAIA;MACLA,IAAI,GAAG;QACLhC,KAAK,EAAEyD,OAAO,CAAC,CAAD;MADT,CAAPzB;IAGD;EAlBH,OAmBO,IAAIlD,IAAI,KAAK,CAAb,EAA4B;IACjCkD,IAAI,GAAGrC,MAAM,CAACgE,wBAAPhE,CAAgC6D,IAAhC7D,EAAsCoC,IAAtCpC,CAAPqC;EACD;;EAED,IAAIlD,IAAI,KAAK,CAAb,EAA+B;IAC7BkB,KAAK,GAAG;MACNN,GAAG,EAAEsC,IAAI,CAACtC,GADJ;MAENQ,GAAG,EAAE8B,IAAI,CAAC9B;IAFJ,CAARF;EADF,OAKO,IAAIlB,IAAI,KAAK,CAAb,EAA6B;IAClCkB,KAAK,GAAGgC,IAAI,CAAChC,KAAbA;EADK,OAEA,IAAIlB,IAAI,KAAK,CAAb,EAA6B;IAClCkB,KAAK,GAAGgC,IAAI,CAACtC,GAAbM;EADK,OAEA,IAAIlB,IAAI,KAAK,CAAb,EAA6B;IAClCkB,KAAK,GAAGgC,IAAI,CAAC9B,GAAbF;EACD;;EAED,IAAI4D,QAAJ,EAAclE,GAAd,EAAmBQ,GAAnB;;EAEA,IAAI,OAAOwD,IAAP,KAAgB,UAApB,EAAgC;IAC9BE,QAAQ,GAAG/B,aAAa,CACtB6B,IADsB,EAEtB3B,IAFsB,EAGtBC,IAHsB,EAItBnD,WAJsB,EAKtB2C,YALsB,EAMtB1C,IANsB,EAOtBmD,QAPsB,EAQtBC,SARsB,EAStBlC,KATsB,CAAxB4D;;IAYA,IAAIA,QAAQ,KAAK,KAAK,CAAtB,EAAyB;MACvBb,0BAA0B,CAACjE,IAAD,EAAO8E,QAAP,CAA1Bb;;MAEA,IAAIjE,IAAI,KAAK,CAAb,EAA4B;QAC1B4C,WAAW,GAAGkC,QAAdlC;MADF,OAEO,IAAI5C,IAAI,KAAK,CAAb,EAA+B;QACpC4C,WAAW,GAAGyB,WAAW,CAACS,QAAD,CAAzBlC;QACAhC,GAAG,GAAGkE,QAAQ,CAAClE,GAATkE,IAAgB5D,KAAK,CAACN,GAA5BA;QACAQ,GAAG,GAAG0D,QAAQ,CAAC1D,GAAT0D,IAAgB5D,KAAK,CAACE,GAA5BA;QAEAF,KAAK,GAAG;UAAEN,GAAG,EAAEA,GAAP;UAAYQ,GAAG,EAAEA;QAAjB,CAARF;MALK,OAMA;QACLA,KAAK,GAAG4D,QAAR5D;MACD;IACF;EA3BH,OA4BO;IACL,KAAK,IAAIY,CAAC,GAAG8C,IAAI,CAAC/C,MAAL+C,GAAc,CAA3B,EAA8B9C,CAAC,IAAI,CAAnC,EAAsCA,CAAC,EAAvC,EAA2C;MACzC,IAAIkB,GAAG,GAAG4B,IAAI,CAAC9C,CAAD,CAAd;MAEAgD,QAAQ,GAAG/B,aAAa,CACtBC,GADsB,EAEtBC,IAFsB,EAGtBC,IAHsB,EAItBnD,WAJsB,EAKtB2C,YALsB,EAMtB1C,IANsB,EAOtBmD,QAPsB,EAQtBC,SARsB,EAStBlC,KATsB,CAAxB4D;;MAYA,IAAIA,QAAQ,KAAK,KAAK,CAAtB,EAAyB;QACvBb,0BAA0B,CAACjE,IAAD,EAAO8E,QAAP,CAA1Bb;QACA,IAAIc,OAAJ;;QAEA,IAAI/E,IAAI,KAAK,CAAb,EAA4B;UAC1B+E,OAAO,GAAGD,QAAVC;QADF,OAEO,IAAI/E,IAAI,KAAK,CAAb,EAA+B;UACpC+E,OAAO,GAAGV,WAAW,CAACS,QAAD,CAArBC;UACAnE,GAAG,GAAGkE,QAAQ,CAAClE,GAATkE,IAAgB5D,KAAK,CAACN,GAA5BA;UACAQ,GAAG,GAAG0D,QAAQ,CAAC1D,GAAT0D,IAAgB5D,KAAK,CAACE,GAA5BA;UAEAF,KAAK,GAAG;YAAEN,GAAG,EAAEA,GAAP;YAAYQ,GAAG,EAAEA;UAAjB,CAARF;QALK,OAMA;UACLA,KAAK,GAAG4D,QAAR5D;QACD;;QAED,IAAI6D,OAAO,KAAK,KAAK,CAArB,EAAwB;UACtB,IAAInC,WAAW,KAAK,KAAK,CAAzB,EAA4B;YAC1BA,WAAW,GAAGmC,OAAdnC;UADF,OAEO,IAAI,OAAOA,WAAP,KAAuB,UAA3B,EAAuC;YAC5CA,WAAW,GAAG,CAACA,WAAD,EAAcmC,OAAd,CAAdnC;UADK,OAEA;YACLA,WAAW,CAACE,IAAZF,CAAiBmC,OAAjBnC;UACD;QACF;MACF;IACF;EACF;;EAED,IAAI5C,IAAI,KAAK,CAATA,IAA0BA,IAAI,KAAK,CAAvC,EAAyD;IACvD,IAAI4C,WAAW,KAAK,KAAK,CAAzB,EAA4B;MAE1BA,WAAW,GAAG,UAAUoC,QAAV,EAAoBZ,IAApB,EAA0B;QACtC,OAAOA,IAAP;MADF;IAFF,OAKO,IAAI,OAAOxB,WAAP,KAAuB,UAA3B,EAAuC;MAC5C,IAAIqC,eAAe,GAAGrC,WAAtB;;MAEAA,WAAW,GAAG,UAAUoC,QAAV,EAAoBZ,IAApB,EAA0B;QACtC,IAAIlD,KAAK,GAAGkD,IAAZ;;QAEA,KAAK,IAAItC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmD,eAAe,CAACpD,MAApC,EAA4CC,CAAC,EAA7C,EAAiD;UAC/CZ,KAAK,GAAG+D,eAAe,CAACnD,CAAD,CAAfmD,CAAmBlE,IAAnBkE,CAAwBD,QAAxBC,EAAkC/D,KAAlC+D,CAAR/D;QACD;;QAED,OAAOA,KAAP;MAPF;IAHK,OAYA;MACL,IAAIgE,mBAAmB,GAAGtC,WAA1B;;MAEAA,WAAW,GAAG,UAAUoC,QAAV,EAAoBZ,IAApB,EAA0B;QACtC,OAAOc,mBAAmB,CAACnE,IAApBmE,CAAyBF,QAAzBE,EAAmCd,IAAnCc,CAAP;MADF;IAGD;;IAEDT,GAAG,CAAC3B,IAAJ2B,CAAS7B,WAAT6B;EACD;;EAED,IAAIzE,IAAI,KAAK,CAAb,EAA4B;IAC1B,IAAIA,IAAI,KAAK,CAAb,EAA+B;MAC7BkD,IAAI,CAACtC,GAALsC,GAAWhC,KAAK,CAACN,GAAjBsC;MACAA,IAAI,CAAC9B,GAAL8B,GAAWhC,KAAK,CAACE,GAAjB8B;IAFF,OAGO,IAAIlD,IAAI,KAAK,CAAb,EAA6B;MAClCkD,IAAI,CAAChC,KAALgC,GAAahC,KAAbgC;IADK,OAEA,IAAIlD,IAAI,KAAK,CAAb,EAA6B;MAClCkD,IAAI,CAACtC,GAALsC,GAAWhC,KAAXgC;IADK,OAEA,IAAIlD,IAAI,KAAK,CAAb,EAA6B;MAClCkD,IAAI,CAAC9B,GAAL8B,GAAWhC,KAAXgC;IACD;;IAED,IAAIE,SAAJ,EAAe;MACb,IAAIpD,IAAI,KAAK,CAAb,EAA+B;QAC7ByE,GAAG,CAAC3B,IAAJ2B,CAAS,UAAUO,QAAV,EAAoBG,IAApB,EAA0B;UACjC,OAAOjE,KAAK,CAACN,GAANM,CAAUH,IAAVG,CAAe8D,QAAf9D,EAAyBiE,IAAzBjE,CAAP;QADF;QAGAuD,GAAG,CAAC3B,IAAJ2B,CAAS,UAAUO,QAAV,EAAoBG,IAApB,EAA0B;UACjC,OAAOjE,KAAK,CAACE,GAANF,CAAUH,IAAVG,CAAe8D,QAAf9D,EAAyBiE,IAAzBjE,CAAP;QADF;MAJF,OAOO,IAAIlB,IAAI,KAAK,CAAb,EAA6B;QAClCyE,GAAG,CAAC3B,IAAJ2B,CAASvD,KAATuD;MADK,OAEA;QACLA,GAAG,CAAC3B,IAAJ2B,CAAS,UAAUO,QAAV,EAAoBG,IAApB,EAA0B;UACjC,OAAOjE,KAAK,CAACH,IAANG,CAAW8D,QAAX9D,EAAqBiE,IAArBjE,CAAP;QADF;MAGD;IAdH,OAeO;MACLL,MAAM,CAACuE,cAAPvE,CAAsB6D,IAAtB7D,EAA4BoC,IAA5BpC,EAAkCqC,IAAlCrC;IACD;EACF;AACF;;AAED,SAASwE,mBAAT,CACEZ,GADF,EAEEa,KAFF,EAGEC,gBAHF,EAIEC,iBAJF,EAKEC,QALF,EAME;EACA,IAAIC,iBAAJ;EACA,IAAIC,kBAAJ;EAEA,IAAIC,sBAAsB,GAAG,IAAIzE,GAAJ,EAA7B;EACA,IAAI0E,uBAAuB,GAAG,IAAI1E,GAAJ,EAA9B;;EAEA,KAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2D,QAAQ,CAAC5D,MAA7B,EAAqCC,CAAC,EAAtC,EAA0C;IACxC,IAAI6C,OAAO,GAAGc,QAAQ,CAAC3D,CAAD,CAAtB;IAGA,IAAI,CAACM,KAAK,CAAC0D,OAAN1D,CAAcuC,OAAdvC,CAAL,EAA6B;IAE7B,IAAIpC,IAAI,GAAG2E,OAAO,CAAC,CAAD,CAAlB;IACA,IAAI1B,IAAI,GAAG0B,OAAO,CAAC,CAAD,CAAlB;IACA,IAAIvB,SAAS,GAAGuB,OAAO,CAAC9C,MAAR8C,GAAiB,CAAjC;IAEA,IAAIxB,QAAQ,GAAGnD,IAAI,IAAI,CAAvB;IACA,IAAI0E,IAAJ;IACA,IAAI3E,WAAJ;IACA,IAAI2C,YAAJ;;IAEA,IAAIS,QAAJ,EAAc;MACZuB,IAAI,GAAGY,KAAPZ;MACA3E,WAAW,GAAGyF,iBAAdzF;MACAC,IAAI,GAAGA,IAAI,GAAG,CAAdA;;MAEA,IAAIA,IAAI,KAAK,CAAb,EAA4B;QAC1B2F,kBAAkB,GAAGA,kBAAkB,IAAI,EAA3CA;QACAjD,YAAY,GAAGiD,kBAAfjD;MACD;IARH,OASO;MACLgC,IAAI,GAAGY,KAAK,CAACS,SAAbrB;MACA3E,WAAW,GAAGwF,gBAAdxF;;MAEA,IAAIC,IAAI,KAAK,CAAb,EAA4B;QAC1B0F,iBAAiB,GAAGA,iBAAiB,IAAI,EAAzCA;QACAhD,YAAY,GAAGgD,iBAAfhD;MACD;IACF;;IAED,IAAI1C,IAAI,KAAK,CAATA,IAA0B,CAACoD,SAA/B,EAA0C;MACxC,IAAI4C,iBAAiB,GAAG7C,QAAQ,GAC5B0C,uBAD4B,GAE5BD,sBAFJ;MAIA,IAAIK,YAAY,GAAGD,iBAAiB,CAACpF,GAAlBoF,CAAsB/C,IAAtB+C,KAA+B,CAAlD;;MAEA,IACEC,YAAY,KAAK,IAAjBA,IACCA,YAAY,KAAK,CAAjBA,IAAmCjG,IAAI,KAAK,CAD7CiG,IAECA,YAAY,KAAK,CAAjBA,IAAmCjG,IAAI,KAAK,CAH/C,EAIE;QACA,MAAM,IAAI6D,KAAJ,CACJ,0MACEZ,IAFE,CAAN;MALF,OASO,IAAI,CAACgD,YAAD,IAAiBjG,IAAI,GAAG,CAA5B,EAA4C;QACjDgG,iBAAiB,CAAC5E,GAAlB4E,CAAsB/C,IAAtB+C,EAA4BhG,IAA5BgG;MADK,OAEA;QACLA,iBAAiB,CAAC5E,GAAlB4E,CAAsB/C,IAAtB+C,EAA4B,IAA5BA;MACD;IACF;;IAEDxB,kBAAkB,CAChBC,GADgB,EAEhBC,IAFgB,EAGhBC,OAHgB,EAIhB1B,IAJgB,EAKhBjD,IALgB,EAMhBmD,QANgB,EAOhBC,SAPgB,EAQhBrD,WARgB,EAShB2C,YATgB,CAAlB8B;EAWD;;EAED0B,oBAAoB,CAACzB,GAAD,EAAMiB,iBAAN,CAApBQ;EACAA,oBAAoB,CAACzB,GAAD,EAAMkB,kBAAN,CAApBO;AACD;;AAED,SAASA,oBAAT,CAA8BzB,GAA9B,EAAmC/B,YAAnC,EAAiD;EAC/C,IAAIA,YAAJ,EAAkB;IAChB+B,GAAG,CAAC3B,IAAJ2B,CAAS,UAAUO,QAAV,EAAoB;MAC3B,KAAK,IAAIlD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGY,YAAY,CAACb,MAAjC,EAAyCC,CAAC,EAA1C,EAA8C;QAC5CY,YAAY,CAACZ,CAAD,CAAZY,CAAgB3B,IAAhB2B,CAAqBsC,QAArBtC;MACD;;MACD,OAAOsC,QAAP;IAJF;EAMD;AACF;;AAED,SAASmB,kBAAT,CAA4B1B,GAA5B,EAAiC2B,WAAjC,EAA8CrG,WAA9C,EAA2DsG,SAA3D,EAAsE;EACpE,IAAIA,SAAS,CAACxE,MAAVwE,GAAmB,CAAvB,EAA0B;IACxB,IAAI3D,YAAY,GAAG,EAAnB;IACA,IAAI4D,QAAQ,GAAGF,WAAf;IACA,IAAInD,IAAI,GAAGmD,WAAW,CAACnD,IAAvB;;IAEA,KAAK,IAAInB,CAAC,GAAGuE,SAAS,CAACxE,MAAVwE,GAAmB,CAAhC,EAAmCvE,CAAC,IAAI,CAAxC,EAA2CA,CAAC,EAA5C,EAAgD;MAC9C,IAAI5B,oBAAoB,GAAG;QAAEqD,CAAC,EAAE;MAAL,CAA3B;;MAEA,IAAI;QACF,IAAID,GAAG,GAAGzC,MAAM,CAAC8C,MAAP9C,CACR;UACEb,IAAI,EAAE,OADR;UAEEiD,IAAI,EAAEA,IAFR;UAGEN,cAAc,EAAEF,8BAA8B,CAC5CC,YAD4C,EAE5CxC,oBAF4C;QAHhD,CADQW,EASRf,oCAAoC,CAClCC,WADkC,EAElC,CAFkC,EAGlCkD,IAHkC,EAIlC/C,oBAJkC,CAT5BW,CAAV;QAgBA,IAAI0F,YAAY,GAAGF,SAAS,CAACvE,CAAD,CAATuE,CAAaC,QAAbD,EAAuB/C,GAAvB+C,CAAnB;MAjBF,UAkBU;QACRnG,oBAAoB,CAACqD,CAArBrD,GAAyB,IAAzBA;MACD;;MAED,IAAIqG,YAAY,KAAKpC,SAArB,EAAgC;QAC9BF,0BAA0B,CAAC,EAAD,EAAiBsC,YAAjB,CAA1BtC;QACAqC,QAAQ,GAAGC,YAAXD;MACD;IACF;;IAED7B,GAAG,CAAC3B,IAAJ2B,CAAS6B,QAAT7B,EAAmB,YAAY;MAC7B,KAAK,IAAI3C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGY,YAAY,CAACb,MAAjC,EAAyCC,CAAC,EAA1C,EAA8C;QAC5CY,YAAY,CAACZ,CAAD,CAAZY,CAAgB3B,IAAhB2B,CAAqB4D,QAArB5D;MACD;IAHH;EAKD;AACF;;AAmJc,SAAS8D,SAAT,CAAmBJ,WAAnB,EAAgCK,UAAhC,EAA4CJ,SAA5C,EAAuD;EACpE,IAAI5B,GAAG,GAAG,EAAV;EACA,IAAIe,iBAAiB,GAAG,EAAxB;EAEA,IAAID,gBAAgB,GAAG,EAAvB;EAEAF,mBAAmB,CACjBZ,GADiB,EAEjB2B,WAFiB,EAGjBb,gBAHiB,EAIjBC,iBAJiB,EAKjBiB,UALiB,CAAnBpB;EAQAhE,6BAA6B,CAAC+E,WAAW,CAACL,SAAb,EAAwBR,gBAAxB,CAA7BlE;EAEA8E,kBAAkB,CAAC1B,GAAD,EAAM2B,WAAN,EAAmBZ,iBAAnB,EAAsCa,SAAtC,CAAlBF;EAEA9E,6BAA6B,CAAC+E,WAAD,EAAcZ,iBAAd,CAA7BnE;EAEA,OAAOoD,GAAP;AACD","names":["old_createMetadataMethodsForProperty","metadataMap","kind","property","decoratorFinishedRef","getMetadata","key","old_assertNotFinished","old_assertMetadataKey","metadataForKey","pub","public","priv","private","get","Object","hasOwnProperty","call","constructor","setMetadata","value","Map","set","old_convertMetadataMapToFinal","obj","parentMetadataMap","Symbol","metadata","for","metadataKeys","getOwnPropertySymbols","length","i","metaForKey","parentMetaForKey","parentPub","setPrototypeOf","privArr","Array","from","values","parentPriv","concat","old_createAddInitializerMethod","initializers","addInitializer","initializer","old_assertCallable","push","old_memberDec","dec","name","desc","isStatic","isPrivate","kindStr","ctx","v","metadataKind","metadataName","access","assign","fnName","Error","TypeError","fn","hint","old_assertValidReturnValue","type","undefined","init","old_getInit","console","warn","old_applyMemberDec","ret","base","decInfo","decs","getOwnPropertyDescriptor","newValue","newInit","instance","ownInitializers","originalInitializer","args","defineProperty","old_applyMemberDecs","Class","protoMetadataMap","staticMetadataMap","decInfos","protoInitializers","staticInitializers","existingProtoNonFields","existingStaticNonFields","isArray","prototype","existingNonFields","existingKind","old_pushInitializers","old_applyClassDecs","targetClass","classDecs","newClass","nextNewClass","applyDecs","memberDecs"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helpers\\src\\helpers\\applyDecs.js"],"sourcesContent":["/* @minVersion 7.17.8 */\n\n/**\n * NOTE: This is an old version of the helper, used for 2021-12 decorators.\n * Updates should be done in applyDecs2203.js.\n */\n\n/**\n  Enums are used in this file, but not assigned to vars to avoid non-hoistable values\n\n  CONSTRUCTOR = 0;\n  PUBLIC = 1;\n  PRIVATE = 2;\n\n  FIELD = 0;\n  ACCESSOR = 1;\n  METHOD = 2;\n  GETTER = 3;\n  SETTER = 4;\n\n  STATIC = 5;\n\n  CLASS = 10; // only used in assertValidReturnValue\n*/\n\nfunction old_createMetadataMethodsForProperty(\n  metadataMap,\n  kind,\n  property,\n  decoratorFinishedRef\n) {\n  return {\n    getMetadata: function (key) {\n      old_assertNotFinished(decoratorFinishedRef, \"getMetadata\");\n      old_assertMetadataKey(key);\n\n      var metadataForKey = metadataMap[key];\n\n      if (metadataForKey === void 0) return void 0;\n\n      if (kind === 1 /* PUBLIC */) {\n        var pub = metadataForKey.public;\n        if (pub !== void 0) {\n          return pub[property];\n        }\n      } else if (kind === 2 /* PRIVATE */) {\n        var priv = metadataForKey.private;\n        if (priv !== void 0) {\n          return priv.get(property);\n        }\n      } else if (Object.hasOwnProperty.call(metadataForKey, \"constructor\")) {\n        return metadataForKey.constructor;\n      }\n    },\n    setMetadata: function (key, value) {\n      old_assertNotFinished(decoratorFinishedRef, \"setMetadata\");\n      old_assertMetadataKey(key);\n\n      var metadataForKey = metadataMap[key];\n\n      if (metadataForKey === void 0) {\n        metadataForKey = metadataMap[key] = {};\n      }\n\n      if (kind === 1 /* PUBLIC */) {\n        var pub = metadataForKey.public;\n\n        if (pub === void 0) {\n          pub = metadataForKey.public = {};\n        }\n\n        pub[property] = value;\n      } else if (kind === 2 /* PRIVATE */) {\n        var priv = metadataForKey.priv;\n\n        if (priv === void 0) {\n          priv = metadataForKey.private = new Map();\n        }\n\n        priv.set(property, value);\n      } else {\n        metadataForKey.constructor = value;\n      }\n    },\n  };\n}\n\nfunction old_convertMetadataMapToFinal(obj, metadataMap) {\n  var parentMetadataMap = obj[Symbol.metadata || Symbol.for(\"Symbol.metadata\")];\n  var metadataKeys = Object.getOwnPropertySymbols(metadataMap);\n\n  if (metadataKeys.length === 0) return;\n\n  for (var i = 0; i < metadataKeys.length; i++) {\n    var key = metadataKeys[i];\n    var metaForKey = metadataMap[key];\n    var parentMetaForKey = parentMetadataMap ? parentMetadataMap[key] : null;\n\n    var pub = metaForKey.public;\n    var parentPub = parentMetaForKey ? parentMetaForKey.public : null;\n\n    if (pub && parentPub) {\n      Object.setPrototypeOf(pub, parentPub);\n    }\n\n    var priv = metaForKey.private;\n\n    if (priv) {\n      var privArr = Array.from(priv.values());\n      var parentPriv = parentMetaForKey ? parentMetaForKey.private : null;\n\n      if (parentPriv) {\n        privArr = privArr.concat(parentPriv);\n      }\n\n      metaForKey.private = privArr;\n    }\n\n    if (parentMetaForKey) {\n      Object.setPrototypeOf(metaForKey, parentMetaForKey);\n    }\n  }\n\n  if (parentMetadataMap) {\n    Object.setPrototypeOf(metadataMap, parentMetadataMap);\n  }\n\n  obj[Symbol.metadata || Symbol.for(\"Symbol.metadata\")] = metadataMap;\n}\n\nfunction old_createAddInitializerMethod(initializers, decoratorFinishedRef) {\n  return function addInitializer(initializer) {\n    old_assertNotFinished(decoratorFinishedRef, \"addInitializer\");\n    old_assertCallable(initializer, \"An initializer\");\n    initializers.push(initializer);\n  };\n}\n\nfunction old_memberDec(\n  dec,\n  name,\n  desc,\n  metadataMap,\n  initializers,\n  kind,\n  isStatic,\n  isPrivate,\n  value\n) {\n  var kindStr;\n\n  switch (kind) {\n    case 1 /* ACCESSOR */:\n      kindStr = \"accessor\";\n      break;\n    case 2 /* METHOD */:\n      kindStr = \"method\";\n      break;\n    case 3 /* GETTER */:\n      kindStr = \"getter\";\n      break;\n    case 4 /* SETTER */:\n      kindStr = \"setter\";\n      break;\n    default:\n      kindStr = \"field\";\n  }\n\n  var ctx = {\n    kind: kindStr,\n    name: isPrivate ? \"#\" + name : name,\n    isStatic: isStatic,\n    isPrivate: isPrivate,\n  };\n\n  var decoratorFinishedRef = { v: false };\n\n  if (kind !== 0 /* FIELD */) {\n    ctx.addInitializer = old_createAddInitializerMethod(\n      initializers,\n      decoratorFinishedRef\n    );\n  }\n\n  var metadataKind, metadataName;\n\n  if (isPrivate) {\n    metadataKind = 2 /* PRIVATE */;\n    metadataName = Symbol(name);\n\n    var access = {};\n\n    if (kind === 0 /* FIELD */) {\n      access.get = desc.get;\n      access.set = desc.set;\n    } else if (kind === 2 /* METHOD */) {\n      access.get = function () {\n        return desc.value;\n      };\n    } else {\n      // replace with values that will go through the final getter and setter\n      if (kind === 1 /* ACCESSOR */ || kind === 3 /* GETTER */) {\n        access.get = function () {\n          return desc.get.call(this);\n        };\n      }\n\n      if (kind === 1 /* ACCESSOR */ || kind === 4 /* SETTER */) {\n        access.set = function (v) {\n          desc.set.call(this, v);\n        };\n      }\n    }\n\n    ctx.access = access;\n  } else {\n    metadataKind = 1 /* PUBLIC */;\n    metadataName = name;\n  }\n\n  try {\n    return dec(\n      value,\n      Object.assign(\n        ctx,\n        old_createMetadataMethodsForProperty(\n          metadataMap,\n          metadataKind,\n          metadataName,\n          decoratorFinishedRef\n        )\n      )\n    );\n  } finally {\n    decoratorFinishedRef.v = true;\n  }\n}\n\nfunction old_assertNotFinished(decoratorFinishedRef, fnName) {\n  if (decoratorFinishedRef.v) {\n    throw new Error(\n      \"attempted to call \" + fnName + \" after decoration was finished\"\n    );\n  }\n}\n\nfunction old_assertMetadataKey(key) {\n  if (typeof key !== \"symbol\") {\n    throw new TypeError(\"Metadata keys must be symbols, received: \" + key);\n  }\n}\n\nfunction old_assertCallable(fn, hint) {\n  if (typeof fn !== \"function\") {\n    throw new TypeError(hint + \" must be a function\");\n  }\n}\n\nfunction old_assertValidReturnValue(kind, value) {\n  var type = typeof value;\n\n  if (kind === 1 /* ACCESSOR */) {\n    if (type !== \"object\" || value === null) {\n      throw new TypeError(\n        \"accessor decorators must return an object with get, set, or init properties or void 0\"\n      );\n    }\n    if (value.get !== undefined) {\n      old_assertCallable(value.get, \"accessor.get\");\n    }\n    if (value.set !== undefined) {\n      old_assertCallable(value.set, \"accessor.set\");\n    }\n    if (value.init !== undefined) {\n      old_assertCallable(value.init, \"accessor.init\");\n    }\n    if (value.initializer !== undefined) {\n      old_assertCallable(value.initializer, \"accessor.initializer\");\n    }\n  } else if (type !== \"function\") {\n    var hint;\n    if (kind === 0 /* FIELD */) {\n      hint = \"field\";\n    } else if (kind === 10 /* CLASS */) {\n      hint = \"class\";\n    } else {\n      hint = \"method\";\n    }\n    throw new TypeError(hint + \" decorators must return a function or void 0\");\n  }\n}\n\nfunction old_getInit(desc) {\n  var initializer;\n  if (\n    (initializer = desc.init) == null &&\n    (initializer = desc.initializer) &&\n    typeof console !== \"undefined\"\n  ) {\n    console.warn(\".initializer has been renamed to .init as of March 2022\");\n  }\n  return initializer;\n}\n\nfunction old_applyMemberDec(\n  ret,\n  base,\n  decInfo,\n  name,\n  kind,\n  isStatic,\n  isPrivate,\n  metadataMap,\n  initializers\n) {\n  var decs = decInfo[0];\n\n  var desc, initializer, value;\n\n  if (isPrivate) {\n    if (kind === 0 /* FIELD */ || kind === 1 /* ACCESSOR */) {\n      desc = {\n        get: decInfo[3],\n        set: decInfo[4],\n      };\n    } else if (kind === 3 /* GETTER */) {\n      desc = {\n        get: decInfo[3],\n      };\n    } else if (kind === 4 /* SETTER */) {\n      desc = {\n        set: decInfo[3],\n      };\n    } else {\n      desc = {\n        value: decInfo[3],\n      };\n    }\n  } else if (kind !== 0 /* FIELD */) {\n    desc = Object.getOwnPropertyDescriptor(base, name);\n  }\n\n  if (kind === 1 /* ACCESSOR */) {\n    value = {\n      get: desc.get,\n      set: desc.set,\n    };\n  } else if (kind === 2 /* METHOD */) {\n    value = desc.value;\n  } else if (kind === 3 /* GETTER */) {\n    value = desc.get;\n  } else if (kind === 4 /* SETTER */) {\n    value = desc.set;\n  }\n\n  var newValue, get, set;\n\n  if (typeof decs === \"function\") {\n    newValue = old_memberDec(\n      decs,\n      name,\n      desc,\n      metadataMap,\n      initializers,\n      kind,\n      isStatic,\n      isPrivate,\n      value\n    );\n\n    if (newValue !== void 0) {\n      old_assertValidReturnValue(kind, newValue);\n\n      if (kind === 0 /* FIELD */) {\n        initializer = newValue;\n      } else if (kind === 1 /* ACCESSOR */) {\n        initializer = old_getInit(newValue);\n        get = newValue.get || value.get;\n        set = newValue.set || value.set;\n\n        value = { get: get, set: set };\n      } else {\n        value = newValue;\n      }\n    }\n  } else {\n    for (var i = decs.length - 1; i >= 0; i--) {\n      var dec = decs[i];\n\n      newValue = old_memberDec(\n        dec,\n        name,\n        desc,\n        metadataMap,\n        initializers,\n        kind,\n        isStatic,\n        isPrivate,\n        value\n      );\n\n      if (newValue !== void 0) {\n        old_assertValidReturnValue(kind, newValue);\n        var newInit;\n\n        if (kind === 0 /* FIELD */) {\n          newInit = newValue;\n        } else if (kind === 1 /* ACCESSOR */) {\n          newInit = old_getInit(newValue);\n          get = newValue.get || value.get;\n          set = newValue.set || value.set;\n\n          value = { get: get, set: set };\n        } else {\n          value = newValue;\n        }\n\n        if (newInit !== void 0) {\n          if (initializer === void 0) {\n            initializer = newInit;\n          } else if (typeof initializer === \"function\") {\n            initializer = [initializer, newInit];\n          } else {\n            initializer.push(newInit);\n          }\n        }\n      }\n    }\n  }\n\n  if (kind === 0 /* FIELD */ || kind === 1 /* ACCESSOR */) {\n    if (initializer === void 0) {\n      // If the initializer was void 0, sub in a dummy initializer\n      initializer = function (instance, init) {\n        return init;\n      };\n    } else if (typeof initializer !== \"function\") {\n      var ownInitializers = initializer;\n\n      initializer = function (instance, init) {\n        var value = init;\n\n        for (var i = 0; i < ownInitializers.length; i++) {\n          value = ownInitializers[i].call(instance, value);\n        }\n\n        return value;\n      };\n    } else {\n      var originalInitializer = initializer;\n\n      initializer = function (instance, init) {\n        return originalInitializer.call(instance, init);\n      };\n    }\n\n    ret.push(initializer);\n  }\n\n  if (kind !== 0 /* FIELD */) {\n    if (kind === 1 /* ACCESSOR */) {\n      desc.get = value.get;\n      desc.set = value.set;\n    } else if (kind === 2 /* METHOD */) {\n      desc.value = value;\n    } else if (kind === 3 /* GETTER */) {\n      desc.get = value;\n    } else if (kind === 4 /* SETTER */) {\n      desc.set = value;\n    }\n\n    if (isPrivate) {\n      if (kind === 1 /* ACCESSOR */) {\n        ret.push(function (instance, args) {\n          return value.get.call(instance, args);\n        });\n        ret.push(function (instance, args) {\n          return value.set.call(instance, args);\n        });\n      } else if (kind === 2 /* METHOD */) {\n        ret.push(value);\n      } else {\n        ret.push(function (instance, args) {\n          return value.call(instance, args);\n        });\n      }\n    } else {\n      Object.defineProperty(base, name, desc);\n    }\n  }\n}\n\nfunction old_applyMemberDecs(\n  ret,\n  Class,\n  protoMetadataMap,\n  staticMetadataMap,\n  decInfos\n) {\n  var protoInitializers;\n  var staticInitializers;\n\n  var existingProtoNonFields = new Map();\n  var existingStaticNonFields = new Map();\n\n  for (var i = 0; i < decInfos.length; i++) {\n    var decInfo = decInfos[i];\n\n    // skip computed property names\n    if (!Array.isArray(decInfo)) continue;\n\n    var kind = decInfo[1];\n    var name = decInfo[2];\n    var isPrivate = decInfo.length > 3;\n\n    var isStatic = kind >= 5; /* STATIC */\n    var base;\n    var metadataMap;\n    var initializers;\n\n    if (isStatic) {\n      base = Class;\n      metadataMap = staticMetadataMap;\n      kind = kind - 5 /* STATIC */;\n      // initialize staticInitializers when we see a non-field static member\n      if (kind !== 0 /* FIELD */) {\n        staticInitializers = staticInitializers || [];\n        initializers = staticInitializers;\n      }\n    } else {\n      base = Class.prototype;\n      metadataMap = protoMetadataMap;\n      // initialize protoInitializers when we see a non-field member\n      if (kind !== 0 /* FIELD */) {\n        protoInitializers = protoInitializers || [];\n        initializers = protoInitializers;\n      }\n    }\n\n    if (kind !== 0 /* FIELD */ && !isPrivate) {\n      var existingNonFields = isStatic\n        ? existingStaticNonFields\n        : existingProtoNonFields;\n\n      var existingKind = existingNonFields.get(name) || 0;\n\n      if (\n        existingKind === true ||\n        (existingKind === 3 /* GETTER */ && kind !== 4) /* SETTER */ ||\n        (existingKind === 4 /* SETTER */ && kind !== 3) /* GETTER */\n      ) {\n        throw new Error(\n          \"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \" +\n            name\n        );\n      } else if (!existingKind && kind > 2 /* METHOD */) {\n        existingNonFields.set(name, kind);\n      } else {\n        existingNonFields.set(name, true);\n      }\n    }\n\n    old_applyMemberDec(\n      ret,\n      base,\n      decInfo,\n      name,\n      kind,\n      isStatic,\n      isPrivate,\n      metadataMap,\n      initializers\n    );\n  }\n\n  old_pushInitializers(ret, protoInitializers);\n  old_pushInitializers(ret, staticInitializers);\n}\n\nfunction old_pushInitializers(ret, initializers) {\n  if (initializers) {\n    ret.push(function (instance) {\n      for (var i = 0; i < initializers.length; i++) {\n        initializers[i].call(instance);\n      }\n      return instance;\n    });\n  }\n}\n\nfunction old_applyClassDecs(ret, targetClass, metadataMap, classDecs) {\n  if (classDecs.length > 0) {\n    var initializers = [];\n    var newClass = targetClass;\n    var name = targetClass.name;\n\n    for (var i = classDecs.length - 1; i >= 0; i--) {\n      var decoratorFinishedRef = { v: false };\n\n      try {\n        var ctx = Object.assign(\n          {\n            kind: \"class\",\n            name: name,\n            addInitializer: old_createAddInitializerMethod(\n              initializers,\n              decoratorFinishedRef\n            ),\n          },\n          old_createMetadataMethodsForProperty(\n            metadataMap,\n            0 /* CONSTRUCTOR */,\n            name,\n            decoratorFinishedRef\n          )\n        );\n        var nextNewClass = classDecs[i](newClass, ctx);\n      } finally {\n        decoratorFinishedRef.v = true;\n      }\n\n      if (nextNewClass !== undefined) {\n        old_assertValidReturnValue(10 /* CLASS */, nextNewClass);\n        newClass = nextNewClass;\n      }\n    }\n\n    ret.push(newClass, function () {\n      for (var i = 0; i < initializers.length; i++) {\n        initializers[i].call(newClass);\n      }\n    });\n  }\n}\n\n/**\n  Basic usage:\n\n  applyDecs(\n    Class,\n    [\n      // member decorators\n      [\n        dec,                // dec or array of decs\n        0,                  // kind of value being decorated\n        'prop',             // name of public prop on class containing the value being decorated,\n        '#p',               // the name of the private property (if is private, void 0 otherwise),\n      ]\n    ],\n    [\n      // class decorators\n      dec1, dec2\n    ]\n  )\n  ```\n\n  Fully transpiled example:\n\n  ```js\n  @dec\n  class Class {\n    @dec\n    a = 123;\n\n    @dec\n    #a = 123;\n\n    @dec\n    @dec2\n    accessor b = 123;\n\n    @dec\n    accessor #b = 123;\n\n    @dec\n    c() { console.log('c'); }\n\n    @dec\n    #c() { console.log('privC'); }\n\n    @dec\n    get d() { console.log('d'); }\n\n    @dec\n    get #d() { console.log('privD'); }\n\n    @dec\n    set e(v) { console.log('e'); }\n\n    @dec\n    set #e(v) { console.log('privE'); }\n  }\n\n\n  // becomes\n  let initializeInstance;\n  let initializeClass;\n\n  let initA;\n  let initPrivA;\n\n  let initB;\n  let initPrivB, getPrivB, setPrivB;\n\n  let privC;\n  let privD;\n  let privE;\n\n  let Class;\n  class _Class {\n    static {\n      let ret = applyDecs(\n        this,\n        [\n          [dec, 0, 'a'],\n          [dec, 0, 'a', (i) => i.#a, (i, v) => i.#a = v],\n          [[dec, dec2], 1, 'b'],\n          [dec, 1, 'b', (i) => i.#privBData, (i, v) => i.#privBData = v],\n          [dec, 2, 'c'],\n          [dec, 2, 'c', () => console.log('privC')],\n          [dec, 3, 'd'],\n          [dec, 3, 'd', () => console.log('privD')],\n          [dec, 4, 'e'],\n          [dec, 4, 'e', () => console.log('privE')],\n        ],\n        [\n          dec\n        ]\n      )\n\n      initA = ret[0];\n\n      initPrivA = ret[1];\n\n      initB = ret[2];\n\n      initPrivB = ret[3];\n      getPrivB = ret[4];\n      setPrivB = ret[5];\n\n      privC = ret[6];\n\n      privD = ret[7];\n\n      privE = ret[8];\n\n      initializeInstance = ret[9];\n\n      Class = ret[10]\n\n      initializeClass = ret[11];\n    }\n\n    a = (initializeInstance(this), initA(this, 123));\n\n    #a = initPrivA(this, 123);\n\n    #bData = initB(this, 123);\n    get b() { return this.#bData }\n    set b(v) { this.#bData = v }\n\n    #privBData = initPrivB(this, 123);\n    get #b() { return getPrivB(this); }\n    set #b(v) { setPrivB(this, v); }\n\n    c() { console.log('c'); }\n\n    #c(...args) { return privC(this, ...args) }\n\n    get d() { console.log('d'); }\n\n    get #d() { return privD(this); }\n\n    set e(v) { console.log('e'); }\n\n    set #e(v) { privE(this, v); }\n  }\n\n  initializeClass(Class);\n */\nexport default function applyDecs(targetClass, memberDecs, classDecs) {\n  var ret = [];\n  var staticMetadataMap = {};\n\n  var protoMetadataMap = {};\n\n  old_applyMemberDecs(\n    ret,\n    targetClass,\n    protoMetadataMap,\n    staticMetadataMap,\n    memberDecs\n  );\n\n  old_convertMetadataMapToFinal(targetClass.prototype, protoMetadataMap);\n\n  old_applyClassDecs(ret, targetClass, staticMetadataMap, classDecs);\n\n  old_convertMetadataMapToFinal(targetClass, staticMetadataMap);\n\n  return ret;\n}\n"]},"metadata":{},"sourceType":"script"}