{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst findCallbackArg = (node, isJestEach) => {\n  if (isJestEach) {\n    return node.arguments[1];\n  }\n\n  if ((0, _utils.isHook)(node) && node.arguments.length >= 1) {\n    return node.arguments[0];\n  }\n\n  if ((0, _utils.isTestCaseCall)(node) && node.arguments.length >= 2) {\n    return node.arguments[1];\n  }\n\n  return null;\n};\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Avoid using a callback in asynchronous tests and hooks',\n      recommended: 'error',\n      suggestion: true\n    },\n    messages: {\n      noDoneCallback: 'Return a Promise instead of relying on callback parameter',\n      suggestWrappingInPromise: 'Wrap in `new Promise({{ callback }} => ...`',\n      useAwaitInsteadOfCallback: 'Use await instead of callback in async functions'\n    },\n    schema: [],\n    type: 'suggestion',\n    hasSuggestions: true\n  },\n  defaultOptions: [],\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        var _getNodeName$endsWith, _getNodeName; // done is the second argument for it.each, not the first\n\n\n        const isJestEach = (_getNodeName$endsWith = (_getNodeName = (0, _utils.getNodeName)(node.callee)) === null || _getNodeName === void 0 ? void 0 : _getNodeName.endsWith('.each')) !== null && _getNodeName$endsWith !== void 0 ? _getNodeName$endsWith : false;\n\n        if (isJestEach && node.callee.type !== _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression) {\n          // isJestEach but not a TaggedTemplateExpression, so this must be\n          // the `jest.each([])()` syntax which this rule doesn't support due\n          // to its complexity (see jest-community/eslint-plugin-jest#710)\n          return;\n        }\n\n        const callback = findCallbackArg(node, isJestEach);\n        const callbackArgIndex = Number(isJestEach);\n\n        if (!callback || !(0, _utils.isFunction)(callback) || callback.params.length !== 1 + callbackArgIndex) {\n          return;\n        }\n\n        const argument = callback.params[callbackArgIndex];\n\n        if (argument.type !== _experimentalUtils.AST_NODE_TYPES.Identifier) {\n          context.report({\n            node: argument,\n            messageId: 'noDoneCallback'\n          });\n          return;\n        }\n\n        if (callback.async) {\n          context.report({\n            node: argument,\n            messageId: 'useAwaitInsteadOfCallback'\n          });\n          return;\n        }\n\n        context.report({\n          node: argument,\n          messageId: 'noDoneCallback',\n          suggest: [{\n            messageId: 'suggestWrappingInPromise',\n            data: {\n              callback: argument.name\n            },\n\n            fix(fixer) {\n              const {\n                body\n              } = callback;\n              const sourceCode = context.getSourceCode();\n              const firstBodyToken = sourceCode.getFirstToken(body);\n              const lastBodyToken = sourceCode.getLastToken(body);\n              const tokenBeforeArgument = sourceCode.getTokenBefore(argument);\n              const tokenAfterArgument = sourceCode.getTokenAfter(argument);\n              /* istanbul ignore if */\n\n              if (!firstBodyToken || !lastBodyToken || !tokenBeforeArgument || !tokenAfterArgument) {\n                throw new Error(`Unexpected null when attempting to fix ${context.getFilename()} - please file a github issue at https://github.com/jest-community/eslint-plugin-jest`);\n              }\n\n              const argumentInParens = tokenBeforeArgument.value === '(' && tokenAfterArgument.value === ')';\n              let argumentFix = fixer.replaceText(argument, '()');\n\n              if (argumentInParens) {\n                argumentFix = fixer.remove(argument);\n              }\n\n              let newCallback = argument.name;\n\n              if (argumentInParens) {\n                newCallback = `(${newCallback})`;\n              }\n\n              let beforeReplacement = `new Promise(${newCallback} => `;\n              let afterReplacement = ')';\n              let replaceBefore = true;\n\n              if (body.type === _experimentalUtils.AST_NODE_TYPES.BlockStatement) {\n                const keyword = 'return';\n                beforeReplacement = `${keyword} ${beforeReplacement}{`;\n                afterReplacement += '}';\n                replaceBefore = false;\n              }\n\n              return [argumentFix, replaceBefore ? fixer.insertTextBefore(firstBodyToken, beforeReplacement) : fixer.insertTextAfter(firstBodyToken, beforeReplacement), fixer.insertTextAfter(lastBodyToken, afterReplacement)];\n            }\n\n          }]\n        });\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_experimentalUtils","require","_utils","findCallbackArg","node","isJestEach","arguments","isHook","length","isTestCaseCall","_default","createRule","name","__filename","meta","docs","category","description","recommended","suggestion","messages","noDoneCallback","suggestWrappingInPromise","useAwaitInsteadOfCallback","schema","type","hasSuggestions","defaultOptions","create","context","CallExpression","_getNodeName$endsWith","_getNodeName","getNodeName","callee","endsWith","AST_NODE_TYPES","TaggedTemplateExpression","callback","callbackArgIndex","Number","isFunction","params","argument","Identifier","report","messageId","async","suggest","data","fix","fixer","body","sourceCode","getSourceCode","firstBodyToken","getFirstToken","lastBodyToken","getLastToken","tokenBeforeArgument","getTokenBefore","tokenAfterArgument","getTokenAfter","Error","getFilename","argumentInParens","argumentFix","replaceText","remove","newCallback","beforeReplacement","afterReplacement","replaceBefore","BlockStatement","keyword","insertTextBefore","insertTextAfter"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-jest/lib/rules/no-done-callback.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst findCallbackArg = (node, isJestEach) => {\n  if (isJestEach) {\n    return node.arguments[1];\n  }\n\n  if ((0, _utils.isHook)(node) && node.arguments.length >= 1) {\n    return node.arguments[0];\n  }\n\n  if ((0, _utils.isTestCaseCall)(node) && node.arguments.length >= 2) {\n    return node.arguments[1];\n  }\n\n  return null;\n};\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Avoid using a callback in asynchronous tests and hooks',\n      recommended: 'error',\n      suggestion: true\n    },\n    messages: {\n      noDoneCallback: 'Return a Promise instead of relying on callback parameter',\n      suggestWrappingInPromise: 'Wrap in `new Promise({{ callback }} => ...`',\n      useAwaitInsteadOfCallback: 'Use await instead of callback in async functions'\n    },\n    schema: [],\n    type: 'suggestion',\n    hasSuggestions: true\n  },\n  defaultOptions: [],\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        var _getNodeName$endsWith, _getNodeName;\n\n        // done is the second argument for it.each, not the first\n        const isJestEach = (_getNodeName$endsWith = (_getNodeName = (0, _utils.getNodeName)(node.callee)) === null || _getNodeName === void 0 ? void 0 : _getNodeName.endsWith('.each')) !== null && _getNodeName$endsWith !== void 0 ? _getNodeName$endsWith : false;\n\n        if (isJestEach && node.callee.type !== _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression) {\n          // isJestEach but not a TaggedTemplateExpression, so this must be\n          // the `jest.each([])()` syntax which this rule doesn't support due\n          // to its complexity (see jest-community/eslint-plugin-jest#710)\n          return;\n        }\n\n        const callback = findCallbackArg(node, isJestEach);\n        const callbackArgIndex = Number(isJestEach);\n\n        if (!callback || !(0, _utils.isFunction)(callback) || callback.params.length !== 1 + callbackArgIndex) {\n          return;\n        }\n\n        const argument = callback.params[callbackArgIndex];\n\n        if (argument.type !== _experimentalUtils.AST_NODE_TYPES.Identifier) {\n          context.report({\n            node: argument,\n            messageId: 'noDoneCallback'\n          });\n          return;\n        }\n\n        if (callback.async) {\n          context.report({\n            node: argument,\n            messageId: 'useAwaitInsteadOfCallback'\n          });\n          return;\n        }\n\n        context.report({\n          node: argument,\n          messageId: 'noDoneCallback',\n          suggest: [{\n            messageId: 'suggestWrappingInPromise',\n            data: {\n              callback: argument.name\n            },\n\n            fix(fixer) {\n              const {\n                body\n              } = callback;\n              const sourceCode = context.getSourceCode();\n              const firstBodyToken = sourceCode.getFirstToken(body);\n              const lastBodyToken = sourceCode.getLastToken(body);\n              const tokenBeforeArgument = sourceCode.getTokenBefore(argument);\n              const tokenAfterArgument = sourceCode.getTokenAfter(argument);\n              /* istanbul ignore if */\n\n              if (!firstBodyToken || !lastBodyToken || !tokenBeforeArgument || !tokenAfterArgument) {\n                throw new Error(`Unexpected null when attempting to fix ${context.getFilename()} - please file a github issue at https://github.com/jest-community/eslint-plugin-jest`);\n              }\n\n              const argumentInParens = tokenBeforeArgument.value === '(' && tokenAfterArgument.value === ')';\n              let argumentFix = fixer.replaceText(argument, '()');\n\n              if (argumentInParens) {\n                argumentFix = fixer.remove(argument);\n              }\n\n              let newCallback = argument.name;\n\n              if (argumentInParens) {\n                newCallback = `(${newCallback})`;\n              }\n\n              let beforeReplacement = `new Promise(${newCallback} => `;\n              let afterReplacement = ')';\n              let replaceBefore = true;\n\n              if (body.type === _experimentalUtils.AST_NODE_TYPES.BlockStatement) {\n                const keyword = 'return';\n                beforeReplacement = `${keyword} ${beforeReplacement}{`;\n                afterReplacement += '}';\n                replaceBefore = false;\n              }\n\n              return [argumentFix, replaceBefore ? fixer.insertTextBefore(firstBodyToken, beforeReplacement) : fixer.insertTextAfter(firstBodyToken, beforeReplacement), fixer.insertTextAfter(lastBodyToken, afterReplacement)];\n            }\n\n          }]\n        });\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}