{"ast":null,"code":"/*! sprintf-js | Alexandru Marasteanu <hello@alexei.ro> (http://alexei.ro/) | BSD-3-Clause */\n!function (a) {\n  function b() {\n    var a = arguments[0],\n        c = b.cache;\n    return c[a] && c.hasOwnProperty(a) || (c[a] = b.parse(a)), b.format.call(null, c[a], arguments);\n  }\n\n  function c(a) {\n    return Object.prototype.toString.call(a).slice(8, -1).toLowerCase();\n  }\n\n  function d(a, b) {\n    return Array(b + 1).join(a);\n  }\n\n  var e = {\n    not_string: /[^s]/,\n    number: /[diefg]/,\n    json: /[j]/,\n    not_json: /[^j]/,\n    text: /^[^\\x25]+/,\n    modulo: /^\\x25{2}/,\n    placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijosuxX])/,\n    key: /^([a-z_][a-z_\\d]*)/i,\n    key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n    index_access: /^\\[(\\d+)\\]/,\n    sign: /^[\\+\\-]/\n  };\n  b.format = function (a, f) {\n    var g,\n        h,\n        i,\n        j,\n        k,\n        l,\n        m,\n        n = 1,\n        o = a.length,\n        p = \"\",\n        q = [],\n        r = !0,\n        s = \"\";\n\n    for (h = 0; o > h; h++) if (p = c(a[h]), \"string\" === p) q[q.length] = a[h];else if (\"array\" === p) {\n      if (j = a[h], j[2]) for (g = f[n], i = 0; i < j[2].length; i++) {\n        if (!g.hasOwnProperty(j[2][i])) throw new Error(b(\"[sprintf] property '%s' does not exist\", j[2][i]));\n        g = g[j[2][i]];\n      } else g = j[1] ? f[j[1]] : f[n++];\n      if (\"function\" == c(g) && (g = g()), e.not_string.test(j[8]) && e.not_json.test(j[8]) && \"number\" != c(g) && isNaN(g)) throw new TypeError(b(\"[sprintf] expecting number but found %s\", c(g)));\n\n      switch (e.number.test(j[8]) && (r = g >= 0), j[8]) {\n        case \"b\":\n          g = g.toString(2);\n          break;\n\n        case \"c\":\n          g = String.fromCharCode(g);\n          break;\n\n        case \"d\":\n        case \"i\":\n          g = parseInt(g, 10);\n          break;\n\n        case \"j\":\n          g = JSON.stringify(g, null, j[6] ? parseInt(j[6]) : 0);\n          break;\n\n        case \"e\":\n          g = j[7] ? g.toExponential(j[7]) : g.toExponential();\n          break;\n\n        case \"f\":\n          g = j[7] ? parseFloat(g).toFixed(j[7]) : parseFloat(g);\n          break;\n\n        case \"g\":\n          g = j[7] ? parseFloat(g).toPrecision(j[7]) : parseFloat(g);\n          break;\n\n        case \"o\":\n          g = g.toString(8);\n          break;\n\n        case \"s\":\n          g = (g = String(g)) && j[7] ? g.substring(0, j[7]) : g;\n          break;\n\n        case \"u\":\n          g >>>= 0;\n          break;\n\n        case \"x\":\n          g = g.toString(16);\n          break;\n\n        case \"X\":\n          g = g.toString(16).toUpperCase();\n      }\n\n      e.json.test(j[8]) ? q[q.length] = g : (!e.number.test(j[8]) || r && !j[3] ? s = \"\" : (s = r ? \"+\" : \"-\", g = g.toString().replace(e.sign, \"\")), l = j[4] ? \"0\" === j[4] ? \"0\" : j[4].charAt(1) : \" \", m = j[6] - (s + g).length, k = j[6] && m > 0 ? d(l, m) : \"\", q[q.length] = j[5] ? s + g + k : \"0\" === l ? s + k + g : k + s + g);\n    }\n\n    return q.join(\"\");\n  }, b.cache = {}, b.parse = function (a) {\n    for (var b = a, c = [], d = [], f = 0; b;) {\n      if (null !== (c = e.text.exec(b))) d[d.length] = c[0];else if (null !== (c = e.modulo.exec(b))) d[d.length] = \"%\";else {\n        if (null === (c = e.placeholder.exec(b))) throw new SyntaxError(\"[sprintf] unexpected placeholder\");\n\n        if (c[2]) {\n          f |= 1;\n          var g = [],\n              h = c[2],\n              i = [];\n          if (null === (i = e.key.exec(h))) throw new SyntaxError(\"[sprintf] failed to parse named argument key\");\n\n          for (g[g.length] = i[1]; \"\" !== (h = h.substring(i[0].length));) if (null !== (i = e.key_access.exec(h))) g[g.length] = i[1];else {\n            if (null === (i = e.index_access.exec(h))) throw new SyntaxError(\"[sprintf] failed to parse named argument key\");\n            g[g.length] = i[1];\n          }\n\n          c[2] = g;\n        } else f |= 2;\n\n        if (3 === f) throw new Error(\"[sprintf] mixing positional and named placeholders is not (yet) supported\");\n        d[d.length] = c;\n      }\n      b = b.substring(c[0].length);\n    }\n\n    return d;\n  };\n\n  var f = function (a, c, d) {\n    return d = (c || []).slice(0), d.splice(0, 0, a), b.apply(null, d);\n  };\n\n  \"undefined\" != typeof exports ? (exports.sprintf = b, exports.vsprintf = f) : (a.sprintf = b, a.vsprintf = f, \"function\" == typeof define && define.amd && define(function () {\n    return {\n      sprintf: b,\n      vsprintf: f\n    };\n  }));\n}(\"undefined\" == typeof window ? this : window);","map":{"version":3,"mappings":"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","names":["window","sprintf","key","arguments","cache","hasOwnProperty","parse","format","call","get_type","variable","Object","prototype","toString","slice","toLowerCase","str_repeat","input","multiplier","Array","join","re","not_string","number","json","not_json","text","modulo","placeholder","key_access","index_access","sign","parse_tree","argv","arg","i","k","match","pad","pad_character","pad_length","cursor","tree_length","length","node_type","output","is_positive","Error","test","isNaN","TypeError","String","fromCharCode","parseInt","JSON","stringify","toExponential","parseFloat","toFixed","toPrecision","substring","toUpperCase","replace","charAt","fmt","_fmt","arg_names","exec","SyntaxError","field_list","replacement_field","field_match","vsprintf","_argv","splice","apply","exports","define","amd","this"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\sprintf-js\\src\\sprintf.js"],"sourcesContent":["(function(window) {\n    var re = {\n        not_string: /[^s]/,\n        number: /[diefg]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijosuxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[\\+\\-]/\n    }\n\n    function sprintf() {\n        var key = arguments[0], cache = sprintf.cache\n        if (!(cache[key] && cache.hasOwnProperty(key))) {\n            cache[key] = sprintf.parse(key)\n        }\n        return sprintf.format.call(null, cache[key], arguments)\n    }\n\n    sprintf.format = function(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, node_type = \"\", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = \"\"\n        for (i = 0; i < tree_length; i++) {\n            node_type = get_type(parse_tree[i])\n            if (node_type === \"string\") {\n                output[output.length] = parse_tree[i]\n            }\n            else if (node_type === \"array\") {\n                match = parse_tree[i] // convenience purposes only\n                if (match[2]) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < match[2].length; k++) {\n                        if (!arg.hasOwnProperty(match[2][k])) {\n                            throw new Error(sprintf(\"[sprintf] property '%s' does not exist\", match[2][k]))\n                        }\n                        arg = arg[match[2][k]]\n                    }\n                }\n                else if (match[1]) { // positional argument (explicit)\n                    arg = argv[match[1]]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (get_type(arg) == \"function\") {\n                    arg = arg()\n                }\n\n                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != \"number\" && isNaN(arg))) {\n                    throw new TypeError(sprintf(\"[sprintf] expecting number but found %s\", get_type(arg)))\n                }\n\n                if (re.number.test(match[8])) {\n                    is_positive = arg >= 0\n                }\n\n                switch (match[8]) {\n                    case \"b\":\n                        arg = arg.toString(2)\n                    break\n                    case \"c\":\n                        arg = String.fromCharCode(arg)\n                    break\n                    case \"d\":\n                    case \"i\":\n                        arg = parseInt(arg, 10)\n                    break\n                    case \"j\":\n                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)\n                    break\n                    case \"e\":\n                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()\n                    break\n                    case \"f\":\n                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)\n                    break\n                    case \"g\":\n                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)\n                    break\n                    case \"o\":\n                        arg = arg.toString(8)\n                    break\n                    case \"s\":\n                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)\n                    break\n                    case \"u\":\n                        arg = arg >>> 0\n                    break\n                    case \"x\":\n                        arg = arg.toString(16)\n                    break\n                    case \"X\":\n                        arg = arg.toString(16).toUpperCase()\n                    break\n                }\n                if (re.json.test(match[8])) {\n                    output[output.length] = arg\n                }\n                else {\n                    if (re.number.test(match[8]) && (!is_positive || match[3])) {\n                        sign = is_positive ? \"+\" : \"-\"\n                        arg = arg.toString().replace(re.sign, \"\")\n                    }\n                    else {\n                        sign = \"\"\n                    }\n                    pad_character = match[4] ? match[4] === \"0\" ? \"0\" : match[4].charAt(1) : \" \"\n                    pad_length = match[6] - (sign + arg).length\n                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : \"\") : \"\"\n                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === \"0\" ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output.join(\"\")\n    }\n\n    sprintf.cache = {}\n\n    sprintf.parse = function(fmt) {\n        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree[parse_tree.length] = match[0]\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree[parse_tree.length] = \"%\"\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list[field_list.length] = field_match[1]\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== \"\") {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list[field_list.length] = field_match[1]\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list[field_list.length] = field_match[1]\n                            }\n                            else {\n                                throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error(\"[sprintf] mixing positional and named placeholders is not (yet) supported\")\n                }\n                parse_tree[parse_tree.length] = match\n            }\n            else {\n                throw new SyntaxError(\"[sprintf] unexpected placeholder\")\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return parse_tree\n    }\n\n    var vsprintf = function(fmt, argv, _argv) {\n        _argv = (argv || []).slice(0)\n        _argv.splice(0, 0, fmt)\n        return sprintf.apply(null, _argv)\n    }\n\n    /**\n     * helpers\n     */\n    function get_type(variable) {\n        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()\n    }\n\n    function str_repeat(input, multiplier) {\n        return Array(multiplier + 1).join(input)\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    if (typeof exports !== \"undefined\") {\n        exports.sprintf = sprintf\n        exports.vsprintf = vsprintf\n    }\n    else {\n        window.sprintf = sprintf\n        window.vsprintf = vsprintf\n\n        if (typeof define === \"function\" && define.amd) {\n            define(function() {\n                return {\n                    sprintf: sprintf,\n                    vsprintf: vsprintf\n                }\n            })\n        }\n    }\n})(typeof window === \"undefined\" ? this : window);\n"]},"metadata":{},"sourceType":"script"}