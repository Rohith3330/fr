{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.phrases = void 0;\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nexports.phrases = {\n  [utils_1.AST_NODE_TYPES.TSTypeLiteral]: 'Type literal',\n  [utils_1.AST_NODE_TYPES.TSInterfaceDeclaration]: 'Interface'\n};\nexports.default = util.createRule({\n  name: 'prefer-function-type',\n  meta: {\n    docs: {\n      description: 'Enforce using function types instead of interfaces with call signatures',\n      recommended: 'strict'\n    },\n    fixable: 'code',\n    messages: {\n      functionTypeOverCallableType: '{{ literalOrInterface }} only has a call signature, you should use a function type instead.',\n      unexpectedThisOnFunctionOnlyInterface: \"`this` refers to the function type '{{ interfaceName }}', did you intend to use a generic `this` parameter like `<Self>(this: Self, ...) => Self` instead?\"\n    },\n    schema: [],\n    type: 'suggestion'\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\n     * Checks if there the interface has exactly one supertype that isn't named 'Function'\n     * @param node The node being checked\n     */\n\n    function hasOneSupertype(node) {\n      if (!node.extends || node.extends.length === 0) {\n        return false;\n      }\n\n      if (node.extends.length !== 1) {\n        return true;\n      }\n\n      const expr = node.extends[0].expression;\n      return expr.type !== utils_1.AST_NODE_TYPES.Identifier || expr.name !== 'Function';\n    }\n    /**\n     * @param parent The parent of the call signature causing the diagnostic\n     */\n\n\n    function shouldWrapSuggestion(parent) {\n      if (!parent) {\n        return false;\n      }\n\n      switch (parent.type) {\n        case utils_1.AST_NODE_TYPES.TSUnionType:\n        case utils_1.AST_NODE_TYPES.TSIntersectionType:\n        case utils_1.AST_NODE_TYPES.TSArrayType:\n          return true;\n\n        default:\n          return false;\n      }\n    }\n    /**\n     * @param member The TypeElement being checked\n     * @param node The parent of member being checked\n     * @param tsThisTypes\n     */\n\n\n    function checkMember(member, node) {\n      let tsThisTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      if ((member.type === utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration || member.type === utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration) && typeof member.returnType !== 'undefined') {\n        if (tsThisTypes !== null && tsThisTypes.length > 0 && node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration) {\n          // the message can be confusing if we don't point directly to the `this` node instead of the whole member\n          // and in favour of generating at most one error we'll only report the first occurrence of `this` if there are multiple\n          context.report({\n            node: tsThisTypes[0],\n            messageId: 'unexpectedThisOnFunctionOnlyInterface',\n            data: {\n              interfaceName: node.id.name\n            }\n          });\n          return;\n        }\n\n        const fixable = node.parent && node.parent.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration;\n        const fix = fixable ? null : fixer => {\n          const fixes = [];\n          const start = member.range[0];\n          const colonPos = member.returnType.range[0] - start;\n          const text = sourceCode.getText().slice(start, member.range[1]);\n          const comments = sourceCode.getCommentsBefore(member).concat(sourceCode.getCommentsAfter(member));\n          let suggestion = `${text.slice(0, colonPos)} =>${text.slice(colonPos + 1)}`;\n          const lastChar = suggestion.endsWith(';') ? ';' : '';\n\n          if (lastChar) {\n            suggestion = suggestion.slice(0, -1);\n          }\n\n          if (shouldWrapSuggestion(node.parent)) {\n            suggestion = `(${suggestion})`;\n          }\n\n          if (node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration) {\n            if (typeof node.typeParameters !== 'undefined') {\n              suggestion = `type ${sourceCode.getText().slice(node.id.range[0], node.typeParameters.range[1])} = ${suggestion}${lastChar}`;\n            } else {\n              suggestion = `type ${node.id.name} = ${suggestion}${lastChar}`;\n            }\n          }\n\n          const isParentExported = node.parent && node.parent.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration;\n\n          if (node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration && isParentExported) {\n            const commentsText = comments.reduce((text, comment) => {\n              return text + (comment.type === utils_1.AST_TOKEN_TYPES.Line ? `//${comment.value}` : `/*${comment.value}*/`) + '\\n';\n            }, ''); // comments should move before export and not between export and interface declaration\n\n            fixes.push(fixer.insertTextBefore(node.parent, commentsText));\n          } else {\n            comments.forEach(comment => {\n              let commentText = comment.type === utils_1.AST_TOKEN_TYPES.Line ? `//${comment.value}` : `/*${comment.value}*/`;\n              const isCommentOnTheSameLine = comment.loc.start.line === member.loc.start.line;\n\n              if (!isCommentOnTheSameLine) {\n                commentText += '\\n';\n              } else {\n                commentText += ' ';\n              }\n\n              suggestion = commentText + suggestion;\n            });\n          }\n\n          const fixStart = node.range[0];\n          fixes.push(fixer.replaceTextRange([fixStart, node.range[1]], suggestion));\n          return fixes;\n        };\n        context.report({\n          node: member,\n          messageId: 'functionTypeOverCallableType',\n          data: {\n            literalOrInterface: exports.phrases[node.type]\n          },\n          fix\n        });\n      }\n    }\n\n    let tsThisTypes = null;\n    let literalNesting = 0;\n    return {\n      TSInterfaceDeclaration() {\n        // when entering an interface reset the count of `this`s to empty.\n        tsThisTypes = [];\n      },\n\n      'TSInterfaceDeclaration TSThisType'(node) {\n        // inside an interface keep track of all ThisType references.\n        // unless it's inside a nested type literal in which case it's invalid code anyway\n        // we don't want to incorrectly say \"it refers to name\" while typescript says it's completely invalid.\n        if (literalNesting === 0 && tsThisTypes !== null) {\n          tsThisTypes.push(node);\n        }\n      },\n\n      'TSInterfaceDeclaration:exit'(node) {\n        if (!hasOneSupertype(node) && node.body.body.length === 1) {\n          checkMember(node.body.body[0], node, tsThisTypes);\n        } // on exit check member and reset the array to nothing.\n\n\n        tsThisTypes = null;\n      },\n\n      // keep track of nested literals to avoid complaining about invalid `this` uses\n      'TSInterfaceDeclaration TSTypeLiteral'() {\n        literalNesting += 1;\n      },\n\n      'TSInterfaceDeclaration TSTypeLiteral:exit'() {\n        literalNesting -= 1;\n      },\n\n      'TSTypeLiteral[members.length = 1]'(node) {\n        checkMember(node.members[0], node);\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","utils_1","TSTypeLiteral","TSInterfaceDeclaration","util","createRule","name","meta","docs","description","recommended","fixable","messages","functionTypeOverCallableType","unexpectedThisOnFunctionOnlyInterface","schema","type","defaultOptions","create","context","sourceCode","getSourceCode","hasOneSupertype","node","extends","length","expr","expression","Identifier","shouldWrapSuggestion","parent","TSUnionType","TSIntersectionType","TSArrayType","checkMember","member","tsThisTypes","TSCallSignatureDeclaration","TSConstructSignatureDeclaration","returnType","report","messageId","data","interfaceName","id","ExportDefaultDeclaration","fix","fixer","fixes","start","range","colonPos","text","getText","slice","comments","getCommentsBefore","concat","getCommentsAfter","suggestion","lastChar","endsWith","typeParameters","isParentExported","ExportNamedDeclaration","commentsText","reduce","comment","Line","value","push","insertTextBefore","forEach","commentText","isCommentOnTheSameLine","loc","line","fixStart","replaceTextRange","literalOrInterface","literalNesting","body","members"],"sources":["../../src/rules/prefer-function-type.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}