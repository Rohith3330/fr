{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.MagicString = factory());\n})(this, function () {\n  'use strict';\n\n  var BitSet = function BitSet(arg) {\n    this.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n  };\n\n  BitSet.prototype.add = function add(n) {\n    this.bits[n >> 5] |= 1 << (n & 31);\n  };\n\n  BitSet.prototype.has = function has(n) {\n    return !!(this.bits[n >> 5] & 1 << (n & 31));\n  };\n\n  var Chunk = function Chunk(start, end, content) {\n    this.start = start;\n    this.end = end;\n    this.original = content;\n    this.intro = '';\n    this.outro = '';\n    this.content = content;\n    this.storeName = false;\n    this.edited = false; // we make these non-enumerable, for sanity while debugging\n\n    Object.defineProperties(this, {\n      previous: {\n        writable: true,\n        value: null\n      },\n      next: {\n        writable: true,\n        value: null\n      }\n    });\n  };\n\n  Chunk.prototype.appendLeft = function appendLeft(content) {\n    this.outro += content;\n  };\n\n  Chunk.prototype.appendRight = function appendRight(content) {\n    this.intro = this.intro + content;\n  };\n\n  Chunk.prototype.clone = function clone() {\n    var chunk = new Chunk(this.start, this.end, this.original);\n    chunk.intro = this.intro;\n    chunk.outro = this.outro;\n    chunk.content = this.content;\n    chunk.storeName = this.storeName;\n    chunk.edited = this.edited;\n    return chunk;\n  };\n\n  Chunk.prototype.contains = function contains(index) {\n    return this.start < index && index < this.end;\n  };\n\n  Chunk.prototype.eachNext = function eachNext(fn) {\n    var chunk = this;\n\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.next;\n    }\n  };\n\n  Chunk.prototype.eachPrevious = function eachPrevious(fn) {\n    var chunk = this;\n\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.previous;\n    }\n  };\n\n  Chunk.prototype.edit = function edit(content, storeName, contentOnly) {\n    this.content = content;\n\n    if (!contentOnly) {\n      this.intro = '';\n      this.outro = '';\n    }\n\n    this.storeName = storeName;\n    this.edited = true;\n    return this;\n  };\n\n  Chunk.prototype.prependLeft = function prependLeft(content) {\n    this.outro = content + this.outro;\n  };\n\n  Chunk.prototype.prependRight = function prependRight(content) {\n    this.intro = content + this.intro;\n  };\n\n  Chunk.prototype.split = function split(index) {\n    var sliceIndex = index - this.start;\n    var originalBefore = this.original.slice(0, sliceIndex);\n    var originalAfter = this.original.slice(sliceIndex);\n    this.original = originalBefore;\n    var newChunk = new Chunk(index, this.end, originalAfter);\n    newChunk.outro = this.outro;\n    this.outro = '';\n    this.end = index;\n\n    if (this.edited) {\n      // TODO is this block necessary?...\n      newChunk.edit('', false);\n      this.content = '';\n    } else {\n      this.content = originalBefore;\n    }\n\n    newChunk.next = this.next;\n\n    if (newChunk.next) {\n      newChunk.next.previous = newChunk;\n    }\n\n    newChunk.previous = this;\n    this.next = newChunk;\n    return newChunk;\n  };\n\n  Chunk.prototype.toString = function toString() {\n    return this.intro + this.content + this.outro;\n  };\n\n  Chunk.prototype.trimEnd = function trimEnd(rx) {\n    this.outro = this.outro.replace(rx, '');\n\n    if (this.outro.length) {\n      return true;\n    }\n\n    var trimmed = this.content.replace(rx, '');\n\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.start + trimmed.length).edit('', undefined, true);\n      }\n\n      return true;\n    } else {\n      this.edit('', undefined, true);\n      this.intro = this.intro.replace(rx, '');\n\n      if (this.intro.length) {\n        return true;\n      }\n    }\n  };\n\n  Chunk.prototype.trimStart = function trimStart(rx) {\n    this.intro = this.intro.replace(rx, '');\n\n    if (this.intro.length) {\n      return true;\n    }\n\n    var trimmed = this.content.replace(rx, '');\n\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.end - trimmed.length);\n        this.edit('', undefined, true);\n      }\n\n      return true;\n    } else {\n      this.edit('', undefined, true);\n      this.outro = this.outro.replace(rx, '');\n\n      if (this.outro.length) {\n        return true;\n      }\n    }\n  };\n\n  var charToInteger = {};\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  for (var i = 0; i < chars.length; i++) {\n    charToInteger[chars.charCodeAt(i)] = i;\n  }\n\n  function encode(decoded) {\n    var sourceFileIndex = 0; // second field\n\n    var sourceCodeLine = 0; // third field\n\n    var sourceCodeColumn = 0; // fourth field\n\n    var nameIndex = 0; // fifth field\n\n    var mappings = '';\n\n    for (var i = 0; i < decoded.length; i++) {\n      var line = decoded[i];\n      if (i > 0) mappings += ';';\n      if (line.length === 0) continue;\n      var generatedCodeColumn = 0; // first field\n\n      var lineMappings = [];\n\n      for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n        var segment = line_1[_i];\n        var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n        generatedCodeColumn = segment[0];\n\n        if (segment.length > 1) {\n          segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);\n          sourceFileIndex = segment[1];\n          sourceCodeLine = segment[2];\n          sourceCodeColumn = segment[3];\n        }\n\n        if (segment.length === 5) {\n          segmentMappings += encodeInteger(segment[4] - nameIndex);\n          nameIndex = segment[4];\n        }\n\n        lineMappings.push(segmentMappings);\n      }\n\n      mappings += lineMappings.join(',');\n    }\n\n    return mappings;\n  }\n\n  function encodeInteger(num) {\n    var result = '';\n    num = num < 0 ? -num << 1 | 1 : num << 1;\n\n    do {\n      var clamped = num & 31;\n      num >>>= 5;\n\n      if (num > 0) {\n        clamped |= 32;\n      }\n\n      result += chars[clamped];\n    } while (num > 0);\n\n    return result;\n  }\n\n  var btoa = function () {\n    throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n  };\n\n  if (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n    btoa = function (str) {\n      return window.btoa(unescape(encodeURIComponent(str)));\n    };\n  } else if (typeof Buffer === 'function') {\n    btoa = function (str) {\n      return Buffer.from(str, 'utf-8').toString('base64');\n    };\n  }\n\n  var SourceMap = function SourceMap(properties) {\n    this.version = 3;\n    this.file = properties.file;\n    this.sources = properties.sources;\n    this.sourcesContent = properties.sourcesContent;\n    this.names = properties.names;\n    this.mappings = encode(properties.mappings);\n  };\n\n  SourceMap.prototype.toString = function toString() {\n    return JSON.stringify(this);\n  };\n\n  SourceMap.prototype.toUrl = function toUrl() {\n    return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n  };\n\n  function guessIndent(code) {\n    var lines = code.split('\\n');\n    var tabbed = lines.filter(function (line) {\n      return /^\\t+/.test(line);\n    });\n    var spaced = lines.filter(function (line) {\n      return /^ {2,}/.test(line);\n    });\n\n    if (tabbed.length === 0 && spaced.length === 0) {\n      return null;\n    } // More lines tabbed than spaced? Assume tabs, and\n    // default to tabs in the case of a tie (or nothing\n    // to go on)\n\n\n    if (tabbed.length >= spaced.length) {\n      return '\\t';\n    } // Otherwise, we need to guess the multiple\n\n\n    var min = spaced.reduce(function (previous, current) {\n      var numSpaces = /^ +/.exec(current)[0].length;\n      return Math.min(numSpaces, previous);\n    }, Infinity);\n    return new Array(min + 1).join(' ');\n  }\n\n  function getRelativePath(from, to) {\n    var fromParts = from.split(/[/\\\\]/);\n    var toParts = to.split(/[/\\\\]/);\n    fromParts.pop(); // get dirname\n\n    while (fromParts[0] === toParts[0]) {\n      fromParts.shift();\n      toParts.shift();\n    }\n\n    if (fromParts.length) {\n      var i = fromParts.length;\n\n      while (i--) {\n        fromParts[i] = '..';\n      }\n    }\n\n    return fromParts.concat(toParts).join('/');\n  }\n\n  var toString = Object.prototype.toString;\n\n  function isObject(thing) {\n    return toString.call(thing) === '[object Object]';\n  }\n\n  function getLocator(source) {\n    var originalLines = source.split('\\n');\n    var lineOffsets = [];\n\n    for (var i = 0, pos = 0; i < originalLines.length; i++) {\n      lineOffsets.push(pos);\n      pos += originalLines[i].length + 1;\n    }\n\n    return function locate(index) {\n      var i = 0;\n      var j = lineOffsets.length;\n\n      while (i < j) {\n        var m = i + j >> 1;\n\n        if (index < lineOffsets[m]) {\n          j = m;\n        } else {\n          i = m + 1;\n        }\n      }\n\n      var line = i - 1;\n      var column = index - lineOffsets[line];\n      return {\n        line: line,\n        column: column\n      };\n    };\n  }\n\n  var Mappings = function Mappings(hires) {\n    this.hires = hires;\n    this.generatedCodeLine = 0;\n    this.generatedCodeColumn = 0;\n    this.raw = [];\n    this.rawSegments = this.raw[this.generatedCodeLine] = [];\n    this.pending = null;\n  };\n\n  Mappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {\n    if (content.length) {\n      var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n      if (nameIndex >= 0) {\n        segment.push(nameIndex);\n      }\n\n      this.rawSegments.push(segment);\n    } else if (this.pending) {\n      this.rawSegments.push(this.pending);\n    }\n\n    this.advance(content);\n    this.pending = null;\n  };\n\n  Mappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n    var originalCharIndex = chunk.start;\n    var first = true;\n\n    while (originalCharIndex < chunk.end) {\n      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n        this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n      }\n\n      if (original[originalCharIndex] === '\\n') {\n        loc.line += 1;\n        loc.column = 0;\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        first = true;\n      } else {\n        loc.column += 1;\n        this.generatedCodeColumn += 1;\n        first = false;\n      }\n\n      originalCharIndex += 1;\n    }\n\n    this.pending = null;\n  };\n\n  Mappings.prototype.advance = function advance(str) {\n    if (!str) {\n      return;\n    }\n\n    var lines = str.split('\\n');\n\n    if (lines.length > 1) {\n      for (var i = 0; i < lines.length - 1; i++) {\n        this.generatedCodeLine++;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      }\n\n      this.generatedCodeColumn = 0;\n    }\n\n    this.generatedCodeColumn += lines[lines.length - 1].length;\n  };\n\n  var n = '\\n';\n  var warned = {\n    insertLeft: false,\n    insertRight: false,\n    storeName: false\n  };\n\n  var MagicString = function MagicString(string, options) {\n    if (options === void 0) options = {};\n    var chunk = new Chunk(0, string.length, string);\n    Object.defineProperties(this, {\n      original: {\n        writable: true,\n        value: string\n      },\n      outro: {\n        writable: true,\n        value: ''\n      },\n      intro: {\n        writable: true,\n        value: ''\n      },\n      firstChunk: {\n        writable: true,\n        value: chunk\n      },\n      lastChunk: {\n        writable: true,\n        value: chunk\n      },\n      lastSearchedChunk: {\n        writable: true,\n        value: chunk\n      },\n      byStart: {\n        writable: true,\n        value: {}\n      },\n      byEnd: {\n        writable: true,\n        value: {}\n      },\n      filename: {\n        writable: true,\n        value: options.filename\n      },\n      indentExclusionRanges: {\n        writable: true,\n        value: options.indentExclusionRanges\n      },\n      sourcemapLocations: {\n        writable: true,\n        value: new BitSet()\n      },\n      storedNames: {\n        writable: true,\n        value: {}\n      },\n      indentStr: {\n        writable: true,\n        value: guessIndent(string)\n      }\n    });\n    this.byStart[0] = chunk;\n    this.byEnd[string.length] = chunk;\n  };\n\n  MagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {\n    this.sourcemapLocations.add(char);\n  };\n\n  MagicString.prototype.append = function append(content) {\n    if (typeof content !== 'string') {\n      throw new TypeError('outro content must be a string');\n    }\n\n    this.outro += content;\n    return this;\n  };\n\n  MagicString.prototype.appendLeft = function appendLeft(index, content) {\n    if (typeof content !== 'string') {\n      throw new TypeError('inserted content must be a string');\n    }\n\n    this._split(index);\n\n    var chunk = this.byEnd[index];\n\n    if (chunk) {\n      chunk.appendLeft(content);\n    } else {\n      this.intro += content;\n    }\n\n    return this;\n  };\n\n  MagicString.prototype.appendRight = function appendRight(index, content) {\n    if (typeof content !== 'string') {\n      throw new TypeError('inserted content must be a string');\n    }\n\n    this._split(index);\n\n    var chunk = this.byStart[index];\n\n    if (chunk) {\n      chunk.appendRight(content);\n    } else {\n      this.outro += content;\n    }\n\n    return this;\n  };\n\n  MagicString.prototype.clone = function clone() {\n    var cloned = new MagicString(this.original, {\n      filename: this.filename\n    });\n    var originalChunk = this.firstChunk;\n    var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n\n    while (originalChunk) {\n      cloned.byStart[clonedChunk.start] = clonedChunk;\n      cloned.byEnd[clonedChunk.end] = clonedChunk;\n      var nextOriginalChunk = originalChunk.next;\n      var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n      if (nextClonedChunk) {\n        clonedChunk.next = nextClonedChunk;\n        nextClonedChunk.previous = clonedChunk;\n        clonedChunk = nextClonedChunk;\n      }\n\n      originalChunk = nextOriginalChunk;\n    }\n\n    cloned.lastChunk = clonedChunk;\n\n    if (this.indentExclusionRanges) {\n      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n    }\n\n    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n    cloned.intro = this.intro;\n    cloned.outro = this.outro;\n    return cloned;\n  };\n\n  MagicString.prototype.generateDecodedMap = function generateDecodedMap(options) {\n    var this$1$1 = this;\n    options = options || {};\n    var sourceIndex = 0;\n    var names = Object.keys(this.storedNames);\n    var mappings = new Mappings(options.hires);\n    var locate = getLocator(this.original);\n\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n\n    this.firstChunk.eachNext(function (chunk) {\n      var loc = locate(chunk.start);\n\n      if (chunk.intro.length) {\n        mappings.advance(chunk.intro);\n      }\n\n      if (chunk.edited) {\n        mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n      } else {\n        mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);\n      }\n\n      if (chunk.outro.length) {\n        mappings.advance(chunk.outro);\n      }\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n      sources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n      sourcesContent: options.includeContent ? [this.original] : [null],\n      names: names,\n      mappings: mappings.raw\n    };\n  };\n\n  MagicString.prototype.generateMap = function generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  };\n\n  MagicString.prototype.getIndentString = function getIndentString() {\n    return this.indentStr === null ? '\\t' : this.indentStr;\n  };\n\n  MagicString.prototype.indent = function indent(indentStr, options) {\n    var pattern = /^[^\\r\\n]/gm;\n\n    if (isObject(indentStr)) {\n      options = indentStr;\n      indentStr = undefined;\n    }\n\n    indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n    if (indentStr === '') {\n      return this;\n    } // noop\n\n\n    options = options || {}; // Process exclusion ranges\n\n    var isExcluded = {};\n\n    if (options.exclude) {\n      var exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n      exclusions.forEach(function (exclusion) {\n        for (var i = exclusion[0]; i < exclusion[1]; i += 1) {\n          isExcluded[i] = true;\n        }\n      });\n    }\n\n    var shouldIndentNextCharacter = options.indentStart !== false;\n\n    var replacer = function (match) {\n      if (shouldIndentNextCharacter) {\n        return \"\" + indentStr + match;\n      }\n\n      shouldIndentNextCharacter = true;\n      return match;\n    };\n\n    this.intro = this.intro.replace(pattern, replacer);\n    var charIndex = 0;\n    var chunk = this.firstChunk;\n\n    while (chunk) {\n      var end = chunk.end;\n\n      if (chunk.edited) {\n        if (!isExcluded[charIndex]) {\n          chunk.content = chunk.content.replace(pattern, replacer);\n\n          if (chunk.content.length) {\n            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n          }\n        }\n      } else {\n        charIndex = chunk.start;\n\n        while (charIndex < end) {\n          if (!isExcluded[charIndex]) {\n            var char = this.original[charIndex];\n\n            if (char === '\\n') {\n              shouldIndentNextCharacter = true;\n            } else if (char !== '\\r' && shouldIndentNextCharacter) {\n              shouldIndentNextCharacter = false;\n\n              if (charIndex === chunk.start) {\n                chunk.prependRight(indentStr);\n              } else {\n                this._splitChunk(chunk, charIndex);\n\n                chunk = chunk.next;\n                chunk.prependRight(indentStr);\n              }\n            }\n          }\n\n          charIndex += 1;\n        }\n      }\n\n      charIndex = chunk.end;\n      chunk = chunk.next;\n    }\n\n    this.outro = this.outro.replace(pattern, replacer);\n    return this;\n  };\n\n  MagicString.prototype.insert = function insert() {\n    throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n  };\n\n  MagicString.prototype.insertLeft = function insertLeft(index, content) {\n    if (!warned.insertLeft) {\n      console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n\n      warned.insertLeft = true;\n    }\n\n    return this.appendLeft(index, content);\n  };\n\n  MagicString.prototype.insertRight = function insertRight(index, content) {\n    if (!warned.insertRight) {\n      console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n\n      warned.insertRight = true;\n    }\n\n    return this.prependRight(index, content);\n  };\n\n  MagicString.prototype.move = function move(start, end, index) {\n    if (index >= start && index <= end) {\n      throw new Error('Cannot move a selection inside itself');\n    }\n\n    this._split(start);\n\n    this._split(end);\n\n    this._split(index);\n\n    var first = this.byStart[start];\n    var last = this.byEnd[end];\n    var oldLeft = first.previous;\n    var oldRight = last.next;\n    var newRight = this.byStart[index];\n\n    if (!newRight && last === this.lastChunk) {\n      return this;\n    }\n\n    var newLeft = newRight ? newRight.previous : this.lastChunk;\n\n    if (oldLeft) {\n      oldLeft.next = oldRight;\n    }\n\n    if (oldRight) {\n      oldRight.previous = oldLeft;\n    }\n\n    if (newLeft) {\n      newLeft.next = first;\n    }\n\n    if (newRight) {\n      newRight.previous = last;\n    }\n\n    if (!first.previous) {\n      this.firstChunk = last.next;\n    }\n\n    if (!last.next) {\n      this.lastChunk = first.previous;\n      this.lastChunk.next = null;\n    }\n\n    first.previous = newLeft;\n    last.next = newRight || null;\n\n    if (!newLeft) {\n      this.firstChunk = first;\n    }\n\n    if (!newRight) {\n      this.lastChunk = last;\n    }\n\n    return this;\n  };\n\n  MagicString.prototype.overwrite = function overwrite(start, end, content, options) {\n    if (typeof content !== 'string') {\n      throw new TypeError('replacement content must be a string');\n    }\n\n    while (start < 0) {\n      start += this.original.length;\n    }\n\n    while (end < 0) {\n      end += this.original.length;\n    }\n\n    if (end > this.original.length) {\n      throw new Error('end is out of bounds');\n    }\n\n    if (start === end) {\n      throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n    }\n\n    this._split(start);\n\n    this._split(end);\n\n    if (options === true) {\n      if (!warned.storeName) {\n        console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n\n        warned.storeName = true;\n      }\n\n      options = {\n        storeName: true\n      };\n    }\n\n    var storeName = options !== undefined ? options.storeName : false;\n    var contentOnly = options !== undefined ? options.contentOnly : false;\n\n    if (storeName) {\n      var original = this.original.slice(start, end);\n      Object.defineProperty(this.storedNames, original, {\n        writable: true,\n        value: true,\n        enumerable: true\n      });\n    }\n\n    var first = this.byStart[start];\n    var last = this.byEnd[end];\n\n    if (first) {\n      var chunk = first;\n\n      while (chunk !== last) {\n        if (chunk.next !== this.byStart[chunk.end]) {\n          throw new Error('Cannot overwrite across a split point');\n        }\n\n        chunk = chunk.next;\n        chunk.edit('', false);\n      }\n\n      first.edit(content, storeName, contentOnly);\n    } else {\n      // must be inserting at the end\n      var newChunk = new Chunk(start, end, '').edit(content, storeName); // TODO last chunk in the array may not be the last chunk, if it's moved...\n\n      last.next = newChunk;\n      newChunk.previous = last;\n    }\n\n    return this;\n  };\n\n  MagicString.prototype.prepend = function prepend(content) {\n    if (typeof content !== 'string') {\n      throw new TypeError('outro content must be a string');\n    }\n\n    this.intro = content + this.intro;\n    return this;\n  };\n\n  MagicString.prototype.prependLeft = function prependLeft(index, content) {\n    if (typeof content !== 'string') {\n      throw new TypeError('inserted content must be a string');\n    }\n\n    this._split(index);\n\n    var chunk = this.byEnd[index];\n\n    if (chunk) {\n      chunk.prependLeft(content);\n    } else {\n      this.intro = content + this.intro;\n    }\n\n    return this;\n  };\n\n  MagicString.prototype.prependRight = function prependRight(index, content) {\n    if (typeof content !== 'string') {\n      throw new TypeError('inserted content must be a string');\n    }\n\n    this._split(index);\n\n    var chunk = this.byStart[index];\n\n    if (chunk) {\n      chunk.prependRight(content);\n    } else {\n      this.outro = content + this.outro;\n    }\n\n    return this;\n  };\n\n  MagicString.prototype.remove = function remove(start, end) {\n    while (start < 0) {\n      start += this.original.length;\n    }\n\n    while (end < 0) {\n      end += this.original.length;\n    }\n\n    if (start === end) {\n      return this;\n    }\n\n    if (start < 0 || end > this.original.length) {\n      throw new Error('Character is out of bounds');\n    }\n\n    if (start > end) {\n      throw new Error('end must be greater than start');\n    }\n\n    this._split(start);\n\n    this._split(end);\n\n    var chunk = this.byStart[start];\n\n    while (chunk) {\n      chunk.intro = '';\n      chunk.outro = '';\n      chunk.edit('');\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n\n    return this;\n  };\n\n  MagicString.prototype.lastChar = function lastChar() {\n    if (this.outro.length) {\n      return this.outro[this.outro.length - 1];\n    }\n\n    var chunk = this.lastChunk;\n\n    do {\n      if (chunk.outro.length) {\n        return chunk.outro[chunk.outro.length - 1];\n      }\n\n      if (chunk.content.length) {\n        return chunk.content[chunk.content.length - 1];\n      }\n\n      if (chunk.intro.length) {\n        return chunk.intro[chunk.intro.length - 1];\n      }\n    } while (chunk = chunk.previous);\n\n    if (this.intro.length) {\n      return this.intro[this.intro.length - 1];\n    }\n\n    return '';\n  };\n\n  MagicString.prototype.lastLine = function lastLine() {\n    var lineIndex = this.outro.lastIndexOf(n);\n\n    if (lineIndex !== -1) {\n      return this.outro.substr(lineIndex + 1);\n    }\n\n    var lineStr = this.outro;\n    var chunk = this.lastChunk;\n\n    do {\n      if (chunk.outro.length > 0) {\n        lineIndex = chunk.outro.lastIndexOf(n);\n\n        if (lineIndex !== -1) {\n          return chunk.outro.substr(lineIndex + 1) + lineStr;\n        }\n\n        lineStr = chunk.outro + lineStr;\n      }\n\n      if (chunk.content.length > 0) {\n        lineIndex = chunk.content.lastIndexOf(n);\n\n        if (lineIndex !== -1) {\n          return chunk.content.substr(lineIndex + 1) + lineStr;\n        }\n\n        lineStr = chunk.content + lineStr;\n      }\n\n      if (chunk.intro.length > 0) {\n        lineIndex = chunk.intro.lastIndexOf(n);\n\n        if (lineIndex !== -1) {\n          return chunk.intro.substr(lineIndex + 1) + lineStr;\n        }\n\n        lineStr = chunk.intro + lineStr;\n      }\n    } while (chunk = chunk.previous);\n\n    lineIndex = this.intro.lastIndexOf(n);\n\n    if (lineIndex !== -1) {\n      return this.intro.substr(lineIndex + 1) + lineStr;\n    }\n\n    return this.intro + lineStr;\n  };\n\n  MagicString.prototype.slice = function slice(start, end) {\n    if (start === void 0) start = 0;\n    if (end === void 0) end = this.original.length;\n\n    while (start < 0) {\n      start += this.original.length;\n    }\n\n    while (end < 0) {\n      end += this.original.length;\n    }\n\n    var result = ''; // find start chunk\n\n    var chunk = this.firstChunk;\n\n    while (chunk && (chunk.start > start || chunk.end <= start)) {\n      // found end chunk before start\n      if (chunk.start < end && chunk.end >= end) {\n        return result;\n      }\n\n      chunk = chunk.next;\n    }\n\n    if (chunk && chunk.edited && chunk.start !== start) {\n      throw new Error(\"Cannot use replaced character \" + start + \" as slice start anchor.\");\n    }\n\n    var startChunk = chunk;\n\n    while (chunk) {\n      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n        result += chunk.intro;\n      }\n\n      var containsEnd = chunk.start < end && chunk.end >= end;\n\n      if (containsEnd && chunk.edited && chunk.end !== end) {\n        throw new Error(\"Cannot use replaced character \" + end + \" as slice end anchor.\");\n      }\n\n      var sliceStart = startChunk === chunk ? start - chunk.start : 0;\n      var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n      result += chunk.content.slice(sliceStart, sliceEnd);\n\n      if (chunk.outro && (!containsEnd || chunk.end === end)) {\n        result += chunk.outro;\n      }\n\n      if (containsEnd) {\n        break;\n      }\n\n      chunk = chunk.next;\n    }\n\n    return result;\n  }; // TODO deprecate this? not really very useful\n\n\n  MagicString.prototype.snip = function snip(start, end) {\n    var clone = this.clone();\n    clone.remove(0, start);\n    clone.remove(end, clone.original.length);\n    return clone;\n  };\n\n  MagicString.prototype._split = function _split(index) {\n    if (this.byStart[index] || this.byEnd[index]) {\n      return;\n    }\n\n    var chunk = this.lastSearchedChunk;\n    var searchForward = index > chunk.end;\n\n    while (chunk) {\n      if (chunk.contains(index)) {\n        return this._splitChunk(chunk, index);\n      }\n\n      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n    }\n  };\n\n  MagicString.prototype._splitChunk = function _splitChunk(chunk, index) {\n    if (chunk.edited && chunk.content.length) {\n      // zero-length edited chunks are a special case (overlapping replacements)\n      var loc = getLocator(this.original)(index);\n      throw new Error(\"Cannot split a chunk that has already been edited (\" + loc.line + \":\" + loc.column + \" – \\\"\" + chunk.original + \"\\\")\");\n    }\n\n    var newChunk = chunk.split(index);\n    this.byEnd[index] = chunk;\n    this.byStart[index] = newChunk;\n    this.byEnd[newChunk.end] = newChunk;\n\n    if (chunk === this.lastChunk) {\n      this.lastChunk = newChunk;\n    }\n\n    this.lastSearchedChunk = chunk;\n    return true;\n  };\n\n  MagicString.prototype.toString = function toString() {\n    var str = this.intro;\n    var chunk = this.firstChunk;\n\n    while (chunk) {\n      str += chunk.toString();\n      chunk = chunk.next;\n    }\n\n    return str + this.outro;\n  };\n\n  MagicString.prototype.isEmpty = function isEmpty() {\n    var chunk = this.firstChunk;\n\n    do {\n      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {\n        return false;\n      }\n    } while (chunk = chunk.next);\n\n    return true;\n  };\n\n  MagicString.prototype.length = function length() {\n    var chunk = this.firstChunk;\n    var length = 0;\n\n    do {\n      length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n    } while (chunk = chunk.next);\n\n    return length;\n  };\n\n  MagicString.prototype.trimLines = function trimLines() {\n    return this.trim('[\\\\r\\\\n]');\n  };\n\n  MagicString.prototype.trim = function trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  };\n\n  MagicString.prototype.trimEndAborted = function trimEndAborted(charType) {\n    var rx = new RegExp((charType || '\\\\s') + '+$');\n    this.outro = this.outro.replace(rx, '');\n\n    if (this.outro.length) {\n      return true;\n    }\n\n    var chunk = this.lastChunk;\n\n    do {\n      var end = chunk.end;\n      var aborted = chunk.trimEnd(rx); // if chunk was trimmed, we have a new lastChunk\n\n      if (chunk.end !== end) {\n        if (this.lastChunk === chunk) {\n          this.lastChunk = chunk.next;\n        }\n\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n\n      if (aborted) {\n        return true;\n      }\n\n      chunk = chunk.previous;\n    } while (chunk);\n\n    return false;\n  };\n\n  MagicString.prototype.trimEnd = function trimEnd(charType) {\n    this.trimEndAborted(charType);\n    return this;\n  };\n\n  MagicString.prototype.trimStartAborted = function trimStartAborted(charType) {\n    var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n    this.intro = this.intro.replace(rx, '');\n\n    if (this.intro.length) {\n      return true;\n    }\n\n    var chunk = this.firstChunk;\n\n    do {\n      var end = chunk.end;\n      var aborted = chunk.trimStart(rx);\n\n      if (chunk.end !== end) {\n        // special case...\n        if (chunk === this.lastChunk) {\n          this.lastChunk = chunk.next;\n        }\n\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n\n      if (aborted) {\n        return true;\n      }\n\n      chunk = chunk.next;\n    } while (chunk);\n\n    return false;\n  };\n\n  MagicString.prototype.trimStart = function trimStart(charType) {\n    this.trimStartAborted(charType);\n    return this;\n  };\n\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n\n  var Bundle = function Bundle(options) {\n    if (options === void 0) options = {};\n    this.intro = options.intro || '';\n    this.separator = options.separator !== undefined ? options.separator : '\\n';\n    this.sources = [];\n    this.uniqueSources = [];\n    this.uniqueSourceIndexByFilename = {};\n  };\n\n  Bundle.prototype.addSource = function addSource(source) {\n    if (source instanceof MagicString) {\n      return this.addSource({\n        content: source,\n        filename: source.filename,\n        separator: this.separator\n      });\n    }\n\n    if (!isObject(source) || !source.content) {\n      throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n    }\n\n    ['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {\n      if (!hasOwnProp.call(source, option)) {\n        source[option] = source.content[option];\n      }\n    });\n\n    if (source.separator === undefined) {\n      // TODO there's a bunch of this sort of thing, needs cleaning up\n      source.separator = this.separator;\n    }\n\n    if (source.filename) {\n      if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n        this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n        this.uniqueSources.push({\n          filename: source.filename,\n          content: source.content.original\n        });\n      } else {\n        var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\n        if (source.content.original !== uniqueSource.content) {\n          throw new Error(\"Illegal source: same filename (\" + source.filename + \"), different contents\");\n        }\n      }\n    }\n\n    this.sources.push(source);\n    return this;\n  };\n\n  Bundle.prototype.append = function append(str, options) {\n    this.addSource({\n      content: new MagicString(str),\n      separator: options && options.separator || ''\n    });\n    return this;\n  };\n\n  Bundle.prototype.clone = function clone() {\n    var bundle = new Bundle({\n      intro: this.intro,\n      separator: this.separator\n    });\n    this.sources.forEach(function (source) {\n      bundle.addSource({\n        filename: source.filename,\n        content: source.content.clone(),\n        separator: source.separator\n      });\n    });\n    return bundle;\n  };\n\n  Bundle.prototype.generateDecodedMap = function generateDecodedMap(options) {\n    var this$1$1 = this;\n    if (options === void 0) options = {};\n    var names = [];\n    this.sources.forEach(function (source) {\n      Object.keys(source.content.storedNames).forEach(function (name) {\n        if (!~names.indexOf(name)) {\n          names.push(name);\n        }\n      });\n    });\n    var mappings = new Mappings(options.hires);\n\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n\n    this.sources.forEach(function (source, i) {\n      if (i > 0) {\n        mappings.advance(this$1$1.separator);\n      }\n\n      var sourceIndex = source.filename ? this$1$1.uniqueSourceIndexByFilename[source.filename] : -1;\n      var magicString = source.content;\n      var locate = getLocator(magicString.original);\n\n      if (magicString.intro) {\n        mappings.advance(magicString.intro);\n      }\n\n      magicString.firstChunk.eachNext(function (chunk) {\n        var loc = locate(chunk.start);\n\n        if (chunk.intro.length) {\n          mappings.advance(chunk.intro);\n        }\n\n        if (source.filename) {\n          if (chunk.edited) {\n            mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n          } else {\n            mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);\n          }\n        } else {\n          mappings.advance(chunk.content);\n        }\n\n        if (chunk.outro.length) {\n          mappings.advance(chunk.outro);\n        }\n      });\n\n      if (magicString.outro) {\n        mappings.advance(magicString.outro);\n      }\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n      sources: this.uniqueSources.map(function (source) {\n        return options.file ? getRelativePath(options.file, source.filename) : source.filename;\n      }),\n      sourcesContent: this.uniqueSources.map(function (source) {\n        return options.includeContent ? source.content : null;\n      }),\n      names: names,\n      mappings: mappings.raw\n    };\n  };\n\n  Bundle.prototype.generateMap = function generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  };\n\n  Bundle.prototype.getIndentString = function getIndentString() {\n    var indentStringCounts = {};\n    this.sources.forEach(function (source) {\n      var indentStr = source.content.indentStr;\n\n      if (indentStr === null) {\n        return;\n      }\n\n      if (!indentStringCounts[indentStr]) {\n        indentStringCounts[indentStr] = 0;\n      }\n\n      indentStringCounts[indentStr] += 1;\n    });\n    return Object.keys(indentStringCounts).sort(function (a, b) {\n      return indentStringCounts[a] - indentStringCounts[b];\n    })[0] || '\\t';\n  };\n\n  Bundle.prototype.indent = function indent(indentStr) {\n    var this$1$1 = this;\n\n    if (!arguments.length) {\n      indentStr = this.getIndentString();\n    }\n\n    if (indentStr === '') {\n      return this;\n    } // noop\n\n\n    var trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n    this.sources.forEach(function (source, i) {\n      var separator = source.separator !== undefined ? source.separator : this$1$1.separator;\n      var indentStart = trailingNewline || i > 0 && /\\r?\\n$/.test(separator);\n      source.content.indent(indentStr, {\n        exclude: source.indentExclusionRanges,\n        indentStart: indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\n      });\n      trailingNewline = source.content.lastChar() === '\\n';\n    });\n\n    if (this.intro) {\n      this.intro = indentStr + this.intro.replace(/^[^\\n]/gm, function (match, index) {\n        return index > 0 ? indentStr + match : match;\n      });\n    }\n\n    return this;\n  };\n\n  Bundle.prototype.prepend = function prepend(str) {\n    this.intro = str + this.intro;\n    return this;\n  };\n\n  Bundle.prototype.toString = function toString() {\n    var this$1$1 = this;\n    var body = this.sources.map(function (source, i) {\n      var separator = source.separator !== undefined ? source.separator : this$1$1.separator;\n      var str = (i > 0 ? separator : '') + source.content.toString();\n      return str;\n    }).join('');\n    return this.intro + body;\n  };\n\n  Bundle.prototype.isEmpty = function isEmpty() {\n    if (this.intro.length && this.intro.trim()) {\n      return false;\n    }\n\n    if (this.sources.some(function (source) {\n      return !source.content.isEmpty();\n    })) {\n      return false;\n    }\n\n    return true;\n  };\n\n  Bundle.prototype.length = function length() {\n    return this.sources.reduce(function (length, source) {\n      return length + source.content.length();\n    }, this.intro.length);\n  };\n\n  Bundle.prototype.trimLines = function trimLines() {\n    return this.trim('[\\\\r\\\\n]');\n  };\n\n  Bundle.prototype.trim = function trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  };\n\n  Bundle.prototype.trimStart = function trimStart(charType) {\n    var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n    this.intro = this.intro.replace(rx, '');\n\n    if (!this.intro) {\n      var source;\n      var i = 0;\n\n      do {\n        source = this.sources[i++];\n\n        if (!source) {\n          break;\n        }\n      } while (!source.content.trimStartAborted(charType));\n    }\n\n    return this;\n  };\n\n  Bundle.prototype.trimEnd = function trimEnd(charType) {\n    var rx = new RegExp((charType || '\\\\s') + '+$');\n    var source;\n    var i = this.sources.length - 1;\n\n    do {\n      source = this.sources[i--];\n\n      if (!source) {\n        this.intro = this.intro.replace(rx, '');\n        break;\n      }\n    } while (!source.content.trimEndAborted(charType));\n\n    return this;\n  };\n\n  MagicString.Bundle = Bundle;\n  MagicString.SourceMap = SourceMap;\n  MagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\n  return MagicString;\n});","map":{"version":3,"mappings":"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","names":["BitSet","arg","bits","slice","add","n","has","Chunk","start","end","content","original","intro","outro","storeName","edited","Object","defineProperties","previous","writable","value","next","appendLeft","appendRight","clone","const","chunk","contains","index","eachNext","fn","let","eachPrevious","edit","contentOnly","prependLeft","prependRight","split","sliceIndex","originalBefore","originalAfter","newChunk","toString","trimEnd","rx","replace","length","trimmed","undefined","trimStart","charToInteger","chars","i","charCodeAt","encode","decoded","sourceFileIndex","sourceCodeLine","sourceCodeColumn","nameIndex","mappings","line","generatedCodeColumn","lineMappings","_i","line_1","segment","segmentMappings","encodeInteger","push","join","num","result","clamped","btoa","Error","window","str","unescape","encodeURIComponent","Buffer","from","SourceMap","properties","version","file","sources","sourcesContent","names","JSON","stringify","toUrl","guessIndent","code","lines","tabbed","filter","test","spaced","min","reduce","current","numSpaces","exec","Math","Infinity","Array","getRelativePath","to","fromParts","toParts","pop","shift","concat","prototype","isObject","thing","call","getLocator","source","originalLines","lineOffsets","pos","locate","j","m","column","Mappings","hires","generatedCodeLine","raw","rawSegments","pending","addEdit","sourceIndex","loc","advance","addUneditedChunk","sourcemapLocations","originalCharIndex","first","warned","insertLeft","insertRight","MagicString","string","options","firstChunk","lastChunk","lastSearchedChunk","byStart","byEnd","filename","indentExclusionRanges","storedNames","indentStr","addSourcemapLocation","char","append","TypeError","_split","cloned","originalChunk","clonedChunk","nextOriginalChunk","nextClonedChunk","generateDecodedMap","keys","indexOf","this","includeContent","generateMap","getIndentString","indent","pattern","isExcluded","exclude","exclusions","forEach","exclusion","shouldIndentNextCharacter","indentStart","replacer","match","charIndex","_splitChunk","insert","console","warn","move","last","oldLeft","oldRight","newRight","newLeft","overwrite","defineProperty","enumerable","prepend","remove","lastChar","lastLine","lineIndex","lastIndexOf","substr","lineStr","startChunk","containsEnd","sliceStart","sliceEnd","snip","searchForward","isEmpty","trim","trimLines","charType","trimEndAborted","RegExp","aborted","trimStartAborted","hasOwnProp","hasOwnProperty","Bundle","separator","uniqueSources","uniqueSourceIndexByFilename","addSource","option","uniqueSource","bundle","name","magicString","map","indentStringCounts","sort","a","b","arguments","trailingNewline","body","some","default"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\magic-string\\src\\BitSet.js","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\magic-string\\src\\Chunk.js","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\magic-string\\node_modules\\sourcemap-codec\\dist\\sourcemap-codec.es.js","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\magic-string\\src\\SourceMap.js","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\magic-string\\src\\utils\\guessIndent.js","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\magic-string\\src\\utils\\getRelativePath.js","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\magic-string\\src\\utils\\isObject.js","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\magic-string\\src\\utils\\getLocator.js","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\magic-string\\src\\utils\\Mappings.js","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\magic-string\\src\\MagicString.js","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\magic-string\\src\\Bundle.js","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\magic-string\\src\\index-legacy.js"],"sourcesContent":["export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n","export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t// we make these non-enumerable, for sanity while debugging\n\t\tObject.defineProperties(this, {\n\t\t\tprevious: { writable: true, value: null },\n\t\t\tnext: { writable: true, value: null },\n\t\t});\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n","var charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nfor (var i = 0; i < chars.length; i++) {\n    charToInteger[chars.charCodeAt(i)] = i;\n}\nfunction decode(mappings) {\n    var decoded = [];\n    var line = [];\n    var segment = [\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    var j = 0;\n    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n        var c = mappings.charCodeAt(i);\n        if (c === 44) { // \",\"\n            segmentify(line, segment, j);\n            j = 0;\n        }\n        else if (c === 59) { // \";\"\n            segmentify(line, segment, j);\n            j = 0;\n            decoded.push(line);\n            line = [];\n            segment[0] = 0;\n        }\n        else {\n            var integer = charToInteger[c];\n            if (integer === undefined) {\n                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n            }\n            var hasContinuationBit = integer & 32;\n            integer &= 31;\n            value += integer << shift;\n            if (hasContinuationBit) {\n                shift += 5;\n            }\n            else {\n                var shouldNegate = value & 1;\n                value >>>= 1;\n                if (shouldNegate) {\n                    value = value === 0 ? -0x80000000 : -value;\n                }\n                segment[j] += value;\n                j++;\n                value = shift = 0; // reset\n            }\n        }\n    }\n    segmentify(line, segment, j);\n    decoded.push(line);\n    return decoded;\n}\nfunction segmentify(line, segment, j) {\n    // This looks ugly, but we're creating specialized arrays with a specific\n    // length. This is much faster than creating a new array (which v8 expands to\n    // a capacity of 17 after pushing the first item), or slicing out a subarray\n    // (which is slow). Length 4 is assumed to be the most frequent, followed by\n    // length 5 (since not everything will have an associated name), followed by\n    // length 1 (it's probably rare for a source substring to not have an\n    // associated segment data).\n    if (j === 4)\n        line.push([segment[0], segment[1], segment[2], segment[3]]);\n    else if (j === 5)\n        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n    else if (j === 1)\n        line.push([segment[0]]);\n}\nfunction encode(decoded) {\n    var sourceFileIndex = 0; // second field\n    var sourceCodeLine = 0; // third field\n    var sourceCodeColumn = 0; // fourth field\n    var nameIndex = 0; // fifth field\n    var mappings = '';\n    for (var i = 0; i < decoded.length; i++) {\n        var line = decoded[i];\n        if (i > 0)\n            mappings += ';';\n        if (line.length === 0)\n            continue;\n        var generatedCodeColumn = 0; // first field\n        var lineMappings = [];\n        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n            var segment = line_1[_i];\n            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n            generatedCodeColumn = segment[0];\n            if (segment.length > 1) {\n                segmentMappings +=\n                    encodeInteger(segment[1] - sourceFileIndex) +\n                        encodeInteger(segment[2] - sourceCodeLine) +\n                        encodeInteger(segment[3] - sourceCodeColumn);\n                sourceFileIndex = segment[1];\n                sourceCodeLine = segment[2];\n                sourceCodeColumn = segment[3];\n            }\n            if (segment.length === 5) {\n                segmentMappings += encodeInteger(segment[4] - nameIndex);\n                nameIndex = segment[4];\n            }\n            lineMappings.push(segmentMappings);\n        }\n        mappings += lineMappings.join(',');\n    }\n    return mappings;\n}\nfunction encodeInteger(num) {\n    var result = '';\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        var clamped = num & 31;\n        num >>>= 5;\n        if (num > 0) {\n            clamped |= 32;\n        }\n        result += chars[clamped];\n    } while (num > 0);\n    return result;\n}\n\nexport { decode, encode };\n//# sourceMappingURL=sourcemap-codec.es.js.map\n","import { encode } from 'sourcemap-codec';\n\nlet btoa = () => {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = (str) => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n\tbtoa = (str) => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n","export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n","export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n","const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n","export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n","export default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n","import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: guessIndent(string) },\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\n\t\t\t);\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, { writable: true, value: true, enumerable: true });\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, contentOnly);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n}\n","import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n","import MagicString from './MagicString.js';\nimport Bundle from './Bundle.js';\nimport SourceMap from './SourceMap.js';\n\nMagicString.Bundle = Bundle;\nMagicString.SourceMap = SourceMap;\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\nexport default MagicString;\n"]},"metadata":{},"sourceType":"script"}