{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadTsconfig = exports.walkForTsConfig = exports.tsConfigLoader = void 0;\n\nvar path = require(\"path\");\n\nvar fs = require(\"fs\"); // tslint:disable:no-require-imports\n\n\nvar JSON5 = require(\"json5\");\n\nvar StripBom = require(\"strip-bom\");\n\nfunction tsConfigLoader(_a) {\n  var getEnv = _a.getEnv,\n      cwd = _a.cwd,\n      _b = _a.loadSync,\n      loadSync = _b === void 0 ? loadSyncDefault : _b;\n  var TS_NODE_PROJECT = getEnv(\"TS_NODE_PROJECT\");\n  var TS_NODE_BASEURL = getEnv(\"TS_NODE_BASEURL\"); // tsconfig.loadSync handles if TS_NODE_PROJECT is a file or directory\n  // and also overrides baseURL if TS_NODE_BASEURL is available.\n\n  var loadResult = loadSync(cwd, TS_NODE_PROJECT, TS_NODE_BASEURL);\n  return loadResult;\n}\n\nexports.tsConfigLoader = tsConfigLoader;\n\nfunction loadSyncDefault(cwd, filename, baseUrl) {\n  // Tsconfig.loadSync uses path.resolve. This is why we can use an absolute path as filename\n  var configPath = resolveConfigPath(cwd, filename);\n\n  if (!configPath) {\n    return {\n      tsConfigPath: undefined,\n      baseUrl: undefined,\n      paths: undefined\n    };\n  }\n\n  var config = loadTsconfig(configPath);\n  return {\n    tsConfigPath: configPath,\n    baseUrl: baseUrl || config && config.compilerOptions && config.compilerOptions.baseUrl,\n    paths: config && config.compilerOptions && config.compilerOptions.paths\n  };\n}\n\nfunction resolveConfigPath(cwd, filename) {\n  if (filename) {\n    var absolutePath = fs.lstatSync(filename).isDirectory() ? path.resolve(filename, \"./tsconfig.json\") : path.resolve(cwd, filename);\n    return absolutePath;\n  }\n\n  if (fs.statSync(cwd).isFile()) {\n    return path.resolve(cwd);\n  }\n\n  var configAbsolutePath = walkForTsConfig(cwd);\n  return configAbsolutePath ? path.resolve(configAbsolutePath) : undefined;\n}\n\nfunction walkForTsConfig(directory, existsSync) {\n  if (existsSync === void 0) {\n    existsSync = fs.existsSync;\n  }\n\n  var configPath = path.join(directory, \"./tsconfig.json\");\n\n  if (existsSync(configPath)) {\n    return configPath;\n  }\n\n  var parentDirectory = path.join(directory, \"../\"); // If we reached the top\n\n  if (directory === parentDirectory) {\n    return undefined;\n  }\n\n  return walkForTsConfig(parentDirectory, existsSync);\n}\n\nexports.walkForTsConfig = walkForTsConfig;\n\nfunction loadTsconfig(configFilePath, existsSync, readFileSync) {\n  if (existsSync === void 0) {\n    existsSync = fs.existsSync;\n  }\n\n  if (readFileSync === void 0) {\n    readFileSync = function (filename) {\n      return fs.readFileSync(filename, \"utf8\");\n    };\n  }\n\n  if (!existsSync(configFilePath)) {\n    return undefined;\n  }\n\n  var configString = readFileSync(configFilePath);\n  var cleanedJson = StripBom(configString);\n  var config = JSON5.parse(cleanedJson);\n  var extendedConfig = config.extends;\n\n  if (extendedConfig) {\n    if (typeof extendedConfig === \"string\" && extendedConfig.indexOf(\".json\") === -1) {\n      extendedConfig += \".json\";\n    }\n\n    var currentDir = path.dirname(configFilePath);\n    var extendedConfigPath = path.join(currentDir, extendedConfig);\n\n    if (extendedConfig.indexOf(\"/\") !== -1 && extendedConfig.indexOf(\".\") !== -1 && !existsSync(extendedConfigPath)) {\n      extendedConfigPath = path.join(currentDir, \"node_modules\", extendedConfig);\n    }\n\n    var base = loadTsconfig(extendedConfigPath, existsSync, readFileSync) || {}; // baseUrl should be interpreted as relative to the base tsconfig,\n    // but we need to update it so it is relative to the original tsconfig being loaded\n\n    if (base.compilerOptions && base.compilerOptions.baseUrl) {\n      var extendsDir = path.dirname(extendedConfig);\n      base.compilerOptions.baseUrl = path.join(extendsDir, base.compilerOptions.baseUrl);\n    }\n\n    return __assign(__assign(__assign({}, base), config), {\n      compilerOptions: __assign(__assign({}, base.compilerOptions), config.compilerOptions)\n    });\n  }\n\n  return config;\n}\n\nexports.loadTsconfig = loadTsconfig;","map":{"version":3,"mappings":"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","names":["tsConfigLoader","_a","getEnv","cwd","_b","loadSync","loadSyncDefault","TS_NODE_PROJECT","TS_NODE_BASEURL","loadResult","exports","filename","baseUrl","configPath","resolveConfigPath","tsConfigPath","undefined","paths","config","loadTsconfig","compilerOptions","absolutePath","fs","lstatSync","isDirectory","path","resolve","statSync","isFile","configAbsolutePath","walkForTsConfig","directory","existsSync","join","parentDirectory","configFilePath","readFileSync","configString","cleanedJson","StripBom","JSON5","parse","extendedConfig","extends","indexOf","currentDir","dirname","extendedConfigPath","base","extendsDir"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\tsconfig-paths\\src\\tsconfig-loader.ts"],"sourcesContent":["import * as path from \"path\";\nimport * as fs from \"fs\";\n// tslint:disable:no-require-imports\nimport JSON5 = require(\"json5\");\nimport StripBom = require(\"strip-bom\");\n// tslint:enable:no-require-imports\n\n/**\n * Typing for the parts of tsconfig that we care about\n */\nexport interface Tsconfig {\n  extends?: string;\n  compilerOptions?: {\n    baseUrl?: string;\n    paths?: { [key: string]: Array<string> };\n    strict?: boolean;\n  };\n}\n\nexport interface TsConfigLoaderResult {\n  tsConfigPath: string | undefined;\n  baseUrl: string | undefined;\n  paths: { [key: string]: Array<string> } | undefined;\n}\n\nexport interface TsConfigLoaderParams {\n  getEnv: (key: string) => string | undefined;\n  cwd: string;\n  loadSync?(\n    cwd: string,\n    filename?: string,\n    baseUrl?: string\n  ): TsConfigLoaderResult;\n}\n\nexport function tsConfigLoader({\n  getEnv,\n  cwd,\n  loadSync = loadSyncDefault,\n}: TsConfigLoaderParams): TsConfigLoaderResult {\n  const TS_NODE_PROJECT = getEnv(\"TS_NODE_PROJECT\");\n  const TS_NODE_BASEURL = getEnv(\"TS_NODE_BASEURL\");\n\n  // tsconfig.loadSync handles if TS_NODE_PROJECT is a file or directory\n  // and also overrides baseURL if TS_NODE_BASEURL is available.\n  const loadResult = loadSync(cwd, TS_NODE_PROJECT, TS_NODE_BASEURL);\n  return loadResult;\n}\n\nfunction loadSyncDefault(\n  cwd: string,\n  filename?: string,\n  baseUrl?: string\n): TsConfigLoaderResult {\n  // Tsconfig.loadSync uses path.resolve. This is why we can use an absolute path as filename\n\n  const configPath = resolveConfigPath(cwd, filename);\n\n  if (!configPath) {\n    return {\n      tsConfigPath: undefined,\n      baseUrl: undefined,\n      paths: undefined,\n    };\n  }\n  const config = loadTsconfig(configPath);\n\n  return {\n    tsConfigPath: configPath,\n    baseUrl:\n      baseUrl ||\n      (config && config.compilerOptions && config.compilerOptions.baseUrl),\n    paths: config && config.compilerOptions && config.compilerOptions.paths,\n  };\n}\n\nfunction resolveConfigPath(cwd: string, filename?: string): string | undefined {\n  if (filename) {\n    const absolutePath = fs.lstatSync(filename).isDirectory()\n      ? path.resolve(filename, \"./tsconfig.json\")\n      : path.resolve(cwd, filename);\n\n    return absolutePath;\n  }\n\n  if (fs.statSync(cwd).isFile()) {\n    return path.resolve(cwd);\n  }\n\n  const configAbsolutePath = walkForTsConfig(cwd);\n  return configAbsolutePath ? path.resolve(configAbsolutePath) : undefined;\n}\n\nexport function walkForTsConfig(\n  directory: string,\n  existsSync: (path: string) => boolean = fs.existsSync\n): string | undefined {\n  const configPath = path.join(directory, \"./tsconfig.json\");\n  if (existsSync(configPath)) {\n    return configPath;\n  }\n\n  const parentDirectory = path.join(directory, \"../\");\n\n  // If we reached the top\n  if (directory === parentDirectory) {\n    return undefined;\n  }\n\n  return walkForTsConfig(parentDirectory, existsSync);\n}\n\nexport function loadTsconfig(\n  configFilePath: string,\n  existsSync: (path: string) => boolean = fs.existsSync,\n  readFileSync: (filename: string) => string = (filename: string) =>\n    fs.readFileSync(filename, \"utf8\")\n): Tsconfig | undefined {\n  if (!existsSync(configFilePath)) {\n    return undefined;\n  }\n\n  const configString = readFileSync(configFilePath);\n  const cleanedJson = StripBom(configString);\n  const config: Tsconfig = JSON5.parse(cleanedJson);\n  let extendedConfig = config.extends;\n\n  if (extendedConfig) {\n    if (\n      typeof extendedConfig === \"string\" &&\n      extendedConfig.indexOf(\".json\") === -1\n    ) {\n      extendedConfig += \".json\";\n    }\n    const currentDir = path.dirname(configFilePath);\n    let extendedConfigPath = path.join(currentDir, extendedConfig);\n    if (\n      extendedConfig.indexOf(\"/\") !== -1 &&\n      extendedConfig.indexOf(\".\") !== -1 &&\n      !existsSync(extendedConfigPath)\n    ) {\n      extendedConfigPath = path.join(\n        currentDir,\n        \"node_modules\",\n        extendedConfig\n      );\n    }\n\n    const base =\n      loadTsconfig(extendedConfigPath, existsSync, readFileSync) || {};\n\n    // baseUrl should be interpreted as relative to the base tsconfig,\n    // but we need to update it so it is relative to the original tsconfig being loaded\n    if (base.compilerOptions && base.compilerOptions.baseUrl) {\n      const extendsDir = path.dirname(extendedConfig);\n      base.compilerOptions.baseUrl = path.join(\n        extendsDir,\n        base.compilerOptions.baseUrl\n      );\n    }\n\n    return {\n      ...base,\n      ...config,\n      compilerOptions: {\n        ...base.compilerOptions,\n        ...config.compilerOptions,\n      },\n    };\n  }\n  return config;\n}\n"]},"metadata":{},"sourceType":"script"}