{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findPackageData = findPackageData;\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _utils = require(\"./utils\");\n\nvar _configError = require(\"../../errors/config-error\");\n\nconst PACKAGE_FILENAME = \"package.json\";\n\nfunction* findPackageData(filepath) {\n  let pkg = null;\n  const directories = [];\n  let isPackage = true;\n\n  let dirname = _path().dirname(filepath);\n\n  while (!pkg && _path().basename(dirname) !== \"node_modules\") {\n    directories.push(dirname);\n    pkg = yield* readConfigPackage(_path().join(dirname, PACKAGE_FILENAME));\n\n    const nextLoc = _path().dirname(dirname);\n\n    if (dirname === nextLoc) {\n      isPackage = false;\n      break;\n    }\n\n    dirname = nextLoc;\n  }\n\n  return {\n    filepath,\n    directories,\n    pkg,\n    isPackage\n  };\n}\n\nconst readConfigPackage = (0, _utils.makeStaticFileCache)((filepath, content) => {\n  let options;\n\n  try {\n    options = JSON.parse(content);\n  } catch (err) {\n    throw new _configError.default(`Error while parsing JSON - ${err.message}`, filepath);\n  }\n\n  if (!options) throw new Error(`${filepath}: No config detected`);\n\n  if (typeof options !== \"object\") {\n    throw new _configError.default(`Config returned typeof ${typeof options}`, filepath);\n  }\n\n  if (Array.isArray(options)) {\n    throw new _configError.default(`Expected config object but found array`, filepath);\n  }\n\n  return {\n    filepath,\n    dirname: _path().dirname(filepath),\n    options\n  };\n});\n0 && 0;","map":{"version":3,"mappings":";;;;;;;AAAA;EAAA;;EAAAA;IAAA;EAAA;;EAAA;AAAA;;AAEA;;AAIA;;AAEA,MAAMC,gBAAgB,GAAG,cAAzB;;AAOO,UAAUC,eAAV,CAA0BC,QAA1B,EAAsE;EAC3E,IAAIC,GAAG,GAAG,IAAV;EACA,MAAMC,WAAW,GAAG,EAApB;EACA,IAAIC,SAAS,GAAG,IAAhB;;EAEA,IAAIC,OAAO,GAAGC,QAAKD,OAALC,CAAaL,QAAbK,CAAd;;EACA,OAAO,CAACJ,GAAD,IAAQI,QAAKC,QAALD,CAAcD,OAAdC,MAA2B,cAA1C,EAA0D;IACxDH,WAAW,CAACK,IAAZL,CAAiBE,OAAjBF;IAEAD,GAAG,GAAG,OAAOO,iBAAiB,CAACH,QAAKI,IAALJ,CAAUD,OAAVC,EAAmBP,gBAAnBO,CAAD,CAA9BJ;;IAEA,MAAMS,OAAO,GAAGL,QAAKD,OAALC,CAAaD,OAAbC,CAAhB;;IACA,IAAID,OAAO,KAAKM,OAAhB,EAAyB;MACvBP,SAAS,GAAG,KAAZA;MACA;IACD;;IACDC,OAAO,GAAGM,OAAVN;EACD;;EAED,OAAO;IAAEJ,QAAF;IAAYE,WAAZ;IAAyBD,GAAzB;IAA8BE;EAA9B,CAAP;AACD;;AAED,MAAMK,iBAAiB,GAAG,gCACxB,CAACR,QAAD,EAAWW,OAAX,KAAmC;EACjC,IAAIC,OAAJ;;EACA,IAAI;IACFA,OAAO,GAAGC,IAAI,CAACC,KAALD,CAAWF,OAAXE,CAAVD;EADF,EAEE,OAAOG,GAAP,EAAY;IACZ,MAAM,IAAIC,oBAAJ,CACH,8BAA6BD,GAAG,CAACE,OAAQ,EADtC,EAEJjB,QAFI,CAAN;EAID;;EAED,IAAI,CAACY,OAAL,EAAc,MAAM,IAAIM,KAAJ,CAAW,GAAElB,QAAS,sBAAtB,CAAN;;EAEd,IAAI,OAAOY,OAAP,KAAmB,QAAvB,EAAiC;IAC/B,MAAM,IAAII,oBAAJ,CACH,0BAAyB,OAAOJ,OAAQ,EADrC,EAEJZ,QAFI,CAAN;EAID;;EACD,IAAImB,KAAK,CAACC,OAAND,CAAcP,OAAdO,CAAJ,EAA4B;IAC1B,MAAM,IAAIH,oBAAJ,CAAiB,wCAAjB,EAA0DhB,QAA1D,CAAN;EACD;;EAED,OAAO;IACLA,QADK;IAELI,OAAO,EAAEC,QAAKD,OAALC,CAAaL,QAAbK,CAFJ;IAGLO;EAHK,CAAP;AAxBsB,EAA1B","names":["_path","PACKAGE_FILENAME","findPackageData","filepath","pkg","directories","isPackage","dirname","path","basename","push","readConfigPackage","join","nextLoc","content","options","JSON","parse","err","ConfigError","message","Error","Array","isArray"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\files\\package.ts"],"sourcesContent":["import path from \"path\";\nimport type { Handler } from \"gensync\";\nimport { makeStaticFileCache } from \"./utils\";\n\nimport type { ConfigFile, FilePackageData } from \"./types\";\n\nimport ConfigError from \"../../errors/config-error\";\n\nconst PACKAGE_FILENAME = \"package.json\";\n\n/**\n * Find metadata about the package that this file is inside of. Resolution\n * of Babel's config requires general package information to decide when to\n * search for .babelrc files\n */\nexport function* findPackageData(filepath: string): Handler<FilePackageData> {\n  let pkg = null;\n  const directories = [];\n  let isPackage = true;\n\n  let dirname = path.dirname(filepath);\n  while (!pkg && path.basename(dirname) !== \"node_modules\") {\n    directories.push(dirname);\n\n    pkg = yield* readConfigPackage(path.join(dirname, PACKAGE_FILENAME));\n\n    const nextLoc = path.dirname(dirname);\n    if (dirname === nextLoc) {\n      isPackage = false;\n      break;\n    }\n    dirname = nextLoc;\n  }\n\n  return { filepath, directories, pkg, isPackage };\n}\n\nconst readConfigPackage = makeStaticFileCache(\n  (filepath, content): ConfigFile => {\n    let options;\n    try {\n      options = JSON.parse(content) as unknown;\n    } catch (err) {\n      throw new ConfigError(\n        `Error while parsing JSON - ${err.message}`,\n        filepath,\n      );\n    }\n\n    if (!options) throw new Error(`${filepath}: No config detected`);\n\n    if (typeof options !== \"object\") {\n      throw new ConfigError(\n        `Config returned typeof ${typeof options}`,\n        filepath,\n      );\n    }\n    if (Array.isArray(options)) {\n      throw new ConfigError(`Expected config object but found array`, filepath);\n    }\n\n    return {\n      filepath,\n      dirname: path.dirname(filepath),\n      options,\n    };\n  },\n);\n"]},"metadata":{},"sourceType":"script"}