{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\n\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('space-infix-ops');\nconst UNIONS = ['|', '&'];\nexports.default = util.createRule({\n  name: 'space-infix-ops',\n  meta: {\n    type: 'layout',\n    docs: {\n      description: 'Require spacing around infix operators',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    fixable: baseRule.meta.fixable,\n    hasSuggestions: baseRule.meta.hasSuggestions,\n    schema: baseRule.meta.schema,\n    messages: Object.assign({\n      // @ts-expect-error -- we report on this messageId so we need to ensure it's there in case ESLint changes in future\n      missingSpace: \"Operator '{{operator}}' must be spaced.\"\n    }, baseRule.meta.messages)\n  },\n  defaultOptions: [{\n    int32Hint: false\n  }],\n\n  create(context) {\n    const rules = baseRule.create(context);\n    const sourceCode = context.getSourceCode();\n\n    function report(operator) {\n      context.report({\n        node: operator,\n        messageId: 'missingSpace',\n        data: {\n          operator: operator.value\n        },\n\n        fix(fixer) {\n          const previousToken = sourceCode.getTokenBefore(operator);\n          const afterToken = sourceCode.getTokenAfter(operator);\n          let fixString = '';\n\n          if (operator.range[0] - previousToken.range[1] === 0) {\n            fixString = ' ';\n          }\n\n          fixString += operator.value;\n\n          if (afterToken.range[0] - operator.range[1] === 0) {\n            fixString += ' ';\n          }\n\n          return fixer.replaceText(operator, fixString);\n        }\n\n      });\n    }\n\n    function isSpaceChar(token) {\n      return token.type === utils_1.AST_TOKEN_TYPES.Punctuator && /^[=?:]$/.test(token.value);\n    }\n\n    function checkAndReportAssignmentSpace(leftNode, rightNode) {\n      if (!rightNode || !leftNode) {\n        return;\n      }\n\n      const operator = sourceCode.getFirstTokenBetween(leftNode, rightNode, isSpaceChar);\n      const prev = sourceCode.getTokenBefore(operator);\n      const next = sourceCode.getTokenAfter(operator);\n\n      if (!sourceCode.isSpaceBetween(prev, operator) || !sourceCode.isSpaceBetween(operator, next)) {\n        report(operator);\n      }\n    }\n    /**\n     * Check if it has an assignment char and report if it's faulty\n     * @param node The node to report\n     */\n\n\n    function checkForEnumAssignmentSpace(node) {\n      checkAndReportAssignmentSpace(node.id, node.initializer);\n    }\n    /**\n     * Check if it has an assignment char and report if it's faulty\n     * @param node The node to report\n     */\n\n\n    function checkForPropertyDefinitionAssignmentSpace(node) {\n      var _a;\n\n      const leftNode = node.optional && !node.typeAnnotation ? sourceCode.getTokenAfter(node.key) : (_a = node.typeAnnotation) !== null && _a !== void 0 ? _a : node.key;\n      checkAndReportAssignmentSpace(leftNode, node.value);\n    }\n    /**\n     * Check if it is missing spaces between type annotations chaining\n     * @param typeAnnotation TypeAnnotations list\n     */\n\n\n    function checkForTypeAnnotationSpace(typeAnnotation) {\n      const types = typeAnnotation.types;\n      types.forEach(type => {\n        const skipFunctionParenthesis = type.type === utils_1.TSESTree.AST_NODE_TYPES.TSFunctionType ? util.isNotOpeningParenToken : 0;\n        const operator = sourceCode.getTokenBefore(type, skipFunctionParenthesis);\n\n        if (operator != null && UNIONS.includes(operator.value)) {\n          const prev = sourceCode.getTokenBefore(operator);\n          const next = sourceCode.getTokenAfter(operator);\n\n          if (!sourceCode.isSpaceBetween(prev, operator) || !sourceCode.isSpaceBetween(operator, next)) {\n            report(operator);\n          }\n        }\n      });\n    }\n    /**\n     * Check if it has an assignment char and report if it's faulty\n     * @param node The node to report\n     */\n\n\n    function checkForTypeAliasAssignment(node) {\n      var _a;\n\n      checkAndReportAssignmentSpace((_a = node.typeParameters) !== null && _a !== void 0 ? _a : node.id, node.typeAnnotation);\n    }\n\n    function checkForTypeConditional(node) {\n      checkAndReportAssignmentSpace(node.extendsType, node.trueType);\n      checkAndReportAssignmentSpace(node.trueType, node.falseType);\n    }\n\n    return Object.assign(Object.assign({}, rules), {\n      TSEnumMember: checkForEnumAssignmentSpace,\n      PropertyDefinition: checkForPropertyDefinitionAssignmentSpace,\n      TSTypeAliasDeclaration: checkForTypeAliasAssignment,\n      TSUnionType: checkForTypeAnnotationSpace,\n      TSIntersectionType: checkForTypeAnnotationSpace,\n      TSConditionalType: checkForTypeConditional\n    });\n  }\n\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAEA;;AACA;;AAEA,MAAMA,QAAQ,GAAG,2CAAkB,iBAAlB,CAAjB;AAKA,MAAMC,MAAM,GAAG,CAAC,GAAD,EAAM,GAAN,CAAf;AAEAC,kBAAeC,IAAI,CAACC,UAAL,CAAqC;EAClDC,IAAI,EAAE,iBAD4C;EAElDC,IAAI,EAAE;IACJC,IAAI,EAAE,QADF;IAEJC,IAAI,EAAE;MACJC,WAAW,EAAE,wCADT;MAEJC,WAAW,EAAE,KAFT;MAGJC,eAAe,EAAE;IAHb,CAFF;IAOJC,OAAO,EAAEZ,QAAQ,CAACM,IAAT,CAAcM,OAPnB;IAQJC,cAAc,EAAEb,QAAQ,CAACM,IAAT,CAAcO,cAR1B;IASJC,MAAM,EAAEd,QAAQ,CAACM,IAAT,CAAcQ,MATlB;IAUJC,QAAQ;MACN;MACAC,YAAY,EAAE;IAFR,GAGHhB,QAAQ,CAACM,IAAT,CAAcS,QAHX;EAVJ,CAF4C;EAkBlDE,cAAc,EAAE,CACd;IACEC,SAAS,EAAE;EADb,CADc,CAlBkC;;EAuBlDC,MAAM,CAACC,OAAD,EAAQ;IACZ,MAAMC,KAAK,GAAGrB,QAAQ,CAACmB,MAAT,CAAgBC,OAAhB,CAAd;IACA,MAAME,UAAU,GAAGF,OAAO,CAACG,aAAR,EAAnB;;IAEA,SAASC,MAAT,CAAgBC,QAAhB,EAAwC;MACtCL,OAAO,CAACI,MAAR,CAAe;QACbE,IAAI,EAAED,QADO;QAEbE,SAAS,EAAE,cAFE;QAGbC,IAAI,EAAE;UACJH,QAAQ,EAAEA,QAAQ,CAACI;QADf,CAHO;;QAMbC,GAAG,CAACC,KAAD,EAAM;UACP,MAAMC,aAAa,GAAGV,UAAU,CAACW,cAAX,CAA0BR,QAA1B,CAAtB;UACA,MAAMS,UAAU,GAAGZ,UAAU,CAACa,aAAX,CAAyBV,QAAzB,CAAnB;UACA,IAAIW,SAAS,GAAG,EAAhB;;UAEA,IAAIX,QAAQ,CAACY,KAAT,CAAe,CAAf,IAAoBL,aAAc,CAACK,KAAf,CAAqB,CAArB,CAApB,KAAgD,CAApD,EAAuD;YACrDD,SAAS,GAAG,GAAZ;UACD;;UAEDA,SAAS,IAAIX,QAAQ,CAACI,KAAtB;;UAEA,IAAIK,UAAW,CAACG,KAAZ,CAAkB,CAAlB,IAAuBZ,QAAQ,CAACY,KAAT,CAAe,CAAf,CAAvB,KAA6C,CAAjD,EAAoD;YAClDD,SAAS,IAAI,GAAb;UACD;;UAED,OAAOL,KAAK,CAACO,WAAN,CAAkBb,QAAlB,EAA4BW,SAA5B,CAAP;QACD;;MAtBY,CAAf;IAwBD;;IAED,SAASG,WAAT,CAAqBC,KAArB,EAA0C;MACxC,OACEA,KAAK,CAACjC,IAAN,KAAekC,wBAAgBC,UAA/B,IAA6C,UAAUC,IAAV,CAAeH,KAAK,CAACX,KAArB,CAD/C;IAGD;;IAED,SAASe,6BAAT,CACEC,QADF,EAEEC,SAFF,EAEmD;MAEjD,IAAI,CAACA,SAAD,IAAc,CAACD,QAAnB,EAA6B;QAC3B;MACD;;MAED,MAAMpB,QAAQ,GAAGH,UAAU,CAACyB,oBAAX,CACfF,QADe,EAEfC,SAFe,EAGfP,WAHe,CAAjB;MAMA,MAAMS,IAAI,GAAG1B,UAAU,CAACW,cAAX,CAA0BR,QAA1B,CAAb;MACA,MAAMwB,IAAI,GAAG3B,UAAU,CAACa,aAAX,CAAyBV,QAAzB,CAAb;;MAEA,IACE,CAACH,UAAU,CAAC4B,cAAX,CAA2BF,IAA3B,EAAiCvB,QAAjC,CAAD,IACA,CAACH,UAAU,CAAC4B,cAAX,CAA2BzB,QAA3B,EAAqCwB,IAArC,CAFH,EAGE;QACAzB,MAAM,CAACC,QAAD,CAAN;MACD;IACF;IAED;;;;;;IAIA,SAAS0B,2BAAT,CAAqCzB,IAArC,EAAgE;MAC9DkB,6BAA6B,CAAClB,IAAI,CAAC0B,EAAN,EAAU1B,IAAI,CAAC2B,WAAf,CAA7B;IACD;IAED;;;;;;IAIA,SAASC,yCAAT,CACE5B,IADF,EACmC;;;MAEjC,MAAMmB,QAAQ,GACZnB,IAAI,CAAC6B,QAAL,IAAiB,CAAC7B,IAAI,CAAC8B,cAAvB,GACIlC,UAAU,CAACa,aAAX,CAAyBT,IAAI,CAAC+B,GAA9B,CADJ,GAEI,UAAI,CAACD,cAAL,MAAmB,IAAnB,IAAmBE,aAAnB,GAAmBA,EAAnB,GAAuBhC,IAAI,CAAC+B,GAHlC;MAKAb,6BAA6B,CAACC,QAAD,EAAWnB,IAAI,CAACG,KAAhB,CAA7B;IACD;IAED;;;;;;IAIA,SAAS8B,2BAAT,CACEH,cADF,EACoE;MAElE,MAAMI,KAAK,GAAGJ,cAAc,CAACI,KAA7B;MAEAA,KAAK,CAACC,OAAN,CAActD,IAAI,IAAG;QACnB,MAAMuD,uBAAuB,GAC3BvD,IAAI,CAACA,IAAL,KAAckC,iBAASsB,cAAT,CAAwBC,cAAtC,GACI7D,IAAI,CAAC8D,sBADT,GAEI,CAHN;QAIA,MAAMxC,QAAQ,GAAGH,UAAU,CAACW,cAAX,CACf1B,IADe,EAEfuD,uBAFe,CAAjB;;QAKA,IAAIrC,QAAQ,IAAI,IAAZ,IAAoBxB,MAAM,CAACiE,QAAP,CAAgBzC,QAAQ,CAACI,KAAzB,CAAxB,EAAyD;UACvD,MAAMmB,IAAI,GAAG1B,UAAU,CAACW,cAAX,CAA0BR,QAA1B,CAAb;UACA,MAAMwB,IAAI,GAAG3B,UAAU,CAACa,aAAX,CAAyBV,QAAzB,CAAb;;UAEA,IACE,CAACH,UAAU,CAAC4B,cAAX,CAA2BF,IAA3B,EAAkCvB,QAAlC,CAAD,IACA,CAACH,UAAU,CAAC4B,cAAX,CAA2BzB,QAA3B,EAAqCwB,IAArC,CAFH,EAGE;YACAzB,MAAM,CAACC,QAAD,CAAN;UACD;QACF;MACF,CArBD;IAsBD;IAED;;;;;;IAIA,SAAS0C,2BAAT,CACEzC,IADF,EACuC;;;MAErCkB,6BAA6B,CAC3B,UAAI,CAACwB,cAAL,MAAmB,IAAnB,IAAmBV,aAAnB,GAAmBA,EAAnB,GAAuBhC,IAAI,CAAC0B,EADD,EAE3B1B,IAAI,CAAC8B,cAFsB,CAA7B;IAID;;IAED,SAASa,uBAAT,CAAiC3C,IAAjC,EAAiE;MAC/DkB,6BAA6B,CAAClB,IAAI,CAAC4C,WAAN,EAAmB5C,IAAI,CAAC6C,QAAxB,CAA7B;MACA3B,6BAA6B,CAAClB,IAAI,CAAC6C,QAAN,EAAgB7C,IAAI,CAAC8C,SAArB,CAA7B;IACD;;IAED,uCACKnD,KADL,GACU;MACRoD,YAAY,EAAEtB,2BADN;MAERuB,kBAAkB,EAAEpB,yCAFZ;MAGRqB,sBAAsB,EAAER,2BAHhB;MAIRS,WAAW,EAAEjB,2BAJL;MAKRkB,kBAAkB,EAAElB,2BALZ;MAMRmB,iBAAiB,EAAET;IANX,CADV;EASD;;AAxKiD,CAArC,CAAf","names":["baseRule","UNIONS","exports","util","createRule","name","meta","type","docs","description","recommended","extendsBaseRule","fixable","hasSuggestions","schema","messages","missingSpace","defaultOptions","int32Hint","create","context","rules","sourceCode","getSourceCode","report","operator","node","messageId","data","value","fix","fixer","previousToken","getTokenBefore","afterToken","getTokenAfter","fixString","range","replaceText","isSpaceChar","token","utils_1","Punctuator","test","checkAndReportAssignmentSpace","leftNode","rightNode","getFirstTokenBetween","prev","next","isSpaceBetween","checkForEnumAssignmentSpace","id","initializer","checkForPropertyDefinitionAssignmentSpace","optional","typeAnnotation","key","_a","checkForTypeAnnotationSpace","types","forEach","skipFunctionParenthesis","AST_NODE_TYPES","TSFunctionType","isNotOpeningParenToken","includes","checkForTypeAliasAssignment","typeParameters","checkForTypeConditional","extendsType","trueType","falseType","TSEnumMember","PropertyDefinition","TSTypeAliasDeclaration","TSUnionType","TSIntersectionType","TSConditionalType"],"sources":["../../src/rules/space-infix-ops.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}