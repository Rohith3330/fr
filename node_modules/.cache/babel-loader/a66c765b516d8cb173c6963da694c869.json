{"ast":null,"code":"import { declare } from '@babel/helper-plugin-utils';\nimport _getTargets, { prettifyTargets, getInclusionReasons, isRequired } from '@babel/helper-compilation-targets';\nimport * as _babel from '@babel/core';\nimport path from 'path';\nimport debounce from 'lodash.debounce';\nimport requireResolve from 'resolve';\nimport { createRequire } from 'module';\nconst {\n  types: t$1,\n  template: template\n} = _babel.default || _babel;\n\nfunction intersection(a, b) {\n  const result = new Set();\n  a.forEach(v => b.has(v) && result.add(v));\n  return result;\n}\n\nfunction has$1(object, key) {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}\n\nfunction getType(target) {\n  return Object.prototype.toString.call(target).slice(8, -1);\n}\n\nfunction resolveId(path) {\n  if (path.isIdentifier() && !path.scope.hasBinding(path.node.name,\n  /* noGlobals */\n  true)) {\n    return path.node.name;\n  }\n\n  const {\n    deopt\n  } = path.evaluate();\n\n  if (deopt && deopt.isIdentifier()) {\n    return deopt.node.name;\n  }\n}\n\nfunction resolveKey(path) {\n  let computed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const {\n    scope\n  } = path;\n  if (path.isStringLiteral()) return path.node.value;\n  const isIdentifier = path.isIdentifier();\n\n  if (isIdentifier && !(computed || path.parent.computed)) {\n    return path.node.name;\n  }\n\n  if (computed && path.isMemberExpression() && path.get(\"object\").isIdentifier({\n    name: \"Symbol\"\n  }) && !scope.hasBinding(\"Symbol\",\n  /* noGlobals */\n  true)) {\n    const sym = resolveKey(path.get(\"property\"), path.node.computed);\n    if (sym) return \"Symbol.\" + sym;\n  }\n\n  if (!isIdentifier || scope.hasBinding(path.node.name,\n  /* noGlobals */\n  true)) {\n    const {\n      value\n    } = path.evaluate();\n    if (typeof value === \"string\") return value;\n  }\n}\n\nfunction resolveSource(obj) {\n  if (obj.isMemberExpression() && obj.get(\"property\").isIdentifier({\n    name: \"prototype\"\n  })) {\n    const id = resolveId(obj.get(\"object\"));\n\n    if (id) {\n      return {\n        id,\n        placement: \"prototype\"\n      };\n    }\n\n    return {\n      id: null,\n      placement: null\n    };\n  }\n\n  const id = resolveId(obj);\n\n  if (id) {\n    return {\n      id,\n      placement: \"static\"\n    };\n  }\n\n  const {\n    value\n  } = obj.evaluate();\n\n  if (value !== undefined) {\n    return {\n      id: getType(value),\n      placement: \"prototype\"\n    };\n  } else if (obj.isRegExpLiteral()) {\n    return {\n      id: \"RegExp\",\n      placement: \"prototype\"\n    };\n  } else if (obj.isFunction()) {\n    return {\n      id: \"Function\",\n      placement: \"prototype\"\n    };\n  }\n\n  return {\n    id: null,\n    placement: null\n  };\n}\n\nfunction getImportSource(_ref) {\n  let {\n    node\n  } = _ref;\n  if (node.specifiers.length === 0) return node.source.value;\n}\n\nfunction getRequireSource(_ref2) {\n  let {\n    node\n  } = _ref2;\n  if (!t$1.isExpressionStatement(node)) return;\n  const {\n    expression\n  } = node;\n\n  if (t$1.isCallExpression(expression) && t$1.isIdentifier(expression.callee) && expression.callee.name === \"require\" && expression.arguments.length === 1 && t$1.isStringLiteral(expression.arguments[0])) {\n    return expression.arguments[0].value;\n  }\n}\n\nfunction hoist(node) {\n  // @ts-expect-error\n  node._blockHoist = 3;\n  return node;\n}\n\nfunction createUtilsGetter(cache) {\n  return path => {\n    const prog = path.findParent(p => p.isProgram());\n    return {\n      injectGlobalImport(url) {\n        cache.storeAnonymous(prog, url, (isScript, source) => {\n          return isScript ? template.statement.ast`require(${source})` : t$1.importDeclaration([], source);\n        });\n      },\n\n      injectNamedImport(url, name) {\n        let hint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : name;\n        return cache.storeNamed(prog, url, name, (isScript, source, name) => {\n          const id = prog.scope.generateUidIdentifier(hint);\n          return {\n            node: isScript ? hoist(template.statement.ast`\n                  var ${id} = require(${source}).${name}\n                `) : t$1.importDeclaration([t$1.importSpecifier(id, name)], source),\n            name: id.name\n          };\n        });\n      },\n\n      injectDefaultImport(url) {\n        let hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;\n        return cache.storeNamed(prog, url, \"default\", (isScript, source) => {\n          const id = prog.scope.generateUidIdentifier(hint);\n          return {\n            node: isScript ? hoist(template.statement.ast`var ${id} = require(${source})`) : t$1.importDeclaration([t$1.importDefaultSpecifier(id)], source),\n            name: id.name\n          };\n        });\n      }\n\n    };\n  };\n}\n\nconst {\n  types: t\n} = _babel.default || _babel;\n\nclass ImportsCache {\n  constructor(resolver) {\n    this._imports = new WeakMap();\n    this._anonymousImports = new WeakMap();\n    this._lastImports = new WeakMap();\n    this._resolver = resolver;\n  }\n\n  storeAnonymous(programPath, url, // eslint-disable-next-line no-undef\n  getVal) {\n    const key = this._normalizeKey(programPath, url);\n\n    const imports = this._ensure(this._anonymousImports, programPath, Set);\n\n    if (imports.has(key)) return;\n    const node = getVal(programPath.node.sourceType === \"script\", t.stringLiteral(this._resolver(url)));\n    imports.add(key);\n\n    this._injectImport(programPath, node);\n  }\n\n  storeNamed(programPath, url, name, getVal) {\n    const key = this._normalizeKey(programPath, url, name);\n\n    const imports = this._ensure(this._imports, programPath, Map);\n\n    if (!imports.has(key)) {\n      const {\n        node,\n        name: id\n      } = getVal(programPath.node.sourceType === \"script\", t.stringLiteral(this._resolver(url)), t.identifier(name));\n      imports.set(key, id);\n\n      this._injectImport(programPath, node);\n    }\n\n    return t.identifier(imports.get(key));\n  }\n\n  _injectImport(programPath, node) {\n    const lastImport = this._lastImports.get(programPath);\n\n    let newNodes;\n\n    if (lastImport && lastImport.node && // Sometimes the AST is modified and the \"last import\"\n    // we have has been replaced\n    lastImport.parent === programPath.node && lastImport.container === programPath.node.body) {\n      newNodes = lastImport.insertAfter(node);\n    } else {\n      newNodes = programPath.unshiftContainer(\"body\", node);\n    }\n\n    const newNode = newNodes[newNodes.length - 1];\n\n    this._lastImports.set(programPath, newNode);\n    /*\n    let lastImport;\n     programPath.get(\"body\").forEach(path => {\n      if (path.isImportDeclaration()) lastImport = path;\n      if (\n        path.isExpressionStatement() &&\n        isRequireCall(path.get(\"expression\"))\n      ) {\n        lastImport = path;\n      }\n      if (\n        path.isVariableDeclaration() &&\n        path.get(\"declarations\").length === 1 &&\n        (isRequireCall(path.get(\"declarations.0.init\")) ||\n          (path.get(\"declarations.0.init\").isMemberExpression() &&\n            isRequireCall(path.get(\"declarations.0.init.object\"))))\n      ) {\n        lastImport = path;\n      }\n    });*/\n\n  }\n\n  _ensure(map, programPath, Collection) {\n    let collection = map.get(programPath);\n\n    if (!collection) {\n      collection = new Collection();\n      map.set(programPath, collection);\n    }\n\n    return collection;\n  }\n\n  _normalizeKey(programPath, url) {\n    let name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    const {\n      sourceType\n    } = programPath.node; // If we rely on the imported binding (the \"name\" parameter), we also need to cache\n    // based on the sourceType. This is because the module transforms change the names\n    // of the import variables.\n\n    return `${name && sourceType}::${url}::${name}`;\n  }\n\n}\n\nconst presetEnvSilentDebugHeader = \"#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets\";\n\nfunction stringifyTargetsMultiline(targets) {\n  return JSON.stringify(prettifyTargets(targets), null, 2);\n}\n\nfunction patternToRegExp(pattern) {\n  if (pattern instanceof RegExp) return pattern;\n\n  try {\n    return new RegExp(`^${pattern}$`);\n  } catch {\n    return null;\n  }\n}\n\nfunction buildUnusedError(label, unused) {\n  if (!unused.length) return \"\";\n  return `  - The following \"${label}\" patterns didn't match any polyfill:\\n` + unused.map(original => `    ${String(original)}\\n`).join(\"\");\n}\n\nfunction buldDuplicatesError(duplicates) {\n  if (!duplicates.size) return \"\";\n  return `  - The following polyfills were matched both by \"include\" and \"exclude\" patterns:\\n` + Array.from(duplicates, name => `    ${name}\\n`).join(\"\");\n}\n\nfunction validateIncludeExclude(provider, polyfills, includePatterns, excludePatterns) {\n  let current;\n\n  const filter = pattern => {\n    const regexp = patternToRegExp(pattern);\n    if (!regexp) return false;\n    let matched = false;\n\n    for (const polyfill of polyfills) {\n      if (regexp.test(polyfill)) {\n        matched = true;\n        current.add(polyfill);\n      }\n    }\n\n    return !matched;\n  }; // prettier-ignore\n\n\n  const include = current = new Set();\n  const unusedInclude = Array.from(includePatterns).filter(filter); // prettier-ignore\n\n  const exclude = current = new Set();\n  const unusedExclude = Array.from(excludePatterns).filter(filter);\n  const duplicates = intersection(include, exclude);\n\n  if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0) {\n    throw new Error(`Error while validating the \"${provider}\" provider options:\\n` + buildUnusedError(\"include\", unusedInclude) + buildUnusedError(\"exclude\", unusedExclude) + buldDuplicatesError(duplicates));\n  }\n\n  return {\n    include,\n    exclude\n  };\n}\n\nfunction applyMissingDependenciesDefaults(options, babelApi) {\n  const {\n    missingDependencies = {}\n  } = options;\n  if (missingDependencies === false) return false;\n  const caller = babelApi.caller(caller => caller == null ? void 0 : caller.name);\n  const {\n    log = \"deferred\",\n    inject = caller === \"rollup-plugin-babel\" ? \"throw\" : \"import\",\n    all = false\n  } = missingDependencies;\n  return {\n    log,\n    inject,\n    all\n  };\n}\n\nvar usage = callProvider => {\n  function property(object, key, placement, path) {\n    return callProvider({\n      kind: \"property\",\n      object,\n      key,\n      placement\n    }, path);\n  }\n\n  return {\n    // Symbol(), new Promise\n    ReferencedIdentifier(path) {\n      const {\n        node: {\n          name\n        },\n        scope\n      } = path;\n      if (scope.getBindingIdentifier(name)) return;\n      callProvider({\n        kind: \"global\",\n        name\n      }, path);\n    },\n\n    MemberExpression(path) {\n      const key = resolveKey(path.get(\"property\"), path.node.computed);\n      if (!key || key === \"prototype\") return;\n      const object = path.get(\"object\");\n\n      if (object.isIdentifier()) {\n        const binding = object.scope.getBinding(object.node.name);\n        if (binding && binding.path.isImportNamespaceSpecifier()) return;\n      }\n\n      const source = resolveSource(object);\n      return property(source.id, key, source.placement, path);\n    },\n\n    ObjectPattern(path) {\n      const {\n        parentPath,\n        parent\n      } = path;\n      let obj; // const { keys, values } = Object\n\n      if (parentPath.isVariableDeclarator()) {\n        obj = parentPath.get(\"init\"); // ({ keys, values } = Object)\n      } else if (parentPath.isAssignmentExpression()) {\n        obj = parentPath.get(\"right\"); // !function ({ keys, values }) {...} (Object)\n        // resolution does not work after properties transform :-(\n      } else if (parentPath.isFunction()) {\n        const grand = parentPath.parentPath;\n\n        if (grand.isCallExpression() || grand.isNewExpression()) {\n          if (grand.node.callee === parent) {\n            obj = grand.get(\"arguments\")[path.key];\n          }\n        }\n      }\n\n      let id = null;\n      let placement = null;\n      if (obj) ({\n        id,\n        placement\n      } = resolveSource(obj));\n\n      for (const prop of path.get(\"properties\")) {\n        if (prop.isObjectProperty()) {\n          const key = resolveKey(prop.get(\"key\"));\n          if (key) property(id, key, placement, prop);\n        }\n      }\n    },\n\n    BinaryExpression(path) {\n      if (path.node.operator !== \"in\") return;\n      const source = resolveSource(path.get(\"right\"));\n      const key = resolveKey(path.get(\"left\"), true);\n      if (!key) return;\n      callProvider({\n        kind: \"in\",\n        object: source.id,\n        key,\n        placement: source.placement\n      }, path);\n    }\n\n  };\n};\n\nvar entry = callProvider => ({\n  ImportDeclaration(path) {\n    const source = getImportSource(path);\n    if (!source) return;\n    callProvider({\n      kind: \"import\",\n      source\n    }, path);\n  },\n\n  Program(path) {\n    path.get(\"body\").forEach(bodyPath => {\n      const source = getRequireSource(bodyPath);\n      if (!source) return;\n      callProvider({\n        kind: \"import\",\n        source\n      }, bodyPath);\n    });\n  }\n\n});\n\nconst nativeRequireResolve = parseFloat(process.versions.node) >= 8.9;\n\nconst require = createRequire(import\n/*::(_)*/\n.meta.url); // eslint-disable-line\n\n\nfunction myResolve(name, basedir) {\n  if (nativeRequireResolve) {\n    return require.resolve(name, {\n      paths: [basedir]\n    }).replace(/\\\\/g, \"/\");\n  } else {\n    return requireResolve.sync(name, {\n      basedir\n    }).replace(/\\\\/g, \"/\");\n  }\n}\n\nfunction resolve(dirname, moduleName, absoluteImports) {\n  if (absoluteImports === false) return moduleName;\n  let basedir = dirname;\n\n  if (typeof absoluteImports === \"string\") {\n    basedir = path.resolve(basedir, absoluteImports);\n  }\n\n  try {\n    return myResolve(moduleName, basedir);\n  } catch (err) {\n    if (err.code !== \"MODULE_NOT_FOUND\") throw err;\n    throw Object.assign(new Error(`Failed to resolve \"${moduleName}\" relative to \"${dirname}\"`), {\n      code: \"BABEL_POLYFILL_NOT_FOUND\",\n      polyfill: moduleName,\n      dirname\n    });\n  }\n}\n\nfunction has(basedir, name) {\n  try {\n    myResolve(name, basedir);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction logMissing(missingDeps) {\n  if (missingDeps.size === 0) return;\n  const deps = Array.from(missingDeps).sort().join(\" \");\n  console.warn(\"\\nSome polyfills have been added but are not present in your dependencies.\\n\" + \"Please run one of the following commands:\\n\" + `\\tnpm install --save ${deps}\\n` + `\\tyarn add ${deps}\\n`);\n  process.exitCode = 1;\n}\n\nlet allMissingDeps = new Set();\nconst laterLogMissingDependencies = debounce(() => {\n  logMissing(allMissingDeps);\n  allMissingDeps = new Set();\n}, 100);\n\nfunction laterLogMissing(missingDeps) {\n  if (missingDeps.size === 0) return;\n  missingDeps.forEach(name => allMissingDeps.add(name));\n  laterLogMissingDependencies();\n}\n\nconst PossibleGlobalObjects = new Set([\"global\", \"globalThis\", \"self\", \"window\"]);\n\nfunction createMetaResolver(polyfills) {\n  const {\n    static: staticP,\n    instance: instanceP,\n    global: globalP\n  } = polyfills;\n  return meta => {\n    if (meta.kind === \"global\" && globalP && has$1(globalP, meta.name)) {\n      return {\n        kind: \"global\",\n        desc: globalP[meta.name],\n        name: meta.name\n      };\n    }\n\n    if (meta.kind === \"property\" || meta.kind === \"in\") {\n      const {\n        placement,\n        object,\n        key\n      } = meta;\n\n      if (object && placement === \"static\") {\n        if (globalP && PossibleGlobalObjects.has(object) && has$1(globalP, key)) {\n          return {\n            kind: \"global\",\n            desc: globalP[key],\n            name: key\n          };\n        }\n\n        if (staticP && has$1(staticP, object) && has$1(staticP[object], key)) {\n          return {\n            kind: \"static\",\n            desc: staticP[object][key],\n            name: `${object}$${key}`\n          };\n        }\n      }\n\n      if (instanceP && has$1(instanceP, key)) {\n        return {\n          kind: \"instance\",\n          desc: instanceP[key],\n          name: `${key}`\n        };\n      }\n    }\n  };\n}\n\nconst getTargets = _getTargets.default || _getTargets;\n\nfunction resolveOptions(options, babelApi) {\n  const {\n    method,\n    targets: targetsOption,\n    ignoreBrowserslistConfig,\n    configPath,\n    debug,\n    shouldInjectPolyfill,\n    absoluteImports,\n    ...providerOptions\n  } = options;\n\n  if (isEmpty(options)) {\n    throw new Error(`\\\nThis plugin requires options, for example:\n    {\n      \"plugins\": [\n        [\"<plugin name>\", { method: \"usage-pure\" }]\n      ]\n    }\n\nSee more options at https://github.com/babel/babel-polyfills/blob/main/docs/usage.md`);\n  }\n\n  let methodName;\n  if (method === \"usage-global\") methodName = \"usageGlobal\";else if (method === \"entry-global\") methodName = \"entryGlobal\";else if (method === \"usage-pure\") methodName = \"usagePure\";else if (typeof method !== \"string\") {\n    throw new Error(\".method must be a string\");\n  } else {\n    throw new Error(`.method must be one of \"entry-global\", \"usage-global\"` + ` or \"usage-pure\" (received ${JSON.stringify(method)})`);\n  }\n\n  if (typeof shouldInjectPolyfill === \"function\") {\n    if (options.include || options.exclude) {\n      throw new Error(`.include and .exclude are not supported when using the` + ` .shouldInjectPolyfill function.`);\n    }\n  } else if (shouldInjectPolyfill != null) {\n    throw new Error(`.shouldInjectPolyfill must be a function, or undefined` + ` (received ${JSON.stringify(shouldInjectPolyfill)})`);\n  }\n\n  if (absoluteImports != null && typeof absoluteImports !== \"boolean\" && typeof absoluteImports !== \"string\") {\n    throw new Error(`.absoluteImports must be a boolean, a string, or undefined` + ` (received ${JSON.stringify(absoluteImports)})`);\n  }\n\n  let targets;\n\n  if ( // If any browserslist-related option is specified, fallback to the old\n  // behavior of not using the targets specified in the top-level options.\n  targetsOption || configPath || ignoreBrowserslistConfig) {\n    const targetsObj = typeof targetsOption === \"string\" || Array.isArray(targetsOption) ? {\n      browsers: targetsOption\n    } : targetsOption;\n    targets = getTargets(targetsObj, {\n      ignoreBrowserslistConfig,\n      configPath\n    });\n  } else {\n    targets = babelApi.targets();\n  }\n\n  return {\n    method,\n    methodName,\n    targets,\n    absoluteImports: absoluteImports != null ? absoluteImports : false,\n    shouldInjectPolyfill,\n    debug: !!debug,\n    providerOptions: providerOptions\n  };\n}\n\nfunction instantiateProvider(factory, options, missingDependencies, dirname, debugLog, babelApi) {\n  const {\n    method,\n    methodName,\n    targets,\n    debug,\n    shouldInjectPolyfill,\n    providerOptions,\n    absoluteImports\n  } = resolveOptions(options, babelApi);\n  const getUtils = createUtilsGetter(new ImportsCache(moduleName => resolve(dirname, moduleName, absoluteImports))); // eslint-disable-next-line prefer-const\n\n  let include, exclude;\n  let polyfillsSupport;\n  let polyfillsNames;\n  let filterPolyfills;\n  const depsCache = new Map();\n  const api = {\n    babel: babelApi,\n    getUtils,\n    method: options.method,\n    targets,\n    createMetaResolver,\n\n    shouldInjectPolyfill(name) {\n      if (polyfillsNames === undefined) {\n        throw new Error(`Internal error in the ${factory.name} provider: ` + `shouldInjectPolyfill() can't be called during initialization.`);\n      }\n\n      if (!polyfillsNames.has(name)) {\n        console.warn(`Internal error in the ${provider.name} provider: ` + `unknown polyfill \"${name}\".`);\n      }\n\n      if (filterPolyfills && !filterPolyfills(name)) return false;\n      let shouldInject = isRequired(name, targets, {\n        compatData: polyfillsSupport,\n        includes: include,\n        excludes: exclude\n      });\n\n      if (shouldInjectPolyfill) {\n        shouldInject = shouldInjectPolyfill(name, shouldInject);\n\n        if (typeof shouldInject !== \"boolean\") {\n          throw new Error(`.shouldInjectPolyfill must return a boolean.`);\n        }\n      }\n\n      return shouldInject;\n    },\n\n    debug(name) {\n      var _debugLog, _debugLog$polyfillsSu;\n\n      debugLog().found = true;\n      if (!debug || !name) return;\n      if (debugLog().polyfills.has(provider.name)) return;\n      debugLog().polyfills.add(name);\n      (_debugLog$polyfillsSu = (_debugLog = debugLog()).polyfillsSupport) != null ? _debugLog$polyfillsSu : _debugLog.polyfillsSupport = polyfillsSupport;\n    },\n\n    assertDependency(name) {\n      let version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"*\";\n      if (missingDependencies === false) return;\n\n      if (absoluteImports) {\n        // If absoluteImports is not false, we will try resolving\n        // the dependency and throw if it's not possible. We can\n        // skip the check here.\n        return;\n      }\n\n      const dep = version === \"*\" ? name : `${name}@^${version}`;\n      const found = missingDependencies.all ? false : mapGetOr(depsCache, `${name} :: ${dirname}`, () => has(dirname, name));\n\n      if (!found) {\n        debugLog().missingDeps.add(dep);\n      }\n    }\n\n  };\n  const provider = factory(api, providerOptions, dirname);\n\n  if (typeof provider[methodName] !== \"function\") {\n    throw new Error(`The \"${provider.name || factory.name}\" provider doesn't ` + `support the \"${method}\" polyfilling method.`);\n  }\n\n  if (Array.isArray(provider.polyfills)) {\n    polyfillsNames = new Set(provider.polyfills);\n    filterPolyfills = provider.filterPolyfills;\n  } else if (provider.polyfills) {\n    polyfillsNames = new Set(Object.keys(provider.polyfills));\n    polyfillsSupport = provider.polyfills;\n    filterPolyfills = provider.filterPolyfills;\n  } else {\n    polyfillsNames = new Set();\n  }\n\n  ({\n    include,\n    exclude\n  } = validateIncludeExclude(provider.name || factory.name, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []));\n  return {\n    debug,\n    method,\n    targets,\n    provider,\n\n    callProvider(payload, path) {\n      const utils = getUtils(path);\n      provider[methodName](payload, utils, path);\n    }\n\n  };\n}\n\nfunction definePolyfillProvider(factory) {\n  return declare((babelApi, options, dirname) => {\n    babelApi.assertVersion(7);\n    const {\n      traverse\n    } = babelApi;\n    let debugLog;\n    const missingDependencies = applyMissingDependenciesDefaults(options, babelApi);\n    const {\n      debug,\n      method,\n      targets,\n      provider,\n      callProvider\n    } = instantiateProvider(factory, options, missingDependencies, dirname, () => debugLog, babelApi);\n    const createVisitor = method === \"entry-global\" ? entry : usage;\n    const visitor = provider.visitor ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor]) : createVisitor(callProvider);\n\n    if (debug && debug !== presetEnvSilentDebugHeader) {\n      console.log(`${provider.name}: \\`DEBUG\\` option`);\n      console.log(`\\nUsing targets: ${stringifyTargetsMultiline(targets)}`);\n      console.log(`\\nUsing polyfills with \\`${method}\\` method:`);\n    }\n\n    return {\n      name: \"inject-polyfills\",\n      visitor,\n\n      pre() {\n        var _provider$pre;\n\n        debugLog = {\n          polyfills: new Set(),\n          polyfillsSupport: undefined,\n          found: false,\n          providers: new Set(),\n          missingDeps: new Set()\n        };\n        (_provider$pre = provider.pre) == null ? void 0 : _provider$pre.apply(this, arguments);\n      },\n\n      post() {\n        var _provider$post;\n\n        (_provider$post = provider.post) == null ? void 0 : _provider$post.apply(this, arguments);\n\n        if (missingDependencies !== false) {\n          if (missingDependencies.log === \"per-file\") {\n            logMissing(debugLog.missingDeps);\n          } else {\n            laterLogMissing(debugLog.missingDeps);\n          }\n        }\n\n        if (!debug) return;\n        if (this.filename) console.log(`\\n[${this.filename}]`);\n\n        if (debugLog.polyfills.size === 0) {\n          console.log(method === \"entry-global\" ? debugLog.found ? `Based on your targets, the ${provider.name} polyfill did not add any polyfill.` : `The entry point for the ${provider.name} polyfill has not been found.` : `Based on your code and targets, the ${provider.name} polyfill did not add any polyfill.`);\n          return;\n        }\n\n        if (method === \"entry-global\") {\n          console.log(`The ${provider.name} polyfill entry has been replaced with ` + `the following polyfills:`);\n        } else {\n          console.log(`The ${provider.name} polyfill added the following polyfills:`);\n        }\n\n        for (const name of debugLog.polyfills) {\n          var _debugLog$polyfillsSu2;\n\n          if ((_debugLog$polyfillsSu2 = debugLog.polyfillsSupport) != null && _debugLog$polyfillsSu2[name]) {\n            const filteredTargets = getInclusionReasons(name, targets, debugLog.polyfillsSupport);\n            const formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, \", \").replace(/^\\{\"/, '{ \"').replace(/\"\\}$/, '\" }');\n            console.log(`  ${name} ${formattedTargets}`);\n          } else {\n            console.log(`  ${name}`);\n          }\n        }\n      }\n\n    };\n  });\n}\n\nfunction mapGetOr(map, key, getDefault) {\n  let val = map.get(key);\n\n  if (val === undefined) {\n    val = getDefault();\n    map.set(key, val);\n  }\n\n  return val;\n}\n\nfunction isEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}\n\nexport default definePolyfillProvider;","map":{"version":3,"mappings":";;;;;;;;EAASA,OAASC;EAAGC;;;AAKd,SAASC,YAAT,CAAyBC,CAAzB,EAAoCC,CAApC,EAAuD;EAC5D,MAAMC,MAAM,GAAG,IAAIC,GAAJ,EAAf;EACAH,CAAC,CAACI,OAAFJ,CAAUK,CAAC,IAAIJ,CAAC,CAACK,GAAFL,CAAMI,CAANJ,KAAYC,MAAM,CAACK,GAAPL,CAAWG,CAAXH,CAA3BF;EACA,OAAOE,MAAP;AACD;;AAEM,SAASI,KAAT,CAAaE,MAAb,EAA0BC,GAA1B,EAAuC;EAC5C,OAAOC,MAAM,CAACC,SAAPD,CAAiBE,cAAjBF,CAAgCG,IAAhCH,CAAqCF,MAArCE,EAA6CD,GAA7CC,CAAP;AACD;;AAED,SAASI,OAAT,CAAiBC,MAAjB,EAAsC;EACpC,OAAOL,MAAM,CAACC,SAAPD,CAAiBM,QAAjBN,CAA0BG,IAA1BH,CAA+BK,MAA/BL,EAAuCO,KAAvCP,CAA6C,CAA7CA,EAAgD,CAAC,CAAjDA,CAAP;AACD;;AAED,SAASQ,SAAT,CAAmBC,IAAnB,EAAiC;EAC/B,IACEA,IAAI,CAACC,YAALD,MACA,CAACA,IAAI,CAACE,KAALF,CAAWG,UAAXH,CAAsBA,IAAI,CAACI,IAALJ,CAAUK,IAAhCL;;EAAsD,IAAtDA,CAFH,EAGE;IACA,OAAOA,IAAI,CAACI,IAALJ,CAAUK,IAAjB;;;EAGF,MAAM;IAAEC;EAAF,IAAYN,IAAI,CAACO,QAALP,EAAlB;;EACA,IAAIM,KAAK,IAAIA,KAAK,CAACL,YAANK,EAAb,EAAmC;IACjC,OAAOA,KAAK,CAACF,IAANE,CAAWD,IAAlB;;AAEH;;AAEM,SAASG,UAAT,CACLR,IADK,EAGL;EAAA,IADAS,QACA,uEADoB,KACpB;EACA,MAAM;IAAEP;EAAF,IAAYF,IAAlB;EACA,IAAIA,IAAI,CAACU,eAALV,EAAJ,EAA4B,OAAOA,IAAI,CAACI,IAALJ,CAAUW,KAAjB;EAC5B,MAAMV,YAAY,GAAGD,IAAI,CAACC,YAALD,EAArB;;EACA,IACEC,YAAY,IACZ,EAAEQ,QAAQ,IAAKT,IAAI,CAACY,MAALZ,CAAmCS,QAAlD,CAFF,EAGE;IACA,OAAOT,IAAI,CAACI,IAALJ,CAAUK,IAAjB;;;EAGF,IACEI,QAAQ,IACRT,IAAI,CAACa,kBAALb,EADAS,IAEAT,IAAI,CAACc,GAALd,CAAS,QAATA,EAAmBC,YAAnBD,CAAgC;IAAEK,IAAI,EAAE;EAAR,CAAhCL,CAFAS,IAGA,CAACP,KAAK,CAACC,UAAND,CAAiB,QAAjBA;;EAA2C,IAA3CA,CAJH,EAKE;IACA,MAAMa,GAAG,GAAGP,UAAU,CAACR,IAAI,CAACc,GAALd,CAAS,UAATA,CAAD,EAAuBA,IAAI,CAACI,IAALJ,CAAUS,QAAjC,CAAtB;IACA,IAAIM,GAAJ,EAAS,OAAO,YAAYA,GAAnB;;;EAGX,IAAI,CAACd,YAAD,IAAiBC,KAAK,CAACC,UAAND,CAAiBF,IAAI,CAACI,IAALJ,CAAUK,IAA3BH;;EAAiD,IAAjDA,CAArB,EAA6E;IAC3E,MAAM;MAAES;IAAF,IAAYX,IAAI,CAACO,QAALP,EAAlB;IACA,IAAI,OAAOW,KAAP,KAAiB,QAArB,EAA+B,OAAOA,KAAP;;AAElC;;AAEM,SAASK,aAAT,CAAuBC,GAAvB,EAGL;EACA,IACEA,GAAG,CAACJ,kBAAJI,MACAA,GAAG,CAACH,GAAJG,CAAQ,UAARA,EAAoBhB,YAApBgB,CAAiC;IAAEZ,IAAI,EAAE;EAAR,CAAjCY,CAFF,EAGE;IACA,MAAMC,EAAE,GAAGnB,SAAS,CAACkB,GAAG,CAACH,GAAJG,CAAQ,QAARA,CAAD,CAApB;;IAEA,IAAIC,EAAJ,EAAQ;MACN,OAAO;QAAEA,EAAF;QAAMC,SAAS,EAAE;MAAjB,CAAP;;;IAEF,OAAO;MAAED,EAAE,EAAE,IAAN;MAAYC,SAAS,EAAE;IAAvB,CAAP;;;EAGF,MAAMD,EAAE,GAAGnB,SAAS,CAACkB,GAAD,CAApB;;EACA,IAAIC,EAAJ,EAAQ;IACN,OAAO;MAAEA,EAAF;MAAMC,SAAS,EAAE;IAAjB,CAAP;;;EAGF,MAAM;IAAER;EAAF,IAAYM,GAAG,CAACV,QAAJU,EAAlB;;EACA,IAAIN,KAAK,KAAKS,SAAd,EAAyB;IACvB,OAAO;MAAEF,EAAE,EAAEvB,OAAO,CAACgB,KAAD,CAAb;MAAsBQ,SAAS,EAAE;IAAjC,CAAP;EADF,OAEO,IAAIF,GAAG,CAACI,eAAJJ,EAAJ,EAA2B;IAChC,OAAO;MAAEC,EAAE,EAAE,QAAN;MAAgBC,SAAS,EAAE;IAA3B,CAAP;EADK,OAEA,IAAIF,GAAG,CAACK,UAAJL,EAAJ,EAAsB;IAC3B,OAAO;MAAEC,EAAE,EAAE,UAAN;MAAkBC,SAAS,EAAE;IAA7B,CAAP;;;EAGF,OAAO;IAAED,EAAE,EAAE,IAAN;IAAYC,SAAS,EAAE;EAAvB,CAAP;AACD;;AAEM,SAASI,eAAT,OAAkE;EAAA,IAAzC;IAAEnB;EAAF,CAAyC;EACvE,IAAIA,IAAI,CAACoB,UAALpB,CAAgBqB,MAAhBrB,KAA2B,CAA/B,EAAkC,OAAOA,IAAI,CAACsB,MAALtB,CAAYO,KAAnB;AACnC;;AAEM,SAASgB,gBAAT,QAA2D;EAAA,IAAjC;IAAEvB;EAAF,CAAiC;EAChE,IAAI,CAAC1B,GAAC,CAACkD,qBAAFlD,CAAwB0B,IAAxB1B,CAAL,EAAoC;EACpC,MAAM;IAAEmD;EAAF,IAAiBzB,IAAvB;;EACA,IACE1B,GAAC,CAACoD,gBAAFpD,CAAmBmD,UAAnBnD,KACAA,GAAC,CAACuB,YAAFvB,CAAemD,UAAU,CAACE,MAA1BrD,CADAA,IAEAmD,UAAU,CAACE,MAAXF,CAAkBxB,IAAlBwB,KAA2B,SAF3BnD,IAGAmD,UAAU,CAACG,SAAXH,CAAqBJ,MAArBI,KAAgC,CAHhCnD,IAIAA,GAAC,CAACgC,eAAFhC,CAAkBmD,UAAU,CAACG,SAAXH,CAAqB,CAArBA,CAAlBnD,CALF,EAME;IACA,OAAOmD,UAAU,CAACG,SAAXH,CAAqB,CAArBA,EAAwBlB,KAA/B;;AAEH;;AAED,SAASsB,KAAT,CAAe7B,IAAf,EAA6B;;EAE3BA,IAAI,CAAC8B,WAAL9B,GAAmB,CAAnBA;EACA,OAAOA,IAAP;AACD;;AAEM,SAAS+B,iBAAT,CAA2BC,KAA3B,EAAgD;EACrD,OAAQpC,IAAD,IAA2B;IAChC,MAAMqC,IAAI,GAAGrC,IAAI,CAACsC,UAALtC,CAAgBuC,CAAC,IAAIA,CAAC,CAACC,SAAFD,EAArBvC,CAAb;IAEA,OAAO;MACLyC,kBAAkB,CAACC,GAAD,EAAM;QACtBN,KAAK,CAACO,cAANP,CAAqBC,IAArBD,EAA2BM,GAA3BN,EAAgC,CAACQ,QAAD,EAAWlB,MAAX,KAAsB;UACpD,OAAOkB,QAAQ,GACXjE,QAAQ,CAACkE,SAATlE,CAAmBmE,GAAI,WAAUpB,MAAO,GAD7B,GAEXhD,GAAC,CAACqE,iBAAFrE,CAAoB,EAApBA,EAAwBgD,MAAxBhD,CAFJ;QADF;MAFG;;MAQLsE,iBAAiB,CAACN,GAAD,EAAMrC,IAAN,EAAyB;QAAA,IAAb4C,IAAa,uEAAN5C,IAAM;QACxC,OAAO+B,KAAK,CAACc,UAANd,CAAiBC,IAAjBD,EAAuBM,GAAvBN,EAA4B/B,IAA5B+B,EAAkC,CAACQ,QAAD,EAAWlB,MAAX,EAAmBrB,IAAnB,KAA4B;UACnE,MAAMa,EAAE,GAAGmB,IAAI,CAACnC,KAALmC,CAAWc,qBAAXd,CAAiCY,IAAjCZ,CAAX;UACA,OAAO;YACLjC,IAAI,EAAEwC,QAAQ,GACVX,KAAK,CAACtD,QAAQ,CAACkE,SAATlE,CAAmBmE,GAAI;AAC7C,wBAAwB5B,EAAG,cAAaQ,MAAO,KAAIrB,IAAK;AACxD,iBAFqB,CADK,GAIV3B,GAAC,CAACqE,iBAAFrE,CAAoB,CAACA,GAAC,CAAC0E,eAAF1E,CAAkBwC,EAAlBxC,EAAsB2B,IAAtB3B,CAAD,CAApBA,EAAmDgD,MAAnDhD,CALC;YAML2B,IAAI,EAAEa,EAAE,CAACb;UANJ,CAAP;QAFK,EAAP;MATG;;MAqBLgD,mBAAmB,CAACX,GAAD,EAAkB;QAAA,IAAZO,IAAY,uEAALP,GAAK;QACnC,OAAON,KAAK,CAACc,UAANd,CAAiBC,IAAjBD,EAAuBM,GAAvBN,EAA4B,SAA5BA,EAAuC,CAACQ,QAAD,EAAWlB,MAAX,KAAsB;UAClE,MAAMR,EAAE,GAAGmB,IAAI,CAACnC,KAALmC,CAAWc,qBAAXd,CAAiCY,IAAjCZ,CAAX;UACA,OAAO;YACLjC,IAAI,EAAEwC,QAAQ,GACVX,KAAK,CAACtD,QAAQ,CAACkE,SAATlE,CAAmBmE,GAAI,OAAM5B,EAAG,cAAaQ,MAAO,GAArD,CADK,GAEVhD,GAAC,CAACqE,iBAAFrE,CAAoB,CAACA,GAAC,CAAC4E,sBAAF5E,CAAyBwC,EAAzBxC,CAAD,CAApBA,EAAoDgD,MAApDhD,CAHC;YAIL2B,IAAI,EAAEa,EAAE,CAACb;UAJJ,CAAP;QAFK,EAAP;;;IAtBG,CAAP;EAHF;AAqCD;;;EC7JQ5B,OAASC;;;AAIH,MAAM6E,YAAN,CAAmB;EAMhCC,WAAW,CAACC,QAAD,EAAoC;IAC7C,KAAKC,QAAL,GAAgB,IAAIC,OAAJ,EAAhB;IACA,KAAKC,iBAAL,GAAyB,IAAID,OAAJ,EAAzB;IACA,KAAKE,YAAL,GAAoB,IAAIF,OAAJ,EAApB;IACA,KAAKG,SAAL,GAAiBL,QAAjB;;;EAGFd,cAAc,CACZoB,WADY,EAEZrB,GAFY;EAIZsB,MAJY,EAKZ;IACA,MAAM1E,GAAG,GAAG,KAAK2E,aAAL,CAAmBF,WAAnB,EAAgCrB,GAAhC,CAAZ;;IACA,MAAMwB,OAAO,GAAG,KAAKC,OAAL,CACd,KAAKP,iBADS,EAEdG,WAFc,EAGd/E,GAHc,CAAhB;;IAMA,IAAIkF,OAAO,CAAC/E,GAAR+E,CAAY5E,GAAZ4E,CAAJ,EAAsB;IAEtB,MAAM9D,IAAI,GAAG4D,MAAM,CACjBD,WAAW,CAAC3D,IAAZ2D,CAAiBK,UAAjBL,KAAgC,QADf,EAEjBrF,CAAC,CAAC2F,aAAF3F,CAAgB,KAAKoF,SAAL,CAAepB,GAAf,CAAhBhE,CAFiB,CAAnB;IAIAwF,OAAO,CAAC9E,GAAR8E,CAAY5E,GAAZ4E;;IACA,KAAKI,aAAL,CAAmBP,WAAnB,EAAgC3D,IAAhC;;;EAGF8C,UAAU,CACRa,WADQ,EAERrB,GAFQ,EAGRrC,IAHQ,EAIR2D,MAJQ,EAWR;IACA,MAAM1E,GAAG,GAAG,KAAK2E,aAAL,CAAmBF,WAAnB,EAAgCrB,GAAhC,EAAqCrC,IAArC,CAAZ;;IACA,MAAM6D,OAAO,GAAG,KAAKC,OAAL,CACd,KAAKT,QADS,EAEdK,WAFc,EAGdQ,GAHc,CAAhB;;IAMA,IAAI,CAACL,OAAO,CAAC/E,GAAR+E,CAAY5E,GAAZ4E,CAAL,EAAuB;MACrB,MAAM;QAAE9D,IAAF;QAAQC,IAAI,EAAEa;MAAd,IAAqB8C,MAAM,CAC/BD,WAAW,CAAC3D,IAAZ2D,CAAiBK,UAAjBL,KAAgC,QADD,EAE/BrF,CAAC,CAAC2F,aAAF3F,CAAgB,KAAKoF,SAAL,CAAepB,GAAf,CAAhBhE,CAF+B,EAG/BA,CAAC,CAAC8F,UAAF9F,CAAa2B,IAAb3B,CAH+B,CAAjC;MAKAwF,OAAO,CAACO,GAARP,CAAY5E,GAAZ4E,EAAiBhD,EAAjBgD;;MACA,KAAKI,aAAL,CAAmBP,WAAnB,EAAgC3D,IAAhC;;;IAGF,OAAO1B,CAAC,CAAC8F,UAAF9F,CAAawF,OAAO,CAACpD,GAARoD,CAAY5E,GAAZ4E,CAAbxF,CAAP;;;EAGF4F,aAAa,CAACP,WAAD,EAAmC3D,IAAnC,EAAiD;IAC5D,MAAMsE,UAAU,GAAG,KAAKb,YAAL,CAAkB/C,GAAlB,CAAsBiD,WAAtB,CAAnB;;IACA,IAAIY,QAAJ;;IACA,IACED,UAAU,IACVA,UAAU,CAACtE,IADXsE;;IAIAA,UAAU,CAAC9D,MAAX8D,KAAsBX,WAAW,CAAC3D,IAJlCsE,IAKAA,UAAU,CAACE,SAAXF,KAAyBX,WAAW,CAAC3D,IAAZ2D,CAAiBc,IAN5C,EAOE;MACAF,QAAQ,GAAGD,UAAU,CAACI,WAAXJ,CAAuBtE,IAAvBsE,CAAXC;IARF,OASO;MACLA,QAAQ,GAAGZ,WAAW,CAACgB,gBAAZhB,CAA6B,MAA7BA,EAAqC3D,IAArC2D,CAAXY;;;IAEF,MAAMK,OAAO,GAAGL,QAAQ,CAACA,QAAQ,CAAClD,MAATkD,GAAkB,CAAnB,CAAxB;;IACA,KAAKd,YAAL,CAAkBY,GAAlB,CAAsBV,WAAtB,EAAmCiB,OAAnC;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;EAIEb,OAAO,CACLc,GADK,EAELlB,WAFK,EAGLmB,UAHK,EAIF;IACH,IAAIC,UAAU,GAAGF,GAAG,CAACnE,GAAJmE,CAAQlB,WAARkB,CAAjB;;IACA,IAAI,CAACE,UAAL,EAAiB;MACfA,UAAU,GAAG,IAAID,UAAJ,EAAbC;MACAF,GAAG,CAACR,GAAJQ,CAAQlB,WAARkB,EAAqBE,UAArBF;;;IAEF,OAAOE,UAAP;;;EAGFlB,aAAa,CACXF,WADW,EAEXrB,GAFW,EAIH;IAAA,IADRrC,IACQ,uEADO,EACP;IACR,MAAM;MAAE+D;IAAF,IAAiBL,WAAW,CAAC3D,IAAnC,CADQ;;;;IAMR,OAAQ,GAAEC,IAAI,IAAI+D,UAAW,KAAI1B,GAAI,KAAIrC,IAAK,EAA9C;;;AApI8B;;ACD3B,MAAM+E,0BAA0B,GACrC,+EADK;;AAGA,SAASC,yBAAT,CAAmCC,OAAnC,EAA6D;EAClE,OAAOC,IAAI,CAACC,SAALD,CAAeE,eAAe,CAACH,OAAD,CAA9BC,EAAyC,IAAzCA,EAA+C,CAA/CA,CAAP;AACD;;ACFD,SAASG,eAAT,CAAyBC,OAAzB,EAA0D;EACxD,IAAIA,OAAO,YAAYC,MAAvB,EAA+B,OAAOD,OAAP;;EAE/B,IAAI;IACF,OAAO,IAAIC,MAAJ,CAAY,IAAGD,OAAQ,GAAvB,CAAP;EADF,EAEE,MAAM;IACN,OAAO,IAAP;;AAEH;;AAED,SAASE,gBAAT,CAA0BC,KAA1B,EAAiCC,MAAjC,EAAyC;EACvC,IAAI,CAACA,MAAM,CAACtE,MAAZ,EAAoB,OAAO,EAAP;EACpB,OACG,sBAAqBqE,KAAM,yCAA3B,GACDC,MAAM,CAACd,GAAPc,CAAWC,QAAQ,IAAK,OAAMC,MAAM,CAACD,QAAD,CAAW,IAA/CD,EAAoDG,IAApDH,CAAyD,EAAzDA,CAFF;AAID;;AAED,SAASI,mBAAT,CAA6BC,UAA7B,EAAyC;EACvC,IAAI,CAACA,UAAU,CAACC,IAAhB,EAAsB,OAAO,EAAP;EACtB,OACG,yFACDC,KAAK,CAACC,IAAND,CAAWF,UAAXE,EAAuBjG,IAAI,IAAK,OAAMA,IAAK,IAA3CiG,EAAgDJ,IAAhDI,CAAqD,EAArDA,CAFF;AAID;;AAEM,SAASE,sBAAT,CACLC,QADK,EAELC,SAFK,EAGLC,eAHK,EAILC,eAJK,EAKL;EACA,IAAIC,OAAJ;;EACA,MAAMC,MAAM,GAAGnB,OAAO,IAAI;IACxB,MAAMoB,MAAM,GAAGrB,eAAe,CAACC,OAAD,CAA9B;IACA,IAAI,CAACoB,MAAL,EAAa,OAAO,KAAP;IAEb,IAAIC,OAAO,GAAG,KAAd;;IACA,KAAK,MAAMC,QAAX,IAAuBP,SAAvB,EAAkC;MAChC,IAAIK,MAAM,CAACG,IAAPH,CAAYE,QAAZF,CAAJ,EAA2B;QACzBC,OAAO,GAAG,IAAVA;QACAH,OAAO,CAACzH,GAARyH,CAAYI,QAAZJ;;;;IAGJ,OAAO,CAACG,OAAR;EAXF,EAFA;;;EAiBA,MAAMG,OAAO,GAAGN,OAAO,GAAG,IAAI7H,GAAJ,EAA1B;EACA,MAAMoI,aAAa,GAAGd,KAAK,CAACC,IAAND,CAAWK,eAAXL,EAA4BQ,MAA5BR,CAAmCQ,MAAnCR,CAAtB,CAlBA;;EAqBA,MAAMe,OAAO,GAAGR,OAAO,GAAG,IAAI7H,GAAJ,EAA1B;EACA,MAAMsI,aAAa,GAAGhB,KAAK,CAACC,IAAND,CAAWM,eAAXN,EAA4BQ,MAA5BR,CAAmCQ,MAAnCR,CAAtB;EAEA,MAAMF,UAAU,GAAGxH,YAAY,CAACuI,OAAD,EAAUE,OAAV,CAA/B;;EAEA,IACEjB,UAAU,CAACC,IAAXD,GAAkB,CAAlBA,IACAgB,aAAa,CAAC3F,MAAd2F,GAAuB,CADvBhB,IAEAkB,aAAa,CAAC7F,MAAd6F,GAAuB,CAHzB,EAIE;IACA,MAAM,IAAIC,KAAJ,CACH,+BAA8Bd,QAAS,uBAAvC,GACCZ,gBAAgB,CAAC,SAAD,EAAYuB,aAAZ,CADjB,GAECvB,gBAAgB,CAAC,SAAD,EAAYyB,aAAZ,CAFjB,GAGCnB,mBAAmB,CAACC,UAAD,CAJjB,CAAN;;;EAQF,OAAO;IAAEe,OAAF;IAAWE;EAAX,CAAP;AACD;;AAEM,SAASG,gCAAT,CACLC,OADK,EAELC,QAFK,EAGsB;EAC3B,MAAM;IAAEC,mBAAmB,GAAG;EAAxB,IAA+BF,OAArC;EACA,IAAIE,mBAAmB,KAAK,KAA5B,EAAmC,OAAO,KAAP;EAEnC,MAAMC,MAAM,GAAGF,QAAQ,CAACE,MAATF,CAAgBE,MAAM,IAAIA,MAAJ,QAAIA,GAAJ,MAAIA,SAAM,CAAEvH,IAAlCqH,CAAf;EAEA,MAAM;IACJG,GAAG,GAAG,UADF;IAEJC,MAAM,GAAGF,MAAM,KAAK,qBAAXA,GAAmC,OAAnCA,GAA6C,QAFlD;IAGJG,GAAG,GAAG;EAHF,IAIFJ,mBAJJ;EAMA,OAAO;IAAEE,GAAF;IAAOC,MAAP;IAAeC;EAAf,CAAP;AACD;;AC1FD,YACEC,YADa,IAEV;EACH,SAASC,QAAT,CAAkB5I,MAAlB,EAA0BC,GAA1B,EAA+B6B,SAA/B,EAA0CnB,IAA1C,EAAgD;IAC9C,OAAOgI,YAAY,CAAC;MAAEE,IAAI,EAAE,UAAR;MAAoB7I,MAApB;MAA4BC,GAA5B;MAAiC6B;IAAjC,CAAD,EAA+CnB,IAA/C,CAAnB;;;EAGF,OAAO;;IAELmI,oBAAoB,CAACnI,IAAD,EAA+B;MACjD,MAAM;QACJI,IAAI,EAAE;UAAEC;QAAF,CADF;QAEJH;MAFI,IAGFF,IAHJ;MAIA,IAAIE,KAAK,CAACkI,oBAANlI,CAA2BG,IAA3BH,CAAJ,EAAsC;MAEtC8H,YAAY,CAAC;QAAEE,IAAI,EAAE,QAAR;QAAkB7H;MAAlB,CAAD,EAA2BL,IAA3B,CAAZgI;IATG;;IAYLK,gBAAgB,CAACrI,IAAD,EAAqC;MACnD,MAAMV,GAAG,GAAGkB,UAAU,CAACR,IAAI,CAACc,GAALd,CAAS,UAATA,CAAD,EAAuBA,IAAI,CAACI,IAALJ,CAAUS,QAAjC,CAAtB;MACA,IAAI,CAACnB,GAAD,IAAQA,GAAG,KAAK,WAApB,EAAiC;MAEjC,MAAMD,MAAM,GAAGW,IAAI,CAACc,GAALd,CAAS,QAATA,CAAf;;MACA,IAAIX,MAAM,CAACY,YAAPZ,EAAJ,EAA2B;QACzB,MAAMiJ,OAAO,GAAGjJ,MAAM,CAACa,KAAPb,CAAakJ,UAAblJ,CAAwBA,MAAM,CAACe,IAAPf,CAAYgB,IAApChB,CAAhB;QACA,IAAIiJ,OAAO,IAAIA,OAAO,CAACtI,IAARsI,CAAaE,0BAAbF,EAAf,EAA0D;;;MAG5D,MAAM5G,MAAM,GAAGV,aAAa,CAAC3B,MAAD,CAA5B;MACA,OAAO4I,QAAQ,CAACvG,MAAM,CAACR,EAAR,EAAY5B,GAAZ,EAAiBoC,MAAM,CAACP,SAAxB,EAAmCnB,IAAnC,CAAf;IAvBG;;IA0BLyI,aAAa,CAACzI,IAAD,EAAkC;MAC7C,MAAM;QAAE0I,UAAF;QAAc9H;MAAd,IAAyBZ,IAA/B;MACA,IAAIiB,GAAJ,CAF6C;;MAK7C,IAAIyH,UAAU,CAACC,oBAAXD,EAAJ,EAAuC;QACrCzH,GAAG,GAAGyH,UAAU,CAAC5H,GAAX4H,CAAe,MAAfA,CAANzH,CADqC;MAAvC,OAGO,IAAIyH,UAAU,CAACE,sBAAXF,EAAJ,EAAyC;QAC9CzH,GAAG,GAAGyH,UAAU,CAAC5H,GAAX4H,CAAe,OAAfA,CAANzH,CAD8C;;MAAzC,OAIA,IAAIyH,UAAU,CAACpH,UAAXoH,EAAJ,EAA6B;QAClC,MAAMG,KAAK,GAAGH,UAAU,CAACA,UAAzB;;QACA,IAAIG,KAAK,CAAC/G,gBAAN+G,MAA4BA,KAAK,CAACC,eAAND,EAAhC,EAAyD;UACvD,IAAIA,KAAK,CAACzI,IAANyI,CAAW9G,MAAX8G,KAAsBjI,MAA1B,EAAkC;YAChCK,GAAG,GAAG4H,KAAK,CAAC/H,GAAN+H,CAAU,WAAVA,EAAuB7I,IAAI,CAACV,GAA5BuJ,CAAN5H;;;;;MAKN,IAAIC,EAAE,GAAG,IAAT;MACA,IAAIC,SAAS,GAAG,IAAhB;MACA,IAAIF,GAAJ,EAAS,CAAC;QAAEC,EAAF;QAAMC;MAAN,IAAoBH,aAAa,CAACC,GAAD,CAAlC;;MAET,KAAK,MAAM8H,IAAX,IAAmB/I,IAAI,CAACc,GAALd,CAAS,YAATA,CAAnB,EAA2C;QACzC,IAAI+I,IAAI,CAACC,gBAALD,EAAJ,EAA6B;UAC3B,MAAMzJ,GAAG,GAAGkB,UAAU,CAACuI,IAAI,CAACjI,GAALiI,CAAS,KAATA,CAAD,CAAtB;UACA,IAAIzJ,GAAJ,EAAS2I,QAAQ,CAAC/G,EAAD,EAAK5B,GAAL,EAAU6B,SAAV,EAAqB4H,IAArB,CAARd;;;IAtDV;;IA2DLgB,gBAAgB,CAACjJ,IAAD,EAAqC;MACnD,IAAIA,IAAI,CAACI,IAALJ,CAAUkJ,QAAVlJ,KAAuB,IAA3B,EAAiC;MAEjC,MAAM0B,MAAM,GAAGV,aAAa,CAAChB,IAAI,CAACc,GAALd,CAAS,OAATA,CAAD,CAA5B;MACA,MAAMV,GAAG,GAAGkB,UAAU,CAACR,IAAI,CAACc,GAALd,CAAS,MAATA,CAAD,EAAmB,IAAnB,CAAtB;MAEA,IAAI,CAACV,GAAL,EAAU;MAEV0I,YAAY,CACV;QACEE,IAAI,EAAE,IADR;QAEE7I,MAAM,EAAEqC,MAAM,CAACR,EAFjB;QAGE5B,GAHF;QAIE6B,SAAS,EAAEO,MAAM,CAACP;MAJpB,CADU,EAOVnB,IAPU,CAAZgI;;;EAnEG,CAAP;AAPF;;ACAA,YACEA,YADa,KAET;EACJmB,iBAAiB,CAACnJ,IAAD,EAAsC;IACrD,MAAM0B,MAAM,GAAGH,eAAe,CAACvB,IAAD,CAA9B;IACA,IAAI,CAAC0B,MAAL,EAAa;IACbsG,YAAY,CAAC;MAAEE,IAAI,EAAE,QAAR;MAAkBxG;IAAlB,CAAD,EAA6B1B,IAA7B,CAAZgI;EAJE;;EAMJoB,OAAO,CAACpJ,IAAD,EAA4B;IACjCA,IAAI,CAACc,GAALd,CAAS,MAATA,EAAiBf,OAAjBe,CAAyBqJ,QAAQ,IAAI;MACnC,MAAM3H,MAAM,GAAGC,gBAAgB,CAAC0H,QAAD,CAA/B;MACA,IAAI,CAAC3H,MAAL,EAAa;MACbsG,YAAY,CAAC;QAAEE,IAAI,EAAE,QAAR;QAAkBxG;MAAlB,CAAD,EAA6B2H,QAA7B,CAAZrB;IAHF;;;AAPE,CAFS,CAAf;;ACFA,MAAMsB,oBAAoB,GAAGC,UAAU,CAACC,OAAO,CAACC,QAARD,CAAiBpJ,IAAlB,CAAVmJ,IAAqC,GAAlE;;AAGA,MAAMG,OAAO,GAAGC,aAAa,CAACC;AAAO;AAAPA,CAAiBC,IAAjBD,CAAsBlH,GAAvB,CAA7B,C,CAAA;;;AAEA,SAASoH,SAAT,CAAmBzJ,IAAnB,EAAiC0J,OAAjC,EAAkD;EAChD,IAAIT,oBAAJ,EAA0B;IACxB,OAAOI,OAAO,CACXM,OADIN,CACIrJ,IADJqJ,EACU;MACbO,KAAK,EAAE,CAACF,OAAD;IADM,CADVL,EAIJQ,OAJIR,CAII,KAJJA,EAIW,GAJXA,CAAP;EADF,OAMO;IACL,OAAOS,cAAc,CAACC,IAAfD,CAAoB9J,IAApB8J,EAA0B;MAAEJ;IAAF,CAA1BI,EAAuCD,OAAvCC,CAA+C,KAA/CA,EAAsD,GAAtDA,CAAP;;AAEH;;AAEM,SAASH,OAAT,CACLK,OADK,EAELC,UAFK,EAGLC,eAHK,EAIG;EACR,IAAIA,eAAe,KAAK,KAAxB,EAA+B,OAAOD,UAAP;EAE/B,IAAIP,OAAO,GAAGM,OAAd;;EACA,IAAI,OAAOE,eAAP,KAA2B,QAA/B,EAAyC;IACvCR,OAAO,GAAG/J,IAAI,CAACgK,OAALhK,CAAa+J,OAAb/J,EAAsBuK,eAAtBvK,CAAV+J;;;EAGF,IAAI;IACF,OAAOD,SAAS,CAACQ,UAAD,EAAaP,OAAb,CAAhB;EADF,EAEE,OAAOS,GAAP,EAAY;IACZ,IAAIA,GAAG,CAACC,IAAJD,KAAa,kBAAjB,EAAqC,MAAMA,GAAN;IAErC,MAAMjL,MAAM,CAACmL,MAAPnL,CACJ,IAAIgI,KAAJ,CAAW,sBAAqB+C,UAAW,kBAAiBD,OAAQ,GAApE,CADI9K,EAEJ;MACEkL,IAAI,EAAE,0BADR;MAEExD,QAAQ,EAAEqD,UAFZ;MAGED;IAHF,CAFI9K,CAAN;;AASH;;AAEM,SAASJ,GAAT,CAAa4K,OAAb,EAA8B1J,IAA9B,EAA4C;EACjD,IAAI;IACFyJ,SAAS,CAACzJ,IAAD,EAAO0J,OAAP,CAATD;IACA,OAAO,IAAP;EAFF,EAGE,MAAM;IACN,OAAO,KAAP;;AAEH;;AAEM,SAASa,UAAT,CAAoBC,WAApB,EAA8C;EACnD,IAAIA,WAAW,CAACvE,IAAZuE,KAAqB,CAAzB,EAA4B;EAE5B,MAAMC,IAAI,GAAGvE,KAAK,CAACC,IAAND,CAAWsE,WAAXtE,EAAwBwE,IAAxBxE,GAA+BJ,IAA/BI,CAAoC,GAApCA,CAAb;EAEAyE,OAAO,CAACC,IAARD,CACE,iFACE,6CADF,GAEG,wBAAuBF,IAAK,IAF/B,GAGG,cAAaA,IAAK,IAJvBE;EAOAvB,OAAO,CAACyB,QAARzB,GAAmB,CAAnBA;AACD;;AAED,IAAI0B,cAAc,GAAG,IAAIlM,GAAJ,EAArB;AAEA,MAAMmM,2BAA2B,GAAGC,QAAQ,CAAC,MAAM;EACjDT,UAAU,CAACO,cAAD,CAAVP;EACAO,cAAc,GAAG,IAAIlM,GAAJ,EAAjBkM;AAF0C,GAGzC,GAHyC,CAA5C;;AAKO,SAASG,eAAT,CAAyBT,WAAzB,EAAmD;EACxD,IAAIA,WAAW,CAACvE,IAAZuE,KAAqB,CAAzB,EAA4B;EAE5BA,WAAW,CAAC3L,OAAZ2L,CAAoBvK,IAAI,IAAI6K,cAAc,CAAC9L,GAAf8L,CAAmB7K,IAAnB6K,CAA5BN;EACAO,2BAA2B;AAC5B;;AC3ED,MAAMG,qBAAqB,GAAG,IAAItM,GAAJ,CAAgB,CAC5C,QAD4C,EAE5C,YAF4C,EAG5C,MAH4C,EAI5C,QAJ4C,CAAhB,CAA9B;;AAOe,SAASuM,kBAAT,CACb7E,SADa,EAEE;EACf,MAAM;IAAE8E,MAAM,EAAEC,OAAV;IAAmBC,QAAQ,EAAEC,SAA7B;IAAwCC,MAAM,EAAEC;EAAhD,IAA4DnF,SAAlE;EAEA,OAAOmD,IAAI,IAAI;IACb,IAAIA,IAAI,CAAC3B,IAAL2B,KAAc,QAAdA,IAA0BgC,OAA1BhC,IAAqC1K,KAAG,CAAC0M,OAAD,EAAUhC,IAAI,CAACxJ,IAAf,CAA5C,EAAkE;MAChE,OAAO;QAAE6H,IAAI,EAAE,QAAR;QAAkB4D,IAAI,EAAED,OAAO,CAAChC,IAAI,CAACxJ,IAAN,CAA/B;QAA4CA,IAAI,EAAEwJ,IAAI,CAACxJ;MAAvD,CAAP;;;IAGF,IAAIwJ,IAAI,CAAC3B,IAAL2B,KAAc,UAAdA,IAA4BA,IAAI,CAAC3B,IAAL2B,KAAc,IAA9C,EAAoD;MAClD,MAAM;QAAE1I,SAAF;QAAa9B,MAAb;QAAqBC;MAArB,IAA6BuK,IAAnC;;MAEA,IAAIxK,MAAM,IAAI8B,SAAS,KAAK,QAA5B,EAAsC;QACpC,IAAI0K,OAAO,IAAIP,qBAAqB,CAACnM,GAAtBmM,CAA0BjM,MAA1BiM,CAAXO,IAAgD1M,KAAG,CAAC0M,OAAD,EAAUvM,GAAV,CAAvD,EAAuE;UACrE,OAAO;YAAE4I,IAAI,EAAE,QAAR;YAAkB4D,IAAI,EAAED,OAAO,CAACvM,GAAD,CAA/B;YAAsCe,IAAI,EAAEf;UAA5C,CAAP;;;QAGF,IAAImM,OAAO,IAAItM,KAAG,CAACsM,OAAD,EAAUpM,MAAV,CAAdoM,IAAmCtM,KAAG,CAACsM,OAAO,CAACpM,MAAD,CAAR,EAAkBC,GAAlB,CAA1C,EAAkE;UAChE,OAAO;YACL4I,IAAI,EAAE,QADD;YAEL4D,IAAI,EAAEL,OAAO,CAACpM,MAAD,CAAPoM,CAAgBnM,GAAhBmM,CAFD;YAGLpL,IAAI,EAAG,GAAEhB,MAAO,IAAGC,GAAI;UAHlB,CAAP;;;;MAQJ,IAAIqM,SAAS,IAAIxM,KAAG,CAACwM,SAAD,EAAYrM,GAAZ,CAApB,EAAsC;QACpC,OAAO;UAAE4I,IAAI,EAAE,UAAR;UAAoB4D,IAAI,EAAEH,SAAS,CAACrM,GAAD,CAAnC;UAA0Ce,IAAI,EAAG,GAAEf,GAAI;QAAvD,CAAP;;;EAvBN;AA2BD;;AC1CD,MAAMyM,UAAU,GAAGC,WAAW,CAACC,OAAZD,IAAuBA,WAA1C;;AA8BA,SAASE,cAAT,CACEzE,OADF,EAEEC,QAFF,EAaE;EACA,MAAM;IACJyE,MADI;IAEJ7G,OAAO,EAAE8G,aAFL;IAGJC,wBAHI;IAIJC,UAJI;IAKJC,KALI;IAMJC,oBANI;IAOJjC,eAPI;IAQJ,GAAGkC;EARC,IASFhF,OATJ;;EAWA,IAAIiF,OAAO,CAACjF,OAAD,CAAX,EAAsB;IACpB,MAAM,IAAIF,KAAJ,CACH;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFATU,CAAN;;;EAaF,IAAIoF,UAAJ;EACA,IAAIR,MAAM,KAAK,cAAf,EAA+BQ,UAAU,GAAG,aAAbA,CAA/B,KACK,IAAIR,MAAM,KAAK,cAAf,EAA+BQ,UAAU,GAAG,aAAbA,CAA/B,KACA,IAAIR,MAAM,KAAK,YAAf,EAA6BQ,UAAU,GAAG,WAAbA,CAA7B,KACA,IAAI,OAAOR,MAAP,KAAkB,QAAtB,EAAgC;IACnC,MAAM,IAAI5E,KAAJ,CAAU,0BAAV,CAAN;EADG,OAEE;IACL,MAAM,IAAIA,KAAJ,CACH,0DACE,8BAA6BhC,IAAI,CAACC,SAALD,CAAe4G,MAAf5G,CAAuB,GAFnD,CAAN;;;EAMF,IAAI,OAAOiH,oBAAP,KAAgC,UAApC,EAAgD;IAC9C,IAAI/E,OAAO,CAACN,OAARM,IAAmBA,OAAO,CAACJ,OAA/B,EAAwC;MACtC,MAAM,IAAIE,KAAJ,CACH,2DACE,kCAFC,CAAN;;EAFJ,OAOO,IAAIiF,oBAAoB,IAAI,IAA5B,EAAkC;IACvC,MAAM,IAAIjF,KAAJ,CACH,2DACE,cAAahC,IAAI,CAACC,SAALD,CAAeiH,oBAAfjH,CAAqC,GAFjD,CAAN;;;EAMF,IACEgF,eAAe,IAAI,IAAnBA,IACA,OAAOA,eAAP,KAA2B,SAD3BA,IAEA,OAAOA,eAAP,KAA2B,QAH7B,EAIE;IACA,MAAM,IAAIhD,KAAJ,CACH,+DACE,cAAahC,IAAI,CAACC,SAALD,CAAegF,eAAfhF,CAAgC,GAF5C,CAAN;;;EAMF,IAAID,OAAJ;;EAEA;;EAGE8G,aAAa,IACbE,UADAF,IAEAC,wBALF,EAME;IACA,MAAMO,UAAU,GACd,OAAOR,aAAP,KAAyB,QAAzB,IAAqC9F,KAAK,CAACuG,OAANvG,CAAc8F,aAAd9F,CAArC,GACI;MAAEwG,QAAQ,EAAEV;IAAZ,CADJ,GAEIA,aAHN;IAKA9G,OAAO,GAAGyG,UAAU,CAACa,UAAD,EAAa;MAC/BP,wBAD+B;MAE/BC;IAF+B,CAAb,CAApBhH;EAZF,OAgBO;IACLA,OAAO,GAAGoC,QAAQ,CAACpC,OAAToC,EAAVpC;;;EAGF,OAAO;IACL6G,MADK;IAELQ,UAFK;IAGLrH,OAHK;IAILiF,eAAe,EAAEA,eAAF,QAAEA,qBAAmB,KAJ/B;IAKLiC,oBALK;IAMLD,KAAK,EAAE,CAAC,CAACA,KANJ;IAOLE,eAAe,EAAEA;EAPZ,CAAP;AASD;;AAED,SAASM,mBAAT,CACEC,OADF,EAEEvF,OAFF,EAGEE,mBAHF,EAIE0C,OAJF,EAKE4C,QALF,EAMEvF,QANF,EAOE;EACA,MAAM;IACJyE,MADI;IAEJQ,UAFI;IAGJrH,OAHI;IAIJiH,KAJI;IAKJC,oBALI;IAMJC,eANI;IAOJlC;EAPI,IAQF2B,cAAc,CAAUzE,OAAV,EAAmBC,QAAnB,CARlB;EAUA,MAAMwF,QAAQ,GAAG/K,iBAAiB,CAChC,IAAIoB,YAAJ,CAAiB+G,UAAU,IACzBO,QAAaR,OAAb,EAAsBC,UAAtB,EAAkCC,eAAlC,CADF,CADgC,CAAlC,CAXA;;EAkBA,IAAIpD,OAAJ,EAAaE,OAAb;EACA,IAAI8F,gBAAJ;EACA,IAAIC,cAAJ;EACA,IAAIC,eAAJ;EAEA,MAAMC,SAAS,GAAG,IAAI/I,GAAJ,EAAlB;EAEA,MAAMgJ,GAAgB,GAAG;IACvBC,KAAK,EAAE9F,QADgB;IAEvBwF,QAFuB;IAGvBf,MAAM,EAAE1E,OAAO,CAAC0E,MAHO;IAIvB7G,OAJuB;IAKvBiG,kBALuB;;IAMvBiB,oBAAoB,CAACnM,IAAD,EAAO;MACzB,IAAI+M,cAAc,KAAKhM,SAAvB,EAAkC;QAChC,MAAM,IAAImG,KAAJ,CACH,yBAAwByF,OAAO,CAAC3M,IAAK,aAArC,GACE,+DAFC,CAAN;;;MAKF,IAAI,CAAC+M,cAAc,CAACjO,GAAfiO,CAAmB/M,IAAnB+M,CAAL,EAA+B;QAC7BrC,OAAO,CAACC,IAARD,CACG,yBAAwBtE,QAAQ,CAACpG,IAAK,aAAtC,GACE,qBAAoBA,IAAK,IAF9B0K;;;MAMF,IAAIsC,eAAe,IAAI,CAACA,eAAe,CAAChN,IAAD,CAAvC,EAA+C,OAAO,KAAP;MAE/C,IAAIoN,YAAY,GAAGC,UAAU,CAACrN,IAAD,EAAOiF,OAAP,EAAgB;QAC3CqI,UAAU,EAAER,gBAD+B;QAE3CS,QAAQ,EAAEzG,OAFiC;QAG3C0G,QAAQ,EAAExG;MAHiC,CAAhB,CAA7B;;MAMA,IAAImF,oBAAJ,EAA0B;QACxBiB,YAAY,GAAGjB,oBAAoB,CAACnM,IAAD,EAAOoN,YAAP,CAAnCA;;QACA,IAAI,OAAOA,YAAP,KAAwB,SAA5B,EAAuC;UACrC,MAAM,IAAIlG,KAAJ,CAAW,8CAAX,CAAN;;;;MAIJ,OAAOkG,YAAP;IAnCqB;;IAqCvBlB,KAAK,CAAClM,IAAD,EAAO;MAAA;;MACV4M,QAAQ,GAAGa,KAAXb,GAAmB,IAAnBA;MAEA,IAAI,CAACV,KAAD,IAAU,CAAClM,IAAf,EAAqB;MAErB,IAAI4M,QAAQ,GAAGvG,SAAXuG,CAAqB9N,GAArB8N,CAAyBxG,QAAQ,CAACpG,IAAlC4M,CAAJ,EAA6C;MAC7CA,QAAQ,GAAGvG,SAAXuG,CAAqB7N,GAArB6N,CAAyB5M,IAAzB4M;MACA,8CAAQ,EAAR,EAAWE,gBAAX,8CAAWA,gBAAX,GAAgCA,gBAAhC;IA5CqB;;IA8CvBY,gBAAgB,CAAC1N,IAAD,EAAsB;MAAA,IAAf2N,OAAe,uEAAL,GAAK;MACpC,IAAIrG,mBAAmB,KAAK,KAA5B,EAAmC;;MACnC,IAAI4C,eAAJ,EAAqB;;;;QAInB;;;MAGF,MAAM0D,GAAG,GAAGD,OAAO,KAAK,GAAZA,GAAkB3N,IAAlB2N,GAA0B,GAAE3N,IAAK,KAAI2N,OAAQ,EAAzD;MAEA,MAAMF,KAAK,GAAGnG,mBAAmB,CAACI,GAApBJ,GACV,KADUA,GAEVuG,QAAQ,CAACZ,SAAD,EAAa,GAAEjN,IAAK,OAAMgK,OAAQ,EAAlC,EAAqC,MAC3CQ,IAASR,OAAT,EAAkBhK,IAAlB,CADM,CAFZ;;MAMA,IAAI,CAACyN,KAAL,EAAY;QACVb,QAAQ,GAAGrC,WAAXqC,CAAuB7N,GAAvB6N,CAA2BgB,GAA3BhB;;;;EAhEmB,CAAzB;EAqEA,MAAMxG,QAAQ,GAAGuG,OAAO,CAACO,GAAD,EAAMd,eAAN,EAAuBpC,OAAvB,CAAxB;;EAEA,IAAI,OAAO5D,QAAQ,CAACkG,UAAD,CAAf,KAAgC,UAApC,EAAgD;IAC9C,MAAM,IAAIpF,KAAJ,CACH,QAAOd,QAAQ,CAACpG,IAAToG,IAAiBuG,OAAO,CAAC3M,IAAK,qBAArC,GACE,gBAAe8L,MAAO,uBAFrB,CAAN;;;EAMF,IAAI7F,KAAK,CAACuG,OAANvG,CAAcG,QAAQ,CAACC,SAAvBJ,CAAJ,EAAuC;IACrC8G,cAAc,GAAG,IAAIpO,GAAJ,CAAQyH,QAAQ,CAACC,SAAjB,CAAjB0G;IACAC,eAAe,GAAG5G,QAAQ,CAAC4G,eAA3BA;EAFF,OAGO,IAAI5G,QAAQ,CAACC,SAAb,EAAwB;IAC7B0G,cAAc,GAAG,IAAIpO,GAAJ,CAAQO,MAAM,CAAC4O,IAAP5O,CAAYkH,QAAQ,CAACC,SAArBnH,CAAR,CAAjB6N;IACAD,gBAAgB,GAAG1G,QAAQ,CAACC,SAA5ByG;IACAE,eAAe,GAAG5G,QAAQ,CAAC4G,eAA3BA;EAHK,OAIA;IACLD,cAAc,GAAG,IAAIpO,GAAJ,EAAjBoO;;;EAGF,CAAC;IAAEjG,OAAF;IAAWE;EAAX,IAAuBb,sBAAsB,CAC5CC,QAAQ,CAACpG,IAAToG,IAAiBuG,OAAO,CAAC3M,IADmB,EAE5C+M,cAF4C,EAG5CX,eAAe,CAACtF,OAAhBsF,IAA2B,EAHiB,EAI5CA,eAAe,CAACpF,OAAhBoF,IAA2B,EAJiB,CAA9C;EAOA,OAAO;IACLF,KADK;IAELJ,MAFK;IAGL7G,OAHK;IAILmB,QAJK;;IAKLuB,YAAY,CAACoG,OAAD,EAA0BpO,IAA1B,EAA0C;MACpD,MAAMqO,KAAK,GAAGnB,QAAQ,CAAClN,IAAD,CAAtB;MACAyG,QAAQ,CAACkG,UAAD,CAARlG,CAAqB2H,OAArB3H,EAA8B4H,KAA9B5H,EAAqCzG,IAArCyG;;;EAPG,CAAP;AAUD;;AAEc,SAAS6H,sBAAT,CACbtB,OADa,EAEb;EACA,OAAOuB,OAAO,CAAC,CAAC7G,QAAD,EAAWD,OAAX,EAAmC4C,OAAnC,KAAuD;IACpE3C,QAAQ,CAAC8G,aAAT9G,CAAuB,CAAvBA;IACA,MAAM;MAAE+G;IAAF,IAAe/G,QAArB;IAEA,IAAIuF,QAAJ;IAEA,MAAMtF,mBAAmB,GAAGH,gCAAgC,CAC1DC,OAD0D,EAE1DC,QAF0D,CAA5D;IAKA,MAAM;MAAE6E,KAAF;MAASJ,MAAT;MAAiB7G,OAAjB;MAA0BmB,QAA1B;MAAoCuB;IAApC,IACJ+E,mBAAmB,CACjBC,OADiB,EAEjBvF,OAFiB,EAGjBE,mBAHiB,EAIjB0C,OAJiB,EAKjB,MAAM4C,QALW,EAMjBvF,QANiB,CADrB;IAUA,MAAMgH,aAAa,GAAGvC,MAAM,KAAK,cAAXA,GAA4BjN,KAA5BiN,GAAsCjN,KAA5D;IAEA,MAAMyP,OAAO,GAAGlI,QAAQ,CAACkI,OAATlI,GACZgI,QAAQ,CAACG,QAATH,CAAkBI,KAAlBJ,CAAwB,CAACC,aAAa,CAAC1G,YAAD,CAAd,EAA8BvB,QAAQ,CAACkI,OAAvC,CAAxBF,CADYhI,GAEZiI,aAAa,CAAC1G,YAAD,CAFjB;;IAIA,IAAIuE,KAAK,IAAIA,KAAK,KAAKnH,0BAAvB,EAAmD;MACjD2F,OAAO,CAAClD,GAARkD,CAAa,GAAEtE,QAAQ,CAACpG,IAAK,oBAA7B0K;MACAA,OAAO,CAAClD,GAARkD,CAAa,oBAAmB1F,yBAAyB,CAACC,OAAD,CAAU,EAAnEyF;MACAA,OAAO,CAAClD,GAARkD,CAAa,4BAA2BoB,MAAO,YAA/CpB;;;IAGF,OAAO;MACL1K,IAAI,EAAE,kBADD;MAELsO,OAFK;;MAILG,GAAG,GAAG;QAAA;;QACJ7B,QAAQ,GAAG;UACTvG,SAAS,EAAE,IAAI1H,GAAJ,EADF;UAETmO,gBAAgB,EAAE/L,SAFT;UAGT0M,KAAK,EAAE,KAHE;UAITiB,SAAS,EAAE,IAAI/P,GAAJ,EAJF;UAKT4L,WAAW,EAAE,IAAI5L,GAAJ;QALJ,CAAXiO;QAQA,yBAAQ,CAAC6B,GAAT,mCAAcE,KAAd,CAAoB,IAApB,EAA0BhN,SAA1B;MAbG;;MAeLiN,IAAI,GAAG;QAAA;;QACL,0BAAQ,CAACA,IAAT,oCAAeD,KAAf,CAAqB,IAArB,EAA2BhN,SAA3B;;QAEA,IAAI2F,mBAAmB,KAAK,KAA5B,EAAmC;UACjC,IAAIA,mBAAmB,CAACE,GAApBF,KAA4B,UAAhC,EAA4C;YAC1CkD,WAAgBoC,QAAQ,CAACrC,WAAzB;UADF,OAEO;YACLC,gBAAqBoC,QAAQ,CAACrC,WAA9B;;;;QAIJ,IAAI,CAAC2B,KAAL,EAAY;QAEZ,IAAI,KAAK2C,QAAT,EAAmBnE,OAAO,CAAClD,GAARkD,CAAa,MAAK,KAAKmE,QAAS,GAAhCnE;;QAEnB,IAAIkC,QAAQ,CAACvG,SAATuG,CAAmB5G,IAAnB4G,KAA4B,CAAhC,EAAmC;UACjClC,OAAO,CAAClD,GAARkD,CACEoB,MAAM,KAAK,cAAXA,GACIc,QAAQ,CAACa,KAATb,GACG,8BAA6BxG,QAAQ,CAACpG,IAAK,qCAD9C4M,GAEG,2BAA0BxG,QAAQ,CAACpG,IAAK,+BAH/C8L,GAIK,uCAAsC1F,QAAQ,CAACpG,IAAK,qCAL3D0K;UAQA;;;QAGF,IAAIoB,MAAM,KAAK,cAAf,EAA+B;UAC7BpB,OAAO,CAAClD,GAARkD,CACG,OAAMtE,QAAQ,CAACpG,IAAK,yCAApB,GACE,0BAFL0K;QADF,OAKO;UACLA,OAAO,CAAClD,GAARkD,CACG,OAAMtE,QAAQ,CAACpG,IAAK,0CADvB0K;;;QAKF,KAAK,MAAM1K,IAAX,IAAmB4M,QAAQ,CAACvG,SAA5B,EAAuC;UAAA;;UACrC,8BAAIuG,QAAQ,CAACE,gBAAb,aAAIgC,uBAA4B9O,IAA5B,CAAJ,EAAuC;YACrC,MAAM+O,eAAe,GAAGC,mBAAmB,CACzChP,IADyC,EAEzCiF,OAFyC,EAGzC2H,QAAQ,CAACE,gBAHgC,CAA3C;YAMA,MAAMmC,gBAAgB,GAAG/J,IAAI,CAACC,SAALD,CAAe6J,eAAf7J,EACtB2E,OADsB3E,CACd,IADcA,EACR,IADQA,EAEtB2E,OAFsB3E,CAEd,MAFcA,EAEN,KAFMA,EAGtB2E,OAHsB3E,CAGd,MAHcA,EAGN,KAHMA,CAAzB;YAKAwF,OAAO,CAAClD,GAARkD,CAAa,KAAI1K,IAAK,IAAGiP,gBAAiB,EAA1CvE;UAZF,OAaO;YACLA,OAAO,CAAClD,GAARkD,CAAa,KAAI1K,IAAK,EAAtB0K;;;;;IApED,CAAP;EAjCY,EAAd;AA2GD;;AAED,SAASmD,QAAT,CAAkBjJ,GAAlB,EAAuB3F,GAAvB,EAA4BiQ,UAA5B,EAAwC;EACtC,IAAIC,GAAG,GAAGvK,GAAG,CAACnE,GAAJmE,CAAQ3F,GAAR2F,CAAV;;EACA,IAAIuK,GAAG,KAAKpO,SAAZ,EAAuB;IACrBoO,GAAG,GAAGD,UAAU,EAAhBC;IACAvK,GAAG,CAACR,GAAJQ,CAAQ3F,GAAR2F,EAAauK,GAAbvK;;;EAEF,OAAOuK,GAAP;AACD;;AAED,SAAS9C,OAAT,CAAiBzL,GAAjB,EAAsB;EACpB,OAAO1B,MAAM,CAAC4O,IAAP5O,CAAY0B,GAAZ1B,EAAiBkC,MAAjBlC,KAA4B,CAAnC;AACD","names":["types","t","template","intersection","a","b","result","Set","forEach","v","has","add","object","key","Object","prototype","hasOwnProperty","call","getType","target","toString","slice","resolveId","path","isIdentifier","scope","hasBinding","node","name","deopt","evaluate","resolveKey","computed","isStringLiteral","value","parent","isMemberExpression","get","sym","resolveSource","obj","id","placement","undefined","isRegExpLiteral","isFunction","getImportSource","specifiers","length","source","getRequireSource","isExpressionStatement","expression","isCallExpression","callee","arguments","hoist","_blockHoist","createUtilsGetter","cache","prog","findParent","p","isProgram","injectGlobalImport","url","storeAnonymous","isScript","statement","ast","importDeclaration","injectNamedImport","hint","storeNamed","generateUidIdentifier","importSpecifier","injectDefaultImport","importDefaultSpecifier","ImportsCache","constructor","resolver","_imports","WeakMap","_anonymousImports","_lastImports","_resolver","programPath","getVal","_normalizeKey","imports","_ensure","sourceType","stringLiteral","_injectImport","Map","identifier","set","lastImport","newNodes","container","body","insertAfter","unshiftContainer","newNode","map","Collection","collection","presetEnvSilentDebugHeader","stringifyTargetsMultiline","targets","JSON","stringify","prettifyTargets","patternToRegExp","pattern","RegExp","buildUnusedError","label","unused","original","String","join","buldDuplicatesError","duplicates","size","Array","from","validateIncludeExclude","provider","polyfills","includePatterns","excludePatterns","current","filter","regexp","matched","polyfill","test","include","unusedInclude","exclude","unusedExclude","Error","applyMissingDependenciesDefaults","options","babelApi","missingDependencies","caller","log","inject","all","callProvider","property","kind","ReferencedIdentifier","getBindingIdentifier","MemberExpression","binding","getBinding","isImportNamespaceSpecifier","ObjectPattern","parentPath","isVariableDeclarator","isAssignmentExpression","grand","isNewExpression","prop","isObjectProperty","BinaryExpression","operator","ImportDeclaration","Program","bodyPath","nativeRequireResolve","parseFloat","process","versions","require","createRequire","import","meta","myResolve","basedir","resolve","paths","replace","requireResolve","sync","dirname","moduleName","absoluteImports","err","code","assign","logMissing","missingDeps","deps","sort","console","warn","exitCode","allMissingDeps","laterLogMissingDependencies","debounce","laterLogMissing","PossibleGlobalObjects","createMetaResolver","static","staticP","instance","instanceP","global","globalP","desc","getTargets","_getTargets","default","resolveOptions","method","targetsOption","ignoreBrowserslistConfig","configPath","debug","shouldInjectPolyfill","providerOptions","isEmpty","methodName","targetsObj","isArray","browsers","instantiateProvider","factory","debugLog","getUtils","polyfillsSupport","polyfillsNames","filterPolyfills","depsCache","api","babel","shouldInject","isRequired","compatData","includes","excludes","found","assertDependency","version","dep","mapGetOr","keys","payload","utils","definePolyfillProvider","declare","assertVersion","traverse","createVisitor","visitor","visitors","merge","pre","providers","apply","post","filename","_debugLog$polyfillsSu2","filteredTargets","getInclusionReasons","formattedTargets","getDefault","val"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-define-polyfill-provider\\src\\utils.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-define-polyfill-provider\\src\\imports-cache.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-define-polyfill-provider\\src\\debug-utils.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-define-polyfill-provider\\src\\normalize-options.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-define-polyfill-provider\\src\\visitors\\usage.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-define-polyfill-provider\\src\\visitors\\entry.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-define-polyfill-provider\\src\\node\\dependencies.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-define-polyfill-provider\\src\\meta-resolver.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-define-polyfill-provider\\src\\index.ts"],"sourcesContent":["import { types as t, template } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport type { Utils } from \"./types\";\nimport type ImportsCache from \"./imports-cache\";\n\nexport function intersection<T>(a: Set<T>, b: Set<T>): Set<T> {\n  const result = new Set<T>();\n  a.forEach(v => b.has(v) && result.add(v));\n  return result;\n}\n\nexport function has(object: any, key: string) {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}\n\nfunction getType(target: any): string {\n  return Object.prototype.toString.call(target).slice(8, -1);\n}\n\nfunction resolveId(path): string {\n  if (\n    path.isIdentifier() &&\n    !path.scope.hasBinding(path.node.name, /* noGlobals */ true)\n  ) {\n    return path.node.name;\n  }\n\n  const { deopt } = path.evaluate();\n  if (deopt && deopt.isIdentifier()) {\n    return deopt.node.name;\n  }\n}\n\nexport function resolveKey(\n  path: NodePath<t.Expression | t.PrivateName>,\n  computed: boolean = false,\n) {\n  const { scope } = path;\n  if (path.isStringLiteral()) return path.node.value;\n  const isIdentifier = path.isIdentifier();\n  if (\n    isIdentifier &&\n    !(computed || (path.parent as t.MemberExpression).computed)\n  ) {\n    return path.node.name;\n  }\n\n  if (\n    computed &&\n    path.isMemberExpression() &&\n    path.get(\"object\").isIdentifier({ name: \"Symbol\" }) &&\n    !scope.hasBinding(\"Symbol\", /* noGlobals */ true)\n  ) {\n    const sym = resolveKey(path.get(\"property\"), path.node.computed);\n    if (sym) return \"Symbol.\" + sym;\n  }\n\n  if (!isIdentifier || scope.hasBinding(path.node.name, /* noGlobals */ true)) {\n    const { value } = path.evaluate();\n    if (typeof value === \"string\") return value;\n  }\n}\n\nexport function resolveSource(obj: NodePath): {\n  id: string | null;\n  placement: \"prototype\" | \"static\" | null;\n} {\n  if (\n    obj.isMemberExpression() &&\n    obj.get(\"property\").isIdentifier({ name: \"prototype\" })\n  ) {\n    const id = resolveId(obj.get(\"object\"));\n\n    if (id) {\n      return { id, placement: \"prototype\" };\n    }\n    return { id: null, placement: null };\n  }\n\n  const id = resolveId(obj);\n  if (id) {\n    return { id, placement: \"static\" };\n  }\n\n  const { value } = obj.evaluate();\n  if (value !== undefined) {\n    return { id: getType(value), placement: \"prototype\" };\n  } else if (obj.isRegExpLiteral()) {\n    return { id: \"RegExp\", placement: \"prototype\" };\n  } else if (obj.isFunction()) {\n    return { id: \"Function\", placement: \"prototype\" };\n  }\n\n  return { id: null, placement: null };\n}\n\nexport function getImportSource({ node }: NodePath<t.ImportDeclaration>) {\n  if (node.specifiers.length === 0) return node.source.value;\n}\n\nexport function getRequireSource({ node }: NodePath<t.Statement>) {\n  if (!t.isExpressionStatement(node)) return;\n  const { expression } = node;\n  if (\n    t.isCallExpression(expression) &&\n    t.isIdentifier(expression.callee) &&\n    expression.callee.name === \"require\" &&\n    expression.arguments.length === 1 &&\n    t.isStringLiteral(expression.arguments[0])\n  ) {\n    return expression.arguments[0].value;\n  }\n}\n\nfunction hoist(node: t.Node) {\n  // @ts-expect-error\n  node._blockHoist = 3;\n  return node;\n}\n\nexport function createUtilsGetter(cache: ImportsCache) {\n  return (path: NodePath): Utils => {\n    const prog = path.findParent(p => p.isProgram()) as NodePath<t.Program>;\n\n    return {\n      injectGlobalImport(url) {\n        cache.storeAnonymous(prog, url, (isScript, source) => {\n          return isScript\n            ? template.statement.ast`require(${source})`\n            : t.importDeclaration([], source);\n        });\n      },\n      injectNamedImport(url, name, hint = name) {\n        return cache.storeNamed(prog, url, name, (isScript, source, name) => {\n          const id = prog.scope.generateUidIdentifier(hint);\n          return {\n            node: isScript\n              ? hoist(template.statement.ast`\n                  var ${id} = require(${source}).${name}\n                `)\n              : t.importDeclaration([t.importSpecifier(id, name)], source),\n            name: id.name,\n          };\n        });\n      },\n      injectDefaultImport(url, hint = url) {\n        return cache.storeNamed(prog, url, \"default\", (isScript, source) => {\n          const id = prog.scope.generateUidIdentifier(hint);\n          return {\n            node: isScript\n              ? hoist(template.statement.ast`var ${id} = require(${source})`)\n              : t.importDeclaration([t.importDefaultSpecifier(id)], source),\n            name: id.name,\n          };\n        });\n      },\n    };\n  };\n}\n","import type { NodePath } from \"@babel/traverse\";\nimport { types as t } from \"@babel/core\";\n\ntype StrMap<K> = Map<string, K>;\n\nexport default class ImportsCache {\n  _imports: WeakMap<NodePath<t.Program>, StrMap<string>>;\n  _anonymousImports: WeakMap<NodePath<t.Program>, Set<string>>;\n  _lastImports: WeakMap<NodePath<t.Program>, NodePath<t.Node>>;\n  _resolver: (url: string) => string;\n\n  constructor(resolver: (url: string) => string) {\n    this._imports = new WeakMap();\n    this._anonymousImports = new WeakMap();\n    this._lastImports = new WeakMap();\n    this._resolver = resolver;\n  }\n\n  storeAnonymous(\n    programPath: NodePath<t.Program>,\n    url: string,\n    // eslint-disable-next-line no-undef\n    getVal: (isScript: boolean, source: t.StringLiteral) => t.Node,\n  ) {\n    const key = this._normalizeKey(programPath, url);\n    const imports = this._ensure<Set<string>>(\n      this._anonymousImports,\n      programPath,\n      Set,\n    );\n\n    if (imports.has(key)) return;\n\n    const node = getVal(\n      programPath.node.sourceType === \"script\",\n      t.stringLiteral(this._resolver(url)),\n    );\n    imports.add(key);\n    this._injectImport(programPath, node);\n  }\n\n  storeNamed(\n    programPath: NodePath<t.Program>,\n    url: string,\n    name: string,\n    getVal: (\n      isScript: boolean,\n      // eslint-disable-next-line no-undef\n      source: t.StringLiteral,\n      // eslint-disable-next-line no-undef\n      name: t.Identifier,\n    ) => { node: t.Node; name: string },\n  ) {\n    const key = this._normalizeKey(programPath, url, name);\n    const imports = this._ensure<Map<string, any>>(\n      this._imports,\n      programPath,\n      Map,\n    );\n\n    if (!imports.has(key)) {\n      const { node, name: id } = getVal(\n        programPath.node.sourceType === \"script\",\n        t.stringLiteral(this._resolver(url)),\n        t.identifier(name),\n      );\n      imports.set(key, id);\n      this._injectImport(programPath, node);\n    }\n\n    return t.identifier(imports.get(key));\n  }\n\n  _injectImport(programPath: NodePath<t.Program>, node: t.Node) {\n    const lastImport = this._lastImports.get(programPath);\n    let newNodes: [NodePath];\n    if (\n      lastImport &&\n      lastImport.node &&\n      // Sometimes the AST is modified and the \"last import\"\n      // we have has been replaced\n      lastImport.parent === programPath.node &&\n      lastImport.container === programPath.node.body\n    ) {\n      newNodes = lastImport.insertAfter(node);\n    } else {\n      newNodes = programPath.unshiftContainer(\"body\", node);\n    }\n    const newNode = newNodes[newNodes.length - 1];\n    this._lastImports.set(programPath, newNode);\n\n    /*\n    let lastImport;\n\n    programPath.get(\"body\").forEach(path => {\n      if (path.isImportDeclaration()) lastImport = path;\n      if (\n        path.isExpressionStatement() &&\n        isRequireCall(path.get(\"expression\"))\n      ) {\n        lastImport = path;\n      }\n      if (\n        path.isVariableDeclaration() &&\n        path.get(\"declarations\").length === 1 &&\n        (isRequireCall(path.get(\"declarations.0.init\")) ||\n          (path.get(\"declarations.0.init\").isMemberExpression() &&\n            isRequireCall(path.get(\"declarations.0.init.object\"))))\n      ) {\n        lastImport = path;\n      }\n    });*/\n  }\n\n  _ensure<C extends Map<string, any> | Set<string>>(\n    map: WeakMap<NodePath<t.Program>, C>,\n    programPath: NodePath<t.Program>,\n    Collection: { new (...args: any): C },\n  ): C {\n    let collection = map.get(programPath);\n    if (!collection) {\n      collection = new Collection();\n      map.set(programPath, collection);\n    }\n    return collection;\n  }\n\n  _normalizeKey(\n    programPath: NodePath<t.Program>,\n    url: string,\n    name: string = \"\",\n  ): string {\n    const { sourceType } = programPath.node;\n\n    // If we rely on the imported binding (the \"name\" parameter), we also need to cache\n    // based on the sourceType. This is because the module transforms change the names\n    // of the import variables.\n    return `${name && sourceType}::${url}::${name}`;\n  }\n}\n","import { prettifyTargets } from \"@babel/helper-compilation-targets\";\n\nimport type { Targets } from \"./types\";\n\nexport const presetEnvSilentDebugHeader =\n  \"#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets\";\n\nexport function stringifyTargetsMultiline(targets: Targets): string {\n  return JSON.stringify(prettifyTargets(targets), null, 2);\n}\n\nexport function stringifyTargets(targets: Targets): string {\n  return JSON.stringify(targets)\n    .replace(/,/g, \", \")\n    .replace(/^\\{\"/, '{ \"')\n    .replace(/\"\\}$/, '\" }');\n}\n","import { intersection } from \"./utils\";\nimport type {\n  Pattern,\n  PluginOptions,\n  MissingDependenciesOption,\n} from \"./types\";\n\nfunction patternToRegExp(pattern: Pattern): RegExp | null {\n  if (pattern instanceof RegExp) return pattern;\n\n  try {\n    return new RegExp(`^${pattern}$`);\n  } catch {\n    return null;\n  }\n}\n\nfunction buildUnusedError(label, unused) {\n  if (!unused.length) return \"\";\n  return (\n    `  - The following \"${label}\" patterns didn't match any polyfill:\\n` +\n    unused.map(original => `    ${String(original)}\\n`).join(\"\")\n  );\n}\n\nfunction buldDuplicatesError(duplicates) {\n  if (!duplicates.size) return \"\";\n  return (\n    `  - The following polyfills were matched both by \"include\" and \"exclude\" patterns:\\n` +\n    Array.from(duplicates, name => `    ${name}\\n`).join(\"\")\n  );\n}\n\nexport function validateIncludeExclude(\n  provider: string,\n  polyfills: Set<string>,\n  includePatterns: Pattern[],\n  excludePatterns: Pattern[],\n) {\n  let current;\n  const filter = pattern => {\n    const regexp = patternToRegExp(pattern);\n    if (!regexp) return false;\n\n    let matched = false;\n    for (const polyfill of polyfills) {\n      if (regexp.test(polyfill)) {\n        matched = true;\n        current.add(polyfill);\n      }\n    }\n    return !matched;\n  };\n\n  // prettier-ignore\n  const include = current = new Set<string> ();\n  const unusedInclude = Array.from(includePatterns).filter(filter);\n\n  // prettier-ignore\n  const exclude = current = new Set<string> ();\n  const unusedExclude = Array.from(excludePatterns).filter(filter);\n\n  const duplicates = intersection(include, exclude);\n\n  if (\n    duplicates.size > 0 ||\n    unusedInclude.length > 0 ||\n    unusedExclude.length > 0\n  ) {\n    throw new Error(\n      `Error while validating the \"${provider}\" provider options:\\n` +\n        buildUnusedError(\"include\", unusedInclude) +\n        buildUnusedError(\"exclude\", unusedExclude) +\n        buldDuplicatesError(duplicates),\n    );\n  }\n\n  return { include, exclude };\n}\n\nexport function applyMissingDependenciesDefaults(\n  options: PluginOptions,\n  babelApi: any,\n): MissingDependenciesOption {\n  const { missingDependencies = {} } = options;\n  if (missingDependencies === false) return false;\n\n  const caller = babelApi.caller(caller => caller?.name);\n\n  const {\n    log = \"deferred\",\n    inject = caller === \"rollup-plugin-babel\" ? \"throw\" : \"import\",\n    all = false,\n  } = missingDependencies;\n\n  return { log, inject, all };\n}\n","import type { NodePath } from \"@babel/traverse\";\nimport { types as t } from \"@babel/core\";\nimport type { MetaDescriptor } from \"../types\";\n\nimport { resolveKey, resolveSource } from \"../utils\";\n\nexport default (\n  callProvider: (payload: MetaDescriptor, path: NodePath) => void,\n) => {\n  function property(object, key, placement, path) {\n    return callProvider({ kind: \"property\", object, key, placement }, path);\n  }\n\n  return {\n    // Symbol(), new Promise\n    ReferencedIdentifier(path: NodePath<t.Identifier>) {\n      const {\n        node: { name },\n        scope,\n      } = path;\n      if (scope.getBindingIdentifier(name)) return;\n\n      callProvider({ kind: \"global\", name }, path);\n    },\n\n    MemberExpression(path: NodePath<t.MemberExpression>) {\n      const key = resolveKey(path.get(\"property\"), path.node.computed);\n      if (!key || key === \"prototype\") return;\n\n      const object = path.get(\"object\");\n      if (object.isIdentifier()) {\n        const binding = object.scope.getBinding(object.node.name);\n        if (binding && binding.path.isImportNamespaceSpecifier()) return;\n      }\n\n      const source = resolveSource(object);\n      return property(source.id, key, source.placement, path);\n    },\n\n    ObjectPattern(path: NodePath<t.ObjectPattern>) {\n      const { parentPath, parent } = path;\n      let obj;\n\n      // const { keys, values } = Object\n      if (parentPath.isVariableDeclarator()) {\n        obj = parentPath.get(\"init\");\n        // ({ keys, values } = Object)\n      } else if (parentPath.isAssignmentExpression()) {\n        obj = parentPath.get(\"right\");\n        // !function ({ keys, values }) {...} (Object)\n        // resolution does not work after properties transform :-(\n      } else if (parentPath.isFunction()) {\n        const grand = parentPath.parentPath;\n        if (grand.isCallExpression() || grand.isNewExpression()) {\n          if (grand.node.callee === parent) {\n            obj = grand.get(\"arguments\")[path.key];\n          }\n        }\n      }\n\n      let id = null;\n      let placement = null;\n      if (obj) ({ id, placement } = resolveSource(obj));\n\n      for (const prop of path.get(\"properties\")) {\n        if (prop.isObjectProperty()) {\n          const key = resolveKey(prop.get(\"key\"));\n          if (key) property(id, key, placement, prop);\n        }\n      }\n    },\n\n    BinaryExpression(path: NodePath<t.BinaryExpression>) {\n      if (path.node.operator !== \"in\") return;\n\n      const source = resolveSource(path.get(\"right\"));\n      const key = resolveKey(path.get(\"left\"), true);\n\n      if (!key) return;\n\n      callProvider(\n        {\n          kind: \"in\",\n          object: source.id,\n          key,\n          placement: source.placement,\n        },\n        path,\n      );\n    },\n  };\n};\n","import type { NodePath } from \"@babel/traverse\";\nimport { types as t } from \"@babel/core\";\nimport type { MetaDescriptor } from \"../types\";\n\nimport { getImportSource, getRequireSource } from \"../utils\";\n\nexport default (\n  callProvider: (payload: MetaDescriptor, path: NodePath) => void,\n) => ({\n  ImportDeclaration(path: NodePath<t.ImportDeclaration>) {\n    const source = getImportSource(path);\n    if (!source) return;\n    callProvider({ kind: \"import\", source }, path);\n  },\n  Program(path: NodePath<t.Program>) {\n    path.get(\"body\").forEach(bodyPath => {\n      const source = getRequireSource(bodyPath);\n      if (!source) return;\n      callProvider({ kind: \"import\", source }, bodyPath);\n    });\n  },\n});\n","import path from \"path\";\nimport debounce from \"lodash.debounce\";\nimport requireResolve from \"resolve\";\n\nconst nativeRequireResolve = parseFloat(process.versions.node) >= 8.9;\n\nimport { createRequire } from \"module\";\nconst require = createRequire(import /*::(_)*/.meta.url); // eslint-disable-line\n\nfunction myResolve(name: string, basedir: string) {\n  if (nativeRequireResolve) {\n    return require\n      .resolve(name, {\n        paths: [basedir],\n      })\n      .replace(/\\\\/g, \"/\");\n  } else {\n    return requireResolve.sync(name, { basedir }).replace(/\\\\/g, \"/\");\n  }\n}\n\nexport function resolve(\n  dirname: string,\n  moduleName: string,\n  absoluteImports: boolean | string,\n): string {\n  if (absoluteImports === false) return moduleName;\n\n  let basedir = dirname;\n  if (typeof absoluteImports === \"string\") {\n    basedir = path.resolve(basedir, absoluteImports);\n  }\n\n  try {\n    return myResolve(moduleName, basedir);\n  } catch (err) {\n    if (err.code !== \"MODULE_NOT_FOUND\") throw err;\n\n    throw Object.assign(\n      new Error(`Failed to resolve \"${moduleName}\" relative to \"${dirname}\"`),\n      {\n        code: \"BABEL_POLYFILL_NOT_FOUND\",\n        polyfill: moduleName,\n        dirname,\n      },\n    );\n  }\n}\n\nexport function has(basedir: string, name: string) {\n  try {\n    myResolve(name, basedir);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function logMissing(missingDeps: Set<string>) {\n  if (missingDeps.size === 0) return;\n\n  const deps = Array.from(missingDeps).sort().join(\" \");\n\n  console.warn(\n    \"\\nSome polyfills have been added but are not present in your dependencies.\\n\" +\n      \"Please run one of the following commands:\\n\" +\n      `\\tnpm install --save ${deps}\\n` +\n      `\\tyarn add ${deps}\\n`,\n  );\n\n  process.exitCode = 1;\n}\n\nlet allMissingDeps = new Set<string>();\n\nconst laterLogMissingDependencies = debounce(() => {\n  logMissing(allMissingDeps);\n  allMissingDeps = new Set<string>();\n}, 100);\n\nexport function laterLogMissing(missingDeps: Set<string>) {\n  if (missingDeps.size === 0) return;\n\n  missingDeps.forEach(name => allMissingDeps.add(name));\n  laterLogMissingDependencies();\n}\n","import type {\n  MetaDescriptor,\n  ResolverPolyfills,\n  ResolvedPolyfill,\n} from \"./types\";\n\nimport { has } from \"./utils\";\n\ntype ResolverFn<T> = (meta: MetaDescriptor) => void | ResolvedPolyfill<T>;\n\nconst PossibleGlobalObjects = new Set<string>([\n  \"global\",\n  \"globalThis\",\n  \"self\",\n  \"window\",\n]);\n\nexport default function createMetaResolver<T>(\n  polyfills: ResolverPolyfills<T>,\n): ResolverFn<T> {\n  const { static: staticP, instance: instanceP, global: globalP } = polyfills;\n\n  return meta => {\n    if (meta.kind === \"global\" && globalP && has(globalP, meta.name)) {\n      return { kind: \"global\", desc: globalP[meta.name], name: meta.name };\n    }\n\n    if (meta.kind === \"property\" || meta.kind === \"in\") {\n      const { placement, object, key } = meta;\n\n      if (object && placement === \"static\") {\n        if (globalP && PossibleGlobalObjects.has(object) && has(globalP, key)) {\n          return { kind: \"global\", desc: globalP[key], name: key };\n        }\n\n        if (staticP && has(staticP, object) && has(staticP[object], key)) {\n          return {\n            kind: \"static\",\n            desc: staticP[object][key],\n            name: `${object}$${key}`,\n          };\n        }\n      }\n\n      if (instanceP && has(instanceP, key)) {\n        return { kind: \"instance\", desc: instanceP[key], name: `${key}` };\n      }\n    }\n  };\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport type { NodePath } from \"@babel/traverse\";\n\nimport _getTargets, {\n  isRequired,\n  getInclusionReasons,\n} from \"@babel/helper-compilation-targets\";\nconst getTargets = _getTargets.default || _getTargets;\n\nimport { createUtilsGetter } from \"./utils\";\nimport ImportsCache from \"./imports-cache\";\nimport {\n  stringifyTargetsMultiline,\n  presetEnvSilentDebugHeader,\n} from \"./debug-utils\";\nimport {\n  validateIncludeExclude,\n  applyMissingDependenciesDefaults,\n} from \"./normalize-options\";\n\nimport type {\n  ProviderApi,\n  MethodString,\n  Targets,\n  MetaDescriptor,\n  PolyfillProvider,\n  PluginOptions,\n  ProviderOptions,\n} from \"./types\";\n\nimport * as v from \"./visitors\";\nimport * as deps from \"./node/dependencies\";\n\nimport createMetaResolver from \"./meta-resolver\";\n\nexport type { PolyfillProvider, MetaDescriptor, Utils, Targets } from \"./types\";\n\nfunction resolveOptions<Options>(\n  options: PluginOptions,\n  babelApi,\n): {\n  method: MethodString;\n  methodName: \"usageGlobal\" | \"entryGlobal\" | \"usagePure\";\n  targets: Targets;\n  debug: boolean | typeof presetEnvSilentDebugHeader;\n  shouldInjectPolyfill:\n    | ((name: string, shouldInject: boolean) => boolean)\n    | undefined;\n  providerOptions: ProviderOptions<Options>;\n  absoluteImports: string | boolean;\n} {\n  const {\n    method,\n    targets: targetsOption,\n    ignoreBrowserslistConfig,\n    configPath,\n    debug,\n    shouldInjectPolyfill,\n    absoluteImports,\n    ...providerOptions\n  } = options;\n\n  if (isEmpty(options)) {\n    throw new Error(\n      `\\\nThis plugin requires options, for example:\n    {\n      \"plugins\": [\n        [\"<plugin name>\", { method: \"usage-pure\" }]\n      ]\n    }\n\nSee more options at https://github.com/babel/babel-polyfills/blob/main/docs/usage.md`,\n    );\n  }\n\n  let methodName;\n  if (method === \"usage-global\") methodName = \"usageGlobal\";\n  else if (method === \"entry-global\") methodName = \"entryGlobal\";\n  else if (method === \"usage-pure\") methodName = \"usagePure\";\n  else if (typeof method !== \"string\") {\n    throw new Error(\".method must be a string\");\n  } else {\n    throw new Error(\n      `.method must be one of \"entry-global\", \"usage-global\"` +\n        ` or \"usage-pure\" (received ${JSON.stringify(method)})`,\n    );\n  }\n\n  if (typeof shouldInjectPolyfill === \"function\") {\n    if (options.include || options.exclude) {\n      throw new Error(\n        `.include and .exclude are not supported when using the` +\n          ` .shouldInjectPolyfill function.`,\n      );\n    }\n  } else if (shouldInjectPolyfill != null) {\n    throw new Error(\n      `.shouldInjectPolyfill must be a function, or undefined` +\n        ` (received ${JSON.stringify(shouldInjectPolyfill)})`,\n    );\n  }\n\n  if (\n    absoluteImports != null &&\n    typeof absoluteImports !== \"boolean\" &&\n    typeof absoluteImports !== \"string\"\n  ) {\n    throw new Error(\n      `.absoluteImports must be a boolean, a string, or undefined` +\n        ` (received ${JSON.stringify(absoluteImports)})`,\n    );\n  }\n\n  let targets;\n\n  if (\n    // If any browserslist-related option is specified, fallback to the old\n    // behavior of not using the targets specified in the top-level options.\n    targetsOption ||\n    configPath ||\n    ignoreBrowserslistConfig\n  ) {\n    const targetsObj =\n      typeof targetsOption === \"string\" || Array.isArray(targetsOption)\n        ? { browsers: targetsOption }\n        : targetsOption;\n\n    targets = getTargets(targetsObj, {\n      ignoreBrowserslistConfig,\n      configPath,\n    });\n  } else {\n    targets = babelApi.targets();\n  }\n\n  return {\n    method,\n    methodName,\n    targets,\n    absoluteImports: absoluteImports ?? false,\n    shouldInjectPolyfill,\n    debug: !!debug,\n    providerOptions: providerOptions as any as ProviderOptions<Options>,\n  };\n}\n\nfunction instantiateProvider<Options>(\n  factory: PolyfillProvider<Options>,\n  options: PluginOptions,\n  missingDependencies,\n  dirname,\n  debugLog,\n  babelApi,\n) {\n  const {\n    method,\n    methodName,\n    targets,\n    debug,\n    shouldInjectPolyfill,\n    providerOptions,\n    absoluteImports,\n  } = resolveOptions<Options>(options, babelApi);\n\n  const getUtils = createUtilsGetter(\n    new ImportsCache(moduleName =>\n      deps.resolve(dirname, moduleName, absoluteImports),\n    ),\n  );\n\n  // eslint-disable-next-line prefer-const\n  let include, exclude;\n  let polyfillsSupport;\n  let polyfillsNames;\n  let filterPolyfills;\n\n  const depsCache = new Map();\n\n  const api: ProviderApi = {\n    babel: babelApi,\n    getUtils,\n    method: options.method,\n    targets,\n    createMetaResolver,\n    shouldInjectPolyfill(name) {\n      if (polyfillsNames === undefined) {\n        throw new Error(\n          `Internal error in the ${factory.name} provider: ` +\n            `shouldInjectPolyfill() can't be called during initialization.`,\n        );\n      }\n      if (!polyfillsNames.has(name)) {\n        console.warn(\n          `Internal error in the ${provider.name} provider: ` +\n            `unknown polyfill \"${name}\".`,\n        );\n      }\n\n      if (filterPolyfills && !filterPolyfills(name)) return false;\n\n      let shouldInject = isRequired(name, targets, {\n        compatData: polyfillsSupport,\n        includes: include,\n        excludes: exclude,\n      });\n\n      if (shouldInjectPolyfill) {\n        shouldInject = shouldInjectPolyfill(name, shouldInject);\n        if (typeof shouldInject !== \"boolean\") {\n          throw new Error(`.shouldInjectPolyfill must return a boolean.`);\n        }\n      }\n\n      return shouldInject;\n    },\n    debug(name) {\n      debugLog().found = true;\n\n      if (!debug || !name) return;\n\n      if (debugLog().polyfills.has(provider.name)) return;\n      debugLog().polyfills.add(name);\n      debugLog().polyfillsSupport ??= polyfillsSupport;\n    },\n    assertDependency(name, version = \"*\") {\n      if (missingDependencies === false) return;\n      if (absoluteImports) {\n        // If absoluteImports is not false, we will try resolving\n        // the dependency and throw if it's not possible. We can\n        // skip the check here.\n        return;\n      }\n\n      const dep = version === \"*\" ? name : `${name}@^${version}`;\n\n      const found = missingDependencies.all\n        ? false\n        : mapGetOr(depsCache, `${name} :: ${dirname}`, () =>\n            deps.has(dirname, name),\n          );\n\n      if (!found) {\n        debugLog().missingDeps.add(dep);\n      }\n    },\n  };\n\n  const provider = factory(api, providerOptions, dirname);\n\n  if (typeof provider[methodName] !== \"function\") {\n    throw new Error(\n      `The \"${provider.name || factory.name}\" provider doesn't ` +\n        `support the \"${method}\" polyfilling method.`,\n    );\n  }\n\n  if (Array.isArray(provider.polyfills)) {\n    polyfillsNames = new Set(provider.polyfills);\n    filterPolyfills = provider.filterPolyfills;\n  } else if (provider.polyfills) {\n    polyfillsNames = new Set(Object.keys(provider.polyfills));\n    polyfillsSupport = provider.polyfills;\n    filterPolyfills = provider.filterPolyfills;\n  } else {\n    polyfillsNames = new Set();\n  }\n\n  ({ include, exclude } = validateIncludeExclude(\n    provider.name || factory.name,\n    polyfillsNames,\n    providerOptions.include || [],\n    providerOptions.exclude || [],\n  ));\n\n  return {\n    debug,\n    method,\n    targets,\n    provider,\n    callProvider(payload: MetaDescriptor, path: NodePath) {\n      const utils = getUtils(path);\n      provider[methodName](payload, utils, path);\n    },\n  };\n}\n\nexport default function definePolyfillProvider<Options>(\n  factory: PolyfillProvider<Options>,\n) {\n  return declare((babelApi, options: PluginOptions, dirname: string) => {\n    babelApi.assertVersion(7);\n    const { traverse } = babelApi;\n\n    let debugLog;\n\n    const missingDependencies = applyMissingDependenciesDefaults(\n      options,\n      babelApi,\n    );\n\n    const { debug, method, targets, provider, callProvider } =\n      instantiateProvider<Options>(\n        factory,\n        options,\n        missingDependencies,\n        dirname,\n        () => debugLog,\n        babelApi,\n      );\n\n    const createVisitor = method === \"entry-global\" ? v.entry : v.usage;\n\n    const visitor = provider.visitor\n      ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor])\n      : createVisitor(callProvider);\n\n    if (debug && debug !== presetEnvSilentDebugHeader) {\n      console.log(`${provider.name}: \\`DEBUG\\` option`);\n      console.log(`\\nUsing targets: ${stringifyTargetsMultiline(targets)}`);\n      console.log(`\\nUsing polyfills with \\`${method}\\` method:`);\n    }\n\n    return {\n      name: \"inject-polyfills\",\n      visitor,\n\n      pre() {\n        debugLog = {\n          polyfills: new Set(),\n          polyfillsSupport: undefined,\n          found: false,\n          providers: new Set(),\n          missingDeps: new Set(),\n        };\n\n        provider.pre?.apply(this, arguments);\n      },\n      post() {\n        provider.post?.apply(this, arguments);\n\n        if (missingDependencies !== false) {\n          if (missingDependencies.log === \"per-file\") {\n            deps.logMissing(debugLog.missingDeps);\n          } else {\n            deps.laterLogMissing(debugLog.missingDeps);\n          }\n        }\n\n        if (!debug) return;\n\n        if (this.filename) console.log(`\\n[${this.filename}]`);\n\n        if (debugLog.polyfills.size === 0) {\n          console.log(\n            method === \"entry-global\"\n              ? debugLog.found\n                ? `Based on your targets, the ${provider.name} polyfill did not add any polyfill.`\n                : `The entry point for the ${provider.name} polyfill has not been found.`\n              : `Based on your code and targets, the ${provider.name} polyfill did not add any polyfill.`,\n          );\n\n          return;\n        }\n\n        if (method === \"entry-global\") {\n          console.log(\n            `The ${provider.name} polyfill entry has been replaced with ` +\n              `the following polyfills:`,\n          );\n        } else {\n          console.log(\n            `The ${provider.name} polyfill added the following polyfills:`,\n          );\n        }\n\n        for (const name of debugLog.polyfills) {\n          if (debugLog.polyfillsSupport?.[name]) {\n            const filteredTargets = getInclusionReasons(\n              name,\n              targets,\n              debugLog.polyfillsSupport,\n            );\n\n            const formattedTargets = JSON.stringify(filteredTargets)\n              .replace(/,/g, \", \")\n              .replace(/^\\{\"/, '{ \"')\n              .replace(/\"\\}$/, '\" }');\n\n            console.log(`  ${name} ${formattedTargets}`);\n          } else {\n            console.log(`  ${name}`);\n          }\n        }\n      },\n    };\n  });\n}\n\nfunction mapGetOr(map, key, getDefault) {\n  let val = map.get(key);\n  if (val === undefined) {\n    val = getDefault();\n    map.set(key, val);\n  }\n  return val;\n}\n\nfunction isEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}\n"]},"metadata":{},"sourceType":"module"}