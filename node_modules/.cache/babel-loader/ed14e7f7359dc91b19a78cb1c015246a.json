{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  assignmentExpression,\n  cloneNode,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isPrivateName,\n  isPureish,\n  isSuper,\n  memberExpression,\n  toComputedKey\n} = _t;\n\nfunction getObjRef(node, nodes, scope) {\n  let ref;\n\n  if (isIdentifier(node)) {\n    if (scope.hasBinding(node.name)) {\n      return node;\n    } else {\n      ref = node;\n    }\n  } else if (isMemberExpression(node)) {\n    ref = node.object;\n\n    if (isSuper(ref) || isIdentifier(ref) && scope.hasBinding(ref.name)) {\n      return ref;\n    }\n  } else {\n    throw new Error(`We can't explode this node type ${node[\"type\"]}`);\n  }\n\n  const temp = scope.generateUidIdentifierBasedOnNode(ref);\n  scope.push({\n    id: temp\n  });\n  nodes.push(assignmentExpression(\"=\", cloneNode(temp), cloneNode(ref)));\n  return temp;\n}\n\nfunction getPropRef(node, nodes, scope) {\n  const prop = node.property;\n\n  if (isPrivateName(prop)) {\n    throw new Error(\"We can't generate property ref for private name, please install `@babel/plugin-proposal-class-properties`\");\n  }\n\n  const key = toComputedKey(node, prop);\n  if (isLiteral(key) && isPureish(key)) return key;\n  const temp = scope.generateUidIdentifierBasedOnNode(prop);\n  scope.push({\n    id: temp\n  });\n  nodes.push(assignmentExpression(\"=\", cloneNode(temp), cloneNode(prop)));\n  return temp;\n}\n\nfunction _default(node, nodes, file, scope, allowedSingleIdent) {\n  let obj;\n\n  if (isIdentifier(node) && allowedSingleIdent) {\n    obj = node;\n  } else {\n    obj = getObjRef(node, nodes, scope);\n  }\n\n  let ref, uid;\n\n  if (isIdentifier(node)) {\n    ref = cloneNode(node);\n    uid = obj;\n  } else {\n    const prop = getPropRef(node, nodes, scope);\n    const computed = node.computed || isLiteral(prop);\n    uid = memberExpression(cloneNode(obj), cloneNode(prop), computed);\n    ref = memberExpression(cloneNode(obj), cloneNode(prop), computed);\n  }\n\n  return {\n    uid: uid,\n    ref: ref\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_default","_t","require","assignmentExpression","cloneNode","isIdentifier","isLiteral","isMemberExpression","isPrivateName","isPureish","isSuper","memberExpression","toComputedKey","getObjRef","node","nodes","scope","ref","hasBinding","name","object","Error","temp","generateUidIdentifierBasedOnNode","push","id","getPropRef","prop","property","key","file","allowedSingleIdent","obj","uid","computed"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/helper-explode-assignable-expression/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  assignmentExpression,\n  cloneNode,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isPrivateName,\n  isPureish,\n  isSuper,\n  memberExpression,\n  toComputedKey\n} = _t;\n\nfunction getObjRef(node, nodes, scope) {\n  let ref;\n\n  if (isIdentifier(node)) {\n    if (scope.hasBinding(node.name)) {\n      return node;\n    } else {\n      ref = node;\n    }\n  } else if (isMemberExpression(node)) {\n    ref = node.object;\n\n    if (isSuper(ref) || isIdentifier(ref) && scope.hasBinding(ref.name)) {\n      return ref;\n    }\n  } else {\n    throw new Error(`We can't explode this node type ${node[\"type\"]}`);\n  }\n\n  const temp = scope.generateUidIdentifierBasedOnNode(ref);\n  scope.push({\n    id: temp\n  });\n  nodes.push(assignmentExpression(\"=\", cloneNode(temp), cloneNode(ref)));\n  return temp;\n}\n\nfunction getPropRef(node, nodes, scope) {\n  const prop = node.property;\n\n  if (isPrivateName(prop)) {\n    throw new Error(\"We can't generate property ref for private name, please install `@babel/plugin-proposal-class-properties`\");\n  }\n\n  const key = toComputedKey(node, prop);\n  if (isLiteral(key) && isPureish(key)) return key;\n  const temp = scope.generateUidIdentifierBasedOnNode(prop);\n  scope.push({\n    id: temp\n  });\n  nodes.push(assignmentExpression(\"=\", cloneNode(temp), cloneNode(prop)));\n  return temp;\n}\n\nfunction _default(node, nodes, file, scope, allowedSingleIdent) {\n  let obj;\n\n  if (isIdentifier(node) && allowedSingleIdent) {\n    obj = node;\n  } else {\n    obj = getObjRef(node, nodes, scope);\n  }\n\n  let ref, uid;\n\n  if (isIdentifier(node)) {\n    ref = cloneNode(node);\n    uid = obj;\n  } else {\n    const prop = getPropRef(node, nodes, scope);\n    const computed = node.computed || isLiteral(prop);\n    uid = memberExpression(cloneNode(obj), cloneNode(prop), computed);\n    ref = memberExpression(cloneNode(obj), cloneNode(prop), computed);\n  }\n\n  return {\n    uid: uid,\n    ref: ref\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}