{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexports.isAbsolute = isAbsolute;\nexports.isBuiltIn = isBuiltIn;\nexports.isExternalModule = isExternalModule;\nexports.isExternalModuleMain = isExternalModuleMain;\nexports.isScoped = isScoped;\nexports.isScopedMain = isScopedMain;\nexports['default'] = resolveImportType;\n\nvar _path = require('path');\n\nvar _isCoreModule = require('is-core-module');\n\nvar _isCoreModule2 = _interopRequireDefault(_isCoreModule);\n\nvar _resolve = require('eslint-module-utils/resolve');\n\nvar _resolve2 = _interopRequireDefault(_resolve);\n\nvar _packagePath = require('./packagePath');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction baseModule(name) {\n  if (isScoped(name)) {\n    var _name$split = name.split('/'),\n        _name$split2 = _slicedToArray(_name$split, 2),\n        scope = _name$split2[0],\n        _pkg = _name$split2[1];\n\n    return String(scope) + '/' + String(_pkg);\n  }\n\n  var _name$split3 = name.split('/'),\n      _name$split4 = _slicedToArray(_name$split3, 1),\n      pkg = _name$split4[0];\n\n  return pkg;\n}\n\nfunction isInternalRegexMatch(name, settings) {\n  var internalScope = settings && settings['import/internal-regex'];\n  return internalScope && new RegExp(internalScope).test(name);\n}\n\nfunction isAbsolute(name) {\n  return typeof name === 'string' && (0, _path.isAbsolute)(name);\n} // path is defined only when a resolver resolves to a non-standard path\n\n\nfunction isBuiltIn(name, settings, path) {\n  if (path || !name) return false;\n  var base = baseModule(name);\n  var extras = settings && settings['import/core-modules'] || [];\n  return (0, _isCoreModule2['default'])(base) || extras.indexOf(base) > -1;\n}\n\nfunction isExternalModule(name, path, context) {\n  if (arguments.length < 3) {\n    throw new TypeError('isExternalModule: name, path, and context are all required');\n  }\n\n  return (isModule(name) || isScoped(name)) && typeTest(name, context, path) === 'external';\n}\n\nfunction isExternalModuleMain(name, path, context) {\n  if (arguments.length < 3) {\n    throw new TypeError('isExternalModule: name, path, and context are all required');\n  }\n\n  return isModuleMain(name) && typeTest(name, context, path) === 'external';\n}\n\nvar moduleRegExp = /^\\w/;\n\nfunction isModule(name) {\n  return name && moduleRegExp.test(name);\n}\n\nvar moduleMainRegExp = /^[\\w]((?!\\/).)*$/;\n\nfunction isModuleMain(name) {\n  return name && moduleMainRegExp.test(name);\n}\n\nvar scopedRegExp = /^@[^/]+\\/?[^/]+/;\n\nfunction isScoped(name) {\n  return name && scopedRegExp.test(name);\n}\n\nvar scopedMainRegExp = /^@[^/]+\\/?[^/]+$/;\n\nfunction isScopedMain(name) {\n  return name && scopedMainRegExp.test(name);\n}\n\nfunction isRelativeToParent(name) {\n  return /^\\.\\.$|^\\.\\.[\\\\/]/.test(name);\n}\n\nvar indexFiles = ['.', './', './index', './index.js'];\n\nfunction isIndex(name) {\n  return indexFiles.indexOf(name) !== -1;\n}\n\nfunction isRelativeToSibling(name) {\n  return /^\\.[\\\\/]/.test(name);\n}\n\nfunction isExternalPath(path, context) {\n  if (!path) {\n    return false;\n  }\n\n  var settings = context.settings;\n  var packagePath = (0, _packagePath.getContextPackagePath)(context);\n\n  if ((0, _path.relative)(packagePath, path).startsWith('..')) {\n    return true;\n  }\n\n  var folders = settings && settings['import/external-module-folders'] || ['node_modules'];\n  return folders.some(function (folder) {\n    var folderPath = (0, _path.resolve)(packagePath, folder);\n    var relativePath = (0, _path.relative)(folderPath, path);\n    return !relativePath.startsWith('..');\n  });\n}\n\nfunction isInternalPath(path, context) {\n  if (!path) {\n    return false;\n  }\n\n  var packagePath = (0, _packagePath.getContextPackagePath)(context);\n  return !(0, _path.relative)(packagePath, path).startsWith('../');\n}\n\nfunction isExternalLookingName(name) {\n  return isModule(name) || isScoped(name);\n}\n\nfunction typeTest(name, context, path) {\n  var settings = context.settings;\n\n  if (isInternalRegexMatch(name, settings)) {\n    return 'internal';\n  }\n\n  if (isAbsolute(name, settings, path)) {\n    return 'absolute';\n  }\n\n  if (isBuiltIn(name, settings, path)) {\n    return 'builtin';\n  }\n\n  if (isRelativeToParent(name, settings, path)) {\n    return 'parent';\n  }\n\n  if (isIndex(name, settings, path)) {\n    return 'index';\n  }\n\n  if (isRelativeToSibling(name, settings, path)) {\n    return 'sibling';\n  }\n\n  if (isExternalPath(path, context)) {\n    return 'external';\n  }\n\n  if (isInternalPath(path, context)) {\n    return 'internal';\n  }\n\n  if (isExternalLookingName(name)) {\n    return 'external';\n  }\n\n  return 'unknown';\n}\n\nfunction resolveImportType(name, context) {\n  return typeTest(name, context, (0, _resolve2['default'])(name, context));\n}","map":{"version":3,"mappings":"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","names":["isAbsolute","isBuiltIn","isExternalModule","isExternalModuleMain","isScoped","isScopedMain","resolveImportType","baseModule","name","split","scope","pkg","isInternalRegexMatch","settings","internalScope","RegExp","test","path","base","extras","indexOf","context","arguments","length","TypeError","isModule","typeTest","isModuleMain","moduleRegExp","moduleMainRegExp","scopedRegExp","scopedMainRegExp","isRelativeToParent","indexFiles","isIndex","isRelativeToSibling","isExternalPath","packagePath","startsWith","folders","some","folder","folderPath","relativePath","isInternalPath","isExternalLookingName"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\core\\importType.js"],"sourcesContent":["import { isAbsolute as nodeIsAbsolute, relative, resolve as nodeResolve } from 'path';\nimport isCoreModule from 'is-core-module';\n\nimport resolve from 'eslint-module-utils/resolve';\nimport { getContextPackagePath } from './packagePath';\n\nfunction baseModule(name) {\n  if (isScoped(name)) {\n    const [scope, pkg] = name.split('/');\n    return `${scope}/${pkg}`;\n  }\n  const [pkg] = name.split('/');\n  return pkg;\n}\n\nfunction isInternalRegexMatch(name, settings) {\n  const internalScope = (settings && settings['import/internal-regex']);\n  return internalScope && new RegExp(internalScope).test(name);\n}\n\nexport function isAbsolute(name) {\n  return typeof name === 'string' && nodeIsAbsolute(name);\n}\n\n// path is defined only when a resolver resolves to a non-standard path\nexport function isBuiltIn(name, settings, path) {\n  if (path || !name) return false;\n  const base = baseModule(name);\n  const extras = (settings && settings['import/core-modules']) || [];\n  return isCoreModule(base) || extras.indexOf(base) > -1;\n}\n\nexport function isExternalModule(name, path, context) {\n  if (arguments.length < 3) {                                                                                                                                                                              \n    throw new TypeError('isExternalModule: name, path, and context are all required');\n  }\n  return (isModule(name) || isScoped(name)) && typeTest(name, context, path) === 'external';\n}\n\nexport function isExternalModuleMain(name, path, context) {\n  if (arguments.length < 3) {                                                                                                                                                                              \n    throw new TypeError('isExternalModule: name, path, and context are all required');\n  }\n  return isModuleMain(name) && typeTest(name, context, path) === 'external';\n}\n\nconst moduleRegExp = /^\\w/;\nfunction isModule(name) {\n  return name && moduleRegExp.test(name);\n}\n\nconst moduleMainRegExp = /^[\\w]((?!\\/).)*$/;\nfunction isModuleMain(name) {\n  return name && moduleMainRegExp.test(name);\n}\n\nconst scopedRegExp = /^@[^/]+\\/?[^/]+/;\nexport function isScoped(name) {\n  return name && scopedRegExp.test(name);\n}\n\nconst scopedMainRegExp = /^@[^/]+\\/?[^/]+$/;\nexport function isScopedMain(name) {\n  return name && scopedMainRegExp.test(name);\n}\n\nfunction isRelativeToParent(name) {\n  return /^\\.\\.$|^\\.\\.[\\\\/]/.test(name);\n}\n\nconst indexFiles = ['.', './', './index', './index.js'];\nfunction isIndex(name) {\n  return indexFiles.indexOf(name) !== -1;\n}\n\nfunction isRelativeToSibling(name) {\n  return /^\\.[\\\\/]/.test(name);\n}\n\nfunction isExternalPath(path, context) {\n  if (!path) {\n    return false;\n  }\n\n  const { settings } = context;\n  const packagePath = getContextPackagePath(context);\n\n  if (relative(packagePath, path).startsWith('..')) {\n    return true;\n  }\n\n  const folders = (settings && settings['import/external-module-folders']) || ['node_modules'];\n  return folders.some((folder) => {\n    const folderPath = nodeResolve(packagePath, folder);\n    const relativePath = relative(folderPath, path);\n    return !relativePath.startsWith('..');\n  });\n}\n\nfunction isInternalPath(path, context) {\n  if (!path) {\n    return false;\n  }\n  const packagePath = getContextPackagePath(context);\n  return !relative(packagePath, path).startsWith('../');\n}\n\nfunction isExternalLookingName(name) {\n  return isModule(name) || isScoped(name);\n}\n\nfunction typeTest(name, context, path ) {\n  const { settings } = context;\n  if (isInternalRegexMatch(name, settings)) { return 'internal'; }\n  if (isAbsolute(name, settings, path)) { return 'absolute'; }\n  if (isBuiltIn(name, settings, path)) { return 'builtin'; }\n  if (isRelativeToParent(name, settings, path)) { return 'parent'; }\n  if (isIndex(name, settings, path)) { return 'index'; }\n  if (isRelativeToSibling(name, settings, path)) { return 'sibling'; }\n  if (isExternalPath(path, context)) { return 'external'; }\n  if (isInternalPath(path, context)) { return 'internal'; }\n  if (isExternalLookingName(name)) { return 'external'; }\n  return 'unknown';\n}\n\nexport default function resolveImportType(name, context) {\n  return typeTest(name, context, resolve(name, context));\n}\n"]},"metadata":{},"sourceType":"script"}