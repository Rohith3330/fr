{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RULE_NAME = void 0;\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst create_testing_library_rule_1 = require(\"../create-testing-library-rule\");\n\nconst node_utils_1 = require(\"../node-utils\");\n\nexports.RULE_NAME = 'prefer-wait-for';\nconst DEPRECATED_METHODS = ['wait', 'waitForElement', 'waitForDomChange'];\nexports.default = (0, create_testing_library_rule_1.createTestingLibraryRule)({\n  name: exports.RULE_NAME,\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Use `waitFor` instead of deprecated wait methods',\n      recommendedConfig: {\n        dom: false,\n        angular: false,\n        react: false,\n        vue: false,\n        marko: false\n      }\n    },\n    messages: {\n      preferWaitForMethod: '`{{ methodName }}` is deprecated in favour of `waitFor`',\n      preferWaitForImport: 'import `waitFor` instead of deprecated async utils',\n      preferWaitForRequire: 'require `waitFor` instead of deprecated async utils'\n    },\n    fixable: 'code',\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context, _, helpers) {\n    let addWaitFor = false;\n\n    const reportRequire = node => {\n      context.report({\n        node,\n        messageId: 'preferWaitForRequire',\n\n        fix(fixer) {\n          const excludedImports = [...DEPRECATED_METHODS, 'waitFor'];\n          const newAllRequired = node.properties.filter(s => (0, node_utils_1.isProperty)(s) && utils_1.ASTUtils.isIdentifier(s.key) && !excludedImports.includes(s.key.name)).map(s => s.key.name);\n          newAllRequired.push('waitFor');\n          return fixer.replaceText(node, `{ ${newAllRequired.join(',')} }`);\n        }\n\n      });\n    };\n\n    const reportImport = node => {\n      context.report({\n        node,\n        messageId: 'preferWaitForImport',\n\n        fix(fixer) {\n          const excludedImports = [...DEPRECATED_METHODS, 'waitFor'];\n          const newImports = node.specifiers.map(specifier => (0, node_utils_1.isImportSpecifier)(specifier) && !excludedImports.includes(specifier.imported.name) && specifier.imported.name).filter(Boolean);\n          newImports.push('waitFor');\n          const newNode = `import { ${newImports.join(',')} } from '${node.source.value}';`;\n          return fixer.replaceText(node, newNode);\n        }\n\n      });\n    };\n\n    const reportWait = node => {\n      context.report({\n        node,\n        messageId: 'preferWaitForMethod',\n        data: {\n          methodName: node.name\n        },\n\n        fix(fixer) {\n          const callExpressionNode = (0, node_utils_1.findClosestCallExpressionNode)(node);\n\n          if (!callExpressionNode) {\n            return null;\n          }\n\n          const [arg] = callExpressionNode.arguments;\n          const fixers = [];\n\n          if (arg) {\n            fixers.push(fixer.replaceText(node, 'waitFor'));\n\n            if (node.name === 'waitForDomChange') {\n              fixers.push(fixer.insertTextBefore(arg, '() => {}, '));\n            }\n          } else {\n            let methodReplacement = 'waitFor(() => {})';\n\n            if ((0, node_utils_1.isMemberExpression)(node.parent) && utils_1.ASTUtils.isIdentifier(node.parent.object)) {\n              methodReplacement = `${node.parent.object.name}.${methodReplacement}`;\n            }\n\n            const newText = methodReplacement;\n            fixers.push(fixer.replaceText(callExpressionNode, newText));\n          }\n\n          return fixers;\n        }\n\n      });\n    };\n\n    return {\n      'CallExpression > MemberExpression'(node) {\n        const isDeprecatedMethod = utils_1.ASTUtils.isIdentifier(node.property) && DEPRECATED_METHODS.includes(node.property.name);\n\n        if (!isDeprecatedMethod) {\n          return;\n        }\n\n        if (!helpers.isNodeComingFromTestingLibrary(node)) {\n          return;\n        }\n\n        addWaitFor = true;\n        reportWait(node.property);\n      },\n\n      'CallExpression > Identifier'(node) {\n        if (!DEPRECATED_METHODS.includes(node.name)) {\n          return;\n        }\n\n        if (!helpers.isNodeComingFromTestingLibrary(node)) {\n          return;\n        }\n\n        addWaitFor = true;\n        reportWait(node);\n      },\n\n      'Program:exit'() {\n        var _a;\n\n        if (!addWaitFor) {\n          return;\n        }\n\n        const testingLibraryNode = (_a = helpers.getCustomModuleImportNode()) !== null && _a !== void 0 ? _a : helpers.getTestingLibraryImportNode();\n\n        if ((0, node_utils_1.isCallExpression)(testingLibraryNode)) {\n          const parent = testingLibraryNode.parent;\n\n          if (!(0, node_utils_1.isObjectPattern)(parent.id)) {\n            return;\n          }\n\n          reportRequire(parent.id);\n        } else if (testingLibraryNode) {\n          if (testingLibraryNode.specifiers.length === 1 && (0, node_utils_1.isImportNamespaceSpecifier)(testingLibraryNode.specifiers[0])) {\n            return;\n          }\n\n          reportImport(testingLibraryNode);\n        }\n      }\n\n    };\n  }\n\n});","map":{"version":3,"names":["Object","defineProperty","exports","value","RULE_NAME","utils_1","require","create_testing_library_rule_1","node_utils_1","DEPRECATED_METHODS","default","createTestingLibraryRule","name","meta","type","docs","description","recommendedConfig","dom","angular","react","vue","marko","messages","preferWaitForMethod","preferWaitForImport","preferWaitForRequire","fixable","schema","defaultOptions","create","context","_","helpers","addWaitFor","reportRequire","node","report","messageId","fix","fixer","excludedImports","newAllRequired","properties","filter","s","isProperty","ASTUtils","isIdentifier","key","includes","map","push","replaceText","join","reportImport","newImports","specifiers","specifier","isImportSpecifier","imported","Boolean","newNode","source","reportWait","data","methodName","callExpressionNode","findClosestCallExpressionNode","arg","arguments","fixers","insertTextBefore","methodReplacement","isMemberExpression","parent","object","newText","isDeprecatedMethod","property","isNodeComingFromTestingLibrary","_a","testingLibraryNode","getCustomModuleImportNode","getTestingLibraryImportNode","isCallExpression","isObjectPattern","id","length","isImportNamespaceSpecifier"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-testing-library/rules/prefer-wait-for.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RULE_NAME = void 0;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst create_testing_library_rule_1 = require(\"../create-testing-library-rule\");\nconst node_utils_1 = require(\"../node-utils\");\nexports.RULE_NAME = 'prefer-wait-for';\nconst DEPRECATED_METHODS = ['wait', 'waitForElement', 'waitForDomChange'];\nexports.default = (0, create_testing_library_rule_1.createTestingLibraryRule)({\n    name: exports.RULE_NAME,\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Use `waitFor` instead of deprecated wait methods',\n            recommendedConfig: {\n                dom: false,\n                angular: false,\n                react: false,\n                vue: false,\n                marko: false,\n            },\n        },\n        messages: {\n            preferWaitForMethod: '`{{ methodName }}` is deprecated in favour of `waitFor`',\n            preferWaitForImport: 'import `waitFor` instead of deprecated async utils',\n            preferWaitForRequire: 'require `waitFor` instead of deprecated async utils',\n        },\n        fixable: 'code',\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context, _, helpers) {\n        let addWaitFor = false;\n        const reportRequire = (node) => {\n            context.report({\n                node,\n                messageId: 'preferWaitForRequire',\n                fix(fixer) {\n                    const excludedImports = [...DEPRECATED_METHODS, 'waitFor'];\n                    const newAllRequired = node.properties\n                        .filter((s) => (0, node_utils_1.isProperty)(s) &&\n                        utils_1.ASTUtils.isIdentifier(s.key) &&\n                        !excludedImports.includes(s.key.name))\n                        .map((s) => s.key.name);\n                    newAllRequired.push('waitFor');\n                    return fixer.replaceText(node, `{ ${newAllRequired.join(',')} }`);\n                },\n            });\n        };\n        const reportImport = (node) => {\n            context.report({\n                node,\n                messageId: 'preferWaitForImport',\n                fix(fixer) {\n                    const excludedImports = [...DEPRECATED_METHODS, 'waitFor'];\n                    const newImports = node.specifiers\n                        .map((specifier) => (0, node_utils_1.isImportSpecifier)(specifier) &&\n                        !excludedImports.includes(specifier.imported.name) &&\n                        specifier.imported.name)\n                        .filter(Boolean);\n                    newImports.push('waitFor');\n                    const newNode = `import { ${newImports.join(',')} } from '${node.source.value}';`;\n                    return fixer.replaceText(node, newNode);\n                },\n            });\n        };\n        const reportWait = (node) => {\n            context.report({\n                node,\n                messageId: 'preferWaitForMethod',\n                data: {\n                    methodName: node.name,\n                },\n                fix(fixer) {\n                    const callExpressionNode = (0, node_utils_1.findClosestCallExpressionNode)(node);\n                    if (!callExpressionNode) {\n                        return null;\n                    }\n                    const [arg] = callExpressionNode.arguments;\n                    const fixers = [];\n                    if (arg) {\n                        fixers.push(fixer.replaceText(node, 'waitFor'));\n                        if (node.name === 'waitForDomChange') {\n                            fixers.push(fixer.insertTextBefore(arg, '() => {}, '));\n                        }\n                    }\n                    else {\n                        let methodReplacement = 'waitFor(() => {})';\n                        if ((0, node_utils_1.isMemberExpression)(node.parent) &&\n                            utils_1.ASTUtils.isIdentifier(node.parent.object)) {\n                            methodReplacement = `${node.parent.object.name}.${methodReplacement}`;\n                        }\n                        const newText = methodReplacement;\n                        fixers.push(fixer.replaceText(callExpressionNode, newText));\n                    }\n                    return fixers;\n                },\n            });\n        };\n        return {\n            'CallExpression > MemberExpression'(node) {\n                const isDeprecatedMethod = utils_1.ASTUtils.isIdentifier(node.property) &&\n                    DEPRECATED_METHODS.includes(node.property.name);\n                if (!isDeprecatedMethod) {\n                    return;\n                }\n                if (!helpers.isNodeComingFromTestingLibrary(node)) {\n                    return;\n                }\n                addWaitFor = true;\n                reportWait(node.property);\n            },\n            'CallExpression > Identifier'(node) {\n                if (!DEPRECATED_METHODS.includes(node.name)) {\n                    return;\n                }\n                if (!helpers.isNodeComingFromTestingLibrary(node)) {\n                    return;\n                }\n                addWaitFor = true;\n                reportWait(node);\n            },\n            'Program:exit'() {\n                var _a;\n                if (!addWaitFor) {\n                    return;\n                }\n                const testingLibraryNode = (_a = helpers.getCustomModuleImportNode()) !== null && _a !== void 0 ? _a : helpers.getTestingLibraryImportNode();\n                if ((0, node_utils_1.isCallExpression)(testingLibraryNode)) {\n                    const parent = testingLibraryNode.parent;\n                    if (!(0, node_utils_1.isObjectPattern)(parent.id)) {\n                        return;\n                    }\n                    reportRequire(parent.id);\n                }\n                else if (testingLibraryNode) {\n                    if (testingLibraryNode.specifiers.length === 1 &&\n                        (0, node_utils_1.isImportNamespaceSpecifier)(testingLibraryNode.specifiers[0])) {\n                        return;\n                    }\n                    reportImport(testingLibraryNode);\n                }\n            },\n        };\n    },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}