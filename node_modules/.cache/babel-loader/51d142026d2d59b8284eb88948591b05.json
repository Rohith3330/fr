{"ast":null,"code":"var List = require('css-tree').List;\n\nvar walk = require('css-tree').walk;\n\nvar utils = require('./utils');\n\nfunction calcSelectorLength(list) {\n  var length = 0;\n  list.each(function (data) {\n    length += data.id.length + 1;\n  });\n  return length - 1;\n}\n\nfunction calcDeclarationsLength(tokens) {\n  var length = 0;\n\n  for (var i = 0; i < tokens.length; i++) {\n    length += tokens[i].length;\n  }\n\n  return length + // declarations\n  tokens.length - 1 // delimeters\n  ;\n}\n\nfunction processRule(node, item, list) {\n  var avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;\n  var selectors = node.prelude.children;\n  var block = node.block;\n  var disallowDownMarkers = Object.create(null);\n  var allowMergeUp = true;\n  var allowMergeDown = true;\n  list.prevUntil(item.prev, function (prev, prevItem) {\n    var prevBlock = prev.block;\n    var prevType = prev.type;\n\n    if (prevType !== 'Rule') {\n      var unsafe = utils.unsafeToSkipNode.call(selectors, prev);\n\n      if (!unsafe && prevType === 'Atrule' && prevBlock) {\n        walk(prevBlock, {\n          visit: 'Rule',\n          enter: function (node) {\n            node.prelude.children.each(function (data) {\n              disallowDownMarkers[data.compareMarker] = true;\n            });\n          }\n        });\n      }\n\n      return unsafe;\n    }\n\n    var prevSelectors = prev.prelude.children;\n\n    if (node.pseudoSignature !== prev.pseudoSignature) {\n      return true;\n    }\n\n    allowMergeDown = !prevSelectors.some(function (selector) {\n      return selector.compareMarker in disallowDownMarkers;\n    }); // try prev ruleset if simpleselectors has no equal specifity and element selector\n\n    if (!allowMergeDown && !allowMergeUp) {\n      return true;\n    } // try to join by selectors\n\n\n    if (allowMergeUp && utils.isEqualSelectors(prevSelectors, selectors)) {\n      prevBlock.children.appendList(block.children);\n      list.remove(item);\n      return true;\n    } // try to join by properties\n\n\n    var diff = utils.compareDeclarations(block.children, prevBlock.children); // console.log(diff.eq, diff.ne1, diff.ne2);\n\n    if (diff.eq.length) {\n      if (!diff.ne1.length && !diff.ne2.length) {\n        // equal blocks\n        if (allowMergeDown) {\n          utils.addSelectors(selectors, prevSelectors);\n          list.remove(prevItem);\n        }\n\n        return true;\n      } else if (!avoidRulesMerge) {\n        /* probably we don't need to prevent those merges for @keyframes\n           TODO: need to be checked */\n        if (diff.ne1.length && !diff.ne2.length) {\n          // prevBlock is subset block\n          var selectorLength = calcSelectorLength(selectors);\n          var blockLength = calcDeclarationsLength(diff.eq); // declarations length\n\n          if (allowMergeUp && selectorLength < blockLength) {\n            utils.addSelectors(prevSelectors, selectors);\n            block.children = new List().fromArray(diff.ne1);\n          }\n        } else if (!diff.ne1.length && diff.ne2.length) {\n          // node is subset of prevBlock\n          var selectorLength = calcSelectorLength(prevSelectors);\n          var blockLength = calcDeclarationsLength(diff.eq); // declarations length\n\n          if (allowMergeDown && selectorLength < blockLength) {\n            utils.addSelectors(selectors, prevSelectors);\n            prevBlock.children = new List().fromArray(diff.ne2);\n          }\n        } else {\n          // diff.ne1.length && diff.ne2.length\n          // extract equal block\n          var newSelector = {\n            type: 'SelectorList',\n            loc: null,\n            children: utils.addSelectors(prevSelectors.copy(), selectors)\n          };\n          var newBlockLength = calcSelectorLength(newSelector.children) + 2; // selectors length + curly braces length\n\n          var blockLength = calcDeclarationsLength(diff.eq); // declarations length\n          // create new ruleset if declarations length greater than\n          // ruleset description overhead\n\n          if (blockLength >= newBlockLength) {\n            var newItem = list.createItem({\n              type: 'Rule',\n              loc: null,\n              prelude: newSelector,\n              block: {\n                type: 'Block',\n                loc: null,\n                children: new List().fromArray(diff.eq)\n              },\n              pseudoSignature: node.pseudoSignature\n            });\n            block.children = new List().fromArray(diff.ne1);\n            prevBlock.children = new List().fromArray(diff.ne2overrided);\n\n            if (allowMergeUp) {\n              list.insert(newItem, prevItem);\n            } else {\n              list.insert(newItem, item);\n            }\n\n            return true;\n          }\n        }\n      }\n    }\n\n    if (allowMergeUp) {\n      // TODO: disallow up merge only if any property interception only (i.e. diff.ne2overrided.length > 0);\n      // await property families to find property interception correctly\n      allowMergeUp = !prevSelectors.some(function (prevSelector) {\n        return selectors.some(function (selector) {\n          return selector.compareMarker === prevSelector.compareMarker;\n        });\n      });\n    }\n\n    prevSelectors.each(function (data) {\n      disallowDownMarkers[data.compareMarker] = true;\n    });\n  });\n}\n\nmodule.exports = function restructRule(ast) {\n  walk(ast, {\n    visit: 'Rule',\n    reverse: true,\n    enter: processRule\n  });\n};","map":{"version":3,"names":["List","require","walk","utils","calcSelectorLength","list","length","each","data","id","calcDeclarationsLength","tokens","i","processRule","node","item","avoidRulesMerge","block","selectors","prelude","children","disallowDownMarkers","Object","create","allowMergeUp","allowMergeDown","prevUntil","prev","prevItem","prevBlock","prevType","type","unsafe","unsafeToSkipNode","call","visit","enter","compareMarker","prevSelectors","pseudoSignature","some","selector","isEqualSelectors","appendList","remove","diff","compareDeclarations","eq","ne1","ne2","addSelectors","selectorLength","blockLength","fromArray","newSelector","loc","copy","newBlockLength","newItem","createItem","ne2overrided","insert","prevSelector","module","exports","restructRule","ast","reverse"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/csso/lib/restructure/8-restructRuleset.js"],"sourcesContent":["var List = require('css-tree').List;\nvar walk = require('css-tree').walk;\nvar utils = require('./utils');\n\nfunction calcSelectorLength(list) {\n    var length = 0;\n\n    list.each(function(data) {\n        length += data.id.length + 1;\n    });\n\n    return length - 1;\n}\n\nfunction calcDeclarationsLength(tokens) {\n    var length = 0;\n\n    for (var i = 0; i < tokens.length; i++) {\n        length += tokens[i].length;\n    }\n\n    return (\n        length +          // declarations\n        tokens.length - 1 // delimeters\n    );\n}\n\nfunction processRule(node, item, list) {\n    var avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;\n    var selectors = node.prelude.children;\n    var block = node.block;\n    var disallowDownMarkers = Object.create(null);\n    var allowMergeUp = true;\n    var allowMergeDown = true;\n\n    list.prevUntil(item.prev, function(prev, prevItem) {\n        var prevBlock = prev.block;\n        var prevType = prev.type;\n\n        if (prevType !== 'Rule') {\n            var unsafe = utils.unsafeToSkipNode.call(selectors, prev);\n\n            if (!unsafe && prevType === 'Atrule' && prevBlock) {\n                walk(prevBlock, {\n                    visit: 'Rule',\n                    enter: function(node) {\n                        node.prelude.children.each(function(data) {\n                            disallowDownMarkers[data.compareMarker] = true;\n                        });\n                    }\n                });\n            }\n\n            return unsafe;\n        }\n\n        var prevSelectors = prev.prelude.children;\n\n        if (node.pseudoSignature !== prev.pseudoSignature) {\n            return true;\n        }\n\n        allowMergeDown = !prevSelectors.some(function(selector) {\n            return selector.compareMarker in disallowDownMarkers;\n        });\n\n        // try prev ruleset if simpleselectors has no equal specifity and element selector\n        if (!allowMergeDown && !allowMergeUp) {\n            return true;\n        }\n\n        // try to join by selectors\n        if (allowMergeUp && utils.isEqualSelectors(prevSelectors, selectors)) {\n            prevBlock.children.appendList(block.children);\n            list.remove(item);\n            return true;\n        }\n\n        // try to join by properties\n        var diff = utils.compareDeclarations(block.children, prevBlock.children);\n\n        // console.log(diff.eq, diff.ne1, diff.ne2);\n\n        if (diff.eq.length) {\n            if (!diff.ne1.length && !diff.ne2.length) {\n                // equal blocks\n                if (allowMergeDown) {\n                    utils.addSelectors(selectors, prevSelectors);\n                    list.remove(prevItem);\n                }\n\n                return true;\n            } else if (!avoidRulesMerge) { /* probably we don't need to prevent those merges for @keyframes\n                                              TODO: need to be checked */\n\n                if (diff.ne1.length && !diff.ne2.length) {\n                    // prevBlock is subset block\n                    var selectorLength = calcSelectorLength(selectors);\n                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length\n\n                    if (allowMergeUp && selectorLength < blockLength) {\n                        utils.addSelectors(prevSelectors, selectors);\n                        block.children = new List().fromArray(diff.ne1);\n                    }\n                } else if (!diff.ne1.length && diff.ne2.length) {\n                    // node is subset of prevBlock\n                    var selectorLength = calcSelectorLength(prevSelectors);\n                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length\n\n                    if (allowMergeDown && selectorLength < blockLength) {\n                        utils.addSelectors(selectors, prevSelectors);\n                        prevBlock.children = new List().fromArray(diff.ne2);\n                    }\n                } else {\n                    // diff.ne1.length && diff.ne2.length\n                    // extract equal block\n                    var newSelector = {\n                        type: 'SelectorList',\n                        loc: null,\n                        children: utils.addSelectors(prevSelectors.copy(), selectors)\n                    };\n                    var newBlockLength = calcSelectorLength(newSelector.children) + 2; // selectors length + curly braces length\n                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length\n\n                    // create new ruleset if declarations length greater than\n                    // ruleset description overhead\n                    if (blockLength >= newBlockLength) {\n                        var newItem = list.createItem({\n                            type: 'Rule',\n                            loc: null,\n                            prelude: newSelector,\n                            block: {\n                                type: 'Block',\n                                loc: null,\n                                children: new List().fromArray(diff.eq)\n                            },\n                            pseudoSignature: node.pseudoSignature\n                        });\n\n                        block.children = new List().fromArray(diff.ne1);\n                        prevBlock.children = new List().fromArray(diff.ne2overrided);\n\n                        if (allowMergeUp) {\n                            list.insert(newItem, prevItem);\n                        } else {\n                            list.insert(newItem, item);\n                        }\n\n                        return true;\n                    }\n                }\n            }\n        }\n\n        if (allowMergeUp) {\n            // TODO: disallow up merge only if any property interception only (i.e. diff.ne2overrided.length > 0);\n            // await property families to find property interception correctly\n            allowMergeUp = !prevSelectors.some(function(prevSelector) {\n                return selectors.some(function(selector) {\n                    return selector.compareMarker === prevSelector.compareMarker;\n                });\n            });\n        }\n\n        prevSelectors.each(function(data) {\n            disallowDownMarkers[data.compareMarker] = true;\n        });\n    });\n}\n\nmodule.exports = function restructRule(ast) {\n    walk(ast, {\n        visit: 'Rule',\n        reverse: true,\n        enter: processRule\n    });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}