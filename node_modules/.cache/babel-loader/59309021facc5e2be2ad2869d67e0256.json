{"ast":null,"code":"'use strict';\n\nconst {\n  unit\n} = require('postcss-value-parser');\n\nconst {\n  getArguments\n} = require('cssnano-utils');\n\nconst addSpace = require('../lib/addSpace');\n\nconst getValue = require('../lib/getValue'); // animation: [ none | <keyframes-name> ] || <time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state>\n\n\nconst functions = new Set(['steps', 'cubic-bezier', 'frames']);\nconst keywords = new Set(['ease', 'ease-in', 'ease-in-out', 'ease-out', 'linear', 'step-end', 'step-start']);\nconst directions = new Set(['normal', 'reverse', 'alternate', 'alternate-reverse']);\nconst fillModes = new Set(['none', 'forwards', 'backwards', 'both']);\nconst playStates = new Set(['running', 'paused']);\nconst timeUnits = new Set(['ms', 's']);\n/**\n * @param {string} value\n * @param {string} type\n * @return {boolean}\n */\n\nconst isTimingFunction = (value, type) => {\n  return type === 'function' && functions.has(value) || keywords.has(value);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\n\n\nconst isDirection = value => {\n  return directions.has(value);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\n\n\nconst isFillMode = value => {\n  return fillModes.has(value);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\n\n\nconst isPlayState = value => {\n  return playStates.has(value);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\n\n\nconst isTime = value => {\n  const quantity = unit(value);\n  return quantity && timeUnits.has(quantity.unit);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\n\n\nconst isIterationCount = value => {\n  const quantity = unit(value);\n  return value === 'infinite' || quantity && !quantity.unit;\n};\n\nconst stateConditions = [{\n  property: 'duration',\n  delegate: isTime\n}, {\n  property: 'timingFunction',\n  delegate: isTimingFunction\n}, {\n  property: 'delay',\n  delegate: isTime\n}, {\n  property: 'iterationCount',\n  delegate: isIterationCount\n}, {\n  property: 'direction',\n  delegate: isDirection\n}, {\n  property: 'fillMode',\n  delegate: isFillMode\n}, {\n  property: 'playState',\n  delegate: isPlayState\n}];\n/**\n * @param {import('postcss-value-parser').Node[][]} args\n * @return {import('postcss-value-parser').Node[][]}\n */\n\nfunction normalize(args) {\n  const list = [];\n\n  for (const arg of args) {\n    /** @type {Record<string, import('postcss-value-parser').Node[]>} */\n    const state = {\n      name: [],\n      duration: [],\n      timingFunction: [],\n      delay: [],\n      iterationCount: [],\n      direction: [],\n      fillMode: [],\n      playState: []\n    };\n    arg.forEach(node => {\n      let {\n        type,\n        value\n      } = node;\n\n      if (type === 'space') {\n        return;\n      }\n\n      value = value.toLowerCase();\n      const hasMatch = stateConditions.some(_ref => {\n        let {\n          property,\n          delegate\n        } = _ref;\n\n        if (delegate(value, type) && !state[property].length) {\n          state[property] = [node, addSpace()];\n          return true;\n        }\n      });\n\n      if (!hasMatch) {\n        state.name = [...state.name, node, addSpace()];\n      }\n    });\n    list.push([...state.name, ...state.duration, ...state.timingFunction, ...state.delay, ...state.iterationCount, ...state.direction, ...state.fillMode, ...state.playState]);\n  }\n\n  return list;\n}\n/**\n * @param {import('postcss-value-parser').ParsedValue} parsed\n * @return {string}\n */\n\n\nmodule.exports = function normalizeAnimation(parsed) {\n  const values = normalize(getArguments(parsed));\n  return getValue(values);\n};","map":{"version":3,"names":["unit","require","getArguments","addSpace","getValue","functions","Set","keywords","directions","fillModes","playStates","timeUnits","isTimingFunction","value","type","has","isDirection","isFillMode","isPlayState","isTime","quantity","isIterationCount","stateConditions","property","delegate","normalize","args","list","arg","state","name","duration","timingFunction","delay","iterationCount","direction","fillMode","playState","forEach","node","toLowerCase","hasMatch","some","length","push","module","exports","normalizeAnimation","parsed","values"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-ordered-values/src/rules/animation.js"],"sourcesContent":["'use strict';\nconst { unit } = require('postcss-value-parser');\nconst { getArguments } = require('cssnano-utils');\nconst addSpace = require('../lib/addSpace');\nconst getValue = require('../lib/getValue');\n\n// animation: [ none | <keyframes-name> ] || <time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state>\nconst functions = new Set(['steps', 'cubic-bezier', 'frames']);\nconst keywords = new Set([\n  'ease',\n  'ease-in',\n  'ease-in-out',\n  'ease-out',\n  'linear',\n  'step-end',\n  'step-start',\n]);\n\nconst directions = new Set([\n  'normal',\n  'reverse',\n  'alternate',\n  'alternate-reverse',\n]);\nconst fillModes = new Set(['none', 'forwards', 'backwards', 'both']);\nconst playStates = new Set(['running', 'paused']);\nconst timeUnits = new Set(['ms', 's']);\n\n/**\n * @param {string} value\n * @param {string} type\n * @return {boolean}\n */\nconst isTimingFunction = (value, type) => {\n  return (type === 'function' && functions.has(value)) || keywords.has(value);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\nconst isDirection = (value) => {\n  return directions.has(value);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\nconst isFillMode = (value) => {\n  return fillModes.has(value);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\nconst isPlayState = (value) => {\n  return playStates.has(value);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\nconst isTime = (value) => {\n  const quantity = unit(value);\n\n  return quantity && timeUnits.has(quantity.unit);\n};\n/**\n * @param {string} value\n * @return {boolean}\n */\nconst isIterationCount = (value) => {\n  const quantity = unit(value);\n\n  return value === 'infinite' || (quantity && !quantity.unit);\n};\n\nconst stateConditions = [\n  { property: 'duration', delegate: isTime },\n  { property: 'timingFunction', delegate: isTimingFunction },\n  { property: 'delay', delegate: isTime },\n  { property: 'iterationCount', delegate: isIterationCount },\n  { property: 'direction', delegate: isDirection },\n  { property: 'fillMode', delegate: isFillMode },\n  { property: 'playState', delegate: isPlayState },\n];\n/**\n * @param {import('postcss-value-parser').Node[][]} args\n * @return {import('postcss-value-parser').Node[][]}\n */\nfunction normalize(args) {\n  const list = [];\n\n  for (const arg of args) {\n    /** @type {Record<string, import('postcss-value-parser').Node[]>} */\n    const state = {\n      name: [],\n      duration: [],\n      timingFunction: [],\n      delay: [],\n      iterationCount: [],\n      direction: [],\n      fillMode: [],\n      playState: [],\n    };\n\n    arg.forEach((node) => {\n      let { type, value } = node;\n\n      if (type === 'space') {\n        return;\n      }\n\n      value = value.toLowerCase();\n\n      const hasMatch = stateConditions.some(({ property, delegate }) => {\n        if (delegate(value, type) && !state[property].length) {\n          state[property] = [node, addSpace()];\n          return true;\n        }\n      });\n\n      if (!hasMatch) {\n        state.name = [...state.name, node, addSpace()];\n      }\n    });\n\n    list.push([\n      ...state.name,\n      ...state.duration,\n      ...state.timingFunction,\n      ...state.delay,\n      ...state.iterationCount,\n      ...state.direction,\n      ...state.fillMode,\n      ...state.playState,\n    ]);\n  }\n  return list;\n}\n/**\n * @param {import('postcss-value-parser').ParsedValue} parsed\n * @return {string}\n */\nmodule.exports = function normalizeAnimation(parsed) {\n  const values = normalize(getArguments(parsed));\n\n  return getValue(values);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}