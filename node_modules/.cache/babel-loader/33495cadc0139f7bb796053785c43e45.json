{"ast":null,"code":"'use strict';\n\nconst convertUnit = require('./convertUnit.js');\n/**\n * @param {import('../parser').CalcNode} node\n * @return {node is import('../parser').ValueExpression}\n */\n\n\nfunction isValueType(node) {\n  switch (node.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n    case 'EmValue':\n    case 'ExValue':\n    case 'ChValue':\n    case 'RemValue':\n    case 'VhValue':\n    case 'VwValue':\n    case 'VminValue':\n    case 'VmaxValue':\n    case 'PercentageValue':\n    case 'Number':\n      return true;\n  }\n\n  return false;\n}\n/** @param {'-'|'+'} operator */\n\n\nfunction flip(operator) {\n  return operator === '+' ? '-' : '+';\n}\n/**\n * @param {string} operator\n * @returns {operator is '+'|'-'}\n */\n\n\nfunction isAddSubOperator(operator) {\n  return operator === '+' || operator === '-';\n}\n/**\n * @typedef {{preOperator: '+'|'-', node: import('../parser').CalcNode}} Collectible\n */\n\n/**\n * @param {'+'|'-'} preOperator\n * @param {import('../parser').CalcNode} node\n * @param {Collectible[]} collected\n * @param {number} precision\n */\n\n\nfunction collectAddSubItems(preOperator, node, collected, precision) {\n  if (!isAddSubOperator(preOperator)) {\n    throw new Error(`invalid operator ${preOperator}`);\n  }\n\n  if (isValueType(node)) {\n    const itemIndex = collected.findIndex(x => x.node.type === node.type);\n\n    if (itemIndex >= 0) {\n      if (node.value === 0) {\n        return;\n      } // can cast because of the criterion used to find itemIndex\n\n\n      const otherValueNode =\n      /** @type import('../parser').ValueExpression*/\n      collected[itemIndex].node;\n      const {\n        left: reducedNode,\n        right: current\n      } = convertNodesUnits(otherValueNode, node, precision);\n\n      if (collected[itemIndex].preOperator === '-') {\n        collected[itemIndex].preOperator = '+';\n        reducedNode.value *= -1;\n      }\n\n      if (preOperator === '+') {\n        reducedNode.value += current.value;\n      } else {\n        reducedNode.value -= current.value;\n      } // make sure reducedNode.value >= 0\n\n\n      if (reducedNode.value >= 0) {\n        collected[itemIndex] = {\n          node: reducedNode,\n          preOperator: '+'\n        };\n      } else {\n        reducedNode.value *= -1;\n        collected[itemIndex] = {\n          node: reducedNode,\n          preOperator: '-'\n        };\n      }\n    } else {\n      // make sure node.value >= 0\n      if (node.value >= 0) {\n        collected.push({\n          node,\n          preOperator\n        });\n      } else {\n        node.value *= -1;\n        collected.push({\n          node,\n          preOperator: flip(preOperator)\n        });\n      }\n    }\n  } else if (node.type === 'MathExpression') {\n    if (isAddSubOperator(node.operator)) {\n      collectAddSubItems(preOperator, node.left, collected, precision);\n      const collectRightOperator = preOperator === '-' ? flip(node.operator) : node.operator;\n      collectAddSubItems(collectRightOperator, node.right, collected, precision);\n    } else {\n      // * or /\n      const reducedNode = reduce(node, precision); // prevent infinite recursive call\n\n      if (reducedNode.type !== 'MathExpression' || isAddSubOperator(reducedNode.operator)) {\n        collectAddSubItems(preOperator, reducedNode, collected, precision);\n      } else {\n        collected.push({\n          node: reducedNode,\n          preOperator\n        });\n      }\n    }\n  } else if (node.type === 'ParenthesizedExpression') {\n    collectAddSubItems(preOperator, node.content, collected, precision);\n  } else {\n    collected.push({\n      node,\n      preOperator\n    });\n  }\n}\n/**\n * @param {import('../parser').CalcNode} node\n * @param {number} precision\n */\n\n\nfunction reduceAddSubExpression(node, precision) {\n  /** @type Collectible[] */\n  const collected = [];\n  collectAddSubItems('+', node, collected, precision);\n  const withoutZeroItem = collected.filter(item => !(isValueType(item.node) && item.node.value === 0));\n  const firstNonZeroItem = withoutZeroItem[0]; // could be undefined\n  // prevent producing \"calc(-var(--a))\" or \"calc()\"\n  // which is invalid css\n\n  if (!firstNonZeroItem || firstNonZeroItem.preOperator === '-' && !isValueType(firstNonZeroItem.node)) {\n    const firstZeroItem = collected.find(item => isValueType(item.node) && item.node.value === 0);\n\n    if (firstZeroItem) {\n      withoutZeroItem.unshift(firstZeroItem);\n    }\n  } // make sure the preOperator of the first item is +\n\n\n  if (withoutZeroItem[0].preOperator === '-' && isValueType(withoutZeroItem[0].node)) {\n    withoutZeroItem[0].node.value *= -1;\n    withoutZeroItem[0].preOperator = '+';\n  }\n\n  let root = withoutZeroItem[0].node;\n\n  for (let i = 1; i < withoutZeroItem.length; i++) {\n    root = {\n      type: 'MathExpression',\n      operator: withoutZeroItem[i].preOperator,\n      left: root,\n      right: withoutZeroItem[i].node\n    };\n  }\n\n  return root;\n}\n/**\n * @param {import('../parser').MathExpression} node\n */\n\n\nfunction reduceDivisionExpression(node) {\n  if (!isValueType(node.right)) {\n    return node;\n  }\n\n  if (node.right.type !== 'Number') {\n    throw new Error(`Cannot divide by \"${node.right.unit}\", number expected`);\n  }\n\n  return applyNumberDivision(node.left, node.right.value);\n}\n/**\n * apply (expr) / number\n *\n * @param {import('../parser').CalcNode} node\n * @param {number} divisor\n * @return {import('../parser').CalcNode}\n */\n\n\nfunction applyNumberDivision(node, divisor) {\n  if (divisor === 0) {\n    throw new Error('Cannot divide by zero');\n  }\n\n  if (isValueType(node)) {\n    node.value /= divisor;\n    return node;\n  }\n\n  if (node.type === 'MathExpression' && isAddSubOperator(node.operator)) {\n    // turn (a + b) / num into a/num + b/num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce division before reducing additions\"\n    return {\n      type: 'MathExpression',\n      operator: node.operator,\n      left: applyNumberDivision(node.left, divisor),\n      right: applyNumberDivision(node.right, divisor)\n    };\n  } // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n\n\n  return {\n    type: 'MathExpression',\n    operator: '/',\n    left: node,\n    right: {\n      type: 'Number',\n      value: divisor\n    }\n  };\n}\n/**\n * @param {import('../parser').MathExpression} node\n */\n\n\nfunction reduceMultiplicationExpression(node) {\n  // (expr) * number\n  if (node.right.type === 'Number') {\n    return applyNumberMultiplication(node.left, node.right.value);\n  } // number * (expr)\n\n\n  if (node.left.type === 'Number') {\n    return applyNumberMultiplication(node.right, node.left.value);\n  }\n\n  return node;\n}\n/**\n * apply (expr) * number\n * @param {number} multiplier\n * @param {import('../parser').CalcNode} node\n * @return {import('../parser').CalcNode}\n */\n\n\nfunction applyNumberMultiplication(node, multiplier) {\n  if (isValueType(node)) {\n    node.value *= multiplier;\n    return node;\n  }\n\n  if (node.type === 'MathExpression' && isAddSubOperator(node.operator)) {\n    // turn (a + b) * num into a*num + b*num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce multiplication before reducing additions\"\n    return {\n      type: 'MathExpression',\n      operator: node.operator,\n      left: applyNumberMultiplication(node.left, multiplier),\n      right: applyNumberMultiplication(node.right, multiplier)\n    };\n  } // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n\n\n  return {\n    type: 'MathExpression',\n    operator: '*',\n    left: node,\n    right: {\n      type: 'Number',\n      value: multiplier\n    }\n  };\n}\n/**\n * @param {import('../parser').ValueExpression} left\n * @param {import('../parser').ValueExpression} right\n * @param {number} precision\n */\n\n\nfunction convertNodesUnits(left, right, precision) {\n  switch (left.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n      if (right.type === left.type && right.unit && left.unit) {\n        const converted = convertUnit(right.value, right.unit, left.unit, precision);\n        right = {\n          type: left.type,\n          value: converted,\n          unit: left.unit\n        };\n      }\n\n      return {\n        left,\n        right\n      };\n\n    default:\n      return {\n        left,\n        right\n      };\n  }\n}\n/**\n * @param {import('../parser').ParenthesizedExpression} node\n */\n\n\nfunction includesNoCssProperties(node) {\n  return node.content.type !== 'Function' && (node.content.type !== 'MathExpression' || node.content.right.type !== 'Function' && node.content.left.type !== 'Function');\n}\n/**\n * @param {import('../parser').CalcNode} node\n * @param {number} precision\n * @return {import('../parser').CalcNode}\n */\n\n\nfunction reduce(node, precision) {\n  if (node.type === 'MathExpression') {\n    if (isAddSubOperator(node.operator)) {\n      // reduceAddSubExpression will call reduce recursively\n      return reduceAddSubExpression(node, precision);\n    }\n\n    node.left = reduce(node.left, precision);\n    node.right = reduce(node.right, precision);\n\n    switch (node.operator) {\n      case '/':\n        return reduceDivisionExpression(node);\n\n      case '*':\n        return reduceMultiplicationExpression(node);\n    }\n\n    return node;\n  }\n\n  if (node.type === 'ParenthesizedExpression') {\n    if (includesNoCssProperties(node)) {\n      return reduce(node.content, precision);\n    }\n  }\n\n  return node;\n}\n\nmodule.exports = reduce;","map":{"version":3,"names":["convertUnit","require","isValueType","node","type","flip","operator","isAddSubOperator","collectAddSubItems","preOperator","collected","precision","Error","itemIndex","findIndex","x","value","otherValueNode","left","reducedNode","right","current","convertNodesUnits","push","collectRightOperator","reduce","content","reduceAddSubExpression","withoutZeroItem","filter","item","firstNonZeroItem","firstZeroItem","find","unshift","root","i","length","reduceDivisionExpression","unit","applyNumberDivision","divisor","reduceMultiplicationExpression","applyNumberMultiplication","multiplier","converted","includesNoCssProperties","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-calc/src/lib/reducer.js"],"sourcesContent":["'use strict';\nconst convertUnit = require('./convertUnit.js');\n\n/**\n * @param {import('../parser').CalcNode} node\n * @return {node is import('../parser').ValueExpression}\n */\nfunction isValueType(node) {\n  switch (node.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n    case 'EmValue':\n    case 'ExValue':\n    case 'ChValue':\n    case 'RemValue':\n    case 'VhValue':\n    case 'VwValue':\n    case 'VminValue':\n    case 'VmaxValue':\n    case 'PercentageValue':\n    case 'Number':\n      return true;\n  }\n  return false;\n}\n\n/** @param {'-'|'+'} operator */\nfunction flip(operator) {\n  return operator === '+' ? '-' : '+';\n}\n\n/**\n * @param {string} operator\n * @returns {operator is '+'|'-'}\n */\nfunction isAddSubOperator(operator) {\n  return operator === '+' || operator === '-';\n}\n\n/**\n * @typedef {{preOperator: '+'|'-', node: import('../parser').CalcNode}} Collectible\n */\n\n/**\n * @param {'+'|'-'} preOperator\n * @param {import('../parser').CalcNode} node\n * @param {Collectible[]} collected\n * @param {number} precision\n */\nfunction collectAddSubItems(preOperator, node, collected, precision) {\n  if (!isAddSubOperator(preOperator)) {\n    throw new Error(`invalid operator ${preOperator}`);\n  }\n  if (isValueType(node)) {\n    const itemIndex = collected.findIndex((x) => x.node.type === node.type);\n    if (itemIndex >= 0) {\n      if (node.value === 0) {\n        return;\n      }\n      // can cast because of the criterion used to find itemIndex\n      const otherValueNode = /** @type import('../parser').ValueExpression*/ (\n        collected[itemIndex].node\n      );\n      const { left: reducedNode, right: current } = convertNodesUnits(\n        otherValueNode,\n        node,\n        precision\n      );\n\n      if (collected[itemIndex].preOperator === '-') {\n        collected[itemIndex].preOperator = '+';\n        reducedNode.value *= -1;\n      }\n      if (preOperator === '+') {\n        reducedNode.value += current.value;\n      } else {\n        reducedNode.value -= current.value;\n      }\n      // make sure reducedNode.value >= 0\n      if (reducedNode.value >= 0) {\n        collected[itemIndex] = { node: reducedNode, preOperator: '+' };\n      } else {\n        reducedNode.value *= -1;\n        collected[itemIndex] = { node: reducedNode, preOperator: '-' };\n      }\n    } else {\n      // make sure node.value >= 0\n      if (node.value >= 0) {\n        collected.push({ node, preOperator });\n      } else {\n        node.value *= -1;\n        collected.push({ node, preOperator: flip(preOperator) });\n      }\n    }\n  } else if (node.type === 'MathExpression') {\n    if (isAddSubOperator(node.operator)) {\n      collectAddSubItems(preOperator, node.left, collected, precision);\n      const collectRightOperator =\n        preOperator === '-' ? flip(node.operator) : node.operator;\n      collectAddSubItems(\n        collectRightOperator,\n        node.right,\n        collected,\n        precision\n      );\n    } else {\n      // * or /\n      const reducedNode = reduce(node, precision);\n      // prevent infinite recursive call\n      if (\n        reducedNode.type !== 'MathExpression' ||\n        isAddSubOperator(reducedNode.operator)\n      ) {\n        collectAddSubItems(preOperator, reducedNode, collected, precision);\n      } else {\n        collected.push({ node: reducedNode, preOperator });\n      }\n    }\n  } else if (node.type === 'ParenthesizedExpression') {\n    collectAddSubItems(preOperator, node.content, collected, precision);\n  } else {\n    collected.push({ node, preOperator });\n  }\n}\n\n/**\n * @param {import('../parser').CalcNode} node\n * @param {number} precision\n */\nfunction reduceAddSubExpression(node, precision) {\n  /** @type Collectible[] */\n  const collected = [];\n  collectAddSubItems('+', node, collected, precision);\n\n  const withoutZeroItem = collected.filter(\n    (item) => !(isValueType(item.node) && item.node.value === 0)\n  );\n  const firstNonZeroItem = withoutZeroItem[0]; // could be undefined\n\n  // prevent producing \"calc(-var(--a))\" or \"calc()\"\n  // which is invalid css\n  if (\n    !firstNonZeroItem ||\n    (firstNonZeroItem.preOperator === '-' &&\n      !isValueType(firstNonZeroItem.node))\n  ) {\n    const firstZeroItem = collected.find(\n      (item) => isValueType(item.node) && item.node.value === 0\n    );\n    if (firstZeroItem) {\n      withoutZeroItem.unshift(firstZeroItem);\n    }\n  }\n\n  // make sure the preOperator of the first item is +\n  if (\n    withoutZeroItem[0].preOperator === '-' &&\n    isValueType(withoutZeroItem[0].node)\n  ) {\n    withoutZeroItem[0].node.value *= -1;\n    withoutZeroItem[0].preOperator = '+';\n  }\n\n  let root = withoutZeroItem[0].node;\n  for (let i = 1; i < withoutZeroItem.length; i++) {\n    root = {\n      type: 'MathExpression',\n      operator: withoutZeroItem[i].preOperator,\n      left: root,\n      right: withoutZeroItem[i].node,\n    };\n  }\n\n  return root;\n}\n/**\n * @param {import('../parser').MathExpression} node\n */\nfunction reduceDivisionExpression(node) {\n  if (!isValueType(node.right)) {\n    return node;\n  }\n\n  if (node.right.type !== 'Number') {\n    throw new Error(`Cannot divide by \"${node.right.unit}\", number expected`);\n  }\n\n  return applyNumberDivision(node.left, node.right.value);\n}\n\n/**\n * apply (expr) / number\n *\n * @param {import('../parser').CalcNode} node\n * @param {number} divisor\n * @return {import('../parser').CalcNode}\n */\nfunction applyNumberDivision(node, divisor) {\n  if (divisor === 0) {\n    throw new Error('Cannot divide by zero');\n  }\n  if (isValueType(node)) {\n    node.value /= divisor;\n    return node;\n  }\n  if (node.type === 'MathExpression' && isAddSubOperator(node.operator)) {\n    // turn (a + b) / num into a/num + b/num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce division before reducing additions\"\n    return {\n      type: 'MathExpression',\n      operator: node.operator,\n      left: applyNumberDivision(node.left, divisor),\n      right: applyNumberDivision(node.right, divisor),\n    };\n  }\n  // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n  return {\n    type: 'MathExpression',\n    operator: '/',\n    left: node,\n    right: {\n      type: 'Number',\n      value: divisor,\n    },\n  };\n}\n/**\n * @param {import('../parser').MathExpression} node\n */\nfunction reduceMultiplicationExpression(node) {\n  // (expr) * number\n  if (node.right.type === 'Number') {\n    return applyNumberMultiplication(node.left, node.right.value);\n  }\n  // number * (expr)\n  if (node.left.type === 'Number') {\n    return applyNumberMultiplication(node.right, node.left.value);\n  }\n  return node;\n}\n\n/**\n * apply (expr) * number\n * @param {number} multiplier\n * @param {import('../parser').CalcNode} node\n * @return {import('../parser').CalcNode}\n */\nfunction applyNumberMultiplication(node, multiplier) {\n  if (isValueType(node)) {\n    node.value *= multiplier;\n    return node;\n  }\n  if (node.type === 'MathExpression' && isAddSubOperator(node.operator)) {\n    // turn (a + b) * num into a*num + b*num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce multiplication before reducing additions\"\n    return {\n      type: 'MathExpression',\n      operator: node.operator,\n      left: applyNumberMultiplication(node.left, multiplier),\n      right: applyNumberMultiplication(node.right, multiplier),\n    };\n  }\n  // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n  return {\n    type: 'MathExpression',\n    operator: '*',\n    left: node,\n    right: {\n      type: 'Number',\n      value: multiplier,\n    },\n  };\n}\n\n/**\n * @param {import('../parser').ValueExpression} left\n * @param {import('../parser').ValueExpression} right\n * @param {number} precision\n */\nfunction convertNodesUnits(left, right, precision) {\n  switch (left.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n      if (right.type === left.type && right.unit && left.unit) {\n        const converted = convertUnit(\n          right.value,\n          right.unit,\n          left.unit,\n          precision\n        );\n\n        right = {\n          type: left.type,\n          value: converted,\n          unit: left.unit,\n        };\n      }\n\n      return { left, right };\n    default:\n      return { left, right };\n  }\n}\n\n/**\n * @param {import('../parser').ParenthesizedExpression} node\n */\nfunction includesNoCssProperties(node) {\n  return (\n    node.content.type !== 'Function' &&\n    (node.content.type !== 'MathExpression' ||\n      (node.content.right.type !== 'Function' &&\n        node.content.left.type !== 'Function'))\n  );\n}\n/**\n * @param {import('../parser').CalcNode} node\n * @param {number} precision\n * @return {import('../parser').CalcNode}\n */\nfunction reduce(node, precision) {\n  if (node.type === 'MathExpression') {\n    if (isAddSubOperator(node.operator)) {\n      // reduceAddSubExpression will call reduce recursively\n      return reduceAddSubExpression(node, precision);\n    }\n    node.left = reduce(node.left, precision);\n    node.right = reduce(node.right, precision);\n    switch (node.operator) {\n      case '/':\n        return reduceDivisionExpression(node);\n      case '*':\n        return reduceMultiplicationExpression(node);\n    }\n\n    return node;\n  }\n\n  if (node.type === 'ParenthesizedExpression') {\n    if (includesNoCssProperties(node)) {\n      return reduce(node.content, precision);\n    }\n  }\n\n  return node;\n}\n\nmodule.exports = reduce;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}