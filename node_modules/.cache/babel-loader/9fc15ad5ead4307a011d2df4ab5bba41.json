{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n\n_export(exports, {\n  resolveMatches: () => resolveMatches,\n  generateRules: () => generateRules\n});\n\nconst _postcss = /*#__PURE__*/_interopRequireDefault(require(\"postcss\"));\n\nconst _postcssSelectorParser = /*#__PURE__*/_interopRequireDefault(require(\"postcss-selector-parser\"));\n\nconst _parseObjectStyles = /*#__PURE__*/_interopRequireDefault(require(\"../util/parseObjectStyles\"));\n\nconst _isPlainObject = /*#__PURE__*/_interopRequireDefault(require(\"../util/isPlainObject\"));\n\nconst _prefixSelector = /*#__PURE__*/_interopRequireDefault(require(\"../util/prefixSelector\"));\n\nconst _pluginUtils = require(\"../util/pluginUtils\");\n\nconst _log = /*#__PURE__*/_interopRequireDefault(require(\"../util/log\"));\n\nconst _sharedState = /*#__PURE__*/_interopRequireWildcard(require(\"./sharedState\"));\n\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\n\nconst _nameClass = require(\"../util/nameClass\");\n\nconst _dataTypes = require(\"../util/dataTypes\");\n\nconst _setupContextUtils = require(\"./setupContextUtils\");\n\nconst _isValidArbitraryValue = /*#__PURE__*/_interopRequireDefault(require(\"../util/isValidArbitraryValue\"));\n\nconst _splitAtTopLevelOnlyJs = require(\"../util/splitAtTopLevelOnly.js\");\n\nconst _featureFlags = require(\"../featureFlags\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nlet classNameParser = (0, _postcssSelectorParser.default)(selectors => {\n  return selectors.first.filter(_ref => {\n    let {\n      type\n    } = _ref;\n    return type === \"class\";\n  }).pop().value;\n});\n\nfunction getClassNameFromSelector(selector) {\n  return classNameParser.transformSync(selector);\n} // Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\n\n\nfunction* candidatePermutations(candidate) {\n  let lastIndex = Infinity;\n\n  while (lastIndex >= 0) {\n    let dashIdx;\n\n    if (lastIndex === Infinity && candidate.endsWith(\"]\")) {\n      let bracketIdx = candidate.indexOf(\"[\"); // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n      // eg. string[]\n\n      dashIdx = [\"-\", \"/\"].includes(candidate[bracketIdx - 1]) ? bracketIdx - 1 : -1;\n    } else {\n      dashIdx = candidate.lastIndexOf(\"-\", lastIndex);\n    }\n\n    if (dashIdx < 0) {\n      break;\n    }\n\n    let prefix = candidate.slice(0, dashIdx);\n    let modifier = candidate.slice(dashIdx + 1);\n    yield [prefix, modifier];\n    lastIndex = dashIdx - 1;\n  }\n}\n\nfunction applyPrefix(matches, context) {\n  if (matches.length === 0 || context.tailwindConfig.prefix === \"\") {\n    return matches;\n  }\n\n  for (let match of matches) {\n    let [meta] = match;\n\n    if (meta.options.respectPrefix) {\n      let container = _postcss.default.root({\n        nodes: [match[1].clone()]\n      });\n\n      let classCandidate = match[1].raws.tailwind.classCandidate;\n      container.walkRules(r => {\n        // If this is a negative utility with a dash *before* the prefix we\n        // have to ensure that the generated selector matches the candidate\n        // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`\n        // The disconnect between candidate <-> class can cause @apply to hard crash.\n        let shouldPrependNegative = classCandidate.startsWith(\"-\");\n        r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);\n      });\n      match[1] = container.nodes[0];\n    }\n  }\n\n  return matches;\n}\n\nfunction applyImportant(matches, classCandidate) {\n  if (matches.length === 0) {\n    return matches;\n  }\n\n  let result = [];\n\n  for (let [meta, rule] of matches) {\n    let container = _postcss.default.root({\n      nodes: [rule.clone()]\n    });\n\n    container.walkRules(r => {\n      r.selector = (0, _pluginUtils.updateAllClasses)(r.selector, className => {\n        if (className === classCandidate) {\n          return `!${className}`;\n        }\n\n        return className;\n      });\n      r.walkDecls(d => d.important = true);\n    });\n    result.push([{ ...meta,\n      important: true\n    }, container.nodes[0]]);\n  }\n\n  return result;\n} // Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\n\n\nfunction applyVariant(variant, matches, context) {\n  if (matches.length === 0) {\n    return matches;\n  }\n\n  let args; // Find partial arbitrary variants\n\n  if (variant.endsWith(\"]\") && !variant.startsWith(\"[\")) {\n    args = variant.slice(variant.lastIndexOf(\"[\") + 1, -1);\n    variant = variant.slice(0, variant.indexOf(args) - 1\n    /* - */\n    - 1\n    /* [ */\n    );\n  } // Register arbitrary variants\n\n\n  if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {\n    let selector = (0, _dataTypes.normalize)(variant.slice(1, -1));\n\n    if (!(0, _setupContextUtils.isValidVariantFormatString)(selector)) {\n      return [];\n    }\n\n    let fn = (0, _setupContextUtils.parseVariant)(selector);\n    let sort = Array.from(context.variantOrder.values()).pop() << 1n;\n    context.variantMap.set(variant, [[sort, fn]]);\n    context.variantOrder.set(variant, sort);\n  }\n\n  if (context.variantMap.has(variant)) {\n    let variantFunctionTuples = context.variantMap.get(variant).slice();\n    let result = [];\n\n    for (let [meta, rule] of matches) {\n      // Don't generate variants for user css\n      if (meta.layer === \"user\") {\n        continue;\n      }\n\n      let container = _postcss.default.root({\n        nodes: [rule.clone()]\n      });\n\n      for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples) {\n        let clone = containerFromArray !== null && containerFromArray !== void 0 ? containerFromArray : container.clone();\n        let collectedFormats = [];\n\n        function prepareBackup() {\n          // Already prepared, chicken out\n          if (clone.raws.neededBackup) {\n            return;\n          }\n\n          clone.raws.neededBackup = true;\n          clone.walkRules(rule => rule.raws.originalSelector = rule.selector);\n        }\n\n        function modifySelectors(modifierFunction) {\n          prepareBackup();\n          clone.each(rule => {\n            if (rule.type !== \"rule\") {\n              return;\n            }\n\n            rule.selectors = rule.selectors.map(selector => {\n              return modifierFunction({\n                get className() {\n                  return getClassNameFromSelector(selector);\n                },\n\n                selector\n              });\n            });\n          });\n          return clone;\n        }\n\n        let ruleWithVariant = variantFunction({\n          // Public API\n          get container() {\n            prepareBackup();\n            return clone;\n          },\n\n          separator: context.tailwindConfig.separator,\n          modifySelectors,\n\n          // Private API for now\n          wrap(wrapper) {\n            let nodes = clone.nodes;\n            clone.removeAll();\n            wrapper.append(nodes);\n            clone.append(wrapper);\n          },\n\n          format(selectorFormat) {\n            collectedFormats.push(selectorFormat);\n          },\n\n          args\n        }); // It can happen that a list of format strings is returned from within the function. In that\n        // case, we have to process them as well. We can use the existing `variantSort`.\n\n        if (Array.isArray(ruleWithVariant)) {\n          for (let [idx, variantFunction1] of ruleWithVariant.entries()) {\n            // This is a little bit scary since we are pushing to an array of items that we are\n            // currently looping over. However, you can also think of it like a processing queue\n            // where you keep handling jobs until everything is done and each job can queue more\n            // jobs if needed.\n            variantFunctionTuples.push([// TODO: This could have potential bugs if we shift the sort order from variant A far\n            // enough into the sort space of variant B. The chances are low, but if this happens\n            // then this might be the place too look at. One potential solution to this problem is\n            // reserving additional X places for these 'unknown' variants in between.\n            variantSort | BigInt(idx << ruleWithVariant.length), variantFunction1, // If the clone has been modified we have to pass that back\n            // though so each rule can use the modified container\n            clone.clone()]);\n          }\n\n          continue;\n        }\n\n        if (typeof ruleWithVariant === \"string\") {\n          collectedFormats.push(ruleWithVariant);\n        }\n\n        if (ruleWithVariant === null) {\n          continue;\n        } // We had to backup selectors, therefore we assume that somebody touched\n        // `container` or `modifySelectors`. Let's see if they did, so that we\n        // can restore the selectors, and collect the format strings.\n\n\n        if (clone.raws.neededBackup) {\n          delete clone.raws.neededBackup;\n          clone.walkRules(rule => {\n            let before = rule.raws.originalSelector;\n            if (!before) return;\n            delete rule.raws.originalSelector;\n            if (before === rule.selector) return; // No mutation happened\n\n            let modified = rule.selector; // Rebuild the base selector, this is what plugin authors would do\n            // as well. E.g.: `${variant}${separator}${className}`.\n            // However, plugin authors probably also prepend or append certain\n            // classes, pseudos, ids, ...\n\n            let rebuiltBase = (0, _postcssSelectorParser.default)(selectors => {\n              selectors.walkClasses(classNode => {\n                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;\n              });\n            }).processSync(before); // Now that we know the original selector, the new selector, and\n            // the rebuild part in between, we can replace the part that plugin\n            // authors need to rebuild with `&`, and eventually store it in the\n            // collectedFormats. Similar to what `format('...')` would do.\n            //\n            // E.g.:\n            //                   variant: foo\n            //                  selector: .markdown > p\n            //      modified (by plugin): .foo .foo\\\\:markdown > p\n            //    rebuiltBase (internal): .foo\\\\:markdown > p\n            //                    format: .foo &\n\n            collectedFormats.push(modified.replace(rebuiltBase, \"&\"));\n            rule.selector = before;\n          });\n        } // This tracks the originating layer for the variant\n        // For example:\n        // .sm:underline {} is a variant of something in the utilities layer\n        // .sm:container {} is a variant of the container component\n\n\n        clone.nodes[0].raws.tailwind = { ...clone.nodes[0].raws.tailwind,\n          parentLayer: meta.layer\n        };\n\n        var _collectedFormats;\n\n        let withOffset = [{ ...meta,\n          sort: variantSort | meta.sort,\n          collectedFormats: ((_collectedFormats = meta.collectedFormats) !== null && _collectedFormats !== void 0 ? _collectedFormats : []).concat(collectedFormats),\n          isArbitraryVariant: isArbitraryValue(variant)\n        }, clone.nodes[0]];\n        result.push(withOffset);\n      }\n    }\n\n    return result;\n  }\n\n  return [];\n}\n\nfunction parseRules(rule, cache) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  // PostCSS node\n  if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {\n    return [[rule], options];\n  } // Tuple\n\n\n  if (Array.isArray(rule)) {\n    return parseRules(rule[0], cache, rule[1]);\n  } // Simple object\n\n\n  if (!cache.has(rule)) {\n    cache.set(rule, (0, _parseObjectStyles.default)(rule));\n  }\n\n  return [cache.get(rule), options];\n}\n\nconst IS_VALID_PROPERTY_NAME = /^[a-z_-]/;\n\nfunction isValidPropName(name) {\n  return IS_VALID_PROPERTY_NAME.test(name);\n}\n/**\n * @param {string} declaration\n * @returns {boolean}\n */\n\n\nfunction looksLikeUri(declaration) {\n  // Quick bailout for obvious non-urls\n  // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem\n  if (!declaration.includes(\"://\")) {\n    return false;\n  }\n\n  try {\n    const url = new URL(declaration);\n    return url.scheme !== \"\" && url.host !== \"\";\n  } catch (err) {\n    // Definitely not a valid url\n    return false;\n  }\n}\n\nfunction isParsableNode(node) {\n  let isParsable = true;\n  node.walkDecls(decl => {\n    if (!isParsableCssValue(decl.name, decl.value)) {\n      isParsable = false;\n      return false;\n    }\n  });\n  return isParsable;\n}\n\nfunction isParsableCssValue(property, value) {\n  // We don't want to to treat [https://example.com] as a custom property\n  // Even though, according to the CSS grammar, it's a totally valid CSS declaration\n  // So we short-circuit here by checking if the custom property looks like a url\n  if (looksLikeUri(`${property}:${value}`)) {\n    return false;\n  }\n\n  try {\n    _postcss.default.parse(`a{${property}:${value}}`).toResult();\n\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction extractArbitraryProperty(classCandidate, context) {\n  var ref;\n  let [, property, value] = (ref = classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/)) !== null && ref !== void 0 ? ref : [];\n\n  if (value === undefined) {\n    return null;\n  }\n\n  if (!isValidPropName(property)) {\n    return null;\n  }\n\n  if (!(0, _isValidArbitraryValue.default)(value)) {\n    return null;\n  }\n\n  let normalized = (0, _dataTypes.normalize)(value);\n\n  if (!isParsableCssValue(property, normalized)) {\n    return null;\n  }\n\n  return [[{\n    sort: context.arbitraryPropertiesSort,\n    layer: \"utilities\"\n  }, () => ({\n    [(0, _nameClass.asClass)(classCandidate)]: {\n      [property]: normalized\n    }\n  })]];\n}\n\nfunction* resolveMatchedPlugins(classCandidate, context) {\n  if (context.candidateRuleMap.has(classCandidate)) {\n    yield [context.candidateRuleMap.get(classCandidate), \"DEFAULT\"];\n  }\n\n  yield* function* (arbitraryPropertyRule) {\n    if (arbitraryPropertyRule !== null) {\n      yield [arbitraryPropertyRule, \"DEFAULT\"];\n    }\n  }(extractArbitraryProperty(classCandidate, context));\n  let candidatePrefix = classCandidate;\n  let negative = false;\n  const twConfigPrefix = context.tailwindConfig.prefix;\n  const twConfigPrefixLen = twConfigPrefix.length;\n  const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);\n\n  if (candidatePrefix[twConfigPrefixLen] === \"-\" && hasMatchingPrefix) {\n    negative = true;\n    candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n  }\n\n  if (negative && context.candidateRuleMap.has(candidatePrefix)) {\n    yield [context.candidateRuleMap.get(candidatePrefix), \"-DEFAULT\"];\n  }\n\n  for (let [prefix, modifier] of candidatePermutations(candidatePrefix)) {\n    if (context.candidateRuleMap.has(prefix)) {\n      yield [context.candidateRuleMap.get(prefix), negative ? `-${modifier}` : modifier];\n    }\n  }\n}\n\nfunction splitWithSeparator(input, separator) {\n  if (input === _sharedState.NOT_ON_DEMAND) {\n    return [_sharedState.NOT_ON_DEMAND];\n  }\n\n  return Array.from((0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(input, separator));\n}\n\nfunction* recordCandidates(matches, classCandidate) {\n  for (const match of matches) {\n    var ref;\n    var ref1;\n    match[1].raws.tailwind = { ...match[1].raws.tailwind,\n      classCandidate,\n      preserveSource: (ref1 = (ref = match[0].options) === null || ref === void 0 ? void 0 : ref.preserveSource) !== null && ref1 !== void 0 ? ref1 : false\n    };\n    yield match;\n  }\n}\n\nfunction* resolveMatches(candidate, context) {\n  let original = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : candidate;\n  let separator = context.tailwindConfig.separator;\n  let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();\n  let important = false;\n\n  if (classCandidate.startsWith(\"!\")) {\n    important = true;\n    classCandidate = classCandidate.slice(1);\n  }\n\n  if ((0, _featureFlags.flagEnabled)(context.tailwindConfig, \"variantGrouping\")) {\n    if (classCandidate.startsWith(\"(\") && classCandidate.endsWith(\")\")) {\n      let base = variants.slice().reverse().join(separator);\n\n      for (let part of (0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(classCandidate.slice(1, -1), \",\")) {\n        yield* resolveMatches(base + separator + part, context, original);\n      }\n    }\n  } // TODO: Reintroduce this in ways that doesn't break on false positives\n  // function sortAgainst(toSort, against) {\n  //   return toSort.slice().sort((a, z) => {\n  //     return bigSign(against.get(a)[0] - against.get(z)[0])\n  //   })\n  // }\n  // let sorted = sortAgainst(variants, context.variantMap)\n  // if (sorted.toString() !== variants.toString()) {\n  //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n  //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n  // }\n\n\n  for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {\n    let matches = [];\n    let typesByMatches = new Map();\n    let [plugins, modifier] = matchedPlugins;\n    let isOnlyPlugin = plugins.length === 1;\n\n    for (let [sort, plugin] of plugins) {\n      let matchesPerPlugin = [];\n\n      if (typeof plugin === \"function\") {\n        for (let ruleSet of [].concat(plugin(modifier, {\n          isOnlyPlugin\n        }))) {\n          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n\n          for (let rule of rules) {\n            matchesPerPlugin.push([{ ...sort,\n              options: { ...sort.options,\n                ...options\n              }\n            }, rule]);\n          }\n        }\n      } else if (modifier === \"DEFAULT\" || modifier === \"-DEFAULT\") {\n        let ruleSet1 = plugin;\n        let [rules1, options1] = parseRules(ruleSet1, context.postCssNodeCache);\n\n        for (let rule1 of rules1) {\n          matchesPerPlugin.push([{ ...sort,\n            options: { ...sort.options,\n              ...options1\n            }\n          }, rule1]);\n        }\n      }\n\n      if (matchesPerPlugin.length > 0) {\n        var ref;\n        typesByMatches.set(matchesPerPlugin, (ref = sort.options) === null || ref === void 0 ? void 0 : ref.type);\n        matches.push(matchesPerPlugin);\n      }\n    }\n\n    if (isArbitraryValue(modifier)) {\n      // When generated arbitrary values are ambiguous, we can't know\n      // which to pick so don't generate any utilities for them\n      if (matches.length > 1) {\n        var ref1;\n        let typesPerPlugin = matches.map(match => new Set([...((ref1 = typesByMatches.get(match)) !== null && ref1 !== void 0 ? ref1 : [])])); // Remove duplicates, so that we can detect proper unique types for each plugin.\n\n        for (let pluginTypes of typesPerPlugin) {\n          for (let type of pluginTypes) {\n            let removeFromOwnGroup = false;\n\n            for (let otherGroup of typesPerPlugin) {\n              if (pluginTypes === otherGroup) continue;\n\n              if (otherGroup.has(type)) {\n                otherGroup.delete(type);\n                removeFromOwnGroup = true;\n              }\n            }\n\n            if (removeFromOwnGroup) pluginTypes.delete(type);\n          }\n        }\n\n        let messages = [];\n\n        for (let [idx, group] of typesPerPlugin.entries()) {\n          for (let type1 of group) {\n            let rules2 = matches[idx].map(_ref2 => {\n              let [, rule] = _ref2;\n              return rule;\n            }).flat().map(rule => rule.toString().split(\"\\n\").slice(1, -1) // Remove selector and closing '}'\n            .map(line => line.trim()).map(x => `      ${x}`) // Re-indent\n            .join(\"\\n\")).join(\"\\n\\n\");\n            messages.push(`  Use \\`${candidate.replace(\"[\", `[${type1}:`)}\\` for \\`${rules2.trim()}\\``);\n            break;\n          }\n        }\n\n        _log.default.warn([`The class \\`${candidate}\\` is ambiguous and matches multiple utilities.`, ...messages, `If this is content and not a class, replace it with \\`${candidate.replace(\"[\", \"&lsqb;\").replace(\"]\", \"&rsqb;\")}\\` to silence this warning.`]);\n\n        continue;\n      }\n\n      matches = matches.map(list => list.filter(match => isParsableNode(match[1])));\n    }\n\n    matches = matches.flat();\n    matches = Array.from(recordCandidates(matches, classCandidate));\n    matches = applyPrefix(matches, context);\n\n    if (important) {\n      matches = applyImportant(matches, classCandidate);\n    }\n\n    for (let variant of variants) {\n      matches = applyVariant(variant, matches, context);\n    }\n\n    for (let match of matches) {\n      match[1].raws.tailwind = { ...match[1].raws.tailwind,\n        candidate\n      }; // Apply final format selector\n\n      if (match[0].collectedFormats) {\n        let finalFormat = (0, _formatVariantSelector.formatVariantSelector)(\"&\", ...match[0].collectedFormats);\n\n        let container = _postcss.default.root({\n          nodes: [match[1].clone()]\n        });\n\n        container.walkRules(rule => {\n          var ref;\n          if (inKeyframes(rule)) return;\n          var ref1;\n          rule.selector = (0, _formatVariantSelector.finalizeSelector)(finalFormat, {\n            selector: rule.selector,\n            candidate: original,\n            base: candidate.split(new RegExp(`\\\\${(ref1 = context === null || context === void 0 ? void 0 : (ref = context.tailwindConfig) === null || ref === void 0 ? void 0 : ref.separator) !== null && ref1 !== void 0 ? ref1 : \":\"}(?![^[]*\\\\])`)).pop(),\n            isArbitraryVariant: match[0].isArbitraryVariant,\n            context\n          });\n        });\n        match[1] = container.nodes[0];\n      }\n\n      yield match;\n    }\n  }\n}\n\nfunction inKeyframes(rule) {\n  return rule.parent && rule.parent.type === \"atrule\" && rule.parent.name === \"keyframes\";\n}\n\nfunction generateRules(candidates, context) {\n  let allRules = [];\n\n  for (let candidate of candidates) {\n    if (context.notClassCache.has(candidate)) {\n      continue;\n    }\n\n    if (context.classCache.has(candidate)) {\n      allRules.push(context.classCache.get(candidate));\n      continue;\n    }\n\n    let matches = Array.from(resolveMatches(candidate, context));\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n\n    context.classCache.set(candidate, matches);\n    allRules.push(matches);\n  } // Strategy based on `tailwindConfig.important`\n\n\n  let strategy = (important => {\n    if (important === true) {\n      return rule => {\n        rule.walkDecls(d => {\n          if (d.parent.type === \"rule\" && !inKeyframes(d.parent)) {\n            d.important = true;\n          }\n        });\n      };\n    }\n\n    if (typeof important === \"string\") {\n      return rule => {\n        rule.selectors = rule.selectors.map(selector => {\n          return `${important} ${selector}`;\n        });\n      };\n    }\n  })(context.tailwindConfig.important);\n\n  return allRules.flat(1).map(_ref3 => {\n    let [{\n      sort,\n      layer,\n      options\n    }, rule] = _ref3;\n\n    if (options.respectImportant) {\n      if (strategy) {\n        let container = _postcss.default.root({\n          nodes: [rule.clone()]\n        });\n\n        container.walkRules(r => {\n          if (inKeyframes(r)) {\n            return;\n          }\n\n          strategy(r);\n        });\n        rule = container.nodes[0];\n      }\n    }\n\n    return [sort | context.layerOrder[layer], rule];\n  });\n}\n\nfunction isArbitraryValue(input) {\n  return input.startsWith(\"[\") && input.endsWith(\"]\");\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","resolveMatches","generateRules","_postcss","_interopRequireDefault","require","_postcssSelectorParser","_parseObjectStyles","_isPlainObject","_prefixSelector","_pluginUtils","_log","_sharedState","_interopRequireWildcard","_formatVariantSelector","_nameClass","_dataTypes","_setupContextUtils","_isValidArbitraryValue","_splitAtTopLevelOnlyJs","_featureFlags","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","classNameParser","selectors","first","filter","type","pop","getClassNameFromSelector","selector","transformSync","candidatePermutations","candidate","lastIndex","Infinity","dashIdx","endsWith","bracketIdx","indexOf","includes","lastIndexOf","prefix","slice","modifier","applyPrefix","matches","context","length","tailwindConfig","match","meta","options","respectPrefix","container","root","nodes","clone","classCandidate","raws","tailwind","walkRules","r","shouldPrependNegative","startsWith","applyImportant","result","rule","updateAllClasses","className","walkDecls","d","important","push","applyVariant","variant","args","isArbitraryValue","variantMap","normalize","isValidVariantFormatString","fn","parseVariant","sort","Array","from","variantOrder","values","variantFunctionTuples","layer","variantSort","variantFunction","containerFromArray","collectedFormats","prepareBackup","neededBackup","originalSelector","modifySelectors","modifierFunction","each","map","ruleWithVariant","separator","wrap","wrapper","removeAll","append","format","selectorFormat","isArray","idx","variantFunction1","entries","BigInt","before","modified","rebuiltBase","walkClasses","classNode","processSync","replace","parentLayer","_collectedFormats","withOffset","concat","isArbitraryVariant","parseRules","IS_VALID_PROPERTY_NAME","isValidPropName","test","looksLikeUri","declaration","url","URL","scheme","host","err","isParsableNode","node","isParsable","decl","isParsableCssValue","property","parse","toResult","extractArbitraryProperty","ref","undefined","normalized","arbitraryPropertiesSort","asClass","resolveMatchedPlugins","candidateRuleMap","arbitraryPropertyRule","candidatePrefix","negative","twConfigPrefix","twConfigPrefixLen","hasMatchingPrefix","splitWithSeparator","input","NOT_ON_DEMAND","splitAtTopLevelOnly","recordCandidates","ref1","preserveSource","original","variants","reverse","flagEnabled","base","join","part","matchedPlugins","typesByMatches","Map","plugins","isOnlyPlugin","plugin","matchesPerPlugin","ruleSet","rules","postCssNodeCache","ruleSet1","rules1","options1","rule1","typesPerPlugin","Set","pluginTypes","removeFromOwnGroup","otherGroup","delete","messages","group","type1","rules2","flat","toString","split","line","trim","x","warn","list","finalFormat","formatVariantSelector","inKeyframes","finalizeSelector","RegExp","parent","candidates","allRules","notClassCache","classCache","add","strategy","respectImportant","layerOrder"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/lib/lib/generateRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    resolveMatches: ()=>resolveMatches,\n    generateRules: ()=>generateRules\n});\nconst _postcss = /*#__PURE__*/ _interopRequireDefault(require(\"postcss\"));\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _parseObjectStyles = /*#__PURE__*/ _interopRequireDefault(require(\"../util/parseObjectStyles\"));\nconst _isPlainObject = /*#__PURE__*/ _interopRequireDefault(require(\"../util/isPlainObject\"));\nconst _prefixSelector = /*#__PURE__*/ _interopRequireDefault(require(\"../util/prefixSelector\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _log = /*#__PURE__*/ _interopRequireDefault(require(\"../util/log\"));\nconst _sharedState = /*#__PURE__*/ _interopRequireWildcard(require(\"./sharedState\"));\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nconst _nameClass = require(\"../util/nameClass\");\nconst _dataTypes = require(\"../util/dataTypes\");\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _isValidArbitraryValue = /*#__PURE__*/ _interopRequireDefault(require(\"../util/isValidArbitraryValue\"));\nconst _splitAtTopLevelOnlyJs = require(\"../util/splitAtTopLevelOnly.js\");\nconst _featureFlags = require(\"../featureFlags\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet classNameParser = (0, _postcssSelectorParser.default)((selectors)=>{\n    return selectors.first.filter(({ type  })=>type === \"class\").pop().value;\n});\nfunction getClassNameFromSelector(selector) {\n    return classNameParser.transformSync(selector);\n}\n// Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\nfunction* candidatePermutations(candidate) {\n    let lastIndex = Infinity;\n    while(lastIndex >= 0){\n        let dashIdx;\n        if (lastIndex === Infinity && candidate.endsWith(\"]\")) {\n            let bracketIdx = candidate.indexOf(\"[\");\n            // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n            // eg. string[]\n            dashIdx = [\n                \"-\",\n                \"/\"\n            ].includes(candidate[bracketIdx - 1]) ? bracketIdx - 1 : -1;\n        } else {\n            dashIdx = candidate.lastIndexOf(\"-\", lastIndex);\n        }\n        if (dashIdx < 0) {\n            break;\n        }\n        let prefix = candidate.slice(0, dashIdx);\n        let modifier = candidate.slice(dashIdx + 1);\n        yield [\n            prefix,\n            modifier\n        ];\n        lastIndex = dashIdx - 1;\n    }\n}\nfunction applyPrefix(matches, context) {\n    if (matches.length === 0 || context.tailwindConfig.prefix === \"\") {\n        return matches;\n    }\n    for (let match of matches){\n        let [meta] = match;\n        if (meta.options.respectPrefix) {\n            let container = _postcss.default.root({\n                nodes: [\n                    match[1].clone()\n                ]\n            });\n            let classCandidate = match[1].raws.tailwind.classCandidate;\n            container.walkRules((r)=>{\n                // If this is a negative utility with a dash *before* the prefix we\n                // have to ensure that the generated selector matches the candidate\n                // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`\n                // The disconnect between candidate <-> class can cause @apply to hard crash.\n                let shouldPrependNegative = classCandidate.startsWith(\"-\");\n                r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);\n            });\n            match[1] = container.nodes[0];\n        }\n    }\n    return matches;\n}\nfunction applyImportant(matches, classCandidate) {\n    if (matches.length === 0) {\n        return matches;\n    }\n    let result = [];\n    for (let [meta, rule] of matches){\n        let container = _postcss.default.root({\n            nodes: [\n                rule.clone()\n            ]\n        });\n        container.walkRules((r)=>{\n            r.selector = (0, _pluginUtils.updateAllClasses)(r.selector, (className)=>{\n                if (className === classCandidate) {\n                    return `!${className}`;\n                }\n                return className;\n            });\n            r.walkDecls((d)=>d.important = true);\n        });\n        result.push([\n            {\n                ...meta,\n                important: true\n            },\n            container.nodes[0]\n        ]);\n    }\n    return result;\n}\n// Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\nfunction applyVariant(variant, matches, context) {\n    if (matches.length === 0) {\n        return matches;\n    }\n    let args;\n    // Find partial arbitrary variants\n    if (variant.endsWith(\"]\") && !variant.startsWith(\"[\")) {\n        args = variant.slice(variant.lastIndexOf(\"[\") + 1, -1);\n        variant = variant.slice(0, variant.indexOf(args) - 1 /* - */  - 1 /* [ */ );\n    }\n    // Register arbitrary variants\n    if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {\n        let selector = (0, _dataTypes.normalize)(variant.slice(1, -1));\n        if (!(0, _setupContextUtils.isValidVariantFormatString)(selector)) {\n            return [];\n        }\n        let fn = (0, _setupContextUtils.parseVariant)(selector);\n        let sort = Array.from(context.variantOrder.values()).pop() << 1n;\n        context.variantMap.set(variant, [\n            [\n                sort,\n                fn\n            ]\n        ]);\n        context.variantOrder.set(variant, sort);\n    }\n    if (context.variantMap.has(variant)) {\n        let variantFunctionTuples = context.variantMap.get(variant).slice();\n        let result = [];\n        for (let [meta, rule] of matches){\n            // Don't generate variants for user css\n            if (meta.layer === \"user\") {\n                continue;\n            }\n            let container = _postcss.default.root({\n                nodes: [\n                    rule.clone()\n                ]\n            });\n            for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples){\n                let clone = containerFromArray !== null && containerFromArray !== void 0 ? containerFromArray : container.clone();\n                let collectedFormats = [];\n                function prepareBackup() {\n                    // Already prepared, chicken out\n                    if (clone.raws.neededBackup) {\n                        return;\n                    }\n                    clone.raws.neededBackup = true;\n                    clone.walkRules((rule)=>rule.raws.originalSelector = rule.selector);\n                }\n                function modifySelectors(modifierFunction) {\n                    prepareBackup();\n                    clone.each((rule)=>{\n                        if (rule.type !== \"rule\") {\n                            return;\n                        }\n                        rule.selectors = rule.selectors.map((selector)=>{\n                            return modifierFunction({\n                                get className () {\n                                    return getClassNameFromSelector(selector);\n                                },\n                                selector\n                            });\n                        });\n                    });\n                    return clone;\n                }\n                let ruleWithVariant = variantFunction({\n                    // Public API\n                    get container () {\n                        prepareBackup();\n                        return clone;\n                    },\n                    separator: context.tailwindConfig.separator,\n                    modifySelectors,\n                    // Private API for now\n                    wrap (wrapper) {\n                        let nodes = clone.nodes;\n                        clone.removeAll();\n                        wrapper.append(nodes);\n                        clone.append(wrapper);\n                    },\n                    format (selectorFormat) {\n                        collectedFormats.push(selectorFormat);\n                    },\n                    args\n                });\n                // It can happen that a list of format strings is returned from within the function. In that\n                // case, we have to process them as well. We can use the existing `variantSort`.\n                if (Array.isArray(ruleWithVariant)) {\n                    for (let [idx, variantFunction1] of ruleWithVariant.entries()){\n                        // This is a little bit scary since we are pushing to an array of items that we are\n                        // currently looping over. However, you can also think of it like a processing queue\n                        // where you keep handling jobs until everything is done and each job can queue more\n                        // jobs if needed.\n                        variantFunctionTuples.push([\n                            // TODO: This could have potential bugs if we shift the sort order from variant A far\n                            // enough into the sort space of variant B. The chances are low, but if this happens\n                            // then this might be the place too look at. One potential solution to this problem is\n                            // reserving additional X places for these 'unknown' variants in between.\n                            variantSort | BigInt(idx << ruleWithVariant.length),\n                            variantFunction1,\n                            // If the clone has been modified we have to pass that back\n                            // though so each rule can use the modified container\n                            clone.clone(), \n                        ]);\n                    }\n                    continue;\n                }\n                if (typeof ruleWithVariant === \"string\") {\n                    collectedFormats.push(ruleWithVariant);\n                }\n                if (ruleWithVariant === null) {\n                    continue;\n                }\n                // We had to backup selectors, therefore we assume that somebody touched\n                // `container` or `modifySelectors`. Let's see if they did, so that we\n                // can restore the selectors, and collect the format strings.\n                if (clone.raws.neededBackup) {\n                    delete clone.raws.neededBackup;\n                    clone.walkRules((rule)=>{\n                        let before = rule.raws.originalSelector;\n                        if (!before) return;\n                        delete rule.raws.originalSelector;\n                        if (before === rule.selector) return; // No mutation happened\n                        let modified = rule.selector;\n                        // Rebuild the base selector, this is what plugin authors would do\n                        // as well. E.g.: `${variant}${separator}${className}`.\n                        // However, plugin authors probably also prepend or append certain\n                        // classes, pseudos, ids, ...\n                        let rebuiltBase = (0, _postcssSelectorParser.default)((selectors)=>{\n                            selectors.walkClasses((classNode)=>{\n                                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;\n                            });\n                        }).processSync(before);\n                        // Now that we know the original selector, the new selector, and\n                        // the rebuild part in between, we can replace the part that plugin\n                        // authors need to rebuild with `&`, and eventually store it in the\n                        // collectedFormats. Similar to what `format('...')` would do.\n                        //\n                        // E.g.:\n                        //                   variant: foo\n                        //                  selector: .markdown > p\n                        //      modified (by plugin): .foo .foo\\\\:markdown > p\n                        //    rebuiltBase (internal): .foo\\\\:markdown > p\n                        //                    format: .foo &\n                        collectedFormats.push(modified.replace(rebuiltBase, \"&\"));\n                        rule.selector = before;\n                    });\n                }\n                // This tracks the originating layer for the variant\n                // For example:\n                // .sm:underline {} is a variant of something in the utilities layer\n                // .sm:container {} is a variant of the container component\n                clone.nodes[0].raws.tailwind = {\n                    ...clone.nodes[0].raws.tailwind,\n                    parentLayer: meta.layer\n                };\n                var _collectedFormats;\n                let withOffset = [\n                    {\n                        ...meta,\n                        sort: variantSort | meta.sort,\n                        collectedFormats: ((_collectedFormats = meta.collectedFormats) !== null && _collectedFormats !== void 0 ? _collectedFormats : []).concat(collectedFormats),\n                        isArbitraryVariant: isArbitraryValue(variant)\n                    },\n                    clone.nodes[0], \n                ];\n                result.push(withOffset);\n            }\n        }\n        return result;\n    }\n    return [];\n}\nfunction parseRules(rule, cache, options = {}) {\n    // PostCSS node\n    if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {\n        return [\n            [\n                rule\n            ],\n            options\n        ];\n    }\n    // Tuple\n    if (Array.isArray(rule)) {\n        return parseRules(rule[0], cache, rule[1]);\n    }\n    // Simple object\n    if (!cache.has(rule)) {\n        cache.set(rule, (0, _parseObjectStyles.default)(rule));\n    }\n    return [\n        cache.get(rule),\n        options\n    ];\n}\nconst IS_VALID_PROPERTY_NAME = /^[a-z_-]/;\nfunction isValidPropName(name) {\n    return IS_VALID_PROPERTY_NAME.test(name);\n}\n/**\n * @param {string} declaration\n * @returns {boolean}\n */ function looksLikeUri(declaration) {\n    // Quick bailout for obvious non-urls\n    // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem\n    if (!declaration.includes(\"://\")) {\n        return false;\n    }\n    try {\n        const url = new URL(declaration);\n        return url.scheme !== \"\" && url.host !== \"\";\n    } catch (err) {\n        // Definitely not a valid url\n        return false;\n    }\n}\nfunction isParsableNode(node) {\n    let isParsable = true;\n    node.walkDecls((decl)=>{\n        if (!isParsableCssValue(decl.name, decl.value)) {\n            isParsable = false;\n            return false;\n        }\n    });\n    return isParsable;\n}\nfunction isParsableCssValue(property, value) {\n    // We don't want to to treat [https://example.com] as a custom property\n    // Even though, according to the CSS grammar, it's a totally valid CSS declaration\n    // So we short-circuit here by checking if the custom property looks like a url\n    if (looksLikeUri(`${property}:${value}`)) {\n        return false;\n    }\n    try {\n        _postcss.default.parse(`a{${property}:${value}}`).toResult();\n        return true;\n    } catch (err) {\n        return false;\n    }\n}\nfunction extractArbitraryProperty(classCandidate, context) {\n    var ref;\n    let [, property, value] = (ref = classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/)) !== null && ref !== void 0 ? ref : [];\n    if (value === undefined) {\n        return null;\n    }\n    if (!isValidPropName(property)) {\n        return null;\n    }\n    if (!(0, _isValidArbitraryValue.default)(value)) {\n        return null;\n    }\n    let normalized = (0, _dataTypes.normalize)(value);\n    if (!isParsableCssValue(property, normalized)) {\n        return null;\n    }\n    return [\n        [\n            {\n                sort: context.arbitraryPropertiesSort,\n                layer: \"utilities\"\n            },\n            ()=>({\n                    [(0, _nameClass.asClass)(classCandidate)]: {\n                        [property]: normalized\n                    }\n                }), \n        ], \n    ];\n}\nfunction* resolveMatchedPlugins(classCandidate, context) {\n    if (context.candidateRuleMap.has(classCandidate)) {\n        yield [\n            context.candidateRuleMap.get(classCandidate),\n            \"DEFAULT\"\n        ];\n    }\n    yield* function*(arbitraryPropertyRule) {\n        if (arbitraryPropertyRule !== null) {\n            yield [\n                arbitraryPropertyRule,\n                \"DEFAULT\"\n            ];\n        }\n    }(extractArbitraryProperty(classCandidate, context));\n    let candidatePrefix = classCandidate;\n    let negative = false;\n    const twConfigPrefix = context.tailwindConfig.prefix;\n    const twConfigPrefixLen = twConfigPrefix.length;\n    const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);\n    if (candidatePrefix[twConfigPrefixLen] === \"-\" && hasMatchingPrefix) {\n        negative = true;\n        candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n    }\n    if (negative && context.candidateRuleMap.has(candidatePrefix)) {\n        yield [\n            context.candidateRuleMap.get(candidatePrefix),\n            \"-DEFAULT\"\n        ];\n    }\n    for (let [prefix, modifier] of candidatePermutations(candidatePrefix)){\n        if (context.candidateRuleMap.has(prefix)) {\n            yield [\n                context.candidateRuleMap.get(prefix),\n                negative ? `-${modifier}` : modifier\n            ];\n        }\n    }\n}\nfunction splitWithSeparator(input, separator) {\n    if (input === _sharedState.NOT_ON_DEMAND) {\n        return [\n            _sharedState.NOT_ON_DEMAND\n        ];\n    }\n    return Array.from((0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(input, separator));\n}\nfunction* recordCandidates(matches, classCandidate) {\n    for (const match of matches){\n        var ref;\n        var ref1;\n        match[1].raws.tailwind = {\n            ...match[1].raws.tailwind,\n            classCandidate,\n            preserveSource: (ref1 = (ref = match[0].options) === null || ref === void 0 ? void 0 : ref.preserveSource) !== null && ref1 !== void 0 ? ref1 : false\n        };\n        yield match;\n    }\n}\nfunction* resolveMatches(candidate, context, original = candidate) {\n    let separator = context.tailwindConfig.separator;\n    let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();\n    let important = false;\n    if (classCandidate.startsWith(\"!\")) {\n        important = true;\n        classCandidate = classCandidate.slice(1);\n    }\n    if ((0, _featureFlags.flagEnabled)(context.tailwindConfig, \"variantGrouping\")) {\n        if (classCandidate.startsWith(\"(\") && classCandidate.endsWith(\")\")) {\n            let base = variants.slice().reverse().join(separator);\n            for (let part of (0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(classCandidate.slice(1, -1), \",\")){\n                yield* resolveMatches(base + separator + part, context, original);\n            }\n        }\n    }\n    // TODO: Reintroduce this in ways that doesn't break on false positives\n    // function sortAgainst(toSort, against) {\n    //   return toSort.slice().sort((a, z) => {\n    //     return bigSign(against.get(a)[0] - against.get(z)[0])\n    //   })\n    // }\n    // let sorted = sortAgainst(variants, context.variantMap)\n    // if (sorted.toString() !== variants.toString()) {\n    //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n    //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n    // }\n    for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)){\n        let matches = [];\n        let typesByMatches = new Map();\n        let [plugins, modifier] = matchedPlugins;\n        let isOnlyPlugin = plugins.length === 1;\n        for (let [sort, plugin] of plugins){\n            let matchesPerPlugin = [];\n            if (typeof plugin === \"function\") {\n                for (let ruleSet of [].concat(plugin(modifier, {\n                    isOnlyPlugin\n                }))){\n                    let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n                    for (let rule of rules){\n                        matchesPerPlugin.push([\n                            {\n                                ...sort,\n                                options: {\n                                    ...sort.options,\n                                    ...options\n                                }\n                            },\n                            rule\n                        ]);\n                    }\n                }\n            } else if (modifier === \"DEFAULT\" || modifier === \"-DEFAULT\") {\n                let ruleSet1 = plugin;\n                let [rules1, options1] = parseRules(ruleSet1, context.postCssNodeCache);\n                for (let rule1 of rules1){\n                    matchesPerPlugin.push([\n                        {\n                            ...sort,\n                            options: {\n                                ...sort.options,\n                                ...options1\n                            }\n                        },\n                        rule1\n                    ]);\n                }\n            }\n            if (matchesPerPlugin.length > 0) {\n                var ref;\n                typesByMatches.set(matchesPerPlugin, (ref = sort.options) === null || ref === void 0 ? void 0 : ref.type);\n                matches.push(matchesPerPlugin);\n            }\n        }\n        if (isArbitraryValue(modifier)) {\n            // When generated arbitrary values are ambiguous, we can't know\n            // which to pick so don't generate any utilities for them\n            if (matches.length > 1) {\n                var ref1;\n                let typesPerPlugin = matches.map((match)=>new Set([\n                        ...(ref1 = typesByMatches.get(match)) !== null && ref1 !== void 0 ? ref1 : []\n                    ]));\n                // Remove duplicates, so that we can detect proper unique types for each plugin.\n                for (let pluginTypes of typesPerPlugin){\n                    for (let type of pluginTypes){\n                        let removeFromOwnGroup = false;\n                        for (let otherGroup of typesPerPlugin){\n                            if (pluginTypes === otherGroup) continue;\n                            if (otherGroup.has(type)) {\n                                otherGroup.delete(type);\n                                removeFromOwnGroup = true;\n                            }\n                        }\n                        if (removeFromOwnGroup) pluginTypes.delete(type);\n                    }\n                }\n                let messages = [];\n                for (let [idx, group] of typesPerPlugin.entries()){\n                    for (let type1 of group){\n                        let rules2 = matches[idx].map(([, rule])=>rule).flat().map((rule)=>rule.toString().split(\"\\n\").slice(1, -1) // Remove selector and closing '}'\n                            .map((line)=>line.trim()).map((x)=>`      ${x}`) // Re-indent\n                            .join(\"\\n\")).join(\"\\n\\n\");\n                        messages.push(`  Use \\`${candidate.replace(\"[\", `[${type1}:`)}\\` for \\`${rules2.trim()}\\``);\n                        break;\n                    }\n                }\n                _log.default.warn([\n                    `The class \\`${candidate}\\` is ambiguous and matches multiple utilities.`,\n                    ...messages,\n                    `If this is content and not a class, replace it with \\`${candidate.replace(\"[\", \"&lsqb;\").replace(\"]\", \"&rsqb;\")}\\` to silence this warning.`, \n                ]);\n                continue;\n            }\n            matches = matches.map((list)=>list.filter((match)=>isParsableNode(match[1])));\n        }\n        matches = matches.flat();\n        matches = Array.from(recordCandidates(matches, classCandidate));\n        matches = applyPrefix(matches, context);\n        if (important) {\n            matches = applyImportant(matches, classCandidate);\n        }\n        for (let variant of variants){\n            matches = applyVariant(variant, matches, context);\n        }\n        for (let match of matches){\n            match[1].raws.tailwind = {\n                ...match[1].raws.tailwind,\n                candidate\n            };\n            // Apply final format selector\n            if (match[0].collectedFormats) {\n                let finalFormat = (0, _formatVariantSelector.formatVariantSelector)(\"&\", ...match[0].collectedFormats);\n                let container = _postcss.default.root({\n                    nodes: [\n                        match[1].clone()\n                    ]\n                });\n                container.walkRules((rule)=>{\n                    var ref;\n                    if (inKeyframes(rule)) return;\n                    var ref1;\n                    rule.selector = (0, _formatVariantSelector.finalizeSelector)(finalFormat, {\n                        selector: rule.selector,\n                        candidate: original,\n                        base: candidate.split(new RegExp(`\\\\${(ref1 = context === null || context === void 0 ? void 0 : (ref = context.tailwindConfig) === null || ref === void 0 ? void 0 : ref.separator) !== null && ref1 !== void 0 ? ref1 : \":\"}(?![^[]*\\\\])`)).pop(),\n                        isArbitraryVariant: match[0].isArbitraryVariant,\n                        context\n                    });\n                });\n                match[1] = container.nodes[0];\n            }\n            yield match;\n        }\n    }\n}\nfunction inKeyframes(rule) {\n    return rule.parent && rule.parent.type === \"atrule\" && rule.parent.name === \"keyframes\";\n}\nfunction generateRules(candidates, context) {\n    let allRules = [];\n    for (let candidate of candidates){\n        if (context.notClassCache.has(candidate)) {\n            continue;\n        }\n        if (context.classCache.has(candidate)) {\n            allRules.push(context.classCache.get(candidate));\n            continue;\n        }\n        let matches = Array.from(resolveMatches(candidate, context));\n        if (matches.length === 0) {\n            context.notClassCache.add(candidate);\n            continue;\n        }\n        context.classCache.set(candidate, matches);\n        allRules.push(matches);\n    }\n    // Strategy based on `tailwindConfig.important`\n    let strategy = ((important)=>{\n        if (important === true) {\n            return (rule)=>{\n                rule.walkDecls((d)=>{\n                    if (d.parent.type === \"rule\" && !inKeyframes(d.parent)) {\n                        d.important = true;\n                    }\n                });\n            };\n        }\n        if (typeof important === \"string\") {\n            return (rule)=>{\n                rule.selectors = rule.selectors.map((selector)=>{\n                    return `${important} ${selector}`;\n                });\n            };\n        }\n    })(context.tailwindConfig.important);\n    return allRules.flat(1).map(([{ sort , layer , options  }, rule])=>{\n        if (options.respectImportant) {\n            if (strategy) {\n                let container = _postcss.default.root({\n                    nodes: [\n                        rule.clone()\n                    ]\n                });\n                container.walkRules((r)=>{\n                    if (inKeyframes(r)) {\n                        return;\n                    }\n                    strategy(r);\n                });\n                rule = container.nodes[0];\n            }\n        }\n        return [\n            sort | context.layerOrder[layer],\n            rule\n        ];\n    });\n}\nfunction isArbitraryValue(input) {\n    return input.startsWith(\"[\") && input.endsWith(\"]\");\n}\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EACzCC,KAAK,EAAE;AADkC,CAA7C;;AAGA,SAASC,OAAT,CAAiBC,MAAjB,EAAyBC,GAAzB,EAA8B;EAC1B,KAAI,IAAIC,IAAR,IAAgBD,GAAhB,EAAoBN,MAAM,CAACC,cAAP,CAAsBI,MAAtB,EAA8BE,IAA9B,EAAoC;IACpDC,UAAU,EAAE,IADwC;IAEpDC,GAAG,EAAEH,GAAG,CAACC,IAAD;EAF4C,CAApC;AAIvB;;AACDH,OAAO,CAACF,OAAD,EAAU;EACbQ,cAAc,EAAE,MAAIA,cADP;EAEbC,aAAa,EAAE,MAAIA;AAFN,CAAV,CAAP;;AAIA,MAAMC,QAAQ,GAAG,aAAcC,sBAAsB,CAACC,OAAO,CAAC,SAAD,CAAR,CAArD;;AACA,MAAMC,sBAAsB,GAAG,aAAcF,sBAAsB,CAACC,OAAO,CAAC,yBAAD,CAAR,CAAnE;;AACA,MAAME,kBAAkB,GAAG,aAAcH,sBAAsB,CAACC,OAAO,CAAC,2BAAD,CAAR,CAA/D;;AACA,MAAMG,cAAc,GAAG,aAAcJ,sBAAsB,CAACC,OAAO,CAAC,uBAAD,CAAR,CAA3D;;AACA,MAAMI,eAAe,GAAG,aAAcL,sBAAsB,CAACC,OAAO,CAAC,wBAAD,CAAR,CAA5D;;AACA,MAAMK,YAAY,GAAGL,OAAO,CAAC,qBAAD,CAA5B;;AACA,MAAMM,IAAI,GAAG,aAAcP,sBAAsB,CAACC,OAAO,CAAC,aAAD,CAAR,CAAjD;;AACA,MAAMO,YAAY,GAAG,aAAcC,uBAAuB,CAACR,OAAO,CAAC,eAAD,CAAR,CAA1D;;AACA,MAAMS,sBAAsB,GAAGT,OAAO,CAAC,+BAAD,CAAtC;;AACA,MAAMU,UAAU,GAAGV,OAAO,CAAC,mBAAD,CAA1B;;AACA,MAAMW,UAAU,GAAGX,OAAO,CAAC,mBAAD,CAA1B;;AACA,MAAMY,kBAAkB,GAAGZ,OAAO,CAAC,qBAAD,CAAlC;;AACA,MAAMa,sBAAsB,GAAG,aAAcd,sBAAsB,CAACC,OAAO,CAAC,+BAAD,CAAR,CAAnE;;AACA,MAAMc,sBAAsB,GAAGd,OAAO,CAAC,gCAAD,CAAtC;;AACA,MAAMe,aAAa,GAAGf,OAAO,CAAC,iBAAD,CAA7B;;AACA,SAASD,sBAAT,CAAgCiB,GAAhC,EAAqC;EACjC,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;IACjCE,OAAO,EAAEF;EADwB,CAArC;AAGH;;AACD,SAASG,wBAAT,CAAkCC,WAAlC,EAA+C;EAC3C,IAAI,OAAOC,OAAP,KAAmB,UAAvB,EAAmC,OAAO,IAAP;EACnC,IAAIC,iBAAiB,GAAG,IAAID,OAAJ,EAAxB;EACA,IAAIE,gBAAgB,GAAG,IAAIF,OAAJ,EAAvB;EACA,OAAO,CAACF,wBAAwB,GAAG,UAASC,WAAT,EAAsB;IACrD,OAAOA,WAAW,GAAGG,gBAAH,GAAsBD,iBAAxC;EACH,CAFM,EAEJF,WAFI,CAAP;AAGH;;AACD,SAASZ,uBAAT,CAAiCQ,GAAjC,EAAsCI,WAAtC,EAAmD;EAC/C,IAAI,CAACA,WAAD,IAAgBJ,GAAhB,IAAuBA,GAAG,CAACC,UAA/B,EAA2C;IACvC,OAAOD,GAAP;EACH;;EACD,IAAIA,GAAG,KAAK,IAAR,IAAgB,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,UAA9D,EAA0E;IACtE,OAAO;MACHE,OAAO,EAAEF;IADN,CAAP;EAGH;;EACD,IAAIQ,KAAK,GAAGL,wBAAwB,CAACC,WAAD,CAApC;;EACA,IAAII,KAAK,IAAIA,KAAK,CAACC,GAAN,CAAUT,GAAV,CAAb,EAA6B;IACzB,OAAOQ,KAAK,CAAC7B,GAAN,CAAUqB,GAAV,CAAP;EACH;;EACD,IAAIU,MAAM,GAAG,EAAb;EACA,IAAIC,qBAAqB,GAAGzC,MAAM,CAACC,cAAP,IAAyBD,MAAM,CAAC0C,wBAA5D;;EACA,KAAI,IAAIC,GAAR,IAAeb,GAAf,EAAmB;IACf,IAAIa,GAAG,KAAK,SAAR,IAAqB3C,MAAM,CAAC4C,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqChB,GAArC,EAA0Ca,GAA1C,CAAzB,EAAyE;MACrE,IAAII,IAAI,GAAGN,qBAAqB,GAAGzC,MAAM,CAAC0C,wBAAP,CAAgCZ,GAAhC,EAAqCa,GAArC,CAAH,GAA+C,IAA/E;;MACA,IAAII,IAAI,KAAKA,IAAI,CAACtC,GAAL,IAAYsC,IAAI,CAACC,GAAtB,CAAR,EAAoC;QAChChD,MAAM,CAACC,cAAP,CAAsBuC,MAAtB,EAA8BG,GAA9B,EAAmCI,IAAnC;MACH,CAFD,MAEO;QACHP,MAAM,CAACG,GAAD,CAAN,GAAcb,GAAG,CAACa,GAAD,CAAjB;MACH;IACJ;EACJ;;EACDH,MAAM,CAACR,OAAP,GAAiBF,GAAjB;;EACA,IAAIQ,KAAJ,EAAW;IACPA,KAAK,CAACU,GAAN,CAAUlB,GAAV,EAAeU,MAAf;EACH;;EACD,OAAOA,MAAP;AACH;;AACD,IAAIS,eAAe,GAAG,CAAC,GAAGlC,sBAAsB,CAACiB,OAA3B,EAAqCkB,SAAD,IAAa;EACnE,OAAOA,SAAS,CAACC,KAAV,CAAgBC,MAAhB,CAAuB;IAAA,IAAC;MAAEC;IAAF,CAAD;IAAA,OAAaA,IAAI,KAAK,OAAtB;EAAA,CAAvB,EAAsDC,GAAtD,GAA4DnD,KAAnE;AACH,CAFqB,CAAtB;;AAGA,SAASoD,wBAAT,CAAkCC,QAAlC,EAA4C;EACxC,OAAOP,eAAe,CAACQ,aAAhB,CAA8BD,QAA9B,CAAP;AACH,C,CACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAUE,qBAAV,CAAgCC,SAAhC,EAA2C;EACvC,IAAIC,SAAS,GAAGC,QAAhB;;EACA,OAAMD,SAAS,IAAI,CAAnB,EAAqB;IACjB,IAAIE,OAAJ;;IACA,IAAIF,SAAS,KAAKC,QAAd,IAA0BF,SAAS,CAACI,QAAV,CAAmB,GAAnB,CAA9B,EAAuD;MACnD,IAAIC,UAAU,GAAGL,SAAS,CAACM,OAAV,CAAkB,GAAlB,CAAjB,CADmD,CAEnD;MACA;;MACAH,OAAO,GAAG,CACN,GADM,EAEN,GAFM,EAGRI,QAHQ,CAGCP,SAAS,CAACK,UAAU,GAAG,CAAd,CAHV,IAG8BA,UAAU,GAAG,CAH3C,GAG+C,CAAC,CAH1D;IAIH,CARD,MAQO;MACHF,OAAO,GAAGH,SAAS,CAACQ,WAAV,CAAsB,GAAtB,EAA2BP,SAA3B,CAAV;IACH;;IACD,IAAIE,OAAO,GAAG,CAAd,EAAiB;MACb;IACH;;IACD,IAAIM,MAAM,GAAGT,SAAS,CAACU,KAAV,CAAgB,CAAhB,EAAmBP,OAAnB,CAAb;IACA,IAAIQ,QAAQ,GAAGX,SAAS,CAACU,KAAV,CAAgBP,OAAO,GAAG,CAA1B,CAAf;IACA,MAAM,CACFM,MADE,EAEFE,QAFE,CAAN;IAIAV,SAAS,GAAGE,OAAO,GAAG,CAAtB;EACH;AACJ;;AACD,SAASS,WAAT,CAAqBC,OAArB,EAA8BC,OAA9B,EAAuC;EACnC,IAAID,OAAO,CAACE,MAAR,KAAmB,CAAnB,IAAwBD,OAAO,CAACE,cAAR,CAAuBP,MAAvB,KAAkC,EAA9D,EAAkE;IAC9D,OAAOI,OAAP;EACH;;EACD,KAAK,IAAII,KAAT,IAAkBJ,OAAlB,EAA0B;IACtB,IAAI,CAACK,IAAD,IAASD,KAAb;;IACA,IAAIC,IAAI,CAACC,OAAL,CAAaC,aAAjB,EAAgC;MAC5B,IAAIC,SAAS,GAAGpE,QAAQ,CAACoB,OAAT,CAAiBiD,IAAjB,CAAsB;QAClCC,KAAK,EAAE,CACHN,KAAK,CAAC,CAAD,CAAL,CAASO,KAAT,EADG;MAD2B,CAAtB,CAAhB;;MAKA,IAAIC,cAAc,GAAGR,KAAK,CAAC,CAAD,CAAL,CAASS,IAAT,CAAcC,QAAd,CAAuBF,cAA5C;MACAJ,SAAS,CAACO,SAAV,CAAqBC,CAAD,IAAK;QACrB;QACA;QACA;QACA;QACA,IAAIC,qBAAqB,GAAGL,cAAc,CAACM,UAAf,CAA0B,GAA1B,CAA5B;QACAF,CAAC,CAAChC,QAAF,GAAa,CAAC,GAAGtC,eAAe,CAACc,OAApB,EAA6ByC,OAAO,CAACE,cAAR,CAAuBP,MAApD,EAA4DoB,CAAC,CAAChC,QAA9D,EAAwEiC,qBAAxE,CAAb;MACH,CAPD;MAQAb,KAAK,CAAC,CAAD,CAAL,GAAWI,SAAS,CAACE,KAAV,CAAgB,CAAhB,CAAX;IACH;EACJ;;EACD,OAAOV,OAAP;AACH;;AACD,SAASmB,cAAT,CAAwBnB,OAAxB,EAAiCY,cAAjC,EAAiD;EAC7C,IAAIZ,OAAO,CAACE,MAAR,KAAmB,CAAvB,EAA0B;IACtB,OAAOF,OAAP;EACH;;EACD,IAAIoB,MAAM,GAAG,EAAb;;EACA,KAAK,IAAI,CAACf,IAAD,EAAOgB,IAAP,CAAT,IAAyBrB,OAAzB,EAAiC;IAC7B,IAAIQ,SAAS,GAAGpE,QAAQ,CAACoB,OAAT,CAAiBiD,IAAjB,CAAsB;MAClCC,KAAK,EAAE,CACHW,IAAI,CAACV,KAAL,EADG;IAD2B,CAAtB,CAAhB;;IAKAH,SAAS,CAACO,SAAV,CAAqBC,CAAD,IAAK;MACrBA,CAAC,CAAChC,QAAF,GAAa,CAAC,GAAGrC,YAAY,CAAC2E,gBAAjB,EAAmCN,CAAC,CAAChC,QAArC,EAAgDuC,SAAD,IAAa;QACrE,IAAIA,SAAS,KAAKX,cAAlB,EAAkC;UAC9B,OAAQ,IAAGW,SAAU,EAArB;QACH;;QACD,OAAOA,SAAP;MACH,CALY,CAAb;MAMAP,CAAC,CAACQ,SAAF,CAAaC,CAAD,IAAKA,CAAC,CAACC,SAAF,GAAc,IAA/B;IACH,CARD;IASAN,MAAM,CAACO,IAAP,CAAY,CACR,EACI,GAAGtB,IADP;MAEIqB,SAAS,EAAE;IAFf,CADQ,EAKRlB,SAAS,CAACE,KAAV,CAAgB,CAAhB,CALQ,CAAZ;EAOH;;EACD,OAAOU,MAAP;AACH,C,CACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,YAAT,CAAsBC,OAAtB,EAA+B7B,OAA/B,EAAwCC,OAAxC,EAAiD;EAC7C,IAAID,OAAO,CAACE,MAAR,KAAmB,CAAvB,EAA0B;IACtB,OAAOF,OAAP;EACH;;EACD,IAAI8B,IAAJ,CAJ6C,CAK7C;;EACA,IAAID,OAAO,CAACtC,QAAR,CAAiB,GAAjB,KAAyB,CAACsC,OAAO,CAACX,UAAR,CAAmB,GAAnB,CAA9B,EAAuD;IACnDY,IAAI,GAAGD,OAAO,CAAChC,KAAR,CAAcgC,OAAO,CAAClC,WAAR,CAAoB,GAApB,IAA2B,CAAzC,EAA4C,CAAC,CAA7C,CAAP;IACAkC,OAAO,GAAGA,OAAO,CAAChC,KAAR,CAAc,CAAd,EAAiBgC,OAAO,CAACpC,OAAR,CAAgBqC,IAAhB,IAAwB;IAAE;IAA1B,EAAqC;IAAE;IAAxD,CAAV;EACH,CAT4C,CAU7C;;;EACA,IAAIC,gBAAgB,CAACF,OAAD,CAAhB,IAA6B,CAAC5B,OAAO,CAAC+B,UAAR,CAAmBjE,GAAnB,CAAuB8D,OAAvB,CAAlC,EAAmE;IAC/D,IAAI7C,QAAQ,GAAG,CAAC,GAAG/B,UAAU,CAACgF,SAAf,EAA0BJ,OAAO,CAAChC,KAAR,CAAc,CAAd,EAAiB,CAAC,CAAlB,CAA1B,CAAf;;IACA,IAAI,CAAC,CAAC,GAAG3C,kBAAkB,CAACgF,0BAAvB,EAAmDlD,QAAnD,CAAL,EAAmE;MAC/D,OAAO,EAAP;IACH;;IACD,IAAImD,EAAE,GAAG,CAAC,GAAGjF,kBAAkB,CAACkF,YAAvB,EAAqCpD,QAArC,CAAT;IACA,IAAIqD,IAAI,GAAGC,KAAK,CAACC,IAAN,CAAWtC,OAAO,CAACuC,YAAR,CAAqBC,MAArB,EAAX,EAA0C3D,GAA1C,MAAmD,EAA9D;IACAmB,OAAO,CAAC+B,UAAR,CAAmBxD,GAAnB,CAAuBqD,OAAvB,EAAgC,CAC5B,CACIQ,IADJ,EAEIF,EAFJ,CAD4B,CAAhC;IAMAlC,OAAO,CAACuC,YAAR,CAAqBhE,GAArB,CAAyBqD,OAAzB,EAAkCQ,IAAlC;EACH;;EACD,IAAIpC,OAAO,CAAC+B,UAAR,CAAmBjE,GAAnB,CAAuB8D,OAAvB,CAAJ,EAAqC;IACjC,IAAIa,qBAAqB,GAAGzC,OAAO,CAAC+B,UAAR,CAAmB/F,GAAnB,CAAuB4F,OAAvB,EAAgChC,KAAhC,EAA5B;IACA,IAAIuB,MAAM,GAAG,EAAb;;IACA,KAAK,IAAI,CAACf,IAAD,EAAOgB,IAAP,CAAT,IAAyBrB,OAAzB,EAAiC;MAC7B;MACA,IAAIK,IAAI,CAACsC,KAAL,KAAe,MAAnB,EAA2B;QACvB;MACH;;MACD,IAAInC,SAAS,GAAGpE,QAAQ,CAACoB,OAAT,CAAiBiD,IAAjB,CAAsB;QAClCC,KAAK,EAAE,CACHW,IAAI,CAACV,KAAL,EADG;MAD2B,CAAtB,CAAhB;;MAKA,KAAK,IAAI,CAACiC,WAAD,EAAcC,eAAd,EAA+BC,kBAA/B,CAAT,IAA+DJ,qBAA/D,EAAqF;QACjF,IAAI/B,KAAK,GAAGmC,kBAAkB,KAAK,IAAvB,IAA+BA,kBAAkB,KAAK,KAAK,CAA3D,GAA+DA,kBAA/D,GAAoFtC,SAAS,CAACG,KAAV,EAAhG;QACA,IAAIoC,gBAAgB,GAAG,EAAvB;;QACA,SAASC,aAAT,GAAyB;UACrB;UACA,IAAIrC,KAAK,CAACE,IAAN,CAAWoC,YAAf,EAA6B;YACzB;UACH;;UACDtC,KAAK,CAACE,IAAN,CAAWoC,YAAX,GAA0B,IAA1B;UACAtC,KAAK,CAACI,SAAN,CAAiBM,IAAD,IAAQA,IAAI,CAACR,IAAL,CAAUqC,gBAAV,GAA6B7B,IAAI,CAACrC,QAA1D;QACH;;QACD,SAASmE,eAAT,CAAyBC,gBAAzB,EAA2C;UACvCJ,aAAa;UACbrC,KAAK,CAAC0C,IAAN,CAAYhC,IAAD,IAAQ;YACf,IAAIA,IAAI,CAACxC,IAAL,KAAc,MAAlB,EAA0B;cACtB;YACH;;YACDwC,IAAI,CAAC3C,SAAL,GAAiB2C,IAAI,CAAC3C,SAAL,CAAe4E,GAAf,CAAoBtE,QAAD,IAAY;cAC5C,OAAOoE,gBAAgB,CAAC;gBACpB,IAAI7B,SAAJ,GAAiB;kBACb,OAAOxC,wBAAwB,CAACC,QAAD,CAA/B;gBACH,CAHmB;;gBAIpBA;cAJoB,CAAD,CAAvB;YAMH,CAPgB,CAAjB;UAQH,CAZD;UAaA,OAAO2B,KAAP;QACH;;QACD,IAAI4C,eAAe,GAAGV,eAAe,CAAC;UAClC;UACA,IAAIrC,SAAJ,GAAiB;YACbwC,aAAa;YACb,OAAOrC,KAAP;UACH,CALiC;;UAMlC6C,SAAS,EAAEvD,OAAO,CAACE,cAAR,CAAuBqD,SANA;UAOlCL,eAPkC;;UAQlC;UACAM,IAAI,CAAEC,OAAF,EAAW;YACX,IAAIhD,KAAK,GAAGC,KAAK,CAACD,KAAlB;YACAC,KAAK,CAACgD,SAAN;YACAD,OAAO,CAACE,MAAR,CAAelD,KAAf;YACAC,KAAK,CAACiD,MAAN,CAAaF,OAAb;UACH,CAdiC;;UAelCG,MAAM,CAAEC,cAAF,EAAkB;YACpBf,gBAAgB,CAACpB,IAAjB,CAAsBmC,cAAtB;UACH,CAjBiC;;UAkBlChC;QAlBkC,CAAD,CAArC,CA5BiF,CAgDjF;QACA;;QACA,IAAIQ,KAAK,CAACyB,OAAN,CAAcR,eAAd,CAAJ,EAAoC;UAChC,KAAK,IAAI,CAACS,GAAD,EAAMC,gBAAN,CAAT,IAAoCV,eAAe,CAACW,OAAhB,EAApC,EAA8D;YAC1D;YACA;YACA;YACA;YACAxB,qBAAqB,CAACf,IAAtB,CAA2B,CACvB;YACA;YACA;YACA;YACAiB,WAAW,GAAGuB,MAAM,CAACH,GAAG,IAAIT,eAAe,CAACrD,MAAxB,CALG,EAMvB+D,gBANuB,EAOvB;YACA;YACAtD,KAAK,CAACA,KAAN,EATuB,CAA3B;UAWH;;UACD;QACH;;QACD,IAAI,OAAO4C,eAAP,KAA2B,QAA/B,EAAyC;UACrCR,gBAAgB,CAACpB,IAAjB,CAAsB4B,eAAtB;QACH;;QACD,IAAIA,eAAe,KAAK,IAAxB,EAA8B;UAC1B;QACH,CA3EgF,CA4EjF;QACA;QACA;;;QACA,IAAI5C,KAAK,CAACE,IAAN,CAAWoC,YAAf,EAA6B;UACzB,OAAOtC,KAAK,CAACE,IAAN,CAAWoC,YAAlB;UACAtC,KAAK,CAACI,SAAN,CAAiBM,IAAD,IAAQ;YACpB,IAAI+C,MAAM,GAAG/C,IAAI,CAACR,IAAL,CAAUqC,gBAAvB;YACA,IAAI,CAACkB,MAAL,EAAa;YACb,OAAO/C,IAAI,CAACR,IAAL,CAAUqC,gBAAjB;YACA,IAAIkB,MAAM,KAAK/C,IAAI,CAACrC,QAApB,EAA8B,OAJV,CAIkB;;YACtC,IAAIqF,QAAQ,GAAGhD,IAAI,CAACrC,QAApB,CALoB,CAMpB;YACA;YACA;YACA;;YACA,IAAIsF,WAAW,GAAG,CAAC,GAAG/H,sBAAsB,CAACiB,OAA3B,EAAqCkB,SAAD,IAAa;cAC/DA,SAAS,CAAC6F,WAAV,CAAuBC,SAAD,IAAa;gBAC/BA,SAAS,CAAC7I,KAAV,GAAmB,GAAEkG,OAAQ,GAAE5B,OAAO,CAACE,cAAR,CAAuBqD,SAAU,GAAEgB,SAAS,CAAC7I,KAAM,EAAlF;cACH,CAFD;YAGH,CAJiB,EAIf8I,WAJe,CAIHL,MAJG,CAAlB,CAVoB,CAepB;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;;YACArB,gBAAgB,CAACpB,IAAjB,CAAsB0C,QAAQ,CAACK,OAAT,CAAiBJ,WAAjB,EAA8B,GAA9B,CAAtB;YACAjD,IAAI,CAACrC,QAAL,GAAgBoF,MAAhB;UACH,CA5BD;QA6BH,CA9GgF,CA+GjF;QACA;QACA;QACA;;;QACAzD,KAAK,CAACD,KAAN,CAAY,CAAZ,EAAeG,IAAf,CAAoBC,QAApB,GAA+B,EAC3B,GAAGH,KAAK,CAACD,KAAN,CAAY,CAAZ,EAAeG,IAAf,CAAoBC,QADI;UAE3B6D,WAAW,EAAEtE,IAAI,CAACsC;QAFS,CAA/B;;QAIA,IAAIiC,iBAAJ;;QACA,IAAIC,UAAU,GAAG,CACb,EACI,GAAGxE,IADP;UAEIgC,IAAI,EAAEO,WAAW,GAAGvC,IAAI,CAACgC,IAF7B;UAGIU,gBAAgB,EAAE,CAAC,CAAC6B,iBAAiB,GAAGvE,IAAI,CAAC0C,gBAA1B,MAAgD,IAAhD,IAAwD6B,iBAAiB,KAAK,KAAK,CAAnF,GAAuFA,iBAAvF,GAA2G,EAA5G,EAAgHE,MAAhH,CAAuH/B,gBAAvH,CAHtB;UAIIgC,kBAAkB,EAAEhD,gBAAgB,CAACF,OAAD;QAJxC,CADa,EAOblB,KAAK,CAACD,KAAN,CAAY,CAAZ,CAPa,CAAjB;QASAU,MAAM,CAACO,IAAP,CAAYkD,UAAZ;MACH;IACJ;;IACD,OAAOzD,MAAP;EACH;;EACD,OAAO,EAAP;AACH;;AACD,SAAS4D,UAAT,CAAoB3D,IAApB,EAA0BvD,KAA1B,EAA+C;EAAA,IAAdwC,OAAc,uEAAJ,EAAI;;EAC3C;EACA,IAAI,CAAC,CAAC,GAAG7D,cAAc,CAACe,OAAnB,EAA4B6D,IAA5B,CAAD,IAAsC,CAACiB,KAAK,CAACyB,OAAN,CAAc1C,IAAd,CAA3C,EAAgE;IAC5D,OAAO,CACH,CACIA,IADJ,CADG,EAIHf,OAJG,CAAP;EAMH,CAT0C,CAU3C;;;EACA,IAAIgC,KAAK,CAACyB,OAAN,CAAc1C,IAAd,CAAJ,EAAyB;IACrB,OAAO2D,UAAU,CAAC3D,IAAI,CAAC,CAAD,CAAL,EAAUvD,KAAV,EAAiBuD,IAAI,CAAC,CAAD,CAArB,CAAjB;EACH,CAb0C,CAc3C;;;EACA,IAAI,CAACvD,KAAK,CAACC,GAAN,CAAUsD,IAAV,CAAL,EAAsB;IAClBvD,KAAK,CAACU,GAAN,CAAU6C,IAAV,EAAgB,CAAC,GAAG7E,kBAAkB,CAACgB,OAAvB,EAAgC6D,IAAhC,CAAhB;EACH;;EACD,OAAO,CACHvD,KAAK,CAAC7B,GAAN,CAAUoF,IAAV,CADG,EAEHf,OAFG,CAAP;AAIH;;AACD,MAAM2E,sBAAsB,GAAG,UAA/B;;AACA,SAASC,eAAT,CAAyBnJ,IAAzB,EAA+B;EAC3B,OAAOkJ,sBAAsB,CAACE,IAAvB,CAA4BpJ,IAA5B,CAAP;AACH;AACD;AACA;AACA;AACA;;;AAAI,SAASqJ,YAAT,CAAsBC,WAAtB,EAAmC;EACnC;EACA;EACA,IAAI,CAACA,WAAW,CAAC3F,QAAZ,CAAqB,KAArB,CAAL,EAAkC;IAC9B,OAAO,KAAP;EACH;;EACD,IAAI;IACA,MAAM4F,GAAG,GAAG,IAAIC,GAAJ,CAAQF,WAAR,CAAZ;IACA,OAAOC,GAAG,CAACE,MAAJ,KAAe,EAAf,IAAqBF,GAAG,CAACG,IAAJ,KAAa,EAAzC;EACH,CAHD,CAGE,OAAOC,GAAP,EAAY;IACV;IACA,OAAO,KAAP;EACH;AACJ;;AACD,SAASC,cAAT,CAAwBC,IAAxB,EAA8B;EAC1B,IAAIC,UAAU,GAAG,IAAjB;EACAD,IAAI,CAACpE,SAAL,CAAgBsE,IAAD,IAAQ;IACnB,IAAI,CAACC,kBAAkB,CAACD,IAAI,CAAC/J,IAAN,EAAY+J,IAAI,CAACnK,KAAjB,CAAvB,EAAgD;MAC5CkK,UAAU,GAAG,KAAb;MACA,OAAO,KAAP;IACH;EACJ,CALD;EAMA,OAAOA,UAAP;AACH;;AACD,SAASE,kBAAT,CAA4BC,QAA5B,EAAsCrK,KAAtC,EAA6C;EACzC;EACA;EACA;EACA,IAAIyJ,YAAY,CAAE,GAAEY,QAAS,IAAGrK,KAAM,EAAtB,CAAhB,EAA0C;IACtC,OAAO,KAAP;EACH;;EACD,IAAI;IACAS,QAAQ,CAACoB,OAAT,CAAiByI,KAAjB,CAAwB,KAAID,QAAS,IAAGrK,KAAM,GAA9C,EAAkDuK,QAAlD;;IACA,OAAO,IAAP;EACH,CAHD,CAGE,OAAOR,GAAP,EAAY;IACV,OAAO,KAAP;EACH;AACJ;;AACD,SAASS,wBAAT,CAAkCvF,cAAlC,EAAkDX,OAAlD,EAA2D;EACvD,IAAImG,GAAJ;EACA,IAAI,GAAGJ,QAAH,EAAarK,KAAb,IAAsB,CAACyK,GAAG,GAAGxF,cAAc,CAACR,KAAf,CAAqB,8BAArB,CAAP,MAAiE,IAAjE,IAAyEgG,GAAG,KAAK,KAAK,CAAtF,GAA0FA,GAA1F,GAAgG,EAA1H;;EACA,IAAIzK,KAAK,KAAK0K,SAAd,EAAyB;IACrB,OAAO,IAAP;EACH;;EACD,IAAI,CAACnB,eAAe,CAACc,QAAD,CAApB,EAAgC;IAC5B,OAAO,IAAP;EACH;;EACD,IAAI,CAAC,CAAC,GAAG7I,sBAAsB,CAACK,OAA3B,EAAoC7B,KAApC,CAAL,EAAiD;IAC7C,OAAO,IAAP;EACH;;EACD,IAAI2K,UAAU,GAAG,CAAC,GAAGrJ,UAAU,CAACgF,SAAf,EAA0BtG,KAA1B,CAAjB;;EACA,IAAI,CAACoK,kBAAkB,CAACC,QAAD,EAAWM,UAAX,CAAvB,EAA+C;IAC3C,OAAO,IAAP;EACH;;EACD,OAAO,CACH,CACI;IACIjE,IAAI,EAAEpC,OAAO,CAACsG,uBADlB;IAEI5D,KAAK,EAAE;EAFX,CADJ,EAKI,OAAK;IACG,CAAC,CAAC,GAAG3F,UAAU,CAACwJ,OAAf,EAAwB5F,cAAxB,CAAD,GAA2C;MACvC,CAACoF,QAAD,GAAYM;IAD2B;EAD9C,CAAL,CALJ,CADG,CAAP;AAaH;;AACD,UAAUG,qBAAV,CAAgC7F,cAAhC,EAAgDX,OAAhD,EAAyD;EACrD,IAAIA,OAAO,CAACyG,gBAAR,CAAyB3I,GAAzB,CAA6B6C,cAA7B,CAAJ,EAAkD;IAC9C,MAAM,CACFX,OAAO,CAACyG,gBAAR,CAAyBzK,GAAzB,CAA6B2E,cAA7B,CADE,EAEF,SAFE,CAAN;EAIH;;EACD,OAAO,WAAU+F,qBAAV,EAAiC;IACpC,IAAIA,qBAAqB,KAAK,IAA9B,EAAoC;MAChC,MAAM,CACFA,qBADE,EAEF,SAFE,CAAN;IAIH;EACJ,CAPM,CAOLR,wBAAwB,CAACvF,cAAD,EAAiBX,OAAjB,CAPnB,CAAP;EAQA,IAAI2G,eAAe,GAAGhG,cAAtB;EACA,IAAIiG,QAAQ,GAAG,KAAf;EACA,MAAMC,cAAc,GAAG7G,OAAO,CAACE,cAAR,CAAuBP,MAA9C;EACA,MAAMmH,iBAAiB,GAAGD,cAAc,CAAC5G,MAAzC;EACA,MAAM8G,iBAAiB,GAAGJ,eAAe,CAAC1F,UAAhB,CAA2B4F,cAA3B,KAA8CF,eAAe,CAAC1F,UAAhB,CAA4B,IAAG4F,cAAe,EAA9C,CAAxE;;EACA,IAAIF,eAAe,CAACG,iBAAD,CAAf,KAAuC,GAAvC,IAA8CC,iBAAlD,EAAqE;IACjEH,QAAQ,GAAG,IAAX;IACAD,eAAe,GAAGE,cAAc,GAAGF,eAAe,CAAC/G,KAAhB,CAAsBkH,iBAAiB,GAAG,CAA1C,CAAnC;EACH;;EACD,IAAIF,QAAQ,IAAI5G,OAAO,CAACyG,gBAAR,CAAyB3I,GAAzB,CAA6B6I,eAA7B,CAAhB,EAA+D;IAC3D,MAAM,CACF3G,OAAO,CAACyG,gBAAR,CAAyBzK,GAAzB,CAA6B2K,eAA7B,CADE,EAEF,UAFE,CAAN;EAIH;;EACD,KAAK,IAAI,CAAChH,MAAD,EAASE,QAAT,CAAT,IAA+BZ,qBAAqB,CAAC0H,eAAD,CAApD,EAAsE;IAClE,IAAI3G,OAAO,CAACyG,gBAAR,CAAyB3I,GAAzB,CAA6B6B,MAA7B,CAAJ,EAA0C;MACtC,MAAM,CACFK,OAAO,CAACyG,gBAAR,CAAyBzK,GAAzB,CAA6B2D,MAA7B,CADE,EAEFiH,QAAQ,GAAI,IAAG/G,QAAS,EAAhB,GAAoBA,QAF1B,CAAN;IAIH;EACJ;AACJ;;AACD,SAASmH,kBAAT,CAA4BC,KAA5B,EAAmC1D,SAAnC,EAA8C;EAC1C,IAAI0D,KAAK,KAAKrK,YAAY,CAACsK,aAA3B,EAA0C;IACtC,OAAO,CACHtK,YAAY,CAACsK,aADV,CAAP;EAGH;;EACD,OAAO7E,KAAK,CAACC,IAAN,CAAW,CAAC,GAAGnF,sBAAsB,CAACgK,mBAA3B,EAAgDF,KAAhD,EAAuD1D,SAAvD,CAAX,CAAP;AACH;;AACD,UAAU6D,gBAAV,CAA2BrH,OAA3B,EAAoCY,cAApC,EAAoD;EAChD,KAAK,MAAMR,KAAX,IAAoBJ,OAApB,EAA4B;IACxB,IAAIoG,GAAJ;IACA,IAAIkB,IAAJ;IACAlH,KAAK,CAAC,CAAD,CAAL,CAASS,IAAT,CAAcC,QAAd,GAAyB,EACrB,GAAGV,KAAK,CAAC,CAAD,CAAL,CAASS,IAAT,CAAcC,QADI;MAErBF,cAFqB;MAGrB2G,cAAc,EAAE,CAACD,IAAI,GAAG,CAAClB,GAAG,GAAGhG,KAAK,CAAC,CAAD,CAAL,CAASE,OAAhB,MAA6B,IAA7B,IAAqC8F,GAAG,KAAK,KAAK,CAAlD,GAAsD,KAAK,CAA3D,GAA+DA,GAAG,CAACmB,cAA3E,MAA+F,IAA/F,IAAuGD,IAAI,KAAK,KAAK,CAArH,GAAyHA,IAAzH,GAAgI;IAH3H,CAAzB;IAKA,MAAMlH,KAAN;EACH;AACJ;;AACD,UAAUlE,cAAV,CAAyBiD,SAAzB,EAAoCc,OAApC,EAAmE;EAAA,IAAtBuH,QAAsB,uEAAXrI,SAAW;EAC/D,IAAIqE,SAAS,GAAGvD,OAAO,CAACE,cAAR,CAAuBqD,SAAvC;EACA,IAAI,CAAC5C,cAAD,EAAiB,GAAG6G,QAApB,IAAgCR,kBAAkB,CAAC9H,SAAD,EAAYqE,SAAZ,CAAlB,CAAyCkE,OAAzC,EAApC;EACA,IAAIhG,SAAS,GAAG,KAAhB;;EACA,IAAId,cAAc,CAACM,UAAf,CAA0B,GAA1B,CAAJ,EAAoC;IAChCQ,SAAS,GAAG,IAAZ;IACAd,cAAc,GAAGA,cAAc,CAACf,KAAf,CAAqB,CAArB,CAAjB;EACH;;EACD,IAAI,CAAC,GAAGxC,aAAa,CAACsK,WAAlB,EAA+B1H,OAAO,CAACE,cAAvC,EAAuD,iBAAvD,CAAJ,EAA+E;IAC3E,IAAIS,cAAc,CAACM,UAAf,CAA0B,GAA1B,KAAkCN,cAAc,CAACrB,QAAf,CAAwB,GAAxB,CAAtC,EAAoE;MAChE,IAAIqI,IAAI,GAAGH,QAAQ,CAAC5H,KAAT,GAAiB6H,OAAjB,GAA2BG,IAA3B,CAAgCrE,SAAhC,CAAX;;MACA,KAAK,IAAIsE,IAAT,IAAiB,CAAC,GAAG1K,sBAAsB,CAACgK,mBAA3B,EAAgDxG,cAAc,CAACf,KAAf,CAAqB,CAArB,EAAwB,CAAC,CAAzB,CAAhD,EAA6E,GAA7E,CAAjB,EAAmG;QAC/F,OAAO3D,cAAc,CAAC0L,IAAI,GAAGpE,SAAP,GAAmBsE,IAApB,EAA0B7H,OAA1B,EAAmCuH,QAAnC,CAArB;MACH;IACJ;EACJ,CAf8D,CAgB/D;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,KAAK,IAAIO,cAAT,IAA2BtB,qBAAqB,CAAC7F,cAAD,EAAiBX,OAAjB,CAAhD,EAA0E;IACtE,IAAID,OAAO,GAAG,EAAd;IACA,IAAIgI,cAAc,GAAG,IAAIC,GAAJ,EAArB;IACA,IAAI,CAACC,OAAD,EAAUpI,QAAV,IAAsBiI,cAA1B;IACA,IAAII,YAAY,GAAGD,OAAO,CAAChI,MAAR,KAAmB,CAAtC;;IACA,KAAK,IAAI,CAACmC,IAAD,EAAO+F,MAAP,CAAT,IAA2BF,OAA3B,EAAmC;MAC/B,IAAIG,gBAAgB,GAAG,EAAvB;;MACA,IAAI,OAAOD,MAAP,KAAkB,UAAtB,EAAkC;QAC9B,KAAK,IAAIE,OAAT,IAAoB,GAAGxD,MAAH,CAAUsD,MAAM,CAACtI,QAAD,EAAW;UAC3CqI;QAD2C,CAAX,CAAhB,CAApB,EAEI;UACA,IAAI,CAACI,KAAD,EAAQjI,OAAR,IAAmB0E,UAAU,CAACsD,OAAD,EAAUrI,OAAO,CAACuI,gBAAlB,CAAjC;;UACA,KAAK,IAAInH,IAAT,IAAiBkH,KAAjB,EAAuB;YACnBF,gBAAgB,CAAC1G,IAAjB,CAAsB,CAClB,EACI,GAAGU,IADP;cAEI/B,OAAO,EAAE,EACL,GAAG+B,IAAI,CAAC/B,OADH;gBAEL,GAAGA;cAFE;YAFb,CADkB,EAQlBe,IARkB,CAAtB;UAUH;QACJ;MACJ,CAlBD,MAkBO,IAAIvB,QAAQ,KAAK,SAAb,IAA0BA,QAAQ,KAAK,UAA3C,EAAuD;QAC1D,IAAI2I,QAAQ,GAAGL,MAAf;QACA,IAAI,CAACM,MAAD,EAASC,QAAT,IAAqB3D,UAAU,CAACyD,QAAD,EAAWxI,OAAO,CAACuI,gBAAnB,CAAnC;;QACA,KAAK,IAAII,KAAT,IAAkBF,MAAlB,EAAyB;UACrBL,gBAAgB,CAAC1G,IAAjB,CAAsB,CAClB,EACI,GAAGU,IADP;YAEI/B,OAAO,EAAE,EACL,GAAG+B,IAAI,CAAC/B,OADH;cAEL,GAAGqI;YAFE;UAFb,CADkB,EAQlBC,KARkB,CAAtB;QAUH;MACJ;;MACD,IAAIP,gBAAgB,CAACnI,MAAjB,GAA0B,CAA9B,EAAiC;QAC7B,IAAIkG,GAAJ;QACA4B,cAAc,CAACxJ,GAAf,CAAmB6J,gBAAnB,EAAqC,CAACjC,GAAG,GAAG/D,IAAI,CAAC/B,OAAZ,MAAyB,IAAzB,IAAiC8F,GAAG,KAAK,KAAK,CAA9C,GAAkD,KAAK,CAAvD,GAA2DA,GAAG,CAACvH,IAApG;QACAmB,OAAO,CAAC2B,IAAR,CAAa0G,gBAAb;MACH;IACJ;;IACD,IAAItG,gBAAgB,CAACjC,QAAD,CAApB,EAAgC;MAC5B;MACA;MACA,IAAIE,OAAO,CAACE,MAAR,GAAiB,CAArB,EAAwB;QACpB,IAAIoH,IAAJ;QACA,IAAIuB,cAAc,GAAG7I,OAAO,CAACsD,GAAR,CAAalD,KAAD,IAAS,IAAI0I,GAAJ,CAAQ,CAC1C,IAAG,CAACxB,IAAI,GAAGU,cAAc,CAAC/L,GAAf,CAAmBmE,KAAnB,CAAR,MAAuC,IAAvC,IAA+CkH,IAAI,KAAK,KAAK,CAA7D,GAAiEA,IAAjE,GAAwE,EAA3E,CAD0C,CAAR,CAArB,CAArB,CAFoB,CAKpB;;QACA,KAAK,IAAIyB,WAAT,IAAwBF,cAAxB,EAAuC;UACnC,KAAK,IAAIhK,IAAT,IAAiBkK,WAAjB,EAA6B;YACzB,IAAIC,kBAAkB,GAAG,KAAzB;;YACA,KAAK,IAAIC,UAAT,IAAuBJ,cAAvB,EAAsC;cAClC,IAAIE,WAAW,KAAKE,UAApB,EAAgC;;cAChC,IAAIA,UAAU,CAAClL,GAAX,CAAec,IAAf,CAAJ,EAA0B;gBACtBoK,UAAU,CAACC,MAAX,CAAkBrK,IAAlB;gBACAmK,kBAAkB,GAAG,IAArB;cACH;YACJ;;YACD,IAAIA,kBAAJ,EAAwBD,WAAW,CAACG,MAAZ,CAAmBrK,IAAnB;UAC3B;QACJ;;QACD,IAAIsK,QAAQ,GAAG,EAAf;;QACA,KAAK,IAAI,CAACnF,GAAD,EAAMoF,KAAN,CAAT,IAAyBP,cAAc,CAAC3E,OAAf,EAAzB,EAAkD;UAC9C,KAAK,IAAImF,KAAT,IAAkBD,KAAlB,EAAwB;YACpB,IAAIE,MAAM,GAAGtJ,OAAO,CAACgE,GAAD,CAAP,CAAaV,GAAb,CAAiB;cAAA,IAAC,GAAGjC,IAAH,CAAD;cAAA,OAAYA,IAAZ;YAAA,CAAjB,EAAmCkI,IAAnC,GAA0CjG,GAA1C,CAA+CjC,IAAD,IAAQA,IAAI,CAACmI,QAAL,GAAgBC,KAAhB,CAAsB,IAAtB,EAA4B5J,KAA5B,CAAkC,CAAlC,EAAqC,CAAC,CAAtC,EAAyC;YAAzC,CAC9DyD,GAD8D,CACzDoG,IAAD,IAAQA,IAAI,CAACC,IAAL,EADkD,EACrCrG,GADqC,CAChCsG,CAAD,IAAM,SAAQA,CAAE,EADiB,EACd;YADc,CAE9D/B,IAF8D,CAEzD,IAFyD,CAAtD,EAEIA,IAFJ,CAES,MAFT,CAAb;YAGAsB,QAAQ,CAACxH,IAAT,CAAe,WAAUxC,SAAS,CAACuF,OAAV,CAAkB,GAAlB,EAAwB,IAAG2E,KAAM,GAAjC,CAAqC,YAAWC,MAAM,CAACK,IAAP,EAAc,IAAvF;YACA;UACH;QACJ;;QACD/M,IAAI,CAACY,OAAL,CAAaqM,IAAb,CAAkB,CACb,eAAc1K,SAAU,iDADX,EAEd,GAAGgK,QAFW,EAGb,yDAAwDhK,SAAS,CAACuF,OAAV,CAAkB,GAAlB,EAAuB,QAAvB,EAAiCA,OAAjC,CAAyC,GAAzC,EAA8C,QAA9C,CAAwD,6BAHnG,CAAlB;;QAKA;MACH;;MACD1E,OAAO,GAAGA,OAAO,CAACsD,GAAR,CAAawG,IAAD,IAAQA,IAAI,CAAClL,MAAL,CAAawB,KAAD,IAASuF,cAAc,CAACvF,KAAK,CAAC,CAAD,CAAN,CAAnC,CAApB,CAAV;IACH;;IACDJ,OAAO,GAAGA,OAAO,CAACuJ,IAAR,EAAV;IACAvJ,OAAO,GAAGsC,KAAK,CAACC,IAAN,CAAW8E,gBAAgB,CAACrH,OAAD,EAAUY,cAAV,CAA3B,CAAV;IACAZ,OAAO,GAAGD,WAAW,CAACC,OAAD,EAAUC,OAAV,CAArB;;IACA,IAAIyB,SAAJ,EAAe;MACX1B,OAAO,GAAGmB,cAAc,CAACnB,OAAD,EAAUY,cAAV,CAAxB;IACH;;IACD,KAAK,IAAIiB,OAAT,IAAoB4F,QAApB,EAA6B;MACzBzH,OAAO,GAAG4B,YAAY,CAACC,OAAD,EAAU7B,OAAV,EAAmBC,OAAnB,CAAtB;IACH;;IACD,KAAK,IAAIG,KAAT,IAAkBJ,OAAlB,EAA0B;MACtBI,KAAK,CAAC,CAAD,CAAL,CAASS,IAAT,CAAcC,QAAd,GAAyB,EACrB,GAAGV,KAAK,CAAC,CAAD,CAAL,CAASS,IAAT,CAAcC,QADI;QAErB3B;MAFqB,CAAzB,CADsB,CAKtB;;MACA,IAAIiB,KAAK,CAAC,CAAD,CAAL,CAAS2C,gBAAb,EAA+B;QAC3B,IAAIgH,WAAW,GAAG,CAAC,GAAGhN,sBAAsB,CAACiN,qBAA3B,EAAkD,GAAlD,EAAuD,GAAG5J,KAAK,CAAC,CAAD,CAAL,CAAS2C,gBAAnE,CAAlB;;QACA,IAAIvC,SAAS,GAAGpE,QAAQ,CAACoB,OAAT,CAAiBiD,IAAjB,CAAsB;UAClCC,KAAK,EAAE,CACHN,KAAK,CAAC,CAAD,CAAL,CAASO,KAAT,EADG;QAD2B,CAAtB,CAAhB;;QAKAH,SAAS,CAACO,SAAV,CAAqBM,IAAD,IAAQ;UACxB,IAAI+E,GAAJ;UACA,IAAI6D,WAAW,CAAC5I,IAAD,CAAf,EAAuB;UACvB,IAAIiG,IAAJ;UACAjG,IAAI,CAACrC,QAAL,GAAgB,CAAC,GAAGjC,sBAAsB,CAACmN,gBAA3B,EAA6CH,WAA7C,EAA0D;YACtE/K,QAAQ,EAAEqC,IAAI,CAACrC,QADuD;YAEtEG,SAAS,EAAEqI,QAF2D;YAGtEI,IAAI,EAAEzI,SAAS,CAACsK,KAAV,CAAgB,IAAIU,MAAJ,CAAY,KAAI,CAAC7C,IAAI,GAAGrH,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkD,CAACmG,GAAG,GAAGnG,OAAO,CAACE,cAAf,MAAmC,IAAnC,IAA2CiG,GAAG,KAAK,KAAK,CAAxD,GAA4D,KAAK,CAAjE,GAAqEA,GAAG,CAAC5C,SAAnI,MAAkJ,IAAlJ,IAA0J8D,IAAI,KAAK,KAAK,CAAxK,GAA4KA,IAA5K,GAAmL,GAAI,cAAvM,CAAhB,EAAuOxI,GAAvO,EAHgE;YAItEiG,kBAAkB,EAAE3E,KAAK,CAAC,CAAD,CAAL,CAAS2E,kBAJyC;YAKtE9E;UALsE,CAA1D,CAAhB;QAOH,CAXD;QAYAG,KAAK,CAAC,CAAD,CAAL,GAAWI,SAAS,CAACE,KAAV,CAAgB,CAAhB,CAAX;MACH;;MACD,MAAMN,KAAN;IACH;EACJ;AACJ;;AACD,SAAS6J,WAAT,CAAqB5I,IAArB,EAA2B;EACvB,OAAOA,IAAI,CAAC+I,MAAL,IAAe/I,IAAI,CAAC+I,MAAL,CAAYvL,IAAZ,KAAqB,QAApC,IAAgDwC,IAAI,CAAC+I,MAAL,CAAYrO,IAAZ,KAAqB,WAA5E;AACH;;AACD,SAASI,aAAT,CAAuBkO,UAAvB,EAAmCpK,OAAnC,EAA4C;EACxC,IAAIqK,QAAQ,GAAG,EAAf;;EACA,KAAK,IAAInL,SAAT,IAAsBkL,UAAtB,EAAiC;IAC7B,IAAIpK,OAAO,CAACsK,aAAR,CAAsBxM,GAAtB,CAA0BoB,SAA1B,CAAJ,EAA0C;MACtC;IACH;;IACD,IAAIc,OAAO,CAACuK,UAAR,CAAmBzM,GAAnB,CAAuBoB,SAAvB,CAAJ,EAAuC;MACnCmL,QAAQ,CAAC3I,IAAT,CAAc1B,OAAO,CAACuK,UAAR,CAAmBvO,GAAnB,CAAuBkD,SAAvB,CAAd;MACA;IACH;;IACD,IAAIa,OAAO,GAAGsC,KAAK,CAACC,IAAN,CAAWrG,cAAc,CAACiD,SAAD,EAAYc,OAAZ,CAAzB,CAAd;;IACA,IAAID,OAAO,CAACE,MAAR,KAAmB,CAAvB,EAA0B;MACtBD,OAAO,CAACsK,aAAR,CAAsBE,GAAtB,CAA0BtL,SAA1B;MACA;IACH;;IACDc,OAAO,CAACuK,UAAR,CAAmBhM,GAAnB,CAAuBW,SAAvB,EAAkCa,OAAlC;IACAsK,QAAQ,CAAC3I,IAAT,CAAc3B,OAAd;EACH,CAjBuC,CAkBxC;;;EACA,IAAI0K,QAAQ,GAAG,CAAEhJ,SAAD,IAAa;IACzB,IAAIA,SAAS,KAAK,IAAlB,EAAwB;MACpB,OAAQL,IAAD,IAAQ;QACXA,IAAI,CAACG,SAAL,CAAgBC,CAAD,IAAK;UAChB,IAAIA,CAAC,CAAC2I,MAAF,CAASvL,IAAT,KAAkB,MAAlB,IAA4B,CAACoL,WAAW,CAACxI,CAAC,CAAC2I,MAAH,CAA5C,EAAwD;YACpD3I,CAAC,CAACC,SAAF,GAAc,IAAd;UACH;QACJ,CAJD;MAKH,CAND;IAOH;;IACD,IAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;MAC/B,OAAQL,IAAD,IAAQ;QACXA,IAAI,CAAC3C,SAAL,GAAiB2C,IAAI,CAAC3C,SAAL,CAAe4E,GAAf,CAAoBtE,QAAD,IAAY;UAC5C,OAAQ,GAAE0C,SAAU,IAAG1C,QAAS,EAAhC;QACH,CAFgB,CAAjB;MAGH,CAJD;IAKH;EACJ,CAjBc,EAiBZiB,OAAO,CAACE,cAAR,CAAuBuB,SAjBX,CAAf;;EAkBA,OAAO4I,QAAQ,CAACf,IAAT,CAAc,CAAd,EAAiBjG,GAAjB,CAAqB,SAAuC;IAAA,IAAtC,CAAC;MAAEjB,IAAF;MAASM,KAAT;MAAiBrC;IAAjB,CAAD,EAA8Be,IAA9B,CAAsC;;IAC/D,IAAIf,OAAO,CAACqK,gBAAZ,EAA8B;MAC1B,IAAID,QAAJ,EAAc;QACV,IAAIlK,SAAS,GAAGpE,QAAQ,CAACoB,OAAT,CAAiBiD,IAAjB,CAAsB;UAClCC,KAAK,EAAE,CACHW,IAAI,CAACV,KAAL,EADG;QAD2B,CAAtB,CAAhB;;QAKAH,SAAS,CAACO,SAAV,CAAqBC,CAAD,IAAK;UACrB,IAAIiJ,WAAW,CAACjJ,CAAD,CAAf,EAAoB;YAChB;UACH;;UACD0J,QAAQ,CAAC1J,CAAD,CAAR;QACH,CALD;QAMAK,IAAI,GAAGb,SAAS,CAACE,KAAV,CAAgB,CAAhB,CAAP;MACH;IACJ;;IACD,OAAO,CACH2B,IAAI,GAAGpC,OAAO,CAAC2K,UAAR,CAAmBjI,KAAnB,CADJ,EAEHtB,IAFG,CAAP;EAIH,CArBM,CAAP;AAsBH;;AACD,SAASU,gBAAT,CAA0BmF,KAA1B,EAAiC;EAC7B,OAAOA,KAAK,CAAChG,UAAN,CAAiB,GAAjB,KAAyBgG,KAAK,CAAC3H,QAAN,CAAe,GAAf,CAAhC;AACH"},"metadata":{},"sourceType":"script"}