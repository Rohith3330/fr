{"ast":null,"code":"/**\n * class ArgumentParser\n *\n * Object for parsing command line strings into js objects.\n *\n * Inherited from [[ActionContainer]]\n **/\n'use strict';\n\nvar util = require('util');\n\nvar format = require('util').format;\n\nvar Path = require('path');\n\nvar sprintf = require('sprintf-js').sprintf; // Constants\n\n\nvar c = require('./const');\n\nvar $$ = require('./utils');\n\nvar ActionContainer = require('./action_container'); // Errors\n\n\nvar argumentErrorHelper = require('./argument/error');\n\nvar HelpFormatter = require('./help/formatter');\n\nvar Namespace = require('./namespace');\n/**\n * new ArgumentParser(options)\n *\n * Create a new ArgumentParser object.\n *\n * ##### Options:\n * - `prog`  The name of the program (default: Path.basename(process.argv[1]))\n * - `usage`  A usage message (default: auto-generated from arguments)\n * - `description`  A description of what the program does\n * - `epilog`  Text following the argument descriptions\n * - `parents`  Parsers whose arguments should be copied into this one\n * - `formatterClass`  HelpFormatter class for printing help messages\n * - `prefixChars`  Characters that prefix optional arguments\n * - `fromfilePrefixChars` Characters that prefix files containing additional arguments\n * - `argumentDefault`  The default value for all arguments\n * - `addHelp`  Add a -h/-help option\n * - `conflictHandler`  Specifies how to handle conflicting argument names\n * - `debug`  Enable debug mode. Argument errors throw exception in\n *   debug mode and process.exit in normal. Used for development and\n *   testing (default: false)\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#argumentparser-objects\n **/\n\n\nfunction ArgumentParser(options) {\n  if (!(this instanceof ArgumentParser)) {\n    return new ArgumentParser(options);\n  }\n\n  var self = this;\n  options = options || {};\n  options.description = options.description || null;\n  options.argumentDefault = options.argumentDefault || null;\n  options.prefixChars = options.prefixChars || '-';\n  options.conflictHandler = options.conflictHandler || 'error';\n  ActionContainer.call(this, options);\n  options.addHelp = typeof options.addHelp === 'undefined' || !!options.addHelp;\n  options.parents = options.parents || []; // default program name\n\n  options.prog = options.prog || Path.basename(process.argv[1]);\n  this.prog = options.prog;\n  this.usage = options.usage;\n  this.epilog = options.epilog;\n  this.version = options.version;\n  this.debug = options.debug === true;\n  this.formatterClass = options.formatterClass || HelpFormatter;\n  this.fromfilePrefixChars = options.fromfilePrefixChars || null;\n  this._positionals = this.addArgumentGroup({\n    title: 'Positional arguments'\n  });\n  this._optionals = this.addArgumentGroup({\n    title: 'Optional arguments'\n  });\n  this._subparsers = null; // register types\n\n  function FUNCTION_IDENTITY(o) {\n    return o;\n  }\n\n  this.register('type', 'auto', FUNCTION_IDENTITY);\n  this.register('type', null, FUNCTION_IDENTITY);\n  this.register('type', 'int', function (x) {\n    var result = parseInt(x, 10);\n\n    if (isNaN(result)) {\n      throw new Error(x + ' is not a valid integer.');\n    }\n\n    return result;\n  });\n  this.register('type', 'float', function (x) {\n    var result = parseFloat(x);\n\n    if (isNaN(result)) {\n      throw new Error(x + ' is not a valid float.');\n    }\n\n    return result;\n  });\n  this.register('type', 'string', function (x) {\n    return '' + x;\n  }); // add help and version arguments if necessary\n\n  var defaultPrefix = this.prefixChars.indexOf('-') > -1 ? '-' : this.prefixChars[0];\n\n  if (options.addHelp) {\n    this.addArgument([defaultPrefix + 'h', defaultPrefix + defaultPrefix + 'help'], {\n      action: 'help',\n      defaultValue: c.SUPPRESS,\n      help: 'Show this help message and exit.'\n    });\n  }\n\n  if (typeof this.version !== 'undefined') {\n    this.addArgument([defaultPrefix + 'v', defaultPrefix + defaultPrefix + 'version'], {\n      action: 'version',\n      version: this.version,\n      defaultValue: c.SUPPRESS,\n      help: \"Show program's version number and exit.\"\n    });\n  } // add parent arguments and defaults\n\n\n  options.parents.forEach(function (parent) {\n    self._addContainerActions(parent);\n\n    if (typeof parent._defaults !== 'undefined') {\n      for (var defaultKey in parent._defaults) {\n        if (parent._defaults.hasOwnProperty(defaultKey)) {\n          self._defaults[defaultKey] = parent._defaults[defaultKey];\n        }\n      }\n    }\n  });\n}\n\nutil.inherits(ArgumentParser, ActionContainer);\n/**\n * ArgumentParser#addSubparsers(options) -> [[ActionSubparsers]]\n * - options (object): hash of options see [[ActionSubparsers.new]]\n *\n * See also [subcommands][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#sub-commands\n **/\n\nArgumentParser.prototype.addSubparsers = function (options) {\n  if (this._subparsers) {\n    this.error('Cannot have multiple subparser arguments.');\n  }\n\n  options = options || {};\n  options.debug = this.debug === true;\n  options.optionStrings = [];\n  options.parserClass = options.parserClass || ArgumentParser;\n\n  if (!!options.title || !!options.description) {\n    this._subparsers = this.addArgumentGroup({\n      title: options.title || 'subcommands',\n      description: options.description\n    });\n    delete options.title;\n    delete options.description;\n  } else {\n    this._subparsers = this._positionals;\n  } // prog defaults to the usage message of this parser, skipping\n  // optional arguments and with no \"usage:\" prefix\n\n\n  if (!options.prog) {\n    var formatter = this._getFormatter();\n\n    var positionals = this._getPositionalActions();\n\n    var groups = this._mutuallyExclusiveGroups;\n    formatter.addUsage(this.usage, positionals, groups, '');\n    options.prog = formatter.formatHelp().trim();\n  } // create the parsers action and add it to the positionals list\n\n\n  var ParsersClass = this._popActionClass(options, 'parsers');\n\n  var action = new ParsersClass(options);\n\n  this._subparsers._addAction(action); // return the created parsers action\n\n\n  return action;\n};\n\nArgumentParser.prototype._addAction = function (action) {\n  if (action.isOptional()) {\n    this._optionals._addAction(action);\n  } else {\n    this._positionals._addAction(action);\n  }\n\n  return action;\n};\n\nArgumentParser.prototype._getOptionalActions = function () {\n  return this._actions.filter(function (action) {\n    return action.isOptional();\n  });\n};\n\nArgumentParser.prototype._getPositionalActions = function () {\n  return this._actions.filter(function (action) {\n    return action.isPositional();\n  });\n};\n/**\n * ArgumentParser#parseArgs(args, namespace) -> Namespace|Object\n * - args (array): input elements\n * - namespace (Namespace|Object): result object\n *\n * Parsed args and throws error if some arguments are not recognized\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#the-parse-args-method\n **/\n\n\nArgumentParser.prototype.parseArgs = function (args, namespace) {\n  var argv;\n  var result = this.parseKnownArgs(args, namespace);\n  args = result[0];\n  argv = result[1];\n\n  if (argv && argv.length > 0) {\n    this.error(format('Unrecognized arguments: %s.', argv.join(' ')));\n  }\n\n  return args;\n};\n/**\n * ArgumentParser#parseKnownArgs(args, namespace) -> array\n * - args (array): input options\n * - namespace (Namespace|Object): result object\n *\n * Parse known arguments and return tuple of result object\n * and unknown args\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#partial-parsing\n **/\n\n\nArgumentParser.prototype.parseKnownArgs = function (args, namespace) {\n  var self = this; // args default to the system args\n\n  args = args || process.argv.slice(2); // default Namespace built from parser defaults\n\n  namespace = namespace || new Namespace();\n\n  self._actions.forEach(function (action) {\n    if (action.dest !== c.SUPPRESS) {\n      if (!$$.has(namespace, action.dest)) {\n        if (action.defaultValue !== c.SUPPRESS) {\n          var defaultValue = action.defaultValue;\n\n          if (typeof action.defaultValue === 'string') {\n            defaultValue = self._getValue(action, defaultValue);\n          }\n\n          namespace[action.dest] = defaultValue;\n        }\n      }\n    }\n  });\n\n  Object.keys(self._defaults).forEach(function (dest) {\n    namespace[dest] = self._defaults[dest];\n  }); // parse the arguments and exit if there are any errors\n\n  try {\n    var res = this._parseKnownArgs(args, namespace);\n\n    namespace = res[0];\n    args = res[1];\n\n    if ($$.has(namespace, c._UNRECOGNIZED_ARGS_ATTR)) {\n      args = $$.arrayUnion(args, namespace[c._UNRECOGNIZED_ARGS_ATTR]);\n      delete namespace[c._UNRECOGNIZED_ARGS_ATTR];\n    }\n\n    return [namespace, args];\n  } catch (e) {\n    this.error(e);\n  }\n};\n\nArgumentParser.prototype._parseKnownArgs = function (argStrings, namespace) {\n  var self = this;\n  var extras = []; // replace arg strings that are file references\n\n  if (this.fromfilePrefixChars !== null) {\n    argStrings = this._readArgsFromFiles(argStrings);\n  } // map all mutually exclusive arguments to the other arguments\n  // they can't occur with\n  // Python has 'conflicts = action_conflicts.setdefault(mutex_action, [])'\n  // though I can't conceive of a way in which an action could be a member\n  // of two different mutually exclusive groups.\n\n\n  function actionHash(action) {\n    // some sort of hashable key for this action\n    // action itself cannot be a key in actionConflicts\n    // I think getName() (join of optionStrings) is unique enough\n    return action.getName();\n  }\n\n  var conflicts, key;\n  var actionConflicts = {};\n\n  this._mutuallyExclusiveGroups.forEach(function (mutexGroup) {\n    mutexGroup._groupActions.forEach(function (mutexAction, i, groupActions) {\n      key = actionHash(mutexAction);\n\n      if (!$$.has(actionConflicts, key)) {\n        actionConflicts[key] = [];\n      }\n\n      conflicts = actionConflicts[key];\n      conflicts.push.apply(conflicts, groupActions.slice(0, i));\n      conflicts.push.apply(conflicts, groupActions.slice(i + 1));\n    });\n  }); // find all option indices, and determine the arg_string_pattern\n  // which has an 'O' if there is an option at an index,\n  // an 'A' if there is an argument, or a '-' if there is a '--'\n\n\n  var optionStringIndices = {};\n  var argStringPatternParts = [];\n  argStrings.forEach(function (argString, argStringIndex) {\n    if (argString === '--') {\n      argStringPatternParts.push('-');\n\n      while (argStringIndex < argStrings.length) {\n        argStringPatternParts.push('A');\n        argStringIndex++;\n      }\n    } else {\n      // otherwise, add the arg to the arg strings\n      // and note the index if it was an option\n      var pattern;\n\n      var optionTuple = self._parseOptional(argString);\n\n      if (!optionTuple) {\n        pattern = 'A';\n      } else {\n        optionStringIndices[argStringIndex] = optionTuple;\n        pattern = 'O';\n      }\n\n      argStringPatternParts.push(pattern);\n    }\n  });\n  var argStringsPattern = argStringPatternParts.join('');\n  var seenActions = [];\n  var seenNonDefaultActions = [];\n\n  function takeAction(action, argumentStrings, optionString) {\n    seenActions.push(action);\n\n    var argumentValues = self._getValues(action, argumentStrings); // error if this argument is not allowed with other previously\n    // seen arguments, assuming that actions that use the default\n    // value don't really count as \"present\"\n\n\n    if (argumentValues !== action.defaultValue) {\n      seenNonDefaultActions.push(action);\n\n      if (actionConflicts[actionHash(action)]) {\n        actionConflicts[actionHash(action)].forEach(function (actionConflict) {\n          if (seenNonDefaultActions.indexOf(actionConflict) >= 0) {\n            throw argumentErrorHelper(action, format('Not allowed with argument \"%s\".', actionConflict.getName()));\n          }\n        });\n      }\n    }\n\n    if (argumentValues !== c.SUPPRESS) {\n      action.call(self, namespace, argumentValues, optionString);\n    }\n  }\n\n  function consumeOptional(startIndex) {\n    // get the optional identified at this index\n    var optionTuple = optionStringIndices[startIndex];\n    var action = optionTuple[0];\n    var optionString = optionTuple[1];\n    var explicitArg = optionTuple[2]; // identify additional optionals in the same arg string\n    // (e.g. -xyz is the same as -x -y -z if no args are required)\n\n    var actionTuples = [];\n    var args, argCount, start, stop;\n\n    for (;;) {\n      if (!action) {\n        extras.push(argStrings[startIndex]);\n        return startIndex + 1;\n      }\n\n      if (explicitArg) {\n        argCount = self._matchArgument(action, 'A'); // if the action is a single-dash option and takes no\n        // arguments, try to parse more single-dash options out\n        // of the tail of the option string\n\n        var chars = self.prefixChars;\n\n        if (argCount === 0 && chars.indexOf(optionString[1]) < 0) {\n          actionTuples.push([action, [], optionString]);\n          optionString = optionString[0] + explicitArg[0];\n          var newExplicitArg = explicitArg.slice(1) || null;\n          var optionalsMap = self._optionStringActions;\n\n          if (Object.keys(optionalsMap).indexOf(optionString) >= 0) {\n            action = optionalsMap[optionString];\n            explicitArg = newExplicitArg;\n          } else {\n            throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));\n          }\n        } else if (argCount === 1) {\n          // if the action expect exactly one argument, we've\n          // successfully matched the option; exit the loop\n          stop = startIndex + 1;\n          args = [explicitArg];\n          actionTuples.push([action, args, optionString]);\n          break;\n        } else {\n          // error if a double-dash option did not use the\n          // explicit argument\n          throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));\n        }\n      } else {\n        // if there is no explicit argument, try to match the\n        // optional's string arguments with the following strings\n        // if successful, exit the loop\n        start = startIndex + 1;\n        var selectedPatterns = argStringsPattern.substr(start);\n        argCount = self._matchArgument(action, selectedPatterns);\n        stop = start + argCount;\n        args = argStrings.slice(start, stop);\n        actionTuples.push([action, args, optionString]);\n        break;\n      }\n    } // add the Optional to the list and return the index at which\n    // the Optional's string args stopped\n\n\n    if (actionTuples.length < 1) {\n      throw new Error('length should be > 0');\n    }\n\n    for (var i = 0; i < actionTuples.length; i++) {\n      takeAction.apply(self, actionTuples[i]);\n    }\n\n    return stop;\n  } // the list of Positionals left to be parsed; this is modified\n  // by consume_positionals()\n\n\n  var positionals = self._getPositionalActions();\n\n  function consumePositionals(startIndex) {\n    // match as many Positionals as possible\n    var selectedPattern = argStringsPattern.substr(startIndex);\n\n    var argCounts = self._matchArgumentsPartial(positionals, selectedPattern); // slice off the appropriate arg strings for each Positional\n    // and add the Positional and its args to the list\n\n\n    for (var i = 0; i < positionals.length; i++) {\n      var action = positionals[i];\n      var argCount = argCounts[i];\n\n      if (typeof argCount === 'undefined') {\n        continue;\n      }\n\n      var args = argStrings.slice(startIndex, startIndex + argCount);\n      startIndex += argCount;\n      takeAction(action, args);\n    } // slice off the Positionals that we just parsed and return the\n    // index at which the Positionals' string args stopped\n\n\n    positionals = positionals.slice(argCounts.length);\n    return startIndex;\n  } // consume Positionals and Optionals alternately, until we have\n  // passed the last option string\n\n\n  var startIndex = 0;\n  var position;\n  var maxOptionStringIndex = -1;\n  Object.keys(optionStringIndices).forEach(function (position) {\n    maxOptionStringIndex = Math.max(maxOptionStringIndex, parseInt(position, 10));\n  });\n  var positionalsEndIndex, nextOptionStringIndex;\n\n  while (startIndex <= maxOptionStringIndex) {\n    // consume any Positionals preceding the next option\n    nextOptionStringIndex = null;\n\n    for (position in optionStringIndices) {\n      if (!optionStringIndices.hasOwnProperty(position)) {\n        continue;\n      }\n\n      position = parseInt(position, 10);\n\n      if (position >= startIndex) {\n        if (nextOptionStringIndex !== null) {\n          nextOptionStringIndex = Math.min(nextOptionStringIndex, position);\n        } else {\n          nextOptionStringIndex = position;\n        }\n      }\n    }\n\n    if (startIndex !== nextOptionStringIndex) {\n      positionalsEndIndex = consumePositionals(startIndex); // only try to parse the next optional if we didn't consume\n      // the option string during the positionals parsing\n\n      if (positionalsEndIndex > startIndex) {\n        startIndex = positionalsEndIndex;\n        continue;\n      } else {\n        startIndex = positionalsEndIndex;\n      }\n    } // if we consumed all the positionals we could and we're not\n    // at the index of an option string, there were extra arguments\n\n\n    if (!optionStringIndices[startIndex]) {\n      var strings = argStrings.slice(startIndex, nextOptionStringIndex);\n      extras = extras.concat(strings);\n      startIndex = nextOptionStringIndex;\n    } // consume the next optional and any arguments for it\n\n\n    startIndex = consumeOptional(startIndex);\n  } // consume any positionals following the last Optional\n\n\n  var stopIndex = consumePositionals(startIndex); // if we didn't consume all the argument strings, there were extras\n\n  extras = extras.concat(argStrings.slice(stopIndex)); // if we didn't use all the Positional objects, there were too few\n  // arg strings supplied.\n\n  if (positionals.length > 0) {\n    self.error('too few arguments');\n  } // make sure all required actions were present\n\n\n  self._actions.forEach(function (action) {\n    if (action.required) {\n      if (seenActions.indexOf(action) < 0) {\n        self.error(format('Argument \"%s\" is required', action.getName()));\n      }\n    }\n  }); // make sure all required groups have one option present\n\n\n  var actionUsed = false;\n\n  self._mutuallyExclusiveGroups.forEach(function (group) {\n    if (group.required) {\n      actionUsed = group._groupActions.some(function (action) {\n        return seenNonDefaultActions.indexOf(action) !== -1;\n      }); // if no actions were used, report the error\n\n      if (!actionUsed) {\n        var names = [];\n\n        group._groupActions.forEach(function (action) {\n          if (action.help !== c.SUPPRESS) {\n            names.push(action.getName());\n          }\n        });\n\n        names = names.join(' ');\n        var msg = 'one of the arguments ' + names + ' is required';\n        self.error(msg);\n      }\n    }\n  }); // return the updated namespace and the extra arguments\n\n\n  return [namespace, extras];\n};\n\nArgumentParser.prototype._readArgsFromFiles = function (argStrings) {\n  // expand arguments referencing files\n  var self = this;\n\n  var fs = require('fs');\n\n  var newArgStrings = [];\n  argStrings.forEach(function (argString) {\n    if (self.fromfilePrefixChars.indexOf(argString[0]) < 0) {\n      // for regular arguments, just add them back into the list\n      newArgStrings.push(argString);\n    } else {\n      // replace arguments referencing files with the file content\n      try {\n        var argstrs = [];\n        var filename = argString.slice(1);\n        var content = fs.readFileSync(filename, 'utf8');\n        content = content.trim().split('\\n');\n        content.forEach(function (argLine) {\n          self.convertArgLineToArgs(argLine).forEach(function (arg) {\n            argstrs.push(arg);\n          });\n          argstrs = self._readArgsFromFiles(argstrs);\n        });\n        newArgStrings.push.apply(newArgStrings, argstrs);\n      } catch (error) {\n        return self.error(error.message);\n      }\n    }\n  });\n  return newArgStrings;\n};\n\nArgumentParser.prototype.convertArgLineToArgs = function (argLine) {\n  return [argLine];\n};\n\nArgumentParser.prototype._matchArgument = function (action, regexpArgStrings) {\n  // match the pattern for this action to the arg strings\n  var regexpNargs = new RegExp('^' + this._getNargsPattern(action));\n  var matches = regexpArgStrings.match(regexpNargs);\n  var message; // throw an exception if we weren't able to find a match\n\n  if (!matches) {\n    switch (action.nargs) {\n      /*eslint-disable no-undefined*/\n      case undefined:\n      case null:\n        message = 'Expected one argument.';\n        break;\n\n      case c.OPTIONAL:\n        message = 'Expected at most one argument.';\n        break;\n\n      case c.ONE_OR_MORE:\n        message = 'Expected at least one argument.';\n        break;\n\n      default:\n        message = 'Expected %s argument(s)';\n    }\n\n    throw argumentErrorHelper(action, format(message, action.nargs));\n  } // return the number of arguments matched\n\n\n  return matches[1].length;\n};\n\nArgumentParser.prototype._matchArgumentsPartial = function (actions, regexpArgStrings) {\n  // progressively shorten the actions list by slicing off the\n  // final actions until we find a match\n  var self = this;\n  var result = [];\n  var actionSlice, pattern, matches;\n  var i, j;\n\n  function getLength(string) {\n    return string.length;\n  }\n\n  for (i = actions.length; i > 0; i--) {\n    pattern = '';\n    actionSlice = actions.slice(0, i);\n\n    for (j = 0; j < actionSlice.length; j++) {\n      pattern += self._getNargsPattern(actionSlice[j]);\n    }\n\n    pattern = new RegExp('^' + pattern);\n    matches = regexpArgStrings.match(pattern);\n\n    if (matches && matches.length > 0) {\n      // need only groups\n      matches = matches.splice(1);\n      result = result.concat(matches.map(getLength));\n      break;\n    }\n  } // return the list of arg string counts\n\n\n  return result;\n};\n\nArgumentParser.prototype._parseOptional = function (argString) {\n  var action, optionString, argExplicit, optionTuples; // if it's an empty string, it was meant to be a positional\n\n  if (!argString) {\n    return null;\n  } // if it doesn't start with a prefix, it was meant to be positional\n\n\n  if (this.prefixChars.indexOf(argString[0]) < 0) {\n    return null;\n  } // if the option string is present in the parser, return the action\n\n\n  if (this._optionStringActions[argString]) {\n    return [this._optionStringActions[argString], argString, null];\n  } // if it's just a single character, it was meant to be positional\n\n\n  if (argString.length === 1) {\n    return null;\n  } // if the option string before the \"=\" is present, return the action\n\n\n  if (argString.indexOf('=') >= 0) {\n    optionString = argString.split('=', 1)[0];\n    argExplicit = argString.slice(optionString.length + 1);\n\n    if (this._optionStringActions[optionString]) {\n      action = this._optionStringActions[optionString];\n      return [action, optionString, argExplicit];\n    }\n  } // search through all possible prefixes of the option string\n  // and all actions in the parser for possible interpretations\n\n\n  optionTuples = this._getOptionTuples(argString); // if multiple actions match, the option string was ambiguous\n\n  if (optionTuples.length > 1) {\n    var optionStrings = optionTuples.map(function (optionTuple) {\n      return optionTuple[1];\n    });\n    this.error(format('Ambiguous option: \"%s\" could match %s.', argString, optionStrings.join(', '))); // if exactly one action matched, this segmentation is good,\n    // so return the parsed action\n  } else if (optionTuples.length === 1) {\n    return optionTuples[0];\n  } // if it was not found as an option, but it looks like a negative\n  // number, it was meant to be positional\n  // unless there are negative-number-like options\n\n\n  if (argString.match(this._regexpNegativeNumber)) {\n    if (!this._hasNegativeNumberOptionals.some(Boolean)) {\n      return null;\n    }\n  } // if it contains a space, it was meant to be a positional\n\n\n  if (argString.search(' ') >= 0) {\n    return null;\n  } // it was meant to be an optional but there is no such option\n  // in this parser (though it might be a valid option in a subparser)\n\n\n  return [null, argString, null];\n};\n\nArgumentParser.prototype._getOptionTuples = function (optionString) {\n  var result = [];\n  var chars = this.prefixChars;\n  var optionPrefix;\n  var argExplicit;\n  var action;\n  var actionOptionString; // option strings starting with two prefix characters are only split at\n  // the '='\n\n  if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) >= 0) {\n    if (optionString.indexOf('=') >= 0) {\n      var optionStringSplit = optionString.split('=', 1);\n      optionPrefix = optionStringSplit[0];\n      argExplicit = optionStringSplit[1];\n    } else {\n      optionPrefix = optionString;\n      argExplicit = null;\n    }\n\n    for (actionOptionString in this._optionStringActions) {\n      if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {\n        action = this._optionStringActions[actionOptionString];\n        result.push([action, actionOptionString, argExplicit]);\n      }\n    } // single character options can be concatenated with their arguments\n    // but multiple character options always have to have their argument\n    // separate\n\n  } else if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) < 0) {\n    optionPrefix = optionString;\n    argExplicit = null;\n    var optionPrefixShort = optionString.substr(0, 2);\n    var argExplicitShort = optionString.substr(2);\n\n    for (actionOptionString in this._optionStringActions) {\n      if (!$$.has(this._optionStringActions, actionOptionString)) continue;\n      action = this._optionStringActions[actionOptionString];\n\n      if (actionOptionString === optionPrefixShort) {\n        result.push([action, actionOptionString, argExplicitShort]);\n      } else if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {\n        result.push([action, actionOptionString, argExplicit]);\n      }\n    } // shouldn't ever get here\n\n  } else {\n    throw new Error(format('Unexpected option string: %s.', optionString));\n  } // return the collected option tuples\n\n\n  return result;\n};\n\nArgumentParser.prototype._getNargsPattern = function (action) {\n  // in all examples below, we have to allow for '--' args\n  // which are represented as '-' in the pattern\n  var regexpNargs;\n\n  switch (action.nargs) {\n    // the default (null) is assumed to be a single argument\n    case undefined:\n    case null:\n      regexpNargs = '(-*A-*)';\n      break;\n    // allow zero or more arguments\n\n    case c.OPTIONAL:\n      regexpNargs = '(-*A?-*)';\n      break;\n    // allow zero or more arguments\n\n    case c.ZERO_OR_MORE:\n      regexpNargs = '(-*[A-]*)';\n      break;\n    // allow one or more arguments\n\n    case c.ONE_OR_MORE:\n      regexpNargs = '(-*A[A-]*)';\n      break;\n    // allow any number of options or arguments\n\n    case c.REMAINDER:\n      regexpNargs = '([-AO]*)';\n      break;\n    // allow one argument followed by any number of options or arguments\n\n    case c.PARSER:\n      regexpNargs = '(-*A[-AO]*)';\n      break;\n    // all others should be integers\n\n    default:\n      regexpNargs = '(-*' + $$.repeat('-*A', action.nargs) + '-*)';\n  } // if this is an optional action, -- is not allowed\n\n\n  if (action.isOptional()) {\n    regexpNargs = regexpNargs.replace(/-\\*/g, '');\n    regexpNargs = regexpNargs.replace(/-/g, '');\n  } // return the pattern\n\n\n  return regexpNargs;\n}; //\n// Value conversion methods\n//\n\n\nArgumentParser.prototype._getValues = function (action, argStrings) {\n  var self = this; // for everything but PARSER args, strip out '--'\n\n  if (action.nargs !== c.PARSER && action.nargs !== c.REMAINDER) {\n    argStrings = argStrings.filter(function (arrayElement) {\n      return arrayElement !== '--';\n    });\n  }\n\n  var value, argString; // optional argument produces a default when not present\n\n  if (argStrings.length === 0 && action.nargs === c.OPTIONAL) {\n    value = action.isOptional() ? action.constant : action.defaultValue;\n\n    if (typeof value === 'string') {\n      value = this._getValue(action, value);\n\n      this._checkValue(action, value);\n    } // when nargs='*' on a positional, if there were no command-line\n    // args, use the default if it is anything other than None\n\n  } else if (argStrings.length === 0 && action.nargs === c.ZERO_OR_MORE && action.optionStrings.length === 0) {\n    value = action.defaultValue || argStrings;\n\n    this._checkValue(action, value); // single argument or optional argument produces a single value\n\n  } else if (argStrings.length === 1 && (!action.nargs || action.nargs === c.OPTIONAL)) {\n    argString = argStrings[0];\n    value = this._getValue(action, argString);\n\n    this._checkValue(action, value); // REMAINDER arguments convert all values, checking none\n\n  } else if (action.nargs === c.REMAINDER) {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    }); // PARSER arguments convert all values, but check only the first\n  } else if (action.nargs === c.PARSER) {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n\n    this._checkValue(action, value[0]); // all other types of nargs produce a list\n\n  } else {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n    value.forEach(function (v) {\n      self._checkValue(action, v);\n    });\n  } // return the converted value\n\n\n  return value;\n};\n\nArgumentParser.prototype._getValue = function (action, argString) {\n  var result;\n\n  var typeFunction = this._registryGet('type', action.type, action.type);\n\n  if (typeof typeFunction !== 'function') {\n    var message = format('%s is not callable', typeFunction);\n    throw argumentErrorHelper(action, message);\n  } // convert the value to the appropriate type\n\n\n  try {\n    result = typeFunction(argString); // ArgumentTypeErrors indicate errors\n    // If action.type is not a registered string, it is a function\n    // Try to deduce its name for inclusion in the error message\n    // Failing that, include the error message it raised.\n  } catch (e) {\n    var name = null;\n\n    if (typeof action.type === 'string') {\n      name = action.type;\n    } else {\n      name = action.type.name || action.type.displayName || '<function>';\n    }\n\n    var msg = format('Invalid %s value: %s', name, argString);\n\n    if (name === '<function>') {\n      msg += '\\n' + e.message;\n    }\n\n    throw argumentErrorHelper(action, msg);\n  } // return the converted value\n\n\n  return result;\n};\n\nArgumentParser.prototype._checkValue = function (action, value) {\n  // converted value must be one of the choices (if specified)\n  var choices = action.choices;\n\n  if (choices) {\n    // choise for argument can by array or string\n    if ((typeof choices === 'string' || Array.isArray(choices)) && choices.indexOf(value) !== -1) {\n      return;\n    } // choise for subparsers can by only hash\n\n\n    if (typeof choices === 'object' && !Array.isArray(choices) && choices[value]) {\n      return;\n    }\n\n    if (typeof choices === 'string') {\n      choices = choices.split('').join(', ');\n    } else if (Array.isArray(choices)) {\n      choices = choices.join(', ');\n    } else {\n      choices = Object.keys(choices).join(', ');\n    }\n\n    var message = format('Invalid choice: %s (choose from [%s])', value, choices);\n    throw argumentErrorHelper(action, message);\n  }\n}; //\n// Help formatting methods\n//\n\n/**\n * ArgumentParser#formatUsage -> string\n *\n * Return usage string\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\n\n\nArgumentParser.prototype.formatUsage = function () {\n  var formatter = this._getFormatter();\n\n  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);\n  return formatter.formatHelp();\n};\n/**\n * ArgumentParser#formatHelp -> string\n *\n * Return help\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\n\n\nArgumentParser.prototype.formatHelp = function () {\n  var formatter = this._getFormatter(); // usage\n\n\n  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups); // description\n\n  formatter.addText(this.description); // positionals, optionals and user-defined groups\n\n  this._actionGroups.forEach(function (actionGroup) {\n    formatter.startSection(actionGroup.title);\n    formatter.addText(actionGroup.description);\n    formatter.addArguments(actionGroup._groupActions);\n    formatter.endSection();\n  }); // epilog\n\n\n  formatter.addText(this.epilog); // determine help from format above\n\n  return formatter.formatHelp();\n};\n\nArgumentParser.prototype._getFormatter = function () {\n  var FormatterClass = this.formatterClass;\n  var formatter = new FormatterClass({\n    prog: this.prog\n  });\n  return formatter;\n}; //\n//  Print functions\n//\n\n/**\n * ArgumentParser#printUsage() -> Void\n *\n * Print usage\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\n\n\nArgumentParser.prototype.printUsage = function () {\n  this._printMessage(this.formatUsage());\n};\n/**\n * ArgumentParser#printHelp() -> Void\n *\n * Print help\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\n\n\nArgumentParser.prototype.printHelp = function () {\n  this._printMessage(this.formatHelp());\n};\n\nArgumentParser.prototype._printMessage = function (message, stream) {\n  if (!stream) {\n    stream = process.stdout;\n  }\n\n  if (message) {\n    stream.write('' + message);\n  }\n}; //\n//  Exit functions\n//\n\n/**\n * ArgumentParser#exit(status=0, message) -> Void\n * - status (int): exit status\n * - message (string): message\n *\n * Print message in stderr/stdout and exit program\n **/\n\n\nArgumentParser.prototype.exit = function (status, message) {\n  if (message) {\n    if (status === 0) {\n      this._printMessage(message);\n    } else {\n      this._printMessage(message, process.stderr);\n    }\n  }\n\n  process.exit(status);\n};\n/**\n * ArgumentParser#error(message) -> Void\n * - err (Error|string): message\n *\n * Error method Prints a usage message incorporating the message to stderr and\n * exits. If you override this in a subclass,\n * it should not return -- it should\n * either exit or throw an exception.\n *\n **/\n\n\nArgumentParser.prototype.error = function (err) {\n  var message;\n\n  if (err instanceof Error) {\n    if (this.debug === true) {\n      throw err;\n    }\n\n    message = err.message;\n  } else {\n    message = err;\n  }\n\n  var msg = format('%s: error: %s', this.prog, message) + c.EOL;\n\n  if (this.debug === true) {\n    throw new Error(msg);\n  }\n\n  this.printUsage(process.stderr);\n  return this.exit(2, msg);\n};\n\nmodule.exports = ArgumentParser;","map":{"version":3,"names":["util","require","format","Path","sprintf","c","$$","ActionContainer","argumentErrorHelper","HelpFormatter","Namespace","ArgumentParser","options","self","description","argumentDefault","prefixChars","conflictHandler","call","addHelp","parents","prog","basename","process","argv","usage","epilog","version","debug","formatterClass","fromfilePrefixChars","_positionals","addArgumentGroup","title","_optionals","_subparsers","FUNCTION_IDENTITY","o","register","x","result","parseInt","isNaN","Error","parseFloat","defaultPrefix","indexOf","addArgument","action","defaultValue","SUPPRESS","help","forEach","parent","_addContainerActions","_defaults","defaultKey","hasOwnProperty","inherits","prototype","addSubparsers","error","optionStrings","parserClass","formatter","_getFormatter","positionals","_getPositionalActions","groups","_mutuallyExclusiveGroups","addUsage","formatHelp","trim","ParsersClass","_popActionClass","_addAction","isOptional","_getOptionalActions","_actions","filter","isPositional","parseArgs","args","namespace","parseKnownArgs","length","join","slice","dest","has","_getValue","Object","keys","res","_parseKnownArgs","_UNRECOGNIZED_ARGS_ATTR","arrayUnion","e","argStrings","extras","_readArgsFromFiles","actionHash","getName","conflicts","key","actionConflicts","mutexGroup","_groupActions","mutexAction","i","groupActions","push","apply","optionStringIndices","argStringPatternParts","argString","argStringIndex","pattern","optionTuple","_parseOptional","argStringsPattern","seenActions","seenNonDefaultActions","takeAction","argumentStrings","optionString","argumentValues","_getValues","actionConflict","consumeOptional","startIndex","explicitArg","actionTuples","argCount","start","stop","_matchArgument","chars","newExplicitArg","optionalsMap","_optionStringActions","selectedPatterns","substr","consumePositionals","selectedPattern","argCounts","_matchArgumentsPartial","position","maxOptionStringIndex","Math","max","positionalsEndIndex","nextOptionStringIndex","min","strings","concat","stopIndex","required","actionUsed","group","some","names","msg","fs","newArgStrings","argstrs","filename","content","readFileSync","split","argLine","convertArgLineToArgs","arg","message","regexpArgStrings","regexpNargs","RegExp","_getNargsPattern","matches","match","nargs","undefined","OPTIONAL","ONE_OR_MORE","actions","actionSlice","j","getLength","string","splice","map","argExplicit","optionTuples","_getOptionTuples","_regexpNegativeNumber","_hasNegativeNumberOptionals","Boolean","search","optionPrefix","actionOptionString","optionStringSplit","optionPrefixShort","argExplicitShort","ZERO_OR_MORE","REMAINDER","PARSER","repeat","replace","arrayElement","value","constant","_checkValue","v","typeFunction","_registryGet","type","name","displayName","choices","Array","isArray","formatUsage","addText","_actionGroups","actionGroup","startSection","addArguments","endSection","FormatterClass","printUsage","_printMessage","printHelp","stream","stdout","write","exit","status","stderr","err","EOL","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/argparse/lib/argument_parser.js"],"sourcesContent":["/**\n * class ArgumentParser\n *\n * Object for parsing command line strings into js objects.\n *\n * Inherited from [[ActionContainer]]\n **/\n'use strict';\n\nvar util    = require('util');\nvar format  = require('util').format;\nvar Path    = require('path');\nvar sprintf = require('sprintf-js').sprintf;\n\n// Constants\nvar c = require('./const');\n\nvar $$ = require('./utils');\n\nvar ActionContainer = require('./action_container');\n\n// Errors\nvar argumentErrorHelper = require('./argument/error');\n\nvar HelpFormatter = require('./help/formatter');\n\nvar Namespace = require('./namespace');\n\n\n/**\n * new ArgumentParser(options)\n *\n * Create a new ArgumentParser object.\n *\n * ##### Options:\n * - `prog`  The name of the program (default: Path.basename(process.argv[1]))\n * - `usage`  A usage message (default: auto-generated from arguments)\n * - `description`  A description of what the program does\n * - `epilog`  Text following the argument descriptions\n * - `parents`  Parsers whose arguments should be copied into this one\n * - `formatterClass`  HelpFormatter class for printing help messages\n * - `prefixChars`  Characters that prefix optional arguments\n * - `fromfilePrefixChars` Characters that prefix files containing additional arguments\n * - `argumentDefault`  The default value for all arguments\n * - `addHelp`  Add a -h/-help option\n * - `conflictHandler`  Specifies how to handle conflicting argument names\n * - `debug`  Enable debug mode. Argument errors throw exception in\n *   debug mode and process.exit in normal. Used for development and\n *   testing (default: false)\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#argumentparser-objects\n **/\nfunction ArgumentParser(options) {\n  if (!(this instanceof ArgumentParser)) {\n    return new ArgumentParser(options);\n  }\n  var self = this;\n  options = options || {};\n\n  options.description = (options.description || null);\n  options.argumentDefault = (options.argumentDefault || null);\n  options.prefixChars = (options.prefixChars || '-');\n  options.conflictHandler = (options.conflictHandler || 'error');\n  ActionContainer.call(this, options);\n\n  options.addHelp = typeof options.addHelp === 'undefined' || !!options.addHelp;\n  options.parents = options.parents || [];\n  // default program name\n  options.prog = (options.prog || Path.basename(process.argv[1]));\n  this.prog = options.prog;\n  this.usage = options.usage;\n  this.epilog = options.epilog;\n  this.version = options.version;\n\n  this.debug = (options.debug === true);\n\n  this.formatterClass = (options.formatterClass || HelpFormatter);\n  this.fromfilePrefixChars = options.fromfilePrefixChars || null;\n  this._positionals = this.addArgumentGroup({ title: 'Positional arguments' });\n  this._optionals = this.addArgumentGroup({ title: 'Optional arguments' });\n  this._subparsers = null;\n\n  // register types\n  function FUNCTION_IDENTITY(o) {\n    return o;\n  }\n  this.register('type', 'auto', FUNCTION_IDENTITY);\n  this.register('type', null, FUNCTION_IDENTITY);\n  this.register('type', 'int', function (x) {\n    var result = parseInt(x, 10);\n    if (isNaN(result)) {\n      throw new Error(x + ' is not a valid integer.');\n    }\n    return result;\n  });\n  this.register('type', 'float', function (x) {\n    var result = parseFloat(x);\n    if (isNaN(result)) {\n      throw new Error(x + ' is not a valid float.');\n    }\n    return result;\n  });\n  this.register('type', 'string', function (x) {\n    return '' + x;\n  });\n\n  // add help and version arguments if necessary\n  var defaultPrefix = (this.prefixChars.indexOf('-') > -1) ? '-' : this.prefixChars[0];\n  if (options.addHelp) {\n    this.addArgument(\n      [ defaultPrefix + 'h', defaultPrefix + defaultPrefix + 'help' ],\n      {\n        action: 'help',\n        defaultValue: c.SUPPRESS,\n        help: 'Show this help message and exit.'\n      }\n    );\n  }\n  if (typeof this.version !== 'undefined') {\n    this.addArgument(\n      [ defaultPrefix + 'v', defaultPrefix + defaultPrefix + 'version' ],\n      {\n        action: 'version',\n        version: this.version,\n        defaultValue: c.SUPPRESS,\n        help: \"Show program's version number and exit.\"\n      }\n    );\n  }\n\n  // add parent arguments and defaults\n  options.parents.forEach(function (parent) {\n    self._addContainerActions(parent);\n    if (typeof parent._defaults !== 'undefined') {\n      for (var defaultKey in parent._defaults) {\n        if (parent._defaults.hasOwnProperty(defaultKey)) {\n          self._defaults[defaultKey] = parent._defaults[defaultKey];\n        }\n      }\n    }\n  });\n}\n\nutil.inherits(ArgumentParser, ActionContainer);\n\n/**\n * ArgumentParser#addSubparsers(options) -> [[ActionSubparsers]]\n * - options (object): hash of options see [[ActionSubparsers.new]]\n *\n * See also [subcommands][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#sub-commands\n **/\nArgumentParser.prototype.addSubparsers = function (options) {\n  if (this._subparsers) {\n    this.error('Cannot have multiple subparser arguments.');\n  }\n\n  options = options || {};\n  options.debug = (this.debug === true);\n  options.optionStrings = [];\n  options.parserClass = (options.parserClass || ArgumentParser);\n\n\n  if (!!options.title || !!options.description) {\n\n    this._subparsers = this.addArgumentGroup({\n      title: (options.title || 'subcommands'),\n      description: options.description\n    });\n    delete options.title;\n    delete options.description;\n\n  } else {\n    this._subparsers = this._positionals;\n  }\n\n  // prog defaults to the usage message of this parser, skipping\n  // optional arguments and with no \"usage:\" prefix\n  if (!options.prog) {\n    var formatter = this._getFormatter();\n    var positionals = this._getPositionalActions();\n    var groups = this._mutuallyExclusiveGroups;\n    formatter.addUsage(this.usage, positionals, groups, '');\n    options.prog = formatter.formatHelp().trim();\n  }\n\n  // create the parsers action and add it to the positionals list\n  var ParsersClass = this._popActionClass(options, 'parsers');\n  var action = new ParsersClass(options);\n  this._subparsers._addAction(action);\n\n  // return the created parsers action\n  return action;\n};\n\nArgumentParser.prototype._addAction = function (action) {\n  if (action.isOptional()) {\n    this._optionals._addAction(action);\n  } else {\n    this._positionals._addAction(action);\n  }\n  return action;\n};\n\nArgumentParser.prototype._getOptionalActions = function () {\n  return this._actions.filter(function (action) {\n    return action.isOptional();\n  });\n};\n\nArgumentParser.prototype._getPositionalActions = function () {\n  return this._actions.filter(function (action) {\n    return action.isPositional();\n  });\n};\n\n\n/**\n * ArgumentParser#parseArgs(args, namespace) -> Namespace|Object\n * - args (array): input elements\n * - namespace (Namespace|Object): result object\n *\n * Parsed args and throws error if some arguments are not recognized\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#the-parse-args-method\n **/\nArgumentParser.prototype.parseArgs = function (args, namespace) {\n  var argv;\n  var result = this.parseKnownArgs(args, namespace);\n\n  args = result[0];\n  argv = result[1];\n  if (argv && argv.length > 0) {\n    this.error(\n      format('Unrecognized arguments: %s.', argv.join(' '))\n    );\n  }\n  return args;\n};\n\n/**\n * ArgumentParser#parseKnownArgs(args, namespace) -> array\n * - args (array): input options\n * - namespace (Namespace|Object): result object\n *\n * Parse known arguments and return tuple of result object\n * and unknown args\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#partial-parsing\n **/\nArgumentParser.prototype.parseKnownArgs = function (args, namespace) {\n  var self = this;\n\n  // args default to the system args\n  args = args || process.argv.slice(2);\n\n  // default Namespace built from parser defaults\n  namespace = namespace || new Namespace();\n\n  self._actions.forEach(function (action) {\n    if (action.dest !== c.SUPPRESS) {\n      if (!$$.has(namespace, action.dest)) {\n        if (action.defaultValue !== c.SUPPRESS) {\n          var defaultValue = action.defaultValue;\n          if (typeof action.defaultValue === 'string') {\n            defaultValue = self._getValue(action, defaultValue);\n          }\n          namespace[action.dest] = defaultValue;\n        }\n      }\n    }\n  });\n\n  Object.keys(self._defaults).forEach(function (dest) {\n    namespace[dest] = self._defaults[dest];\n  });\n\n  // parse the arguments and exit if there are any errors\n  try {\n    var res = this._parseKnownArgs(args, namespace);\n\n    namespace = res[0];\n    args = res[1];\n    if ($$.has(namespace, c._UNRECOGNIZED_ARGS_ATTR)) {\n      args = $$.arrayUnion(args, namespace[c._UNRECOGNIZED_ARGS_ATTR]);\n      delete namespace[c._UNRECOGNIZED_ARGS_ATTR];\n    }\n    return [ namespace, args ];\n  } catch (e) {\n    this.error(e);\n  }\n};\n\nArgumentParser.prototype._parseKnownArgs = function (argStrings, namespace) {\n  var self = this;\n\n  var extras = [];\n\n  // replace arg strings that are file references\n  if (this.fromfilePrefixChars !== null) {\n    argStrings = this._readArgsFromFiles(argStrings);\n  }\n  // map all mutually exclusive arguments to the other arguments\n  // they can't occur with\n  // Python has 'conflicts = action_conflicts.setdefault(mutex_action, [])'\n  // though I can't conceive of a way in which an action could be a member\n  // of two different mutually exclusive groups.\n\n  function actionHash(action) {\n    // some sort of hashable key for this action\n    // action itself cannot be a key in actionConflicts\n    // I think getName() (join of optionStrings) is unique enough\n    return action.getName();\n  }\n\n  var conflicts, key;\n  var actionConflicts = {};\n\n  this._mutuallyExclusiveGroups.forEach(function (mutexGroup) {\n    mutexGroup._groupActions.forEach(function (mutexAction, i, groupActions) {\n      key = actionHash(mutexAction);\n      if (!$$.has(actionConflicts, key)) {\n        actionConflicts[key] = [];\n      }\n      conflicts = actionConflicts[key];\n      conflicts.push.apply(conflicts, groupActions.slice(0, i));\n      conflicts.push.apply(conflicts, groupActions.slice(i + 1));\n    });\n  });\n\n  // find all option indices, and determine the arg_string_pattern\n  // which has an 'O' if there is an option at an index,\n  // an 'A' if there is an argument, or a '-' if there is a '--'\n  var optionStringIndices = {};\n\n  var argStringPatternParts = [];\n\n  argStrings.forEach(function (argString, argStringIndex) {\n    if (argString === '--') {\n      argStringPatternParts.push('-');\n      while (argStringIndex < argStrings.length) {\n        argStringPatternParts.push('A');\n        argStringIndex++;\n      }\n    } else {\n      // otherwise, add the arg to the arg strings\n      // and note the index if it was an option\n      var pattern;\n      var optionTuple = self._parseOptional(argString);\n      if (!optionTuple) {\n        pattern = 'A';\n      } else {\n        optionStringIndices[argStringIndex] = optionTuple;\n        pattern = 'O';\n      }\n      argStringPatternParts.push(pattern);\n    }\n  });\n  var argStringsPattern = argStringPatternParts.join('');\n\n  var seenActions = [];\n  var seenNonDefaultActions = [];\n\n\n  function takeAction(action, argumentStrings, optionString) {\n    seenActions.push(action);\n    var argumentValues = self._getValues(action, argumentStrings);\n\n    // error if this argument is not allowed with other previously\n    // seen arguments, assuming that actions that use the default\n    // value don't really count as \"present\"\n    if (argumentValues !== action.defaultValue) {\n      seenNonDefaultActions.push(action);\n      if (actionConflicts[actionHash(action)]) {\n        actionConflicts[actionHash(action)].forEach(function (actionConflict) {\n          if (seenNonDefaultActions.indexOf(actionConflict) >= 0) {\n            throw argumentErrorHelper(\n              action,\n              format('Not allowed with argument \"%s\".', actionConflict.getName())\n            );\n          }\n        });\n      }\n    }\n\n    if (argumentValues !== c.SUPPRESS) {\n      action.call(self, namespace, argumentValues, optionString);\n    }\n  }\n\n  function consumeOptional(startIndex) {\n    // get the optional identified at this index\n    var optionTuple = optionStringIndices[startIndex];\n    var action = optionTuple[0];\n    var optionString = optionTuple[1];\n    var explicitArg = optionTuple[2];\n\n    // identify additional optionals in the same arg string\n    // (e.g. -xyz is the same as -x -y -z if no args are required)\n    var actionTuples = [];\n\n    var args, argCount, start, stop;\n\n    for (;;) {\n      if (!action) {\n        extras.push(argStrings[startIndex]);\n        return startIndex + 1;\n      }\n      if (explicitArg) {\n        argCount = self._matchArgument(action, 'A');\n\n        // if the action is a single-dash option and takes no\n        // arguments, try to parse more single-dash options out\n        // of the tail of the option string\n        var chars = self.prefixChars;\n        if (argCount === 0 && chars.indexOf(optionString[1]) < 0) {\n          actionTuples.push([ action, [], optionString ]);\n          optionString = optionString[0] + explicitArg[0];\n          var newExplicitArg = explicitArg.slice(1) || null;\n          var optionalsMap = self._optionStringActions;\n\n          if (Object.keys(optionalsMap).indexOf(optionString) >= 0) {\n            action = optionalsMap[optionString];\n            explicitArg = newExplicitArg;\n          } else {\n            throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));\n          }\n        } else if (argCount === 1) {\n          // if the action expect exactly one argument, we've\n          // successfully matched the option; exit the loop\n          stop = startIndex + 1;\n          args = [ explicitArg ];\n          actionTuples.push([ action, args, optionString ]);\n          break;\n        } else {\n          // error if a double-dash option did not use the\n          // explicit argument\n          throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));\n        }\n      } else {\n        // if there is no explicit argument, try to match the\n        // optional's string arguments with the following strings\n        // if successful, exit the loop\n\n        start = startIndex + 1;\n        var selectedPatterns = argStringsPattern.substr(start);\n\n        argCount = self._matchArgument(action, selectedPatterns);\n        stop = start + argCount;\n\n\n        args = argStrings.slice(start, stop);\n\n        actionTuples.push([ action, args, optionString ]);\n        break;\n      }\n\n    }\n\n    // add the Optional to the list and return the index at which\n    // the Optional's string args stopped\n    if (actionTuples.length < 1) {\n      throw new Error('length should be > 0');\n    }\n    for (var i = 0; i < actionTuples.length; i++) {\n      takeAction.apply(self, actionTuples[i]);\n    }\n    return stop;\n  }\n\n  // the list of Positionals left to be parsed; this is modified\n  // by consume_positionals()\n  var positionals = self._getPositionalActions();\n\n  function consumePositionals(startIndex) {\n    // match as many Positionals as possible\n    var selectedPattern = argStringsPattern.substr(startIndex);\n    var argCounts = self._matchArgumentsPartial(positionals, selectedPattern);\n\n    // slice off the appropriate arg strings for each Positional\n    // and add the Positional and its args to the list\n    for (var i = 0; i < positionals.length; i++) {\n      var action = positionals[i];\n      var argCount = argCounts[i];\n      if (typeof argCount === 'undefined') {\n        continue;\n      }\n      var args = argStrings.slice(startIndex, startIndex + argCount);\n\n      startIndex += argCount;\n      takeAction(action, args);\n    }\n\n    // slice off the Positionals that we just parsed and return the\n    // index at which the Positionals' string args stopped\n    positionals = positionals.slice(argCounts.length);\n    return startIndex;\n  }\n\n  // consume Positionals and Optionals alternately, until we have\n  // passed the last option string\n  var startIndex = 0;\n  var position;\n\n  var maxOptionStringIndex = -1;\n\n  Object.keys(optionStringIndices).forEach(function (position) {\n    maxOptionStringIndex = Math.max(maxOptionStringIndex, parseInt(position, 10));\n  });\n\n  var positionalsEndIndex, nextOptionStringIndex;\n\n  while (startIndex <= maxOptionStringIndex) {\n    // consume any Positionals preceding the next option\n    nextOptionStringIndex = null;\n    for (position in optionStringIndices) {\n      if (!optionStringIndices.hasOwnProperty(position)) { continue; }\n\n      position = parseInt(position, 10);\n      if (position >= startIndex) {\n        if (nextOptionStringIndex !== null) {\n          nextOptionStringIndex = Math.min(nextOptionStringIndex, position);\n        } else {\n          nextOptionStringIndex = position;\n        }\n      }\n    }\n\n    if (startIndex !== nextOptionStringIndex) {\n      positionalsEndIndex = consumePositionals(startIndex);\n      // only try to parse the next optional if we didn't consume\n      // the option string during the positionals parsing\n      if (positionalsEndIndex > startIndex) {\n        startIndex = positionalsEndIndex;\n        continue;\n      } else {\n        startIndex = positionalsEndIndex;\n      }\n    }\n\n    // if we consumed all the positionals we could and we're not\n    // at the index of an option string, there were extra arguments\n    if (!optionStringIndices[startIndex]) {\n      var strings = argStrings.slice(startIndex, nextOptionStringIndex);\n      extras = extras.concat(strings);\n      startIndex = nextOptionStringIndex;\n    }\n    // consume the next optional and any arguments for it\n    startIndex = consumeOptional(startIndex);\n  }\n\n  // consume any positionals following the last Optional\n  var stopIndex = consumePositionals(startIndex);\n\n  // if we didn't consume all the argument strings, there were extras\n  extras = extras.concat(argStrings.slice(stopIndex));\n\n  // if we didn't use all the Positional objects, there were too few\n  // arg strings supplied.\n  if (positionals.length > 0) {\n    self.error('too few arguments');\n  }\n\n  // make sure all required actions were present\n  self._actions.forEach(function (action) {\n    if (action.required) {\n      if (seenActions.indexOf(action) < 0) {\n        self.error(format('Argument \"%s\" is required', action.getName()));\n      }\n    }\n  });\n\n  // make sure all required groups have one option present\n  var actionUsed = false;\n  self._mutuallyExclusiveGroups.forEach(function (group) {\n    if (group.required) {\n      actionUsed = group._groupActions.some(function (action) {\n        return seenNonDefaultActions.indexOf(action) !== -1;\n      });\n\n      // if no actions were used, report the error\n      if (!actionUsed) {\n        var names = [];\n        group._groupActions.forEach(function (action) {\n          if (action.help !== c.SUPPRESS) {\n            names.push(action.getName());\n          }\n        });\n        names = names.join(' ');\n        var msg = 'one of the arguments ' + names + ' is required';\n        self.error(msg);\n      }\n    }\n  });\n\n  // return the updated namespace and the extra arguments\n  return [ namespace, extras ];\n};\n\nArgumentParser.prototype._readArgsFromFiles = function (argStrings) {\n  // expand arguments referencing files\n  var self = this;\n  var fs = require('fs');\n  var newArgStrings = [];\n  argStrings.forEach(function (argString) {\n    if (self.fromfilePrefixChars.indexOf(argString[0]) < 0) {\n      // for regular arguments, just add them back into the list\n      newArgStrings.push(argString);\n    } else {\n      // replace arguments referencing files with the file content\n      try {\n        var argstrs = [];\n        var filename = argString.slice(1);\n        var content = fs.readFileSync(filename, 'utf8');\n        content = content.trim().split('\\n');\n        content.forEach(function (argLine) {\n          self.convertArgLineToArgs(argLine).forEach(function (arg) {\n            argstrs.push(arg);\n          });\n          argstrs = self._readArgsFromFiles(argstrs);\n        });\n        newArgStrings.push.apply(newArgStrings, argstrs);\n      } catch (error) {\n        return self.error(error.message);\n      }\n    }\n  });\n  return newArgStrings;\n};\n\nArgumentParser.prototype.convertArgLineToArgs = function (argLine) {\n  return [ argLine ];\n};\n\nArgumentParser.prototype._matchArgument = function (action, regexpArgStrings) {\n\n  // match the pattern for this action to the arg strings\n  var regexpNargs = new RegExp('^' + this._getNargsPattern(action));\n  var matches = regexpArgStrings.match(regexpNargs);\n  var message;\n\n  // throw an exception if we weren't able to find a match\n  if (!matches) {\n    switch (action.nargs) {\n      /*eslint-disable no-undefined*/\n      case undefined:\n      case null:\n        message = 'Expected one argument.';\n        break;\n      case c.OPTIONAL:\n        message = 'Expected at most one argument.';\n        break;\n      case c.ONE_OR_MORE:\n        message = 'Expected at least one argument.';\n        break;\n      default:\n        message = 'Expected %s argument(s)';\n    }\n\n    throw argumentErrorHelper(\n      action,\n      format(message, action.nargs)\n    );\n  }\n  // return the number of arguments matched\n  return matches[1].length;\n};\n\nArgumentParser.prototype._matchArgumentsPartial = function (actions, regexpArgStrings) {\n  // progressively shorten the actions list by slicing off the\n  // final actions until we find a match\n  var self = this;\n  var result = [];\n  var actionSlice, pattern, matches;\n  var i, j;\n\n  function getLength(string) {\n    return string.length;\n  }\n\n  for (i = actions.length; i > 0; i--) {\n    pattern = '';\n    actionSlice = actions.slice(0, i);\n    for (j = 0; j < actionSlice.length; j++) {\n      pattern += self._getNargsPattern(actionSlice[j]);\n    }\n\n    pattern = new RegExp('^' + pattern);\n    matches = regexpArgStrings.match(pattern);\n\n    if (matches && matches.length > 0) {\n      // need only groups\n      matches = matches.splice(1);\n      result = result.concat(matches.map(getLength));\n      break;\n    }\n  }\n\n  // return the list of arg string counts\n  return result;\n};\n\nArgumentParser.prototype._parseOptional = function (argString) {\n  var action, optionString, argExplicit, optionTuples;\n\n  // if it's an empty string, it was meant to be a positional\n  if (!argString) {\n    return null;\n  }\n\n  // if it doesn't start with a prefix, it was meant to be positional\n  if (this.prefixChars.indexOf(argString[0]) < 0) {\n    return null;\n  }\n\n  // if the option string is present in the parser, return the action\n  if (this._optionStringActions[argString]) {\n    return [ this._optionStringActions[argString], argString, null ];\n  }\n\n  // if it's just a single character, it was meant to be positional\n  if (argString.length === 1) {\n    return null;\n  }\n\n  // if the option string before the \"=\" is present, return the action\n  if (argString.indexOf('=') >= 0) {\n    optionString = argString.split('=', 1)[0];\n    argExplicit = argString.slice(optionString.length + 1);\n\n    if (this._optionStringActions[optionString]) {\n      action = this._optionStringActions[optionString];\n      return [ action, optionString, argExplicit ];\n    }\n  }\n\n  // search through all possible prefixes of the option string\n  // and all actions in the parser for possible interpretations\n  optionTuples = this._getOptionTuples(argString);\n\n  // if multiple actions match, the option string was ambiguous\n  if (optionTuples.length > 1) {\n    var optionStrings = optionTuples.map(function (optionTuple) {\n      return optionTuple[1];\n    });\n    this.error(format(\n          'Ambiguous option: \"%s\" could match %s.',\n          argString, optionStrings.join(', ')\n    ));\n  // if exactly one action matched, this segmentation is good,\n  // so return the parsed action\n  } else if (optionTuples.length === 1) {\n    return optionTuples[0];\n  }\n\n  // if it was not found as an option, but it looks like a negative\n  // number, it was meant to be positional\n  // unless there are negative-number-like options\n  if (argString.match(this._regexpNegativeNumber)) {\n    if (!this._hasNegativeNumberOptionals.some(Boolean)) {\n      return null;\n    }\n  }\n  // if it contains a space, it was meant to be a positional\n  if (argString.search(' ') >= 0) {\n    return null;\n  }\n\n  // it was meant to be an optional but there is no such option\n  // in this parser (though it might be a valid option in a subparser)\n  return [ null, argString, null ];\n};\n\nArgumentParser.prototype._getOptionTuples = function (optionString) {\n  var result = [];\n  var chars = this.prefixChars;\n  var optionPrefix;\n  var argExplicit;\n  var action;\n  var actionOptionString;\n\n  // option strings starting with two prefix characters are only split at\n  // the '='\n  if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) >= 0) {\n    if (optionString.indexOf('=') >= 0) {\n      var optionStringSplit = optionString.split('=', 1);\n\n      optionPrefix = optionStringSplit[0];\n      argExplicit = optionStringSplit[1];\n    } else {\n      optionPrefix = optionString;\n      argExplicit = null;\n    }\n\n    for (actionOptionString in this._optionStringActions) {\n      if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {\n        action = this._optionStringActions[actionOptionString];\n        result.push([ action, actionOptionString, argExplicit ]);\n      }\n    }\n\n  // single character options can be concatenated with their arguments\n  // but multiple character options always have to have their argument\n  // separate\n  } else if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) < 0) {\n    optionPrefix = optionString;\n    argExplicit = null;\n    var optionPrefixShort = optionString.substr(0, 2);\n    var argExplicitShort = optionString.substr(2);\n\n    for (actionOptionString in this._optionStringActions) {\n      if (!$$.has(this._optionStringActions, actionOptionString)) continue;\n\n      action = this._optionStringActions[actionOptionString];\n      if (actionOptionString === optionPrefixShort) {\n        result.push([ action, actionOptionString, argExplicitShort ]);\n      } else if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {\n        result.push([ action, actionOptionString, argExplicit ]);\n      }\n    }\n\n  // shouldn't ever get here\n  } else {\n    throw new Error(format('Unexpected option string: %s.', optionString));\n  }\n  // return the collected option tuples\n  return result;\n};\n\nArgumentParser.prototype._getNargsPattern = function (action) {\n  // in all examples below, we have to allow for '--' args\n  // which are represented as '-' in the pattern\n  var regexpNargs;\n\n  switch (action.nargs) {\n    // the default (null) is assumed to be a single argument\n    case undefined:\n    case null:\n      regexpNargs = '(-*A-*)';\n      break;\n    // allow zero or more arguments\n    case c.OPTIONAL:\n      regexpNargs = '(-*A?-*)';\n      break;\n    // allow zero or more arguments\n    case c.ZERO_OR_MORE:\n      regexpNargs = '(-*[A-]*)';\n      break;\n    // allow one or more arguments\n    case c.ONE_OR_MORE:\n      regexpNargs = '(-*A[A-]*)';\n      break;\n    // allow any number of options or arguments\n    case c.REMAINDER:\n      regexpNargs = '([-AO]*)';\n      break;\n    // allow one argument followed by any number of options or arguments\n    case c.PARSER:\n      regexpNargs = '(-*A[-AO]*)';\n      break;\n    // all others should be integers\n    default:\n      regexpNargs = '(-*' + $$.repeat('-*A', action.nargs) + '-*)';\n  }\n\n  // if this is an optional action, -- is not allowed\n  if (action.isOptional()) {\n    regexpNargs = regexpNargs.replace(/-\\*/g, '');\n    regexpNargs = regexpNargs.replace(/-/g, '');\n  }\n\n  // return the pattern\n  return regexpNargs;\n};\n\n//\n// Value conversion methods\n//\n\nArgumentParser.prototype._getValues = function (action, argStrings) {\n  var self = this;\n\n  // for everything but PARSER args, strip out '--'\n  if (action.nargs !== c.PARSER && action.nargs !== c.REMAINDER) {\n    argStrings = argStrings.filter(function (arrayElement) {\n      return arrayElement !== '--';\n    });\n  }\n\n  var value, argString;\n\n  // optional argument produces a default when not present\n  if (argStrings.length === 0 && action.nargs === c.OPTIONAL) {\n\n    value = (action.isOptional()) ? action.constant : action.defaultValue;\n\n    if (typeof (value) === 'string') {\n      value = this._getValue(action, value);\n      this._checkValue(action, value);\n    }\n\n  // when nargs='*' on a positional, if there were no command-line\n  // args, use the default if it is anything other than None\n  } else if (argStrings.length === 0 && action.nargs === c.ZERO_OR_MORE &&\n    action.optionStrings.length === 0) {\n\n    value = (action.defaultValue || argStrings);\n    this._checkValue(action, value);\n\n  // single argument or optional argument produces a single value\n  } else if (argStrings.length === 1 &&\n        (!action.nargs || action.nargs === c.OPTIONAL)) {\n\n    argString = argStrings[0];\n    value = this._getValue(action, argString);\n    this._checkValue(action, value);\n\n  // REMAINDER arguments convert all values, checking none\n  } else if (action.nargs === c.REMAINDER) {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n\n  // PARSER arguments convert all values, but check only the first\n  } else if (action.nargs === c.PARSER) {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n    this._checkValue(action, value[0]);\n\n  // all other types of nargs produce a list\n  } else {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n    value.forEach(function (v) {\n      self._checkValue(action, v);\n    });\n  }\n\n  // return the converted value\n  return value;\n};\n\nArgumentParser.prototype._getValue = function (action, argString) {\n  var result;\n\n  var typeFunction = this._registryGet('type', action.type, action.type);\n  if (typeof typeFunction !== 'function') {\n    var message = format('%s is not callable', typeFunction);\n    throw argumentErrorHelper(action, message);\n  }\n\n  // convert the value to the appropriate type\n  try {\n    result = typeFunction(argString);\n\n    // ArgumentTypeErrors indicate errors\n    // If action.type is not a registered string, it is a function\n    // Try to deduce its name for inclusion in the error message\n    // Failing that, include the error message it raised.\n  } catch (e) {\n    var name = null;\n    if (typeof action.type === 'string') {\n      name = action.type;\n    } else {\n      name = action.type.name || action.type.displayName || '<function>';\n    }\n    var msg = format('Invalid %s value: %s', name, argString);\n    if (name === '<function>') { msg += '\\n' + e.message; }\n    throw argumentErrorHelper(action, msg);\n  }\n  // return the converted value\n  return result;\n};\n\nArgumentParser.prototype._checkValue = function (action, value) {\n  // converted value must be one of the choices (if specified)\n  var choices = action.choices;\n  if (choices) {\n    // choise for argument can by array or string\n    if ((typeof choices === 'string' || Array.isArray(choices)) &&\n        choices.indexOf(value) !== -1) {\n      return;\n    }\n    // choise for subparsers can by only hash\n    if (typeof choices === 'object' && !Array.isArray(choices) && choices[value]) {\n      return;\n    }\n\n    if (typeof choices === 'string') {\n      choices = choices.split('').join(', ');\n    } else if (Array.isArray(choices)) {\n      choices =  choices.join(', ');\n    } else {\n      choices =  Object.keys(choices).join(', ');\n    }\n    var message = format('Invalid choice: %s (choose from [%s])', value, choices);\n    throw argumentErrorHelper(action, message);\n  }\n};\n\n//\n// Help formatting methods\n//\n\n/**\n * ArgumentParser#formatUsage -> string\n *\n * Return usage string\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.formatUsage = function () {\n  var formatter = this._getFormatter();\n  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);\n  return formatter.formatHelp();\n};\n\n/**\n * ArgumentParser#formatHelp -> string\n *\n * Return help\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.formatHelp = function () {\n  var formatter = this._getFormatter();\n\n  // usage\n  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);\n\n  // description\n  formatter.addText(this.description);\n\n  // positionals, optionals and user-defined groups\n  this._actionGroups.forEach(function (actionGroup) {\n    formatter.startSection(actionGroup.title);\n    formatter.addText(actionGroup.description);\n    formatter.addArguments(actionGroup._groupActions);\n    formatter.endSection();\n  });\n\n  // epilog\n  formatter.addText(this.epilog);\n\n  // determine help from format above\n  return formatter.formatHelp();\n};\n\nArgumentParser.prototype._getFormatter = function () {\n  var FormatterClass = this.formatterClass;\n  var formatter = new FormatterClass({ prog: this.prog });\n  return formatter;\n};\n\n//\n//  Print functions\n//\n\n/**\n * ArgumentParser#printUsage() -> Void\n *\n * Print usage\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.printUsage = function () {\n  this._printMessage(this.formatUsage());\n};\n\n/**\n * ArgumentParser#printHelp() -> Void\n *\n * Print help\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.printHelp = function () {\n  this._printMessage(this.formatHelp());\n};\n\nArgumentParser.prototype._printMessage = function (message, stream) {\n  if (!stream) {\n    stream = process.stdout;\n  }\n  if (message) {\n    stream.write('' + message);\n  }\n};\n\n//\n//  Exit functions\n//\n\n/**\n * ArgumentParser#exit(status=0, message) -> Void\n * - status (int): exit status\n * - message (string): message\n *\n * Print message in stderr/stdout and exit program\n **/\nArgumentParser.prototype.exit = function (status, message) {\n  if (message) {\n    if (status === 0) {\n      this._printMessage(message);\n    } else {\n      this._printMessage(message, process.stderr);\n    }\n  }\n\n  process.exit(status);\n};\n\n/**\n * ArgumentParser#error(message) -> Void\n * - err (Error|string): message\n *\n * Error method Prints a usage message incorporating the message to stderr and\n * exits. If you override this in a subclass,\n * it should not return -- it should\n * either exit or throw an exception.\n *\n **/\nArgumentParser.prototype.error = function (err) {\n  var message;\n  if (err instanceof Error) {\n    if (this.debug === true) {\n      throw err;\n    }\n    message = err.message;\n  } else {\n    message = err;\n  }\n  var msg = format('%s: error: %s', this.prog, message) + c.EOL;\n\n  if (this.debug === true) {\n    throw new Error(msg);\n  }\n\n  this.printUsage(process.stderr);\n\n  return this.exit(2, msg);\n};\n\nmodule.exports = ArgumentParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}