{"ast":null,"code":"\"use strict\";\n\nconst {\n  dirname,\n  isAbsolute,\n  join\n} = require('path');\n\nconst ESLintError = require('./ESLintError');\n\nconst {\n  getESLint\n} = require('./getESLint');\n/** @typedef {import('eslint').ESLint} ESLint */\n\n/** @typedef {import('eslint').ESLint.Formatter} Formatter */\n\n/** @typedef {import('eslint').ESLint.LintResult} LintResult */\n\n/** @typedef {import('webpack').Compiler} Compiler */\n\n/** @typedef {import('webpack').Compilation} Compilation */\n\n/** @typedef {import('./options').Options} Options */\n\n/** @typedef {import('./options').FormatterFunction} FormatterFunction */\n\n/** @typedef {(compilation: Compilation) => Promise<void>} GenerateReport */\n\n/** @typedef {{errors?: ESLintError, warnings?: ESLintError, generateReportAsset?: GenerateReport}} Report */\n\n/** @typedef {() => Promise<Report>} Reporter */\n\n/** @typedef {(files: string|string[]) => void} Linter */\n\n/** @typedef {{[files: string]: LintResult}} LintResultMap */\n\n/** @type {WeakMap<Compiler, LintResultMap>} */\n\n\nconst resultStorage = new WeakMap();\n/**\n * @param {string|undefined} key\n * @param {Options} options\n * @param {Compilation} compilation\n * @returns {{lint: Linter, report: Reporter, threads: number}}\n */\n\nfunction linter(key, options, compilation) {\n  /** @type {ESLint} */\n  let eslint;\n  /** @type {(files: string|string[]) => Promise<LintResult[]>} */\n\n  let lintFiles;\n  /** @type {() => Promise<void>} */\n\n  let cleanup;\n  /** @type number */\n\n  let threads;\n  /** @type {Promise<LintResult[]>[]} */\n\n  const rawResults = [];\n  const crossRunResultStorage = getResultStorage(compilation);\n\n  try {\n    ({\n      eslint,\n      lintFiles,\n      cleanup,\n      threads\n    } = getESLint(key, options));\n  } catch (e) {\n    throw new ESLintError(e.message);\n  }\n\n  return {\n    lint,\n    report,\n    threads\n  };\n  /**\n   * @param {string | string[]} files\n   */\n\n  function lint(files) {\n    for (const file of asList(files)) {\n      delete crossRunResultStorage[file];\n    }\n\n    rawResults.push(lintFiles(files).catch(e => {\n      // @ts-ignore\n      compilation.errors.push(new ESLintError(e.message));\n      return [];\n    }));\n  }\n\n  async function report() {\n    // Filter out ignored files.\n    let results = await removeIgnoredWarnings(eslint, // Get the current results, resetting the rawResults to empty\n    await flatten(rawResults.splice(0, rawResults.length)));\n    await cleanup();\n\n    for (const result of results) {\n      crossRunResultStorage[result.filePath] = result;\n    }\n\n    results = Object.values(crossRunResultStorage); // do not analyze if there are no results or eslint config\n\n    if (!results || results.length < 1) {\n      return {};\n    }\n\n    const formatter = await loadFormatter(eslint, options.formatter);\n    const {\n      errors,\n      warnings\n    } = await formatResults(formatter, parseResults(options, results));\n    return {\n      errors,\n      warnings,\n      generateReportAsset\n    };\n    /**\n     * @param {Compilation} compilation\n     * @returns {Promise<void>}\n     */\n\n    async function generateReportAsset(_ref) {\n      let {\n        compiler\n      } = _ref;\n      const {\n        outputReport\n      } = options;\n      /**\n       * @param {string} name\n       * @param {string | Buffer} content\n       */\n\n      const save = (name, content) =>\n      /** @type {Promise<void>} */\n      new Promise((finish, bail) => {\n        const {\n          mkdir,\n          writeFile\n        } = compiler.outputFileSystem; // ensure directory exists\n        // @ts-ignore - the types for `outputFileSystem` are missing the 3 arg overload\n\n        mkdir(dirname(name), {\n          recursive: true\n        }, err => {\n          /* istanbul ignore if */\n          if (err) bail(err);else writeFile(name, content, err2 => {\n            /* istanbul ignore if */\n            if (err2) bail(err2);else finish();\n          });\n        });\n      });\n\n      if (!outputReport || !outputReport.filePath) {\n        return;\n      }\n\n      const content = await (outputReport.formatter ? (await loadFormatter(eslint, outputReport.formatter)).format(results) : formatter.format(results));\n      let {\n        filePath\n      } = outputReport;\n\n      if (!isAbsolute(filePath)) {\n        filePath = join(compiler.outputPath, filePath);\n      }\n\n      await save(filePath, content);\n    }\n  }\n}\n/**\n * @param {Formatter} formatter\n * @param {{ errors: LintResult[]; warnings: LintResult[]; }} results\n * @returns {Promise<{errors?: ESLintError, warnings?: ESLintError}>}\n */\n\n\nasync function formatResults(formatter, results) {\n  let errors;\n  let warnings;\n\n  if (results.warnings.length > 0) {\n    warnings = new ESLintError(await formatter.format(results.warnings));\n  }\n\n  if (results.errors.length > 0) {\n    errors = new ESLintError(await formatter.format(results.errors));\n  }\n\n  return {\n    errors,\n    warnings\n  };\n}\n/**\n * @param {Options} options\n * @param {LintResult[]} results\n * @returns {{errors: LintResult[], warnings: LintResult[]}}\n */\n\n\nfunction parseResults(options, results) {\n  /** @type {LintResult[]} */\n  const errors = [];\n  /** @type {LintResult[]} */\n\n  const warnings = [];\n  results.forEach(file => {\n    if (fileHasErrors(file)) {\n      const messages = file.messages.filter(message => options.emitError && message.severity === 2);\n\n      if (messages.length > 0) {\n        errors.push({ ...file,\n          messages\n        });\n      }\n    }\n\n    if (fileHasWarnings(file)) {\n      const messages = file.messages.filter(message => options.emitWarning && message.severity === 1);\n\n      if (messages.length > 0) {\n        warnings.push({ ...file,\n          messages\n        });\n      }\n    }\n  });\n  return {\n    errors,\n    warnings\n  };\n}\n/**\n * @param {LintResult} file\n * @returns {boolean}\n */\n\n\nfunction fileHasErrors(file) {\n  return file.errorCount > 0;\n}\n/**\n * @param {LintResult} file\n * @returns {boolean}\n */\n\n\nfunction fileHasWarnings(file) {\n  return file.warningCount > 0;\n}\n/**\n * @param {ESLint} eslint\n * @param {string|FormatterFunction=} formatter\n * @returns {Promise<Formatter>}\n */\n\n\nasync function loadFormatter(eslint, formatter) {\n  if (typeof formatter === 'function') {\n    return {\n      format: formatter\n    };\n  }\n\n  if (typeof formatter === 'string') {\n    try {\n      return eslint.loadFormatter(formatter);\n    } catch (_) {// Load the default formatter.\n    }\n  }\n\n  return eslint.loadFormatter();\n}\n/**\n * @param {ESLint} eslint\n * @param {LintResult[]} results\n * @returns {Promise<LintResult[]>}\n */\n\n\nasync function removeIgnoredWarnings(eslint, results) {\n  const filterPromises = results.map(async result => {\n    // Short circuit the call to isPathIgnored.\n    //   fatal is false for ignored file warnings.\n    //   ruleId is unset for internal ESLint errors.\n    //   line is unset for warnings not involving file contents.\n    const ignored = result.messages.length === 0 || result.warningCount === 1 && result.errorCount === 0 && !result.messages[0].fatal && !result.messages[0].ruleId && !result.messages[0].line && (await eslint.isPathIgnored(result.filePath));\n    return ignored ? false : result;\n  }); // @ts-ignore\n\n  return (await Promise.all(filterPromises)).filter(result => !!result);\n}\n/**\n * @param {Promise<LintResult[]>[]} results\n * @returns {Promise<LintResult[]>}\n */\n\n\nasync function flatten(results) {\n  /**\n   * @param {LintResult[]} acc\n   * @param {LintResult[]} list\n   */\n  const flat = (acc, list) => [...acc, ...list];\n\n  return (await Promise.all(results)).reduce(flat, []);\n}\n/**\n * @param {Compilation} compilation\n * @returns {LintResultMap}\n */\n\n\nfunction getResultStorage(_ref2) {\n  let {\n    compiler\n  } = _ref2;\n  let storage = resultStorage.get(compiler);\n\n  if (!storage) {\n    resultStorage.set(compiler, storage = {});\n  }\n\n  return storage;\n}\n/**\n * @param {string | string[]} x\n */\n\n\nfunction asList(x) {\n  /* istanbul ignore next */\n  return Array.isArray(x) ? x : [x];\n}\n\nmodule.exports = linter;","map":{"version":3,"names":["dirname","isAbsolute","join","require","ESLintError","getESLint","resultStorage","WeakMap","linter","key","options","compilation","eslint","lintFiles","cleanup","threads","rawResults","crossRunResultStorage","getResultStorage","e","message","lint","report","files","file","asList","push","catch","errors","results","removeIgnoredWarnings","flatten","splice","length","result","filePath","Object","values","formatter","loadFormatter","warnings","formatResults","parseResults","generateReportAsset","compiler","outputReport","save","name","content","Promise","finish","bail","mkdir","writeFile","outputFileSystem","recursive","err","err2","format","outputPath","forEach","fileHasErrors","messages","filter","emitError","severity","fileHasWarnings","emitWarning","errorCount","warningCount","_","filterPromises","map","ignored","fatal","ruleId","line","isPathIgnored","all","flat","acc","list","reduce","storage","get","set","x","Array","isArray","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-webpack-plugin/dist/linter.js"],"sourcesContent":["\"use strict\";\n\nconst {\n  dirname,\n  isAbsolute,\n  join\n} = require('path');\n\nconst ESLintError = require('./ESLintError');\n\nconst {\n  getESLint\n} = require('./getESLint');\n/** @typedef {import('eslint').ESLint} ESLint */\n\n/** @typedef {import('eslint').ESLint.Formatter} Formatter */\n\n/** @typedef {import('eslint').ESLint.LintResult} LintResult */\n\n/** @typedef {import('webpack').Compiler} Compiler */\n\n/** @typedef {import('webpack').Compilation} Compilation */\n\n/** @typedef {import('./options').Options} Options */\n\n/** @typedef {import('./options').FormatterFunction} FormatterFunction */\n\n/** @typedef {(compilation: Compilation) => Promise<void>} GenerateReport */\n\n/** @typedef {{errors?: ESLintError, warnings?: ESLintError, generateReportAsset?: GenerateReport}} Report */\n\n/** @typedef {() => Promise<Report>} Reporter */\n\n/** @typedef {(files: string|string[]) => void} Linter */\n\n/** @typedef {{[files: string]: LintResult}} LintResultMap */\n\n/** @type {WeakMap<Compiler, LintResultMap>} */\n\n\nconst resultStorage = new WeakMap();\n/**\n * @param {string|undefined} key\n * @param {Options} options\n * @param {Compilation} compilation\n * @returns {{lint: Linter, report: Reporter, threads: number}}\n */\n\nfunction linter(key, options, compilation) {\n  /** @type {ESLint} */\n  let eslint;\n  /** @type {(files: string|string[]) => Promise<LintResult[]>} */\n\n  let lintFiles;\n  /** @type {() => Promise<void>} */\n\n  let cleanup;\n  /** @type number */\n\n  let threads;\n  /** @type {Promise<LintResult[]>[]} */\n\n  const rawResults = [];\n  const crossRunResultStorage = getResultStorage(compilation);\n\n  try {\n    ({\n      eslint,\n      lintFiles,\n      cleanup,\n      threads\n    } = getESLint(key, options));\n  } catch (e) {\n    throw new ESLintError(e.message);\n  }\n\n  return {\n    lint,\n    report,\n    threads\n  };\n  /**\n   * @param {string | string[]} files\n   */\n\n  function lint(files) {\n    for (const file of asList(files)) {\n      delete crossRunResultStorage[file];\n    }\n\n    rawResults.push(lintFiles(files).catch(e => {\n      // @ts-ignore\n      compilation.errors.push(new ESLintError(e.message));\n      return [];\n    }));\n  }\n\n  async function report() {\n    // Filter out ignored files.\n    let results = await removeIgnoredWarnings(eslint, // Get the current results, resetting the rawResults to empty\n    await flatten(rawResults.splice(0, rawResults.length)));\n    await cleanup();\n\n    for (const result of results) {\n      crossRunResultStorage[result.filePath] = result;\n    }\n\n    results = Object.values(crossRunResultStorage); // do not analyze if there are no results or eslint config\n\n    if (!results || results.length < 1) {\n      return {};\n    }\n\n    const formatter = await loadFormatter(eslint, options.formatter);\n    const {\n      errors,\n      warnings\n    } = await formatResults(formatter, parseResults(options, results));\n    return {\n      errors,\n      warnings,\n      generateReportAsset\n    };\n    /**\n     * @param {Compilation} compilation\n     * @returns {Promise<void>}\n     */\n\n    async function generateReportAsset({\n      compiler\n    }) {\n      const {\n        outputReport\n      } = options;\n      /**\n       * @param {string} name\n       * @param {string | Buffer} content\n       */\n\n      const save = (name, content) =>\n      /** @type {Promise<void>} */\n      new Promise((finish, bail) => {\n        const {\n          mkdir,\n          writeFile\n        } = compiler.outputFileSystem; // ensure directory exists\n        // @ts-ignore - the types for `outputFileSystem` are missing the 3 arg overload\n\n        mkdir(dirname(name), {\n          recursive: true\n        }, err => {\n          /* istanbul ignore if */\n          if (err) bail(err);else writeFile(name, content, err2 => {\n            /* istanbul ignore if */\n            if (err2) bail(err2);else finish();\n          });\n        });\n      });\n\n      if (!outputReport || !outputReport.filePath) {\n        return;\n      }\n\n      const content = await (outputReport.formatter ? (await loadFormatter(eslint, outputReport.formatter)).format(results) : formatter.format(results));\n      let {\n        filePath\n      } = outputReport;\n\n      if (!isAbsolute(filePath)) {\n        filePath = join(compiler.outputPath, filePath);\n      }\n\n      await save(filePath, content);\n    }\n  }\n}\n/**\n * @param {Formatter} formatter\n * @param {{ errors: LintResult[]; warnings: LintResult[]; }} results\n * @returns {Promise<{errors?: ESLintError, warnings?: ESLintError}>}\n */\n\n\nasync function formatResults(formatter, results) {\n  let errors;\n  let warnings;\n\n  if (results.warnings.length > 0) {\n    warnings = new ESLintError(await formatter.format(results.warnings));\n  }\n\n  if (results.errors.length > 0) {\n    errors = new ESLintError(await formatter.format(results.errors));\n  }\n\n  return {\n    errors,\n    warnings\n  };\n}\n/**\n * @param {Options} options\n * @param {LintResult[]} results\n * @returns {{errors: LintResult[], warnings: LintResult[]}}\n */\n\n\nfunction parseResults(options, results) {\n  /** @type {LintResult[]} */\n  const errors = [];\n  /** @type {LintResult[]} */\n\n  const warnings = [];\n  results.forEach(file => {\n    if (fileHasErrors(file)) {\n      const messages = file.messages.filter(message => options.emitError && message.severity === 2);\n\n      if (messages.length > 0) {\n        errors.push({ ...file,\n          messages\n        });\n      }\n    }\n\n    if (fileHasWarnings(file)) {\n      const messages = file.messages.filter(message => options.emitWarning && message.severity === 1);\n\n      if (messages.length > 0) {\n        warnings.push({ ...file,\n          messages\n        });\n      }\n    }\n  });\n  return {\n    errors,\n    warnings\n  };\n}\n/**\n * @param {LintResult} file\n * @returns {boolean}\n */\n\n\nfunction fileHasErrors(file) {\n  return file.errorCount > 0;\n}\n/**\n * @param {LintResult} file\n * @returns {boolean}\n */\n\n\nfunction fileHasWarnings(file) {\n  return file.warningCount > 0;\n}\n/**\n * @param {ESLint} eslint\n * @param {string|FormatterFunction=} formatter\n * @returns {Promise<Formatter>}\n */\n\n\nasync function loadFormatter(eslint, formatter) {\n  if (typeof formatter === 'function') {\n    return {\n      format: formatter\n    };\n  }\n\n  if (typeof formatter === 'string') {\n    try {\n      return eslint.loadFormatter(formatter);\n    } catch (_) {// Load the default formatter.\n    }\n  }\n\n  return eslint.loadFormatter();\n}\n/**\n * @param {ESLint} eslint\n * @param {LintResult[]} results\n * @returns {Promise<LintResult[]>}\n */\n\n\nasync function removeIgnoredWarnings(eslint, results) {\n  const filterPromises = results.map(async result => {\n    // Short circuit the call to isPathIgnored.\n    //   fatal is false for ignored file warnings.\n    //   ruleId is unset for internal ESLint errors.\n    //   line is unset for warnings not involving file contents.\n    const ignored = result.messages.length === 0 || result.warningCount === 1 && result.errorCount === 0 && !result.messages[0].fatal && !result.messages[0].ruleId && !result.messages[0].line && (await eslint.isPathIgnored(result.filePath));\n    return ignored ? false : result;\n  }); // @ts-ignore\n\n  return (await Promise.all(filterPromises)).filter(result => !!result);\n}\n/**\n * @param {Promise<LintResult[]>[]} results\n * @returns {Promise<LintResult[]>}\n */\n\n\nasync function flatten(results) {\n  /**\n   * @param {LintResult[]} acc\n   * @param {LintResult[]} list\n   */\n  const flat = (acc, list) => [...acc, ...list];\n\n  return (await Promise.all(results)).reduce(flat, []);\n}\n/**\n * @param {Compilation} compilation\n * @returns {LintResultMap}\n */\n\n\nfunction getResultStorage({\n  compiler\n}) {\n  let storage = resultStorage.get(compiler);\n\n  if (!storage) {\n    resultStorage.set(compiler, storage = {});\n  }\n\n  return storage;\n}\n/**\n * @param {string | string[]} x\n */\n\n\nfunction asList(x) {\n  /* istanbul ignore next */\n  return Array.isArray(x) ? x : [x];\n}\n\nmodule.exports = linter;"],"mappings":"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"},"metadata":{},"sourceType":"script"}