{"ast":null,"code":"/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst CHAR_LIMIT = 40; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow specified warning terms in comments\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-warning-comments\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        terms: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        location: {\n          enum: [\"start\", \"anywhere\"]\n        },\n        decoration: {\n          type: \"array\",\n          items: {\n            type: \"string\",\n            pattern: \"^\\\\S$\"\n          },\n          minItems: 1,\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedComment: \"Unexpected '{{matchedTerm}}' comment: '{{comment}}'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(),\n          configuration = context.options[0] || {},\n          warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n          location = configuration.location || \"start\",\n          decoration = [...(configuration.decoration || [])].join(\"\"),\n          selfConfigRegEx = /\\bno-warning-comments\\b/u;\n    /**\n     * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n     * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n     * require word boundaries on that side.\n     * @param {string} term A term to convert to a RegExp\n     * @returns {RegExp} The term converted to a RegExp\n     */\n\n    function convertToRegExp(term) {\n      const escaped = escapeRegExp(term);\n      const escapedDecoration = escapeRegExp(decoration);\n      /*\n       * When matching at the start, ignore leading whitespace, and\n       * there's no need to worry about word boundaries.\n       *\n       * These expressions for the prefix and suffix are designed as follows:\n       * ^   handles any terms at the beginning of a comment.\n       *     e.g. terms [\"TODO\"] matches `//TODO something`\n       * $   handles any terms at the end of a comment\n       *     e.g. terms [\"TODO\"] matches `// something TODO`\n       * \\b  handles terms preceded/followed by word boundary\n       *     e.g. terms: [\"!FIX\", \"FIX!\"] matches `// FIX!something` or `// something!FIX`\n       *          terms: [\"FIX\"] matches `// FIX!` or `// !FIX`, but not `// fixed or affix`\n       *\n       * For location start:\n       * [\\s]* handles optional leading spaces\n       *     e.g. terms [\"TODO\"] matches `//    TODO something`\n       * [\\s\\*]* (where \"\\*\" is the escaped string of decoration)\n       *     handles optional leading spaces or decoration characters (for \"start\" location only)\n       *     e.g. terms [\"TODO\"] matches `/**** TODO something ... `\n       */\n\n      const wordBoundary = \"\\\\b\";\n      let prefix = \"\";\n\n      if (location === \"start\") {\n        prefix = `^[\\\\s${escapedDecoration}]*`;\n      } else if (/^\\w/u.test(term)) {\n        prefix = wordBoundary;\n      }\n\n      const suffix = /\\w$/u.test(term) ? wordBoundary : \"\";\n      const flags = \"iu\"; // Case-insensitive with Unicode case folding.\n\n      /*\n       * For location \"start\", the typical regex is:\n       *   /^[\\s]*ESCAPED_TERM\\b/iu.\n       * Or if decoration characters are specified (e.g. \"*\"), then any of\n       * those characters may appear in any order at the start:\n       *   /^[\\s\\*]*ESCAPED_TERM\\b/iu.\n       *\n       * For location \"anywhere\" the typical regex is\n       *   /\\bESCAPED_TERM\\b/iu\n       *\n       * If it starts or ends with non-word character, the prefix and suffix are empty, respectively.\n       */\n\n      return new RegExp(`${prefix}${escaped}${suffix}`, flags);\n    }\n\n    const warningRegExps = warningTerms.map(convertToRegExp);\n    /**\n     * Checks the specified comment for matches of the configured warning terms and returns the matches.\n     * @param {string} comment The comment which is checked.\n     * @returns {Array} All matched warning terms for this comment.\n     */\n\n    function commentContainsWarningTerm(comment) {\n      const matches = [];\n      warningRegExps.forEach((regex, index) => {\n        if (regex.test(comment)) {\n          matches.push(warningTerms[index]);\n        }\n      });\n      return matches;\n    }\n    /**\n     * Checks the specified node for matching warning comments and reports them.\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {void} undefined.\n     */\n\n\n    function checkComment(node) {\n      const comment = node.value;\n\n      if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(comment)) {\n        return;\n      }\n\n      const matches = commentContainsWarningTerm(comment);\n      matches.forEach(matchedTerm => {\n        let commentToDisplay = \"\";\n        let truncated = false;\n\n        for (const c of comment.trim().split(/\\s+/u)) {\n          const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;\n\n          if (tmp.length <= CHAR_LIMIT) {\n            commentToDisplay = tmp;\n          } else {\n            truncated = true;\n            break;\n          }\n        }\n\n        context.report({\n          node,\n          messageId: \"unexpectedComment\",\n          data: {\n            matchedTerm,\n            comment: `${commentToDisplay}${truncated ? \"...\" : \"\"}`\n          }\n        });\n      });\n    }\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(checkComment);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["escapeRegExp","require","astUtils","CHAR_LIMIT","module","exports","meta","type","docs","description","recommended","url","schema","properties","terms","items","location","enum","decoration","pattern","minItems","uniqueItems","additionalProperties","messages","unexpectedComment","create","context","sourceCode","getSourceCode","configuration","options","warningTerms","join","selfConfigRegEx","convertToRegExp","term","escaped","escapedDecoration","wordBoundary","prefix","test","suffix","flags","RegExp","warningRegExps","map","commentContainsWarningTerm","comment","matches","forEach","regex","index","push","checkComment","node","value","isDirectiveComment","matchedTerm","commentToDisplay","truncated","c","trim","split","tmp","length","report","messageId","data","Program","comments","getAllComments","filter","token"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/no-warning-comments.js"],"sourcesContent":["/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst CHAR_LIMIT = 40;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow specified warning terms in comments\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-warning-comments\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    terms: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    location: {\n                        enum: [\"start\", \"anywhere\"]\n                    },\n                    decoration: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\",\n                            pattern: \"^\\\\S$\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedComment: \"Unexpected '{{matchedTerm}}' comment: '{{comment}}'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode(),\n            configuration = context.options[0] || {},\n            warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n            location = configuration.location || \"start\",\n            decoration = [...configuration.decoration || []].join(\"\"),\n            selfConfigRegEx = /\\bno-warning-comments\\b/u;\n\n        /**\n         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n         * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n         * require word boundaries on that side.\n         * @param {string} term A term to convert to a RegExp\n         * @returns {RegExp} The term converted to a RegExp\n         */\n        function convertToRegExp(term) {\n            const escaped = escapeRegExp(term);\n            const escapedDecoration = escapeRegExp(decoration);\n\n            /*\n             * When matching at the start, ignore leading whitespace, and\n             * there's no need to worry about word boundaries.\n             *\n             * These expressions for the prefix and suffix are designed as follows:\n             * ^   handles any terms at the beginning of a comment.\n             *     e.g. terms [\"TODO\"] matches `//TODO something`\n             * $   handles any terms at the end of a comment\n             *     e.g. terms [\"TODO\"] matches `// something TODO`\n             * \\b  handles terms preceded/followed by word boundary\n             *     e.g. terms: [\"!FIX\", \"FIX!\"] matches `// FIX!something` or `// something!FIX`\n             *          terms: [\"FIX\"] matches `// FIX!` or `// !FIX`, but not `// fixed or affix`\n             *\n             * For location start:\n             * [\\s]* handles optional leading spaces\n             *     e.g. terms [\"TODO\"] matches `//    TODO something`\n             * [\\s\\*]* (where \"\\*\" is the escaped string of decoration)\n             *     handles optional leading spaces or decoration characters (for \"start\" location only)\n             *     e.g. terms [\"TODO\"] matches `/**** TODO something ... `\n             */\n            const wordBoundary = \"\\\\b\";\n\n            let prefix = \"\";\n\n            if (location === \"start\") {\n                prefix = `^[\\\\s${escapedDecoration}]*`;\n            } else if (/^\\w/u.test(term)) {\n                prefix = wordBoundary;\n            }\n\n            const suffix = /\\w$/u.test(term) ? wordBoundary : \"\";\n            const flags = \"iu\"; // Case-insensitive with Unicode case folding.\n\n            /*\n             * For location \"start\", the typical regex is:\n             *   /^[\\s]*ESCAPED_TERM\\b/iu.\n             * Or if decoration characters are specified (e.g. \"*\"), then any of\n             * those characters may appear in any order at the start:\n             *   /^[\\s\\*]*ESCAPED_TERM\\b/iu.\n             *\n             * For location \"anywhere\" the typical regex is\n             *   /\\bESCAPED_TERM\\b/iu\n             *\n             * If it starts or ends with non-word character, the prefix and suffix are empty, respectively.\n             */\n            return new RegExp(`${prefix}${escaped}${suffix}`, flags);\n        }\n\n        const warningRegExps = warningTerms.map(convertToRegExp);\n\n        /**\n         * Checks the specified comment for matches of the configured warning terms and returns the matches.\n         * @param {string} comment The comment which is checked.\n         * @returns {Array} All matched warning terms for this comment.\n         */\n        function commentContainsWarningTerm(comment) {\n            const matches = [];\n\n            warningRegExps.forEach((regex, index) => {\n                if (regex.test(comment)) {\n                    matches.push(warningTerms[index]);\n                }\n            });\n\n            return matches;\n        }\n\n        /**\n         * Checks the specified node for matching warning comments and reports them.\n         * @param {ASTNode} node The AST node being checked.\n         * @returns {void} undefined.\n         */\n        function checkComment(node) {\n            const comment = node.value;\n\n            if (\n                astUtils.isDirectiveComment(node) &&\n                selfConfigRegEx.test(comment)\n            ) {\n                return;\n            }\n\n            const matches = commentContainsWarningTerm(comment);\n\n            matches.forEach(matchedTerm => {\n                let commentToDisplay = \"\";\n                let truncated = false;\n\n                for (const c of comment.trim().split(/\\s+/u)) {\n                    const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;\n\n                    if (tmp.length <= CHAR_LIMIT) {\n                        commentToDisplay = tmp;\n                    } else {\n                        truncated = true;\n                        break;\n                    }\n                }\n\n                context.report({\n                    node,\n                    messageId: \"unexpectedComment\",\n                    data: {\n                        matchedTerm,\n                        comment: `${commentToDisplay}${\n                            truncated ? \"...\" : \"\"\n                        }`\n                    }\n                });\n            });\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments\n                    .filter(token => token.type !== \"Shebang\")\n                    .forEach(checkComment);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}