{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isIterableIterator = isIterableIterator;\nexports.mergeOptions = mergeOptions;\n\nfunction mergeOptions(target, source) {\n  for (var _i = 0, _Object$keys = Object.keys(source); _i < _Object$keys.length; _i++) {\n    var k = _Object$keys[_i];\n\n    if ((k === \"parserOpts\" || k === \"generatorOpts\" || k === \"assumptions\") && source[k]) {\n      var parserOpts = source[k];\n      var targetObj = target[k] || (target[k] = {});\n      mergeDefaultFields(targetObj, parserOpts);\n    } else {\n      var val = source[k];\n      if (val !== undefined) target[k] = val;\n    }\n  }\n}\n\nfunction mergeDefaultFields(target, source) {\n  for (var _i2 = 0, _Object$keys2 = Object.keys(source); _i2 < _Object$keys2.length; _i2++) {\n    var k = _Object$keys2[_i2];\n    var val = source[k];\n    if (val !== undefined) target[k] = val;\n  }\n}\n\nfunction isIterableIterator(value) {\n  return !!value && typeof value.next === \"function\" && typeof value[Symbol.iterator] === \"function\";\n}\n\n0 && 0;","map":{"version":3,"mappings":";;;;;;;;AAEO,SAASA,YAAT,CACLC,MADK,EAELC,MAFK,EAGC;EACN,gCAAgBC,MAAM,CAACC,IAAPD,CAAYD,MAAZC,CAAhB,kCAAqC;IAAhC,IAAME,CAAX,mBAAK;;IACH,IACE,CAACA,CAAC,KAAK,YAANA,IAAsBA,CAAC,KAAK,eAA5BA,IAA+CA,CAAC,KAAK,aAAtD,KACAH,MAAM,CAACG,CAAD,CAFR,EAGE;MACA,IAAMC,UAAU,GAAGJ,MAAM,CAACG,CAAD,CAAzB;MACA,IAAME,SAAS,GAAGN,MAAM,CAACI,CAAD,CAANJ,KAAcA,MAAM,CAACI,CAAD,CAANJ,GAAY,EAA1BA,CAAlB;MACAO,kBAAkB,CAACD,SAAD,EAAYD,UAAZ,CAAlBE;IANF,OAOO;MAEL,IAAMC,GAAG,GAAGP,MAAM,CAACG,CAAD,CAAlB;MAEA,IAAII,GAAG,KAAKC,SAAZ,EAAuBT,MAAM,CAACI,CAAD,CAANJ,GAAYQ,GAAZR;IACxB;EACF;AACF;;AAED,SAASO,kBAAT,CAA0CP,MAA1C,EAAqDC,MAArD,EAAgE;EAC9D,kCAAgBC,MAAM,CAACC,IAAPD,CAAYD,MAAZC,CAAhB,qCAAoD;IAA/C,IAAME,CAAX,qBAAK;IACH,IAAMI,GAAG,GAAGP,MAAM,CAACG,CAAD,CAAlB;IACA,IAAII,GAAG,KAAKC,SAAZ,EAAuBT,MAAM,CAACI,CAAD,CAANJ,GAAYQ,GAAZR;EACxB;AACF;;AAEM,SAASU,kBAAT,CAA4BC,KAA5B,EAAwE;EAC7E,OACE,CAAC,CAACA,KAAF,IACA,OAAOA,KAAK,CAACC,IAAb,KAAsB,UADtB,IAEA,OAAOD,KAAK,CAACE,MAAM,CAACC,QAAR,CAAZ,KAAkC,UAHpC;AAKD","names":["mergeOptions","target","source","Object","keys","k","parserOpts","targetObj","mergeDefaultFields","val","undefined","isIterableIterator","value","next","Symbol","iterator"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\util.ts"],"sourcesContent":["import type { ValidatedOptions, NormalizedOptions } from \"./validation/options\";\n\nexport function mergeOptions(\n  target: ValidatedOptions,\n  source: ValidatedOptions | NormalizedOptions,\n): void {\n  for (const k of Object.keys(source)) {\n    if (\n      (k === \"parserOpts\" || k === \"generatorOpts\" || k === \"assumptions\") &&\n      source[k]\n    ) {\n      const parserOpts = source[k];\n      const targetObj = target[k] || (target[k] = {});\n      mergeDefaultFields(targetObj, parserOpts);\n    } else {\n      //@ts-expect-error k must index source\n      const val = source[k];\n      //@ts-expect-error assigning source to target\n      if (val !== undefined) target[k] = val as any;\n    }\n  }\n}\n\nfunction mergeDefaultFields<T extends {}>(target: T, source: T) {\n  for (const k of Object.keys(source) as (keyof T)[]) {\n    const val = source[k];\n    if (val !== undefined) target[k] = val;\n  }\n}\n\nexport function isIterableIterator(value: any): value is IterableIterator<any> {\n  return (\n    !!value &&\n    typeof value.next === \"function\" &&\n    typeof value[Symbol.iterator] === \"function\"\n  );\n}\n"]},"metadata":{},"sourceType":"script"}