{"ast":null,"code":"import { SetArray, put } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\n\nlet addSegment;\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\n\nlet addMapping;\n/**\n * Adds/removes the content of the source file to the source map.\n */\n\nlet setSourceContent;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\n\nlet decodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\n\nlet encodedMap;\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\n\nlet allMappings;\n/**\n * Provides the state to generate a sourcemap.\n */\n\nclass GenMapping {\n  constructor() {\n    let {\n      file,\n      sourceRoot\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._names = new SetArray();\n    this._sources = new SetArray();\n    this._sourcesContent = [];\n    this._mappings = [];\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n  }\n\n}\n\n(() => {\n  addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {\n    const {\n      _mappings: mappings,\n      _sources: sources,\n      _sourcesContent: sourcesContent,\n      _names: names\n    } = map;\n    const line = getLine(mappings, genLine);\n\n    if (source == null) {\n      const seg = [genColumn];\n      const index = getColumnIndex(line, genColumn, seg);\n      return insert(line, index, seg);\n    }\n\n    const sourcesIndex = put(sources, source);\n    const seg = name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, put(names, name)] : [genColumn, sourcesIndex, sourceLine, sourceColumn];\n    const index = getColumnIndex(line, genColumn, seg);\n    if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = null;\n    insert(line, index, seg);\n  };\n\n  addMapping = (map, mapping) => {\n    const {\n      generated,\n      source,\n      original,\n      name\n    } = mapping;\n    return addSegment(map, generated.line - 1, generated.column, source, original == null ? undefined : original.line - 1, original === null || original === void 0 ? void 0 : original.column, name);\n  };\n\n  setSourceContent = (map, source, content) => {\n    const {\n      _sources: sources,\n      _sourcesContent: sourcesContent\n    } = map;\n    sourcesContent[put(sources, source)] = content;\n  };\n\n  decodedMap = map => {\n    const {\n      file,\n      sourceRoot,\n      _mappings: mappings,\n      _sources: sources,\n      _sourcesContent: sourcesContent,\n      _names: names\n    } = map;\n    return {\n      version: 3,\n      file,\n      names: names.array,\n      sourceRoot: sourceRoot || undefined,\n      sources: sources.array,\n      sourcesContent,\n      mappings\n    };\n  };\n\n  encodedMap = map => {\n    const decoded = decodedMap(map);\n    return Object.assign(Object.assign({}, decoded), {\n      mappings: encode(decoded.mappings)\n    });\n  };\n\n  allMappings = map => {\n    const out = [];\n    const {\n      _mappings: mappings,\n      _sources: sources,\n      _names: names\n    } = map;\n\n    for (let i = 0; i < mappings.length; i++) {\n      const line = mappings[i];\n\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        const generated = {\n          line: i + 1,\n          column: seg[0]\n        };\n        let source = undefined;\n        let original = undefined;\n        let name = undefined;\n\n        if (seg.length !== 1) {\n          source = sources.array[seg[1]];\n          original = {\n            line: seg[2] + 1,\n            column: seg[3]\n          };\n          if (seg.length === 5) name = names.array[seg[4]];\n        }\n\n        out.push({\n          generated,\n          source,\n          original,\n          name\n        });\n      }\n    }\n\n    return out;\n  };\n})();\n\nfunction getLine(mappings, index) {\n  for (let i = mappings.length; i <= index; i++) {\n    mappings[i] = [];\n  }\n\n  return mappings[index];\n}\n\nfunction getColumnIndex(line, column, seg) {\n  let index = line.length;\n\n  for (let i = index - 1; i >= 0; i--, index--) {\n    const current = line[i];\n    const col = current[0];\n    if (col > column) continue;\n    if (col < column) break;\n    const cmp = compare(current, seg);\n    if (cmp === 0) return index;\n    if (cmp < 0) break;\n  }\n\n  return index;\n}\n\nfunction compare(a, b) {\n  let cmp = compareNum(a.length, b.length);\n  if (cmp !== 0) return cmp; // We've already checked genColumn\n\n  if (a.length === 1) return 0;\n  cmp = compareNum(a[1], b[1]);\n  if (cmp !== 0) return cmp;\n  cmp = compareNum(a[2], b[2]);\n  if (cmp !== 0) return cmp;\n  cmp = compareNum(a[3], b[3]);\n  if (cmp !== 0) return cmp;\n  if (a.length === 4) return 0;\n  return compareNum(a[4], b[4]);\n}\n\nfunction compareNum(a, b) {\n  return a - b;\n}\n\nfunction insert(array, index, value) {\n  if (index === -1) return;\n\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n\n  array[index] = value;\n}\n\nexport { GenMapping, addMapping, addSegment, allMappings, decodedMap, encodedMap, setSourceContent };","map":{"version":3,"mappings":"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","names":["GenMapping","constructor","file","sourceRoot","SetArray","_sourcesContent","_mappings","addSegment","map","genLine","genColumn","source","sourceLine","sourceColumn","name","mappings","_sources","sources","sourcesContent","_names","names","line","getLine","seg","index","getColumnIndex","insert","sourcesIndex","put","length","addMapping","mapping","generated","original","column","undefined","setSourceContent","content","decodedMap","version","array","encodedMap","decoded","Object","encode","allMappings","out","i","j","push","current","col","cmp","compare","a","b","compareNum","value"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@jridgewell\\src\\gen-mapping.ts"],"sourcesContent":["import { SetArray, put } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\n\nimport type { SourceMapSegment } from './sourcemap-segment';\nimport type { DecodedSourceMap, EncodedSourceMap, Pos, Mapping } from './types';\n\nexport type { DecodedSourceMap, EncodedSourceMap, Mapping };\n\nexport type Options = {\n  file?: string | null;\n  sourceRoot?: string | null;\n};\n\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nexport let addSegment: {\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source?: null,\n    sourceLine?: null,\n    sourceColumn?: null,\n    name?: null,\n  ): void;\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source: string,\n    sourceLine: number,\n    sourceColumn: number,\n    name?: null,\n  ): void;\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source: string,\n    sourceLine: number,\n    sourceColumn: number,\n    name: string,\n  ): void;\n};\n\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nexport let addMapping: {\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source?: null;\n      original?: null;\n      name?: null;\n    },\n  ): void;\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source: string;\n      original: Pos;\n      name?: null;\n    },\n  ): void;\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source: string;\n      original: Pos;\n      name: string;\n    },\n  ): void;\n};\n\n/**\n * Adds/removes the content of the source file to the source map.\n */\nexport let setSourceContent: (map: GenMapping, source: string, content: string | null) => void;\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let decodedMap: (map: GenMapping) => DecodedSourceMap;\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let encodedMap: (map: GenMapping) => EncodedSourceMap;\n\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nexport let allMappings: (map: GenMapping) => Mapping[];\n\n/**\n * Provides the state to generate a sourcemap.\n */\nexport class GenMapping {\n  private _names = new SetArray();\n  private _sources = new SetArray();\n  private _sourcesContent: (string | null)[] = [];\n  private _mappings: SourceMapSegment[][] = [];\n  declare file: string | null | undefined;\n  declare sourceRoot: string | null | undefined;\n\n  constructor({ file, sourceRoot }: Options = {}) {\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n  }\n\n  static {\n    addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {\n      const {\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names,\n      } = map;\n\n      const line = getLine(mappings, genLine);\n      if (source == null) {\n        const seg: SourceMapSegment = [genColumn];\n        const index = getColumnIndex(line, genColumn, seg);\n        return insert(line, index, seg);\n      }\n\n      // Sigh, TypeScript can't figure out sourceLine and sourceColumn aren't nullish if source\n      // isn't nullish.\n      assert<number>(sourceLine);\n      assert<number>(sourceColumn);\n      const sourcesIndex = put(sources, source);\n      const seg: SourceMapSegment = name\n        ? [genColumn, sourcesIndex, sourceLine, sourceColumn, put(names, name)]\n        : [genColumn, sourcesIndex, sourceLine, sourceColumn];\n\n      const index = getColumnIndex(line, genColumn, seg);\n      if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = null;\n      insert(line, index, seg);\n    };\n\n    addMapping = (map, mapping) => {\n      const { generated, source, original, name } = mapping;\n      return (addSegment as any)(\n        map,\n        generated.line - 1,\n        generated.column,\n        source,\n        original == null ? undefined : original.line - 1,\n        original?.column,\n        name,\n      );\n    };\n\n    setSourceContent = (map, source, content) => {\n      const { _sources: sources, _sourcesContent: sourcesContent } = map;\n      sourcesContent[put(sources, source)] = content;\n    };\n\n    decodedMap = (map) => {\n      const {\n        file,\n        sourceRoot,\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names,\n      } = map;\n\n      return {\n        version: 3,\n        file,\n        names: names.array,\n        sourceRoot: sourceRoot || undefined,\n        sources: sources.array,\n        sourcesContent,\n        mappings,\n      };\n    };\n\n    encodedMap = (map) => {\n      const decoded = decodedMap(map);\n      return {\n        ...decoded,\n        mappings: encode(decoded.mappings as SourceMapSegment[][]),\n      };\n    };\n\n    allMappings = (map) => {\n      const out: Mapping[] = [];\n      const { _mappings: mappings, _sources: sources, _names: names } = map;\n\n      for (let i = 0; i < mappings.length; i++) {\n        const line = mappings[i];\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n\n          const generated = { line: i + 1, column: seg[0] };\n          let source: string | undefined = undefined;\n          let original: Pos | undefined = undefined;\n          let name: string | undefined = undefined;\n\n          if (seg.length !== 1) {\n            source = sources.array[seg[1]];\n            original = { line: seg[2] + 1, column: seg[3] };\n\n            if (seg.length === 5) name = names.array[seg[4]];\n          }\n\n          out.push({ generated, source, original, name } as Mapping);\n        }\n      }\n\n      return out;\n    };\n  }\n}\n\nfunction assert<T>(_val: unknown): asserts _val is T {\n  // noop.\n}\n\nfunction getLine(mappings: SourceMapSegment[][], index: number): SourceMapSegment[] {\n  for (let i = mappings.length; i <= index; i++) {\n    mappings[i] = [];\n  }\n  return mappings[index];\n}\n\nfunction getColumnIndex(line: SourceMapSegment[], column: number, seg: SourceMapSegment): number {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; i--, index--) {\n    const current = line[i];\n    const col = current[0];\n    if (col > column) continue;\n    if (col < column) break;\n\n    const cmp = compare(current, seg);\n    if (cmp === 0) return index;\n    if (cmp < 0) break;\n  }\n  return index;\n}\n\nfunction compare(a: SourceMapSegment, b: SourceMapSegment): number {\n  let cmp = compareNum(a.length, b.length);\n  if (cmp !== 0) return cmp;\n\n  // We've already checked genColumn\n  if (a.length === 1) return 0;\n\n  cmp = compareNum(a[1], b[1]!);\n  if (cmp !== 0) return cmp;\n  cmp = compareNum(a[2], b[2]!);\n  if (cmp !== 0) return cmp;\n  cmp = compareNum(a[3], b[3]!);\n  if (cmp !== 0) return cmp;\n\n  if (a.length === 4) return 0;\n  return compareNum(a[4], b[4]!);\n}\n\nfunction compareNum(a: number, b: number): number {\n  return a - b;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  if (index === -1) return;\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n"]},"metadata":{},"sourceType":"module"}