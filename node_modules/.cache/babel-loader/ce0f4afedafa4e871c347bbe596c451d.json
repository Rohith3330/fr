{"ast":null,"code":"'use strict';\n\nvar transport = require('../../../spdy-transport');\n\nvar utils = transport.utils;\n\nvar assert = require('assert');\n\nvar util = require('util');\n\nvar debug = require('debug')('spdy:scheduler');\n\nvar Readable = require('readable-stream').Readable;\n/*\n * We create following structure in `pending`:\n * [ [ id = 0 ], [ id = 1 ], [ id = 2 ], [ id = 0 ] ]\n *     chunks      chunks      chunks      chunks\n *     chunks                  chunks\n *     chunks\n *\n * Then on the `.tick()` pass we pick one chunks from each item and remove the\n * item if it is empty:\n *\n * [ [ id = 0 ], [ id = 2 ] ]\n *     chunks      chunks\n *     chunks\n *\n * Writing out: chunks for 0, chunks for 1, chunks for 2, chunks for 0\n *\n * This way data is interleaved between the different streams.\n */\n\n\nfunction Scheduler(options) {\n  Readable.call(this); // Pretty big window by default\n\n  this.window = 0.25;\n\n  if (options && options.window) {\n    this.window = options.window;\n  }\n\n  this.sync = [];\n  this.list = [];\n  this.count = 0;\n  this.pendingTick = false;\n}\n\nutil.inherits(Scheduler, Readable);\nmodule.exports = Scheduler; // Just for testing, really\n\nScheduler.create = function create(options) {\n  return new Scheduler(options);\n};\n\nfunction insertCompare(a, b) {\n  return a.priority === b.priority ? a.stream - b.stream : b.priority - a.priority;\n}\n\nScheduler.prototype.schedule = function schedule(data) {\n  var priority = data.priority;\n  var stream = data.stream;\n  var chunks = data.chunks; // Synchronous frames should not be interleaved\n\n  if (priority === false) {\n    debug('queue sync', chunks);\n    this.sync.push(data);\n    this.count += chunks.length;\n\n    this._read();\n\n    return;\n  }\n\n  debug('queue async priority=%d stream=%d', priority, stream, chunks);\n  var item = new SchedulerItem(stream, priority);\n  var index = utils.binaryLookup(this.list, item, insertCompare); // Push new item\n\n  if (index >= this.list.length || insertCompare(this.list[index], item) !== 0) {\n    this.list.splice(index, 0, item);\n  } else {\n    // Coalesce\n    item = this.list[index];\n  }\n\n  item.push(data);\n  this.count += chunks.length;\n\n  this._read();\n};\n\nScheduler.prototype._read = function _read() {\n  if (this.count === 0) {\n    return;\n  }\n\n  if (this.pendingTick) {\n    return;\n  }\n\n  this.pendingTick = true;\n  var self = this;\n  process.nextTick(function () {\n    self.pendingTick = false;\n    self.tick();\n  });\n};\n\nScheduler.prototype.tick = function tick() {\n  // No luck for async frames\n  if (!this.tickSync()) {\n    return false;\n  }\n\n  return this.tickAsync();\n};\n\nScheduler.prototype.tickSync = function tickSync() {\n  // Empty sync queue first\n  var sync = this.sync;\n  var res = true;\n  this.sync = [];\n\n  for (var i = 0; i < sync.length; i++) {\n    var item = sync[i];\n    debug('tick sync pending=%d', this.count, item.chunks);\n\n    for (var j = 0; j < item.chunks.length; j++) {\n      this.count--; // TODO: handle stream backoff properly\n\n      try {\n        res = this.push(item.chunks[j]);\n      } catch (err) {\n        this.emit('error', err);\n        return false;\n      }\n    }\n\n    debug('after tick sync pending=%d', this.count); // TODO(indutny): figure out the way to invoke callback on actual write\n\n    if (item.callback) {\n      item.callback(null);\n    }\n  }\n\n  return res;\n};\n\nScheduler.prototype.tickAsync = function tickAsync() {\n  var res = true;\n  var list = this.list;\n\n  if (list.length === 0) {\n    return res;\n  }\n\n  var startPriority = list[0].priority;\n\n  for (var index = 0; list.length > 0; index++) {\n    // Loop index\n    index %= list.length;\n\n    if (startPriority - list[index].priority > this.window) {\n      index = 0;\n    }\n\n    debug('tick async index=%d start=%d', index, startPriority);\n    var current = list[index];\n    var item = current.shift();\n\n    if (current.isEmpty()) {\n      list.splice(index, 1);\n\n      if (index === 0 && list.length > 0) {\n        startPriority = list[0].priority;\n      }\n\n      index--;\n    }\n\n    debug('tick async pending=%d', this.count, item.chunks);\n\n    for (var i = 0; i < item.chunks.length; i++) {\n      this.count--; // TODO: handle stream backoff properly\n\n      try {\n        res = this.push(item.chunks[i]);\n      } catch (err) {\n        this.emit('error', err);\n        return false;\n      }\n    }\n\n    debug('after tick pending=%d', this.count); // TODO(indutny): figure out the way to invoke callback on actual write\n\n    if (item.callback) {\n      item.callback(null);\n    }\n\n    if (!res) {\n      break;\n    }\n  }\n\n  return res;\n};\n\nScheduler.prototype.dump = function dump() {\n  this.tickSync(); // Write everything out\n\n  while (!this.tickAsync()) {// Intentional no-op\n  }\n\n  assert.strictEqual(this.count, 0);\n};\n\nfunction SchedulerItem(stream, priority) {\n  this.stream = stream;\n  this.priority = priority;\n  this.queue = [];\n}\n\nSchedulerItem.prototype.push = function push(chunks) {\n  this.queue.push(chunks);\n};\n\nSchedulerItem.prototype.shift = function shift() {\n  return this.queue.shift();\n};\n\nSchedulerItem.prototype.isEmpty = function isEmpty() {\n  return this.queue.length === 0;\n};","map":{"version":3,"names":["transport","require","utils","assert","util","debug","Readable","Scheduler","options","call","window","sync","list","count","pendingTick","inherits","module","exports","create","insertCompare","a","b","priority","stream","prototype","schedule","data","chunks","push","length","_read","item","SchedulerItem","index","binaryLookup","splice","self","process","nextTick","tick","tickSync","tickAsync","res","i","j","err","emit","callback","startPriority","current","shift","isEmpty","dump","strictEqual","queue"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/spdy-transport/lib/spdy-transport/protocol/base/scheduler.js"],"sourcesContent":["'use strict'\n\nvar transport = require('../../../spdy-transport')\nvar utils = transport.utils\n\nvar assert = require('assert')\nvar util = require('util')\nvar debug = require('debug')('spdy:scheduler')\nvar Readable = require('readable-stream').Readable\n\n/*\n * We create following structure in `pending`:\n * [ [ id = 0 ], [ id = 1 ], [ id = 2 ], [ id = 0 ] ]\n *     chunks      chunks      chunks      chunks\n *     chunks                  chunks\n *     chunks\n *\n * Then on the `.tick()` pass we pick one chunks from each item and remove the\n * item if it is empty:\n *\n * [ [ id = 0 ], [ id = 2 ] ]\n *     chunks      chunks\n *     chunks\n *\n * Writing out: chunks for 0, chunks for 1, chunks for 2, chunks for 0\n *\n * This way data is interleaved between the different streams.\n */\n\nfunction Scheduler (options) {\n  Readable.call(this)\n\n  // Pretty big window by default\n  this.window = 0.25\n\n  if (options && options.window) { this.window = options.window }\n\n  this.sync = []\n  this.list = []\n  this.count = 0\n  this.pendingTick = false\n}\nutil.inherits(Scheduler, Readable)\nmodule.exports = Scheduler\n\n// Just for testing, really\nScheduler.create = function create (options) {\n  return new Scheduler(options)\n}\n\nfunction insertCompare (a, b) {\n  return a.priority === b.priority\n    ? a.stream - b.stream\n    : b.priority - a.priority\n}\n\nScheduler.prototype.schedule = function schedule (data) {\n  var priority = data.priority\n  var stream = data.stream\n  var chunks = data.chunks\n\n  // Synchronous frames should not be interleaved\n  if (priority === false) {\n    debug('queue sync', chunks)\n    this.sync.push(data)\n    this.count += chunks.length\n\n    this._read()\n    return\n  }\n\n  debug('queue async priority=%d stream=%d', priority, stream, chunks)\n  var item = new SchedulerItem(stream, priority)\n  var index = utils.binaryLookup(this.list, item, insertCompare)\n\n  // Push new item\n  if (index >= this.list.length || insertCompare(this.list[index], item) !== 0) {\n    this.list.splice(index, 0, item)\n  } else { // Coalesce\n    item = this.list[index]\n  }\n\n  item.push(data)\n\n  this.count += chunks.length\n\n  this._read()\n}\n\nScheduler.prototype._read = function _read () {\n  if (this.count === 0) {\n    return\n  }\n\n  if (this.pendingTick) {\n    return\n  }\n  this.pendingTick = true\n\n  var self = this\n  process.nextTick(function () {\n    self.pendingTick = false\n    self.tick()\n  })\n}\n\nScheduler.prototype.tick = function tick () {\n  // No luck for async frames\n  if (!this.tickSync()) { return false }\n\n  return this.tickAsync()\n}\n\nScheduler.prototype.tickSync = function tickSync () {\n  // Empty sync queue first\n  var sync = this.sync\n  var res = true\n  this.sync = []\n  for (var i = 0; i < sync.length; i++) {\n    var item = sync[i]\n    debug('tick sync pending=%d', this.count, item.chunks)\n    for (var j = 0; j < item.chunks.length; j++) {\n      this.count--\n      // TODO: handle stream backoff properly\n      try {\n        res = this.push(item.chunks[j])\n      } catch (err) {\n        this.emit('error', err)\n        return false\n      }\n    }\n    debug('after tick sync pending=%d', this.count)\n\n    // TODO(indutny): figure out the way to invoke callback on actual write\n    if (item.callback) {\n      item.callback(null)\n    }\n  }\n  return res\n}\n\nScheduler.prototype.tickAsync = function tickAsync () {\n  var res = true\n  var list = this.list\n  if (list.length === 0) {\n    return res\n  }\n\n  var startPriority = list[0].priority\n  for (var index = 0; list.length > 0; index++) {\n    // Loop index\n    index %= list.length\n    if (startPriority - list[index].priority > this.window) { index = 0 }\n    debug('tick async index=%d start=%d', index, startPriority)\n\n    var current = list[index]\n    var item = current.shift()\n\n    if (current.isEmpty()) {\n      list.splice(index, 1)\n      if (index === 0 && list.length > 0) {\n        startPriority = list[0].priority\n      }\n      index--\n    }\n\n    debug('tick async pending=%d', this.count, item.chunks)\n    for (var i = 0; i < item.chunks.length; i++) {\n      this.count--\n      // TODO: handle stream backoff properly\n      try {\n        res = this.push(item.chunks[i])\n      } catch (err) {\n        this.emit('error', err)\n        return false\n      }\n    }\n    debug('after tick pending=%d', this.count)\n\n    // TODO(indutny): figure out the way to invoke callback on actual write\n    if (item.callback) {\n      item.callback(null)\n    }\n    if (!res) { break }\n  }\n\n  return res\n}\n\nScheduler.prototype.dump = function dump () {\n  this.tickSync()\n\n  // Write everything out\n  while (!this.tickAsync()) {\n    // Intentional no-op\n  }\n  assert.strictEqual(this.count, 0)\n}\n\nfunction SchedulerItem (stream, priority) {\n  this.stream = stream\n  this.priority = priority\n  this.queue = []\n}\n\nSchedulerItem.prototype.push = function push (chunks) {\n  this.queue.push(chunks)\n}\n\nSchedulerItem.prototype.shift = function shift () {\n  return this.queue.shift()\n}\n\nSchedulerItem.prototype.isEmpty = function isEmpty () {\n  return this.queue.length === 0\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}