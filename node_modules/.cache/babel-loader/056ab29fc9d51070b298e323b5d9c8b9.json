{"ast":null,"code":"\"use strict\";\n\nconst p = require('path');\n\nconst resolve = require('resolve'); // const printAST = require('ast-pretty-print')\n\n\nconst macrosRegex = /[./]macro(\\.c?js)?$/;\n\nconst testMacrosRegex = v => macrosRegex.test(v); // https://stackoverflow.com/a/32749533/971592\n\n\nclass MacroError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'MacroError';\n    /* istanbul ignore else */\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, this.constructor);\n    } else if (!this.stack) {\n      this.stack = new Error(message).stack;\n    }\n  }\n\n}\n\nlet _configExplorer = null;\n\nfunction getConfigExplorer() {\n  return _configExplorer = _configExplorer || // Lazy load cosmiconfig since it is a relatively large bundle\n  require('cosmiconfig').cosmiconfigSync('babel-plugin-macros', {\n    searchPlaces: ['package.json', '.babel-plugin-macrosrc', '.babel-plugin-macrosrc.json', '.babel-plugin-macrosrc.yaml', '.babel-plugin-macrosrc.yml', '.babel-plugin-macrosrc.js', 'babel-plugin-macros.config.js'],\n    packageProp: 'babelMacros'\n  });\n}\n\nfunction createMacro(macro) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (options.configName === 'options') {\n    throw new Error(`You cannot use the configName \"options\". It is reserved for babel-plugin-macros.`);\n  }\n\n  macroWrapper.isBabelMacro = true;\n  macroWrapper.options = options;\n  return macroWrapper;\n\n  function macroWrapper(args) {\n    const {\n      source,\n      isBabelMacrosCall\n    } = args;\n\n    if (!isBabelMacrosCall) {\n      throw new MacroError(`The macro you imported from \"${source}\" is being executed outside the context of compilation with babel-plugin-macros. ` + `This indicates that you don't have the babel plugin \"babel-plugin-macros\" configured correctly. ` + `Please see the documentation for how to configure babel-plugin-macros properly: ` + 'https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/user.md');\n    }\n\n    return macro(args);\n  }\n}\n\nfunction nodeResolvePath(source, basedir) {\n  return resolve.sync(source, {\n    basedir,\n    extensions: ['.js', '.ts', '.tsx', '.mjs', '.cjs', '.jsx'],\n    // This is here to support the package being globally installed\n    // read more: https://github.com/kentcdodds/babel-plugin-macros/pull/138\n    paths: [p.resolve(__dirname, '../../')]\n  });\n}\n\nfunction macrosPlugin(babel) {\n  let {\n    require: _require = require,\n    resolvePath = nodeResolvePath,\n    isMacrosName = testMacrosRegex,\n    ...options\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  function interopRequire(path) {\n    // eslint-disable-next-line import/no-dynamic-require\n    const o = _require(path);\n\n    return o && o.__esModule && o.default ? o.default : o;\n  }\n\n  return {\n    name: 'macros',\n    visitor: {\n      Program(progPath, state) {\n        progPath.traverse({\n          ImportDeclaration(path) {\n            const isMacros = looksLike(path, {\n              node: {\n                source: {\n                  value: v => isMacrosName(v)\n                }\n              }\n            });\n\n            if (!isMacros) {\n              return;\n            }\n\n            const imports = path.node.specifiers.map(s => ({\n              localName: s.local.name,\n              importedName: s.type === 'ImportDefaultSpecifier' ? 'default' : s.imported.name\n            }));\n            const source = path.node.source.value;\n            const result = applyMacros({\n              path,\n              imports,\n              source,\n              state,\n              babel,\n              interopRequire,\n              resolvePath,\n              options\n            });\n\n            if (!result || !result.keepImports) {\n              path.remove();\n            }\n          },\n\n          VariableDeclaration(path) {\n            const isMacros = child => looksLike(child, {\n              node: {\n                init: {\n                  callee: {\n                    type: 'Identifier',\n                    name: 'require'\n                  },\n                  arguments: args => args.length === 1 && isMacrosName(args[0].value)\n                }\n              }\n            });\n\n            path.get('declarations').filter(isMacros).forEach(child => {\n              const imports = child.node.id.name ? [{\n                localName: child.node.id.name,\n                importedName: 'default'\n              }] : child.node.id.properties.map(property => ({\n                localName: property.value.name,\n                importedName: property.key.name\n              }));\n              const call = child.get('init');\n              const source = call.node.arguments[0].value;\n              const result = applyMacros({\n                path: call,\n                imports,\n                source,\n                state,\n                babel,\n                interopRequire,\n                resolvePath,\n                options\n              });\n\n              if (!result || !result.keepImports) {\n                child.remove();\n              }\n            });\n          }\n\n        });\n      }\n\n    }\n  };\n} // eslint-disable-next-line complexity\n\n\nfunction applyMacros(_ref) {\n  let {\n    path,\n    imports,\n    source,\n    state,\n    babel,\n    interopRequire,\n    resolvePath,\n    options\n  } = _ref;\n\n  /* istanbul ignore next (pretty much only useful for astexplorer I think) */\n  const {\n    file: {\n      opts: {\n        filename = ''\n      }\n    }\n  } = state;\n  let hasReferences = false;\n  const referencePathsByImportName = imports.reduce((byName, _ref2) => {\n    let {\n      importedName,\n      localName\n    } = _ref2;\n    const binding = path.scope.getBinding(localName);\n    byName[importedName] = binding.referencePaths;\n    hasReferences = hasReferences || Boolean(byName[importedName].length);\n    return byName;\n  }, {});\n  const isRelative = source.indexOf('.') === 0;\n  const requirePath = resolvePath(source, p.dirname(getFullFilename(filename)));\n  const macro = interopRequire(requirePath);\n\n  if (!macro.isBabelMacro) {\n    throw new Error(`The macro imported from \"${source}\" must be wrapped in \"createMacro\" ` + `which you can get from \"babel-plugin-macros\". ` + `Please refer to the documentation to see how to do this properly: https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/author.md#writing-a-macro`);\n  }\n\n  const config = getConfig(macro, filename, source, options);\n  let result;\n\n  try {\n    /**\n     * Other plugins that run before babel-plugin-macros might use path.replace, where a path is\n     * put into its own replacement. Apparently babel does not update the scope after such\n     * an operation. As a remedy, the whole scope is traversed again with an empty \"Identifier\"\n     * visitor - this makes the problem go away.\n     *\n     * See: https://github.com/kentcdodds/import-all.macro/issues/7\n     */\n    state.file.scope.path.traverse({\n      Identifier() {}\n\n    });\n    result = macro({\n      references: referencePathsByImportName,\n      source,\n      state,\n      babel,\n      config,\n      isBabelMacrosCall: true\n    });\n  } catch (error) {\n    if (error.name === 'MacroError') {\n      throw error;\n    }\n\n    error.message = `${source}: ${error.message}`;\n\n    if (!isRelative) {\n      error.message = `${error.message} Learn more: https://www.npmjs.com/package/${source.replace( // remove everything after package name\n      // @org/package/macro -> @org/package\n      // package/macro      -> package\n      /^((?:@[^/]+\\/)?[^/]+).*/, '$1')}`;\n    }\n\n    throw error;\n  }\n\n  return result;\n}\n\nfunction getConfigFromFile(configName, filename) {\n  try {\n    const loaded = getConfigExplorer().search(filename);\n\n    if (loaded) {\n      return {\n        options: loaded.config[configName],\n        path: loaded.filepath\n      };\n    }\n  } catch (e) {\n    return {\n      error: e\n    };\n  }\n\n  return {};\n}\n\nfunction getConfigFromOptions(configName, options) {\n  if (options.hasOwnProperty(configName)) {\n    if (options[configName] && typeof options[configName] !== 'object') {\n      // eslint-disable-next-line no-console\n      console.error(`The macro plugin options' ${configName} property was not an object or null.`);\n    } else {\n      return {\n        options: options[configName]\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getConfig(macro, filename, source, options) {\n  const {\n    configName\n  } = macro.options;\n\n  if (configName) {\n    const fileConfig = getConfigFromFile(configName, filename);\n    const optionsConfig = getConfigFromOptions(configName, options);\n\n    if (optionsConfig.options === undefined && fileConfig.options === undefined && fileConfig.error !== undefined) {\n      // eslint-disable-next-line no-console\n      console.error(`There was an error trying to load the config \"${configName}\" ` + `for the macro imported from \"${source}. ` + `Please see the error thrown for more information.`);\n      throw fileConfig.error;\n    }\n\n    if (fileConfig.options !== undefined && optionsConfig.options !== undefined && typeof fileConfig.options !== 'object') {\n      throw new Error(`${fileConfig.path} specified a ${configName} config of type ` + `${typeof optionsConfig.options}, but the the macros plugin's ` + `options.${configName} did contain an object. Both configs must ` + `contain objects for their options to be mergeable.`);\n    }\n\n    return { ...optionsConfig.options,\n      ...fileConfig.options\n    };\n  }\n\n  return undefined;\n}\n/*\n istanbul ignore next\n because this is hard to test\n and not worth it...\n */\n\n\nfunction getFullFilename(filename) {\n  if (p.isAbsolute(filename)) {\n    return filename;\n  }\n\n  return p.join(process.cwd(), filename);\n}\n\nfunction looksLike(a, b) {\n  return a && b && Object.keys(b).every(bKey => {\n    const bVal = b[bKey];\n    const aVal = a[bKey];\n\n    if (typeof bVal === 'function') {\n      return bVal(aVal);\n    }\n\n    return isPrimitive(bVal) ? bVal === aVal : looksLike(aVal, bVal);\n  });\n}\n\nfunction isPrimitive(val) {\n  // eslint-disable-next-line\n  return val == null || /^[sbn]/.test(typeof val);\n}\n\nmodule.exports = macrosPlugin;\nObject.assign(module.exports, {\n  createMacro,\n  MacroError\n});","map":{"version":3,"names":["p","require","resolve","macrosRegex","testMacrosRegex","v","test","MacroError","Error","constructor","message","name","captureStackTrace","stack","_configExplorer","getConfigExplorer","cosmiconfigSync","searchPlaces","packageProp","createMacro","macro","options","configName","macroWrapper","isBabelMacro","args","source","isBabelMacrosCall","nodeResolvePath","basedir","sync","extensions","paths","__dirname","macrosPlugin","babel","_require","resolvePath","isMacrosName","interopRequire","path","o","__esModule","default","visitor","Program","progPath","state","traverse","ImportDeclaration","isMacros","looksLike","node","value","imports","specifiers","map","s","localName","local","importedName","type","imported","result","applyMacros","keepImports","remove","VariableDeclaration","child","init","callee","arguments","length","get","filter","forEach","id","properties","property","key","call","file","opts","filename","hasReferences","referencePathsByImportName","reduce","byName","binding","scope","getBinding","referencePaths","Boolean","isRelative","indexOf","requirePath","dirname","getFullFilename","config","getConfig","Identifier","references","error","replace","getConfigFromFile","loaded","search","filepath","e","getConfigFromOptions","hasOwnProperty","console","fileConfig","optionsConfig","undefined","isAbsolute","join","process","cwd","a","b","Object","keys","every","bKey","bVal","aVal","isPrimitive","val","module","exports","assign"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/babel-plugin-macros/dist/index.js"],"sourcesContent":["\"use strict\";\n\nconst p = require('path');\n\nconst resolve = require('resolve'); // const printAST = require('ast-pretty-print')\n\n\nconst macrosRegex = /[./]macro(\\.c?js)?$/;\n\nconst testMacrosRegex = v => macrosRegex.test(v); // https://stackoverflow.com/a/32749533/971592\n\n\nclass MacroError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'MacroError';\n    /* istanbul ignore else */\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, this.constructor);\n    } else if (!this.stack) {\n      this.stack = new Error(message).stack;\n    }\n  }\n\n}\n\nlet _configExplorer = null;\n\nfunction getConfigExplorer() {\n  return _configExplorer = _configExplorer || // Lazy load cosmiconfig since it is a relatively large bundle\n  require('cosmiconfig').cosmiconfigSync('babel-plugin-macros', {\n    searchPlaces: ['package.json', '.babel-plugin-macrosrc', '.babel-plugin-macrosrc.json', '.babel-plugin-macrosrc.yaml', '.babel-plugin-macrosrc.yml', '.babel-plugin-macrosrc.js', 'babel-plugin-macros.config.js'],\n    packageProp: 'babelMacros'\n  });\n}\n\nfunction createMacro(macro, options = {}) {\n  if (options.configName === 'options') {\n    throw new Error(`You cannot use the configName \"options\". It is reserved for babel-plugin-macros.`);\n  }\n\n  macroWrapper.isBabelMacro = true;\n  macroWrapper.options = options;\n  return macroWrapper;\n\n  function macroWrapper(args) {\n    const {\n      source,\n      isBabelMacrosCall\n    } = args;\n\n    if (!isBabelMacrosCall) {\n      throw new MacroError(`The macro you imported from \"${source}\" is being executed outside the context of compilation with babel-plugin-macros. ` + `This indicates that you don't have the babel plugin \"babel-plugin-macros\" configured correctly. ` + `Please see the documentation for how to configure babel-plugin-macros properly: ` + 'https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/user.md');\n    }\n\n    return macro(args);\n  }\n}\n\nfunction nodeResolvePath(source, basedir) {\n  return resolve.sync(source, {\n    basedir,\n    extensions: ['.js', '.ts', '.tsx', '.mjs', '.cjs', '.jsx'],\n    // This is here to support the package being globally installed\n    // read more: https://github.com/kentcdodds/babel-plugin-macros/pull/138\n    paths: [p.resolve(__dirname, '../../')]\n  });\n}\n\nfunction macrosPlugin(babel, // istanbul doesn't like the default of an object for the plugin options\n// but I think older versions of babel didn't always pass options\n// istanbul ignore next\n{\n  require: _require = require,\n  resolvePath = nodeResolvePath,\n  isMacrosName = testMacrosRegex,\n  ...options\n} = {}) {\n  function interopRequire(path) {\n    // eslint-disable-next-line import/no-dynamic-require\n    const o = _require(path);\n\n    return o && o.__esModule && o.default ? o.default : o;\n  }\n\n  return {\n    name: 'macros',\n    visitor: {\n      Program(progPath, state) {\n        progPath.traverse({\n          ImportDeclaration(path) {\n            const isMacros = looksLike(path, {\n              node: {\n                source: {\n                  value: v => isMacrosName(v)\n                }\n              }\n            });\n\n            if (!isMacros) {\n              return;\n            }\n\n            const imports = path.node.specifiers.map(s => ({\n              localName: s.local.name,\n              importedName: s.type === 'ImportDefaultSpecifier' ? 'default' : s.imported.name\n            }));\n            const source = path.node.source.value;\n            const result = applyMacros({\n              path,\n              imports,\n              source,\n              state,\n              babel,\n              interopRequire,\n              resolvePath,\n              options\n            });\n\n            if (!result || !result.keepImports) {\n              path.remove();\n            }\n          },\n\n          VariableDeclaration(path) {\n            const isMacros = child => looksLike(child, {\n              node: {\n                init: {\n                  callee: {\n                    type: 'Identifier',\n                    name: 'require'\n                  },\n                  arguments: args => args.length === 1 && isMacrosName(args[0].value)\n                }\n              }\n            });\n\n            path.get('declarations').filter(isMacros).forEach(child => {\n              const imports = child.node.id.name ? [{\n                localName: child.node.id.name,\n                importedName: 'default'\n              }] : child.node.id.properties.map(property => ({\n                localName: property.value.name,\n                importedName: property.key.name\n              }));\n              const call = child.get('init');\n              const source = call.node.arguments[0].value;\n              const result = applyMacros({\n                path: call,\n                imports,\n                source,\n                state,\n                babel,\n                interopRequire,\n                resolvePath,\n                options\n              });\n\n              if (!result || !result.keepImports) {\n                child.remove();\n              }\n            });\n          }\n\n        });\n      }\n\n    }\n  };\n} // eslint-disable-next-line complexity\n\n\nfunction applyMacros({\n  path,\n  imports,\n  source,\n  state,\n  babel,\n  interopRequire,\n  resolvePath,\n  options\n}) {\n  /* istanbul ignore next (pretty much only useful for astexplorer I think) */\n  const {\n    file: {\n      opts: {\n        filename = ''\n      }\n    }\n  } = state;\n  let hasReferences = false;\n  const referencePathsByImportName = imports.reduce((byName, {\n    importedName,\n    localName\n  }) => {\n    const binding = path.scope.getBinding(localName);\n    byName[importedName] = binding.referencePaths;\n    hasReferences = hasReferences || Boolean(byName[importedName].length);\n    return byName;\n  }, {});\n  const isRelative = source.indexOf('.') === 0;\n  const requirePath = resolvePath(source, p.dirname(getFullFilename(filename)));\n  const macro = interopRequire(requirePath);\n\n  if (!macro.isBabelMacro) {\n    throw new Error(`The macro imported from \"${source}\" must be wrapped in \"createMacro\" ` + `which you can get from \"babel-plugin-macros\". ` + `Please refer to the documentation to see how to do this properly: https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/author.md#writing-a-macro`);\n  }\n\n  const config = getConfig(macro, filename, source, options);\n  let result;\n\n  try {\n    /**\n     * Other plugins that run before babel-plugin-macros might use path.replace, where a path is\n     * put into its own replacement. Apparently babel does not update the scope after such\n     * an operation. As a remedy, the whole scope is traversed again with an empty \"Identifier\"\n     * visitor - this makes the problem go away.\n     *\n     * See: https://github.com/kentcdodds/import-all.macro/issues/7\n     */\n    state.file.scope.path.traverse({\n      Identifier() {}\n\n    });\n    result = macro({\n      references: referencePathsByImportName,\n      source,\n      state,\n      babel,\n      config,\n      isBabelMacrosCall: true\n    });\n  } catch (error) {\n    if (error.name === 'MacroError') {\n      throw error;\n    }\n\n    error.message = `${source}: ${error.message}`;\n\n    if (!isRelative) {\n      error.message = `${error.message} Learn more: https://www.npmjs.com/package/${source.replace( // remove everything after package name\n      // @org/package/macro -> @org/package\n      // package/macro      -> package\n      /^((?:@[^/]+\\/)?[^/]+).*/, '$1')}`;\n    }\n\n    throw error;\n  }\n\n  return result;\n}\n\nfunction getConfigFromFile(configName, filename) {\n  try {\n    const loaded = getConfigExplorer().search(filename);\n\n    if (loaded) {\n      return {\n        options: loaded.config[configName],\n        path: loaded.filepath\n      };\n    }\n  } catch (e) {\n    return {\n      error: e\n    };\n  }\n\n  return {};\n}\n\nfunction getConfigFromOptions(configName, options) {\n  if (options.hasOwnProperty(configName)) {\n    if (options[configName] && typeof options[configName] !== 'object') {\n      // eslint-disable-next-line no-console\n      console.error(`The macro plugin options' ${configName} property was not an object or null.`);\n    } else {\n      return {\n        options: options[configName]\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getConfig(macro, filename, source, options) {\n  const {\n    configName\n  } = macro.options;\n\n  if (configName) {\n    const fileConfig = getConfigFromFile(configName, filename);\n    const optionsConfig = getConfigFromOptions(configName, options);\n\n    if (optionsConfig.options === undefined && fileConfig.options === undefined && fileConfig.error !== undefined) {\n      // eslint-disable-next-line no-console\n      console.error(`There was an error trying to load the config \"${configName}\" ` + `for the macro imported from \"${source}. ` + `Please see the error thrown for more information.`);\n      throw fileConfig.error;\n    }\n\n    if (fileConfig.options !== undefined && optionsConfig.options !== undefined && typeof fileConfig.options !== 'object') {\n      throw new Error(`${fileConfig.path} specified a ${configName} config of type ` + `${typeof optionsConfig.options}, but the the macros plugin's ` + `options.${configName} did contain an object. Both configs must ` + `contain objects for their options to be mergeable.`);\n    }\n\n    return { ...optionsConfig.options,\n      ...fileConfig.options\n    };\n  }\n\n  return undefined;\n}\n/*\n istanbul ignore next\n because this is hard to test\n and not worth it...\n */\n\n\nfunction getFullFilename(filename) {\n  if (p.isAbsolute(filename)) {\n    return filename;\n  }\n\n  return p.join(process.cwd(), filename);\n}\n\nfunction looksLike(a, b) {\n  return a && b && Object.keys(b).every(bKey => {\n    const bVal = b[bKey];\n    const aVal = a[bKey];\n\n    if (typeof bVal === 'function') {\n      return bVal(aVal);\n    }\n\n    return isPrimitive(bVal) ? bVal === aVal : looksLike(aVal, bVal);\n  });\n}\n\nfunction isPrimitive(val) {\n  // eslint-disable-next-line\n  return val == null || /^[sbn]/.test(typeof val);\n}\n\nmodule.exports = macrosPlugin;\nObject.assign(module.exports, {\n  createMacro,\n  MacroError\n});"],"mappings":"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"},"metadata":{},"sourceType":"script"}