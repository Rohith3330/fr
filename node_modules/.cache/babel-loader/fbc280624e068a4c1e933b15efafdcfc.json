{"ast":null,"code":"\"use strict\"; // builtin tooling\n\nconst path = require(\"path\"); // internal tooling\n\n\nconst joinMedia = require(\"./lib/join-media\");\n\nconst joinLayer = require(\"./lib/join-layer\");\n\nconst resolveId = require(\"./lib/resolve-id\");\n\nconst loadContent = require(\"./lib/load-content\");\n\nconst processContent = require(\"./lib/process-content\");\n\nconst parseStatements = require(\"./lib/parse-statements\");\n\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    ...options\n  };\n  options.root = path.resolve(options.root); // convert string to an array of a single element\n\n  if (typeof options.path === \"string\") options.path = [options.path];\n  if (!Array.isArray(options.path)) options.path = [];\n  options.path = options.path.map(p => path.resolve(options.root, p));\n  return {\n    postcssPlugin: \"postcss-import\",\n\n    Once(styles, _ref) {\n      let {\n        result,\n        atRule,\n        postcss\n      } = _ref;\n      const state = {\n        importedFiles: {},\n        hashFiles: {}\n      };\n\n      if (styles.source && styles.source.input && styles.source.input.file) {\n        state.importedFiles[styles.source.input.file] = {};\n      }\n\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\");\n      }\n\n      return parseStyles(result, styles, options, state, [], []).then(bundle => {\n        applyRaws(bundle);\n        applyMedia(bundle);\n        applyStyles(bundle, styles);\n      });\n\n      function applyRaws(bundle) {\n        bundle.forEach((stmt, index) => {\n          if (index === 0) return;\n\n          if (stmt.parent) {\n            const {\n              before\n            } = stmt.parent.node.raws;\n            if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before;else stmt.node.raws.before = before;\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\";\n          }\n        });\n      }\n\n      function applyMedia(bundle) {\n        bundle.forEach(stmt => {\n          if (!stmt.media.length && !stmt.layer.length || stmt.type === \"charset\") {\n            return;\n          }\n\n          if (stmt.type === \"import\") {\n            stmt.node.params = `${stmt.fullUri} ${stmt.media.join(\", \")}`;\n          } else if (stmt.type === \"media\") {\n            stmt.node.params = stmt.media.join(\", \");\n          } else {\n            const {\n              nodes\n            } = stmt;\n            const {\n              parent\n            } = nodes[0];\n            let outerAtRule;\n            let innerAtRule;\n\n            if (stmt.media.length && stmt.layer.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source\n              });\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.filter(layer => layer !== \"\").join(\".\"),\n                source: parent.source\n              });\n              mediaNode.append(layerNode);\n              innerAtRule = layerNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.media.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source\n              });\n              innerAtRule = mediaNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.filter(layer => layer !== \"\").join(\".\"),\n                source: parent.source\n              });\n              innerAtRule = layerNode;\n              outerAtRule = layerNode;\n            }\n\n            parent.insertBefore(nodes[0], outerAtRule); // remove nodes\n\n            nodes.forEach(node => {\n              node.parent = undefined;\n            }); // better output\n\n            nodes[0].raws.before = nodes[0].raws.before || \"\\n\"; // wrap new rules with media query and/or layer at rule\n\n            innerAtRule.append(nodes);\n            stmt.type = \"media\";\n            stmt.node = outerAtRule;\n            delete stmt.nodes;\n          }\n        });\n      }\n\n      function applyStyles(bundle, styles) {\n        styles.nodes = []; // Strip additional statements.\n\n        bundle.forEach(stmt => {\n          if ([\"charset\", \"import\", \"media\"].includes(stmt.type)) {\n            stmt.node.parent = undefined;\n            styles.append(stmt.node);\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes.forEach(node => {\n              node.parent = undefined;\n              styles.append(node);\n            });\n          }\n        });\n      }\n\n      function parseStyles(result, styles, options, state, media, layer) {\n        const statements = parseStatements(result, styles);\n        return Promise.resolve(statements).then(stmts => {\n          // process each statement in series\n          return stmts.reduce((promise, stmt) => {\n            return promise.then(() => {\n              stmt.media = joinMedia(media, stmt.media || []);\n              stmt.layer = joinLayer(layer, stmt.layer || []); // skip protocol base uri (protocol://url) or protocol-relative\n\n              if (stmt.type !== \"import\" || /^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)) {\n                return;\n              }\n\n              if (options.filter && !options.filter(stmt.uri)) {\n                // rejected by filter\n                return;\n              }\n\n              return resolveImportId(result, stmt, options, state);\n            });\n          }, Promise.resolve());\n        }).then(() => {\n          let charset;\n          const imports = [];\n          const bundle = [];\n\n          function handleCharset(stmt) {\n            if (!charset) charset = stmt; // charsets aren't case-sensitive, so convert to lower case to compare\n            else if (stmt.node.params.toLowerCase() !== charset.node.params.toLowerCase()) {\n              throw new Error(`Incompatable @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`);\n            }\n          } // squash statements and their children\n\n\n          statements.forEach(stmt => {\n            if (stmt.type === \"charset\") handleCharset(stmt);else if (stmt.type === \"import\") {\n              if (stmt.children) {\n                stmt.children.forEach((child, index) => {\n                  if (child.type === \"import\") imports.push(child);else if (child.type === \"charset\") handleCharset(child);else bundle.push(child); // For better output\n\n                  if (index === 0) child.parent = stmt;\n                });\n              } else imports.push(stmt);\n            } else if (stmt.type === \"media\" || stmt.type === \"nodes\") {\n              bundle.push(stmt);\n            }\n          });\n          return charset ? [charset, ...imports.concat(bundle)] : imports.concat(bundle);\n        });\n      }\n\n      function resolveImportId(result, stmt, options, state) {\n        const atRule = stmt.node;\n        let sourceFile;\n\n        if (atRule.source && atRule.source.input && atRule.source.input.file) {\n          sourceFile = atRule.source.input.file;\n        }\n\n        const base = sourceFile ? path.dirname(atRule.source.input.file) : options.root;\n        return Promise.resolve(options.resolve(stmt.uri, base, options)).then(paths => {\n          if (!Array.isArray(paths)) paths = [paths]; // Ensure that each path is absolute:\n\n          return Promise.all(paths.map(file => {\n            return !path.isAbsolute(file) ? resolveId(file, base, options) : file;\n          }));\n        }).then(resolved => {\n          // Add dependency messages:\n          resolved.forEach(file => {\n            result.messages.push({\n              type: \"dependency\",\n              plugin: \"postcss-import\",\n              file,\n              parent: sourceFile\n            });\n          });\n          return Promise.all(resolved.map(file => {\n            return loadImportContent(result, stmt, file, options, state);\n          }));\n        }).then(result => {\n          // Merge loaded statements\n          stmt.children = result.reduce((result, statements) => {\n            return statements ? result.concat(statements) : result;\n          }, []);\n        });\n      }\n\n      function loadImportContent(result, stmt, filename, options, state) {\n        const atRule = stmt.node;\n        const {\n          media,\n          layer\n        } = stmt;\n\n        if (options.skipDuplicates) {\n          // skip files already imported at the same scope\n          if (state.importedFiles[filename] && state.importedFiles[filename][media]) {\n            return;\n          } // save imported files to skip them next time\n\n\n          if (!state.importedFiles[filename]) state.importedFiles[filename] = {};\n          state.importedFiles[filename][media] = true;\n        }\n\n        return Promise.resolve(options.load(filename, options)).then(content => {\n          if (content.trim() === \"\") {\n            result.warn(`${filename} is empty`, {\n              node: atRule\n            });\n            return;\n          } // skip previous imported files not containing @import rules\n\n\n          if (state.hashFiles[content] && state.hashFiles[content][media]) return;\n          return processContent(result, content, filename, options, postcss).then(importedResult => {\n            const styles = importedResult.root;\n            result.messages = result.messages.concat(importedResult.messages);\n\n            if (options.skipDuplicates) {\n              const hasImport = styles.some(child => {\n                return child.type === \"atrule\" && child.name === \"import\";\n              });\n\n              if (!hasImport) {\n                // save hash files to skip them next time\n                if (!state.hashFiles[content]) state.hashFiles[content] = {};\n                state.hashFiles[content][media] = true;\n              }\n            } // recursion: import @import from imported file\n\n\n            return parseStyles(result, styles, options, state, media, layer);\n          });\n        });\n      }\n    }\n\n  };\n}\n\nAtImport.postcss = true;\nmodule.exports = AtImport;","map":{"version":3,"names":["path","require","joinMedia","joinLayer","resolveId","loadContent","processContent","parseStatements","AtImport","options","root","process","cwd","skipDuplicates","resolve","load","plugins","addModulesDirectories","Array","isArray","map","p","postcssPlugin","Once","styles","result","atRule","postcss","state","importedFiles","hashFiles","source","input","file","Error","parseStyles","then","bundle","applyRaws","applyMedia","applyStyles","forEach","stmt","index","parent","before","node","raws","type","nodes","media","length","layer","params","fullUri","join","outerAtRule","innerAtRule","mediaNode","name","layerNode","filter","append","insertBefore","undefined","includes","statements","Promise","stmts","reduce","promise","test","uri","resolveImportId","charset","imports","handleCharset","toLowerCase","children","child","push","concat","sourceFile","base","dirname","paths","all","isAbsolute","resolved","messages","plugin","loadImportContent","filename","content","trim","warn","importedResult","hasImport","some","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-import/index.js"],"sourcesContent":["\"use strict\"\n// builtin tooling\nconst path = require(\"path\")\n\n// internal tooling\nconst joinMedia = require(\"./lib/join-media\")\nconst joinLayer = require(\"./lib/join-layer\")\nconst resolveId = require(\"./lib/resolve-id\")\nconst loadContent = require(\"./lib/load-content\")\nconst processContent = require(\"./lib/process-content\")\nconst parseStatements = require(\"./lib/parse-statements\")\n\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    ...options,\n  }\n\n  options.root = path.resolve(options.root)\n\n  // convert string to an array of a single element\n  if (typeof options.path === \"string\") options.path = [options.path]\n\n  if (!Array.isArray(options.path)) options.path = []\n\n  options.path = options.path.map(p => path.resolve(options.root, p))\n\n  return {\n    postcssPlugin: \"postcss-import\",\n    Once(styles, { result, atRule, postcss }) {\n      const state = {\n        importedFiles: {},\n        hashFiles: {},\n      }\n\n      if (styles.source && styles.source.input && styles.source.input.file) {\n        state.importedFiles[styles.source.input.file] = {}\n      }\n\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\")\n      }\n\n      return parseStyles(result, styles, options, state, [], []).then(\n        bundle => {\n          applyRaws(bundle)\n          applyMedia(bundle)\n          applyStyles(bundle, styles)\n        }\n      )\n\n      function applyRaws(bundle) {\n        bundle.forEach((stmt, index) => {\n          if (index === 0) return\n\n          if (stmt.parent) {\n            const { before } = stmt.parent.node.raws\n            if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before\n            else stmt.node.raws.before = before\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\"\n          }\n        })\n      }\n\n      function applyMedia(bundle) {\n        bundle.forEach(stmt => {\n          if (\n            (!stmt.media.length && !stmt.layer.length) ||\n            stmt.type === \"charset\"\n          ) {\n            return\n          }\n\n          if (stmt.type === \"import\") {\n            stmt.node.params = `${stmt.fullUri} ${stmt.media.join(\", \")}`\n          } else if (stmt.type === \"media\") {\n            stmt.node.params = stmt.media.join(\", \")\n          } else {\n            const { nodes } = stmt\n            const { parent } = nodes[0]\n\n            let outerAtRule\n            let innerAtRule\n            if (stmt.media.length && stmt.layer.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              })\n\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.filter(layer => layer !== \"\").join(\".\"),\n                source: parent.source,\n              })\n\n              mediaNode.append(layerNode)\n              innerAtRule = layerNode\n              outerAtRule = mediaNode\n            } else if (stmt.media.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              })\n\n              innerAtRule = mediaNode\n              outerAtRule = mediaNode\n            } else if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.filter(layer => layer !== \"\").join(\".\"),\n                source: parent.source,\n              })\n\n              innerAtRule = layerNode\n              outerAtRule = layerNode\n            }\n\n            parent.insertBefore(nodes[0], outerAtRule)\n\n            // remove nodes\n            nodes.forEach(node => {\n              node.parent = undefined\n            })\n\n            // better output\n            nodes[0].raws.before = nodes[0].raws.before || \"\\n\"\n\n            // wrap new rules with media query and/or layer at rule\n            innerAtRule.append(nodes)\n\n            stmt.type = \"media\"\n            stmt.node = outerAtRule\n            delete stmt.nodes\n          }\n        })\n      }\n\n      function applyStyles(bundle, styles) {\n        styles.nodes = []\n\n        // Strip additional statements.\n        bundle.forEach(stmt => {\n          if ([\"charset\", \"import\", \"media\"].includes(stmt.type)) {\n            stmt.node.parent = undefined\n            styles.append(stmt.node)\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes.forEach(node => {\n              node.parent = undefined\n              styles.append(node)\n            })\n          }\n        })\n      }\n\n      function parseStyles(result, styles, options, state, media, layer) {\n        const statements = parseStatements(result, styles)\n\n        return Promise.resolve(statements)\n          .then(stmts => {\n            // process each statement in series\n            return stmts.reduce((promise, stmt) => {\n              return promise.then(() => {\n                stmt.media = joinMedia(media, stmt.media || [])\n                stmt.layer = joinLayer(layer, stmt.layer || [])\n\n                // skip protocol base uri (protocol://url) or protocol-relative\n                if (\n                  stmt.type !== \"import\" ||\n                  /^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)\n                ) {\n                  return\n                }\n\n                if (options.filter && !options.filter(stmt.uri)) {\n                  // rejected by filter\n                  return\n                }\n\n                return resolveImportId(result, stmt, options, state)\n              })\n            }, Promise.resolve())\n          })\n          .then(() => {\n            let charset\n            const imports = []\n            const bundle = []\n\n            function handleCharset(stmt) {\n              if (!charset) charset = stmt\n              // charsets aren't case-sensitive, so convert to lower case to compare\n              else if (\n                stmt.node.params.toLowerCase() !==\n                charset.node.params.toLowerCase()\n              ) {\n                throw new Error(\n                  `Incompatable @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`\n                )\n              }\n            }\n\n            // squash statements and their children\n            statements.forEach(stmt => {\n              if (stmt.type === \"charset\") handleCharset(stmt)\n              else if (stmt.type === \"import\") {\n                if (stmt.children) {\n                  stmt.children.forEach((child, index) => {\n                    if (child.type === \"import\") imports.push(child)\n                    else if (child.type === \"charset\") handleCharset(child)\n                    else bundle.push(child)\n                    // For better output\n                    if (index === 0) child.parent = stmt\n                  })\n                } else imports.push(stmt)\n              } else if (stmt.type === \"media\" || stmt.type === \"nodes\") {\n                bundle.push(stmt)\n              }\n            })\n\n            return charset\n              ? [charset, ...imports.concat(bundle)]\n              : imports.concat(bundle)\n          })\n      }\n\n      function resolveImportId(result, stmt, options, state) {\n        const atRule = stmt.node\n        let sourceFile\n        if (atRule.source && atRule.source.input && atRule.source.input.file) {\n          sourceFile = atRule.source.input.file\n        }\n        const base = sourceFile\n          ? path.dirname(atRule.source.input.file)\n          : options.root\n\n        return Promise.resolve(options.resolve(stmt.uri, base, options))\n          .then(paths => {\n            if (!Array.isArray(paths)) paths = [paths]\n            // Ensure that each path is absolute:\n            return Promise.all(\n              paths.map(file => {\n                return !path.isAbsolute(file)\n                  ? resolveId(file, base, options)\n                  : file\n              })\n            )\n          })\n          .then(resolved => {\n            // Add dependency messages:\n            resolved.forEach(file => {\n              result.messages.push({\n                type: \"dependency\",\n                plugin: \"postcss-import\",\n                file,\n                parent: sourceFile,\n              })\n            })\n\n            return Promise.all(\n              resolved.map(file => {\n                return loadImportContent(result, stmt, file, options, state)\n              })\n            )\n          })\n          .then(result => {\n            // Merge loaded statements\n            stmt.children = result.reduce((result, statements) => {\n              return statements ? result.concat(statements) : result\n            }, [])\n          })\n      }\n\n      function loadImportContent(result, stmt, filename, options, state) {\n        const atRule = stmt.node\n        const { media, layer } = stmt\n        if (options.skipDuplicates) {\n          // skip files already imported at the same scope\n          if (\n            state.importedFiles[filename] &&\n            state.importedFiles[filename][media]\n          ) {\n            return\n          }\n\n          // save imported files to skip them next time\n          if (!state.importedFiles[filename]) state.importedFiles[filename] = {}\n          state.importedFiles[filename][media] = true\n        }\n\n        return Promise.resolve(options.load(filename, options)).then(\n          content => {\n            if (content.trim() === \"\") {\n              result.warn(`${filename} is empty`, { node: atRule })\n              return\n            }\n\n            // skip previous imported files not containing @import rules\n            if (state.hashFiles[content] && state.hashFiles[content][media])\n              return\n\n            return processContent(\n              result,\n              content,\n              filename,\n              options,\n              postcss\n            ).then(importedResult => {\n              const styles = importedResult.root\n              result.messages = result.messages.concat(importedResult.messages)\n\n              if (options.skipDuplicates) {\n                const hasImport = styles.some(child => {\n                  return child.type === \"atrule\" && child.name === \"import\"\n                })\n                if (!hasImport) {\n                  // save hash files to skip them next time\n                  if (!state.hashFiles[content]) state.hashFiles[content] = {}\n                  state.hashFiles[content][media] = true\n                }\n              }\n\n              // recursion: import @import from imported file\n              return parseStyles(result, styles, options, state, media, layer)\n            })\n          }\n        )\n      }\n    },\n  }\n}\n\nAtImport.postcss = true\n\nmodule.exports = AtImport\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}