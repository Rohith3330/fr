{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _t = require(\"@babel/types\");\n\nvar _util = require(\"./util\");\n\nconst {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createTypeAnnotationBasedOnTypeof,\n  numberTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations.push(...functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  return (0, _util.createUnionType)(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    return {\n      typeAnnotation: (0, _util.createUnionType)(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(binding, ifStatement, name);\n}","map":{"version":3,"mappings":"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","names":["BOOLEAN_NUMBER_BINARY_OPERATORS","createTypeAnnotationBasedOnTypeof","numberTypeAnnotation","voidTypeAnnotation","node","isReferenced","binding","scope","getBinding","name","identifier","typeAnnotation","getTypeAnnotationBindingConstantViolations","path","types","functionConstantViolations","constantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","filter","indexOf","push","length","violation","getTypeAnnotation","functions","violations","slice","unshift","resolve","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","operator","right","get","left","target","isIdentifier","typeofPath","typePath","isUnaryExpression","isLiteral","typeValue","value","getParentConditionalPath","parentPath","isIfStatement","isConditionalExpression","key","isFunction","test","paths","i","isLogicalExpression","isBinaryExpression","type"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\path\\inference\\inferer-reference.ts"],"sourcesContent":["import type NodePath from \"../index\";\nimport {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createTypeAnnotationBasedOnTypeof,\n  numberTypeAnnotation,\n  voidTypeAnnotation,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type Binding from \"../../scope/binding\";\n\nimport { createUnionType } from \"./util\";\n\nexport default function (this: NodePath<t.Identifier>, node: t.Identifier) {\n  if (!this.isReferenced()) return;\n\n  // check if a binding exists of this value and if so then return a union type of all\n  // possible types that the binding could be\n  const binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(\n        binding,\n        this,\n        node.name,\n      );\n    }\n  }\n\n  // built-in values\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {\n    // todo\n  }\n}\n\nfunction getTypeAnnotationBindingConstantViolations(\n  binding: Binding,\n  path: NodePath<t.Identifier>,\n  name: string,\n) {\n  const types = [];\n\n  const functionConstantViolations: NodePath[] = [];\n  let constantViolations = getConstantViolationsBefore(\n    binding,\n    path,\n    functionConstantViolations,\n  );\n\n  const testType = getConditionalAnnotation(binding, path, name);\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(\n      binding,\n      testType.ifStatement,\n    );\n\n    // remove constant violations observed before the IfStatement\n    constantViolations = constantViolations.filter(\n      path => testConstantViolations.indexOf(path) < 0,\n    );\n\n    // clear current types and add in observed test type\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    // pick one constant from each scope which will represent the last possible\n    // control flow path that it could've taken/been\n    /* This code is broken for the following problems:\n     * It thinks that assignments can only happen in scopes.\n     * What about conditionals, if statements without block,\n     * or guarded assignments.\n     * It also checks to see if one of the assignments is in the\n     * same scope and uses that as the only \"violation\". However,\n     * the binding is returned by `getConstantViolationsBefore` so we for\n     * sure always going to return that as the only \"violation\".\n    let rawConstantViolations = constantViolations.reverse();\n    let visitedScopes = [];\n    constantViolations = [];\n    for (let violation of (rawConstantViolations: Array<NodePath>)) {\n      let violationScope = violation.scope;\n      if (visitedScopes.indexOf(violationScope) >= 0) continue;\n\n      visitedScopes.push(violationScope);\n      constantViolations.push(violation);\n\n      if (violationScope === path.scope) {\n        constantViolations = [violation];\n        break;\n      }\n    }*/\n\n    // add back on function constant violations since we can't track calls\n    constantViolations.push(...functionConstantViolations);\n\n    // push on inferred types of violated paths\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  return createUnionType(types);\n}\n\nfunction getConstantViolationsBefore(\n  binding: Binding,\n  path: NodePath,\n  functions?: NodePath[],\n) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n    const status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(\n  name: string,\n  path: NodePath<t.BinaryExpression>,\n) {\n  const operator = path.node.operator;\n\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n\n  let target;\n  if (left.isIdentifier({ name })) {\n    target = right;\n  } else if (right.isIdentifier({ name })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n\n  //\n  let typeofPath: NodePath<t.UnaryExpression>;\n  let typePath: NodePath<t.Expression>;\n  if (left.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = left;\n    typePath = right as NodePath<t.Expression>;\n  } else if (right.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = right;\n    typePath = left as NodePath<t.Expression>;\n  }\n\n  if (!typeofPath) return;\n  // and that the argument of the typeof path references us!\n  if (!typeofPath.get(\"argument\").isIdentifier({ name })) return;\n\n  // ensure that the type path is a Literal\n  typePath = typePath.resolve() as NodePath<t.Expression>;\n  if (!typePath.isLiteral()) return;\n\n  // and that it's a string so we can infer it\n  // @ts-expect-error todo(flow->ts): value is not defined for NullLiteral and some other\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n\n  // turn type value into a type annotation\n  // @ts-expect-error todo(flow->ts): move validation from helper or relax type constraint to just a string\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(\n  binding: Binding,\n  path: NodePath,\n  name: string,\n) {\n  let parentPath;\n  while ((parentPath = path.parentPath)) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath as NodePath<t.IfStatement | t.ConditionalExpression>;\n    }\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation<T extends t.Node>(\n  binding: Binding,\n  path: NodePath<T>,\n  name?: string,\n): {\n  typeAnnotation: t.FlowType | t.TSType;\n  ifStatement: NodePath<t.IfStatement | t.ConditionalExpression>;\n} {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    return {\n      typeAnnotation: createUnionType(types),\n      ifStatement,\n    };\n  }\n\n  return getConditionalAnnotation(binding, ifStatement, name);\n}\n"]},"metadata":{},"sourceType":"script"}