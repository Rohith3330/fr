{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst TreeNode_1 = __importDefault(require(\"./TreeNode\"));\n\nconst index_1 = require(\"../../ContainerBase/index\");\n\nconst checkParams_1 = require(\"../../../utils/checkParams\");\n\nclass TreeContainer extends index_1.Container {\n  constructor() {\n    let cmp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (x, y) => {\n      if (x < y) return -1;\n      if (x > y) return 1;\n      return 0;\n    };\n    super();\n    this.root = undefined;\n    this.header = new TreeNode_1.default();\n    /**\n     * @description InOrder traversal the tree.\n     * @protected\n     */\n\n    this.inOrderTraversal = (curNode, callback) => {\n      if (curNode === undefined) return false;\n      const ifReturn = this.inOrderTraversal(curNode.left, callback);\n      if (ifReturn) return true;\n      if (callback(curNode)) return true;\n      return this.inOrderTraversal(curNode.right, callback);\n    };\n\n    this.cmp = cmp;\n  }\n  /**\n   * @param curNode The starting node of the search.\n   * @param key The key you want to search.\n   * @return TreeNode which key is greater than or equals to the given key.\n   * @protected\n   */\n\n\n  _lowerBound(curNode, key) {\n    let resNode;\n\n    while (curNode) {\n      const cmpResult = this.cmp(curNode.key, key);\n\n      if (cmpResult < 0) {\n        curNode = curNode.right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode.left;\n      } else return curNode;\n    }\n\n    return resNode === undefined ? this.header : resNode;\n  }\n  /**\n   * @param curNode The starting node of the search.\n   * @param key The key you want to search.\n   * @return TreeNode which key is greater than the given key.\n   * @protected\n   */\n\n\n  _upperBound(curNode, key) {\n    let resNode;\n\n    while (curNode) {\n      const cmpResult = this.cmp(curNode.key, key);\n\n      if (cmpResult <= 0) {\n        curNode = curNode.right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode.left;\n      }\n    }\n\n    return resNode === undefined ? this.header : resNode;\n  }\n  /**\n   * @param curNode The starting node of the search.\n   * @param key The key you want to search.\n   * @return TreeNode which key is less than or equals to the given key.\n   * @protected\n   */\n\n\n  _reverseLowerBound(curNode, key) {\n    let resNode;\n\n    while (curNode) {\n      const cmpResult = this.cmp(curNode.key, key);\n\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode.right;\n      } else if (cmpResult > 0) {\n        curNode = curNode.left;\n      } else return curNode;\n    }\n\n    return resNode === undefined ? this.header : resNode;\n  }\n  /**\n   * @param curNode The starting node of the search.\n   * @param key The key you want to search.\n   * @return TreeNode which key is less than the given key.\n   * @protected\n   */\n\n\n  _reverseUpperBound(curNode, key) {\n    let resNode;\n\n    while (curNode) {\n      const cmpResult = this.cmp(curNode.key, key);\n\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode.right;\n      } else if (cmpResult >= 0) {\n        curNode = curNode.left;\n      }\n    }\n\n    return resNode === undefined ? this.header : resNode;\n  }\n  /**\n   * @description Make self balance after erase a node.\n   * @param curNode The node want to remove.\n   * @protected\n   */\n\n\n  eraseNodeSelfBalance(curNode) {\n    while (true) {\n      const parentNode = curNode.parent;\n      if (parentNode === this.header) return;\n\n      if (curNode.color === TreeNode_1.default.RED) {\n        curNode.color = TreeNode_1.default.BLACK;\n        return;\n      }\n\n      if (curNode === parentNode.left) {\n        const brother = parentNode.right;\n\n        if (brother.color === TreeNode_1.default.RED) {\n          brother.color = TreeNode_1.default.BLACK;\n          parentNode.color = TreeNode_1.default.RED;\n\n          if (parentNode === this.root) {\n            this.root = parentNode.rotateLeft();\n          } else parentNode.rotateLeft();\n        } else if (brother.color === TreeNode_1.default.BLACK) {\n          if (brother.right && brother.right.color === TreeNode_1.default.RED) {\n            brother.color = parentNode.color;\n            parentNode.color = TreeNode_1.default.BLACK;\n            brother.right.color = TreeNode_1.default.BLACK;\n\n            if (parentNode === this.root) {\n              this.root = parentNode.rotateLeft();\n            } else parentNode.rotateLeft();\n\n            return;\n          } else if (brother.left && brother.left.color === TreeNode_1.default.RED) {\n            brother.color = TreeNode_1.default.RED;\n            brother.left.color = TreeNode_1.default.BLACK;\n            brother.rotateRight();\n          } else {\n            brother.color = TreeNode_1.default.RED;\n            curNode = parentNode;\n          }\n        }\n      } else {\n        const brother = parentNode.left;\n\n        if (brother.color === TreeNode_1.default.RED) {\n          brother.color = TreeNode_1.default.BLACK;\n          parentNode.color = TreeNode_1.default.RED;\n\n          if (parentNode === this.root) {\n            this.root = parentNode.rotateRight();\n          } else parentNode.rotateRight();\n        } else {\n          if (brother.left && brother.left.color === TreeNode_1.default.RED) {\n            brother.color = parentNode.color;\n            parentNode.color = TreeNode_1.default.BLACK;\n            brother.left.color = TreeNode_1.default.BLACK;\n\n            if (parentNode === this.root) {\n              this.root = parentNode.rotateRight();\n            } else parentNode.rotateRight();\n\n            return;\n          } else if (brother.right && brother.right.color === TreeNode_1.default.RED) {\n            brother.color = TreeNode_1.default.RED;\n            brother.right.color = TreeNode_1.default.BLACK;\n            brother.rotateLeft();\n          } else {\n            brother.color = TreeNode_1.default.RED;\n            curNode = parentNode;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @description Remove a node.\n   * @param curNode The node you want to remove.\n   * @protected\n   */\n\n\n  eraseNode(curNode) {\n    if (this.length === 1) {\n      this.clear();\n      return;\n    }\n\n    let swapNode = curNode;\n\n    while (swapNode.left || swapNode.right) {\n      if (swapNode.right) {\n        swapNode = swapNode.right;\n\n        while (swapNode.left) swapNode = swapNode.left;\n      } else if (swapNode.left) {\n        swapNode = swapNode.left;\n      }\n\n      [curNode.key, swapNode.key] = [swapNode.key, curNode.key];\n      [curNode.value, swapNode.value] = [swapNode.value, curNode.value];\n      curNode = swapNode;\n    }\n\n    if (this.header.left === swapNode) {\n      this.header.left = swapNode.parent;\n    } else if (this.header.right === swapNode) {\n      this.header.right = swapNode.parent;\n    }\n\n    this.eraseNodeSelfBalance(swapNode);\n    swapNode.remove();\n    this.length -= 1;\n    this.root.color = TreeNode_1.default.BLACK;\n  }\n  /**\n   * @description Make self balance after insert a node.\n   * @param curNode The node want to insert.\n   * @protected\n   */\n\n\n  insertNodeSelfBalance(curNode) {\n    while (true) {\n      const parentNode = curNode.parent;\n      if (parentNode.color === TreeNode_1.default.BLACK) return;\n      const grandParent = parentNode.parent;\n\n      if (parentNode === grandParent.left) {\n        const uncle = grandParent.right;\n\n        if (uncle && uncle.color === TreeNode_1.default.RED) {\n          uncle.color = parentNode.color = TreeNode_1.default.BLACK;\n          if (grandParent === this.root) return;\n          grandParent.color = TreeNode_1.default.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode.right) {\n          curNode.color = TreeNode_1.default.BLACK;\n          if (curNode.left) curNode.left.parent = parentNode;\n          if (curNode.right) curNode.right.parent = grandParent;\n          parentNode.right = curNode.left;\n          grandParent.left = curNode.right;\n          curNode.left = parentNode;\n          curNode.right = grandParent;\n\n          if (grandParent === this.root) {\n            this.root = curNode;\n            this.header.parent = curNode;\n          } else {\n            const GP = grandParent.parent;\n\n            if (GP.left === grandParent) {\n              GP.left = curNode;\n            } else GP.right = curNode;\n          }\n\n          curNode.parent = grandParent.parent;\n          parentNode.parent = curNode;\n          grandParent.parent = curNode;\n        } else {\n          parentNode.color = TreeNode_1.default.BLACK;\n\n          if (grandParent === this.root) {\n            this.root = grandParent.rotateRight();\n          } else grandParent.rotateRight();\n        }\n\n        grandParent.color = TreeNode_1.default.RED;\n      } else {\n        const uncle = grandParent.left;\n\n        if (uncle && uncle.color === TreeNode_1.default.RED) {\n          uncle.color = parentNode.color = TreeNode_1.default.BLACK;\n          if (grandParent === this.root) return;\n          grandParent.color = TreeNode_1.default.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode.left) {\n          curNode.color = TreeNode_1.default.BLACK;\n          if (curNode.left) curNode.left.parent = grandParent;\n          if (curNode.right) curNode.right.parent = parentNode;\n          grandParent.right = curNode.left;\n          parentNode.left = curNode.right;\n          curNode.left = grandParent;\n          curNode.right = parentNode;\n\n          if (grandParent === this.root) {\n            this.root = curNode;\n            this.header.parent = curNode;\n          } else {\n            const GP = grandParent.parent;\n\n            if (GP.left === grandParent) {\n              GP.left = curNode;\n            } else GP.right = curNode;\n          }\n\n          curNode.parent = grandParent.parent;\n          parentNode.parent = curNode;\n          grandParent.parent = curNode;\n        } else {\n          parentNode.color = TreeNode_1.default.BLACK;\n\n          if (grandParent === this.root) {\n            this.root = grandParent.rotateLeft();\n          } else grandParent.rotateLeft();\n        }\n\n        grandParent.color = TreeNode_1.default.RED;\n      }\n\n      return;\n    }\n  }\n  /**\n   * @description Find node which key is equals to the given key.\n   * @param curNode The starting node of the search.\n   * @param key The key you want to search.\n   * @protected\n   */\n\n\n  findElementNode(curNode, key) {\n    while (curNode) {\n      const cmpResult = this.cmp(curNode.key, key);\n\n      if (cmpResult < 0) {\n        curNode = curNode.right;\n      } else if (cmpResult > 0) {\n        curNode = curNode.left;\n      } else return curNode;\n    }\n\n    return curNode;\n  }\n  /**\n   * @description Insert a key-value pair or set value by the given key.\n   * @param key The key want to insert.\n   * @param value The value want to set.\n   * @param hint You can give an iterator hint to improve insertion efficiency.\n   * @protected\n   */\n\n\n  set(key, value, hint) {\n    if (this.root === undefined) {\n      this.length += 1;\n      this.root = new TreeNode_1.default(key, value);\n      this.root.color = TreeNode_1.default.BLACK;\n      this.root.parent = this.header;\n      this.header.parent = this.root;\n      this.header.left = this.root;\n      this.header.right = this.root;\n      return;\n    }\n\n    let curNode;\n    const minNode = this.header.left;\n    const compareToMin = this.cmp(minNode.key, key);\n\n    if (compareToMin === 0) {\n      minNode.value = value;\n      return;\n    } else if (compareToMin > 0) {\n      minNode.left = new TreeNode_1.default(key, value);\n      minNode.left.parent = minNode;\n      curNode = minNode.left;\n      this.header.left = curNode;\n    } else {\n      const maxNode = this.header.right;\n      const compareToMax = this.cmp(maxNode.key, key);\n\n      if (compareToMax === 0) {\n        maxNode.value = value;\n        return;\n      } else if (compareToMax < 0) {\n        maxNode.right = new TreeNode_1.default(key, value);\n        maxNode.right.parent = maxNode;\n        curNode = maxNode.right;\n        this.header.right = curNode;\n      } else {\n        if (hint !== undefined) {\n          // @ts-ignore\n          const iterNode = hint.node;\n\n          if (iterNode !== this.header) {\n            const iterCmpRes = this.cmp(iterNode.key, key);\n\n            if (iterCmpRes === 0) {\n              iterNode.value = value;\n              return;\n            } else if (iterCmpRes > 0) {\n              const preNode = iterNode.pre();\n              const preCmpRes = this.cmp(preNode.key, key);\n\n              if (preCmpRes === 0) {\n                preNode.value = value;\n                return;\n              } else if (preCmpRes < 0) {\n                curNode = new TreeNode_1.default(key, value);\n\n                if (preNode.right === undefined) {\n                  preNode.right = curNode;\n                  curNode.parent = preNode;\n                } else {\n                  iterNode.left = curNode;\n                  curNode.parent = iterNode;\n                }\n              }\n            }\n          }\n        }\n\n        if (curNode === undefined) {\n          curNode = this.root;\n\n          while (true) {\n            const cmpResult = this.cmp(curNode.key, key);\n\n            if (cmpResult > 0) {\n              if (curNode.left === undefined) {\n                curNode.left = new TreeNode_1.default(key, value);\n                curNode.left.parent = curNode;\n                curNode = curNode.left;\n                break;\n              }\n\n              curNode = curNode.left;\n            } else if (cmpResult < 0) {\n              if (curNode.right === undefined) {\n                curNode.right = new TreeNode_1.default(key, value);\n                curNode.right.parent = curNode;\n                curNode = curNode.right;\n                break;\n              }\n\n              curNode = curNode.right;\n            } else {\n              curNode.value = value;\n              return;\n            }\n          }\n        }\n      }\n    }\n\n    this.length += 1;\n    this.insertNodeSelfBalance(curNode);\n  }\n\n  clear() {\n    this.length = 0;\n    this.root = undefined;\n    this.header.parent = undefined;\n    this.header.left = this.header.right = undefined;\n  }\n  /**\n   * @description Update node's key by iterator.\n   * @param iter The iterator you want to change.\n   * @param key The key you want to update.\n   * @return Boolean about if the modification is successful.\n   */\n\n\n  updateKeyByIterator(iter, key) {\n    // @ts-ignore\n    const node = iter.node;\n\n    if (node === this.header) {\n      throw new TypeError('Invalid iterator!');\n    }\n\n    if (this.length === 1) {\n      node.key = key;\n      return true;\n    }\n\n    if (node === this.header.left) {\n      if (this.cmp(node.next().key, key) > 0) {\n        node.key = key;\n        return true;\n      }\n\n      return false;\n    }\n\n    if (node === this.header.right) {\n      if (this.cmp(node.pre().key, key) < 0) {\n        node.key = key;\n        return true;\n      }\n\n      return false;\n    }\n\n    const preKey = node.pre().key;\n    if (this.cmp(preKey, key) >= 0) return false;\n    const nextKey = node.next().key;\n    if (this.cmp(nextKey, key) <= 0) return false;\n    node.key = key;\n    return true;\n  }\n\n  eraseElementByPos(pos) {\n    (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n    let index = 0;\n    this.inOrderTraversal(this.root, curNode => {\n      if (pos === index) {\n        this.eraseNode(curNode);\n        return true;\n      }\n\n      index += 1;\n      return false;\n    });\n  }\n  /**\n   * @description Remove the element of the specified key.\n   * @param key The key you want to remove.\n   */\n\n\n  eraseElementByKey(key) {\n    if (!this.length) return;\n    const curNode = this.findElementNode(this.root, key);\n    if (curNode === undefined) return;\n    this.eraseNode(curNode);\n  }\n\n  eraseElementByIterator(iter) {\n    // @ts-ignore\n    const node = iter.node;\n\n    if (node === this.header) {\n      throw new RangeError('Invalid iterator');\n    }\n\n    if (node.right === undefined) {\n      iter = iter.next();\n    }\n\n    this.eraseNode(node);\n    return iter;\n  }\n  /**\n   * @description Get the height of the tree.\n   * @return Number about the height of the RB-tree.\n   */\n\n\n  getHeight() {\n    if (!this.length) return 0;\n\n    const traversal = curNode => {\n      if (!curNode) return 0;\n      return Math.max(traversal(curNode.left), traversal(curNode.right)) + 1;\n    };\n\n    return traversal(this.root);\n  }\n\n}\n\nexports.default = TreeContainer;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","TreeNode_1","require","index_1","checkParams_1","TreeContainer","Container","constructor","cmp","x","y","root","undefined","header","default","inOrderTraversal","curNode","callback","ifReturn","left","right","_lowerBound","key","resNode","cmpResult","_upperBound","_reverseLowerBound","_reverseUpperBound","eraseNodeSelfBalance","parentNode","parent","color","RED","BLACK","brother","rotateLeft","rotateRight","eraseNode","length","clear","swapNode","remove","insertNodeSelfBalance","grandParent","uncle","GP","findElementNode","set","hint","minNode","compareToMin","maxNode","compareToMax","iterNode","node","iterCmpRes","preNode","pre","preCmpRes","updateKeyByIterator","iter","TypeError","next","preKey","nextKey","eraseElementByPos","pos","checkWithinAccessParams","index","eraseElementByKey","eraseElementByIterator","RangeError","getHeight","traversal","Math","max"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/js-sdsl/dist/cjs/container/TreeContainer/Base/index.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TreeNode_1 = __importDefault(require(\"./TreeNode\"));\nconst index_1 = require(\"../../ContainerBase/index\");\nconst checkParams_1 = require(\"../../../utils/checkParams\");\nclass TreeContainer extends index_1.Container {\n    constructor(cmp = (x, y) => {\n        if (x < y)\n            return -1;\n        if (x > y)\n            return 1;\n        return 0;\n    }) {\n        super();\n        this.root = undefined;\n        this.header = new TreeNode_1.default();\n        /**\n         * @description InOrder traversal the tree.\n         * @protected\n         */\n        this.inOrderTraversal = (curNode, callback) => {\n            if (curNode === undefined)\n                return false;\n            const ifReturn = this.inOrderTraversal(curNode.left, callback);\n            if (ifReturn)\n                return true;\n            if (callback(curNode))\n                return true;\n            return this.inOrderTraversal(curNode.right, callback);\n        };\n        this.cmp = cmp;\n    }\n    /**\n     * @param curNode The starting node of the search.\n     * @param key The key you want to search.\n     * @return TreeNode which key is greater than or equals to the given key.\n     * @protected\n     */\n    _lowerBound(curNode, key) {\n        let resNode;\n        while (curNode) {\n            const cmpResult = this.cmp(curNode.key, key);\n            if (cmpResult < 0) {\n                curNode = curNode.right;\n            }\n            else if (cmpResult > 0) {\n                resNode = curNode;\n                curNode = curNode.left;\n            }\n            else\n                return curNode;\n        }\n        return resNode === undefined ? this.header : resNode;\n    }\n    /**\n     * @param curNode The starting node of the search.\n     * @param key The key you want to search.\n     * @return TreeNode which key is greater than the given key.\n     * @protected\n     */\n    _upperBound(curNode, key) {\n        let resNode;\n        while (curNode) {\n            const cmpResult = this.cmp(curNode.key, key);\n            if (cmpResult <= 0) {\n                curNode = curNode.right;\n            }\n            else if (cmpResult > 0) {\n                resNode = curNode;\n                curNode = curNode.left;\n            }\n        }\n        return resNode === undefined ? this.header : resNode;\n    }\n    /**\n     * @param curNode The starting node of the search.\n     * @param key The key you want to search.\n     * @return TreeNode which key is less than or equals to the given key.\n     * @protected\n     */\n    _reverseLowerBound(curNode, key) {\n        let resNode;\n        while (curNode) {\n            const cmpResult = this.cmp(curNode.key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode.right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode.left;\n            }\n            else\n                return curNode;\n        }\n        return resNode === undefined ? this.header : resNode;\n    }\n    /**\n     * @param curNode The starting node of the search.\n     * @param key The key you want to search.\n     * @return TreeNode which key is less than the given key.\n     * @protected\n     */\n    _reverseUpperBound(curNode, key) {\n        let resNode;\n        while (curNode) {\n            const cmpResult = this.cmp(curNode.key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode.right;\n            }\n            else if (cmpResult >= 0) {\n                curNode = curNode.left;\n            }\n        }\n        return resNode === undefined ? this.header : resNode;\n    }\n    /**\n     * @description Make self balance after erase a node.\n     * @param curNode The node want to remove.\n     * @protected\n     */\n    eraseNodeSelfBalance(curNode) {\n        while (true) {\n            const parentNode = curNode.parent;\n            if (parentNode === this.header)\n                return;\n            if (curNode.color === TreeNode_1.default.RED) {\n                curNode.color = TreeNode_1.default.BLACK;\n                return;\n            }\n            if (curNode === parentNode.left) {\n                const brother = parentNode.right;\n                if (brother.color === TreeNode_1.default.RED) {\n                    brother.color = TreeNode_1.default.BLACK;\n                    parentNode.color = TreeNode_1.default.RED;\n                    if (parentNode === this.root) {\n                        this.root = parentNode.rotateLeft();\n                    }\n                    else\n                        parentNode.rotateLeft();\n                }\n                else if (brother.color === TreeNode_1.default.BLACK) {\n                    if (brother.right && brother.right.color === TreeNode_1.default.RED) {\n                        brother.color = parentNode.color;\n                        parentNode.color = TreeNode_1.default.BLACK;\n                        brother.right.color = TreeNode_1.default.BLACK;\n                        if (parentNode === this.root) {\n                            this.root = parentNode.rotateLeft();\n                        }\n                        else\n                            parentNode.rotateLeft();\n                        return;\n                    }\n                    else if (brother.left && brother.left.color === TreeNode_1.default.RED) {\n                        brother.color = TreeNode_1.default.RED;\n                        brother.left.color = TreeNode_1.default.BLACK;\n                        brother.rotateRight();\n                    }\n                    else {\n                        brother.color = TreeNode_1.default.RED;\n                        curNode = parentNode;\n                    }\n                }\n            }\n            else {\n                const brother = parentNode.left;\n                if (brother.color === TreeNode_1.default.RED) {\n                    brother.color = TreeNode_1.default.BLACK;\n                    parentNode.color = TreeNode_1.default.RED;\n                    if (parentNode === this.root) {\n                        this.root = parentNode.rotateRight();\n                    }\n                    else\n                        parentNode.rotateRight();\n                }\n                else {\n                    if (brother.left && brother.left.color === TreeNode_1.default.RED) {\n                        brother.color = parentNode.color;\n                        parentNode.color = TreeNode_1.default.BLACK;\n                        brother.left.color = TreeNode_1.default.BLACK;\n                        if (parentNode === this.root) {\n                            this.root = parentNode.rotateRight();\n                        }\n                        else\n                            parentNode.rotateRight();\n                        return;\n                    }\n                    else if (brother.right && brother.right.color === TreeNode_1.default.RED) {\n                        brother.color = TreeNode_1.default.RED;\n                        brother.right.color = TreeNode_1.default.BLACK;\n                        brother.rotateLeft();\n                    }\n                    else {\n                        brother.color = TreeNode_1.default.RED;\n                        curNode = parentNode;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @description Remove a node.\n     * @param curNode The node you want to remove.\n     * @protected\n     */\n    eraseNode(curNode) {\n        if (this.length === 1) {\n            this.clear();\n            return;\n        }\n        let swapNode = curNode;\n        while (swapNode.left || swapNode.right) {\n            if (swapNode.right) {\n                swapNode = swapNode.right;\n                while (swapNode.left)\n                    swapNode = swapNode.left;\n            }\n            else if (swapNode.left) {\n                swapNode = swapNode.left;\n            }\n            [curNode.key, swapNode.key] = [swapNode.key, curNode.key];\n            [curNode.value, swapNode.value] = [swapNode.value, curNode.value];\n            curNode = swapNode;\n        }\n        if (this.header.left === swapNode) {\n            this.header.left = swapNode.parent;\n        }\n        else if (this.header.right === swapNode) {\n            this.header.right = swapNode.parent;\n        }\n        this.eraseNodeSelfBalance(swapNode);\n        swapNode.remove();\n        this.length -= 1;\n        this.root.color = TreeNode_1.default.BLACK;\n    }\n    /**\n     * @description Make self balance after insert a node.\n     * @param curNode The node want to insert.\n     * @protected\n     */\n    insertNodeSelfBalance(curNode) {\n        while (true) {\n            const parentNode = curNode.parent;\n            if (parentNode.color === TreeNode_1.default.BLACK)\n                return;\n            const grandParent = parentNode.parent;\n            if (parentNode === grandParent.left) {\n                const uncle = grandParent.right;\n                if (uncle && uncle.color === TreeNode_1.default.RED) {\n                    uncle.color = parentNode.color = TreeNode_1.default.BLACK;\n                    if (grandParent === this.root)\n                        return;\n                    grandParent.color = TreeNode_1.default.RED;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode.right) {\n                    curNode.color = TreeNode_1.default.BLACK;\n                    if (curNode.left)\n                        curNode.left.parent = parentNode;\n                    if (curNode.right)\n                        curNode.right.parent = grandParent;\n                    parentNode.right = curNode.left;\n                    grandParent.left = curNode.right;\n                    curNode.left = parentNode;\n                    curNode.right = grandParent;\n                    if (grandParent === this.root) {\n                        this.root = curNode;\n                        this.header.parent = curNode;\n                    }\n                    else {\n                        const GP = grandParent.parent;\n                        if (GP.left === grandParent) {\n                            GP.left = curNode;\n                        }\n                        else\n                            GP.right = curNode;\n                    }\n                    curNode.parent = grandParent.parent;\n                    parentNode.parent = curNode;\n                    grandParent.parent = curNode;\n                }\n                else {\n                    parentNode.color = TreeNode_1.default.BLACK;\n                    if (grandParent === this.root) {\n                        this.root = grandParent.rotateRight();\n                    }\n                    else\n                        grandParent.rotateRight();\n                }\n                grandParent.color = TreeNode_1.default.RED;\n            }\n            else {\n                const uncle = grandParent.left;\n                if (uncle && uncle.color === TreeNode_1.default.RED) {\n                    uncle.color = parentNode.color = TreeNode_1.default.BLACK;\n                    if (grandParent === this.root)\n                        return;\n                    grandParent.color = TreeNode_1.default.RED;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode.left) {\n                    curNode.color = TreeNode_1.default.BLACK;\n                    if (curNode.left)\n                        curNode.left.parent = grandParent;\n                    if (curNode.right)\n                        curNode.right.parent = parentNode;\n                    grandParent.right = curNode.left;\n                    parentNode.left = curNode.right;\n                    curNode.left = grandParent;\n                    curNode.right = parentNode;\n                    if (grandParent === this.root) {\n                        this.root = curNode;\n                        this.header.parent = curNode;\n                    }\n                    else {\n                        const GP = grandParent.parent;\n                        if (GP.left === grandParent) {\n                            GP.left = curNode;\n                        }\n                        else\n                            GP.right = curNode;\n                    }\n                    curNode.parent = grandParent.parent;\n                    parentNode.parent = curNode;\n                    grandParent.parent = curNode;\n                }\n                else {\n                    parentNode.color = TreeNode_1.default.BLACK;\n                    if (grandParent === this.root) {\n                        this.root = grandParent.rotateLeft();\n                    }\n                    else\n                        grandParent.rotateLeft();\n                }\n                grandParent.color = TreeNode_1.default.RED;\n            }\n            return;\n        }\n    }\n    /**\n     * @description Find node which key is equals to the given key.\n     * @param curNode The starting node of the search.\n     * @param key The key you want to search.\n     * @protected\n     */\n    findElementNode(curNode, key) {\n        while (curNode) {\n            const cmpResult = this.cmp(curNode.key, key);\n            if (cmpResult < 0) {\n                curNode = curNode.right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode.left;\n            }\n            else\n                return curNode;\n        }\n        return curNode;\n    }\n    /**\n     * @description Insert a key-value pair or set value by the given key.\n     * @param key The key want to insert.\n     * @param value The value want to set.\n     * @param hint You can give an iterator hint to improve insertion efficiency.\n     * @protected\n     */\n    set(key, value, hint) {\n        if (this.root === undefined) {\n            this.length += 1;\n            this.root = new TreeNode_1.default(key, value);\n            this.root.color = TreeNode_1.default.BLACK;\n            this.root.parent = this.header;\n            this.header.parent = this.root;\n            this.header.left = this.root;\n            this.header.right = this.root;\n            return;\n        }\n        let curNode;\n        const minNode = this.header.left;\n        const compareToMin = this.cmp(minNode.key, key);\n        if (compareToMin === 0) {\n            minNode.value = value;\n            return;\n        }\n        else if (compareToMin > 0) {\n            minNode.left = new TreeNode_1.default(key, value);\n            minNode.left.parent = minNode;\n            curNode = minNode.left;\n            this.header.left = curNode;\n        }\n        else {\n            const maxNode = this.header.right;\n            const compareToMax = this.cmp(maxNode.key, key);\n            if (compareToMax === 0) {\n                maxNode.value = value;\n                return;\n            }\n            else if (compareToMax < 0) {\n                maxNode.right = new TreeNode_1.default(key, value);\n                maxNode.right.parent = maxNode;\n                curNode = maxNode.right;\n                this.header.right = curNode;\n            }\n            else {\n                if (hint !== undefined) {\n                    // @ts-ignore\n                    const iterNode = hint.node;\n                    if (iterNode !== this.header) {\n                        const iterCmpRes = this.cmp(iterNode.key, key);\n                        if (iterCmpRes === 0) {\n                            iterNode.value = value;\n                            return;\n                        }\n                        else if (iterCmpRes > 0) {\n                            const preNode = iterNode.pre();\n                            const preCmpRes = this.cmp(preNode.key, key);\n                            if (preCmpRes === 0) {\n                                preNode.value = value;\n                                return;\n                            }\n                            else if (preCmpRes < 0) {\n                                curNode = new TreeNode_1.default(key, value);\n                                if (preNode.right === undefined) {\n                                    preNode.right = curNode;\n                                    curNode.parent = preNode;\n                                }\n                                else {\n                                    iterNode.left = curNode;\n                                    curNode.parent = iterNode;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (curNode === undefined) {\n                    curNode = this.root;\n                    while (true) {\n                        const cmpResult = this.cmp(curNode.key, key);\n                        if (cmpResult > 0) {\n                            if (curNode.left === undefined) {\n                                curNode.left = new TreeNode_1.default(key, value);\n                                curNode.left.parent = curNode;\n                                curNode = curNode.left;\n                                break;\n                            }\n                            curNode = curNode.left;\n                        }\n                        else if (cmpResult < 0) {\n                            if (curNode.right === undefined) {\n                                curNode.right = new TreeNode_1.default(key, value);\n                                curNode.right.parent = curNode;\n                                curNode = curNode.right;\n                                break;\n                            }\n                            curNode = curNode.right;\n                        }\n                        else {\n                            curNode.value = value;\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        this.length += 1;\n        this.insertNodeSelfBalance(curNode);\n    }\n    clear() {\n        this.length = 0;\n        this.root = undefined;\n        this.header.parent = undefined;\n        this.header.left = this.header.right = undefined;\n    }\n    /**\n     * @description Update node's key by iterator.\n     * @param iter The iterator you want to change.\n     * @param key The key you want to update.\n     * @return Boolean about if the modification is successful.\n     */\n    updateKeyByIterator(iter, key) {\n        // @ts-ignore\n        const node = iter.node;\n        if (node === this.header) {\n            throw new TypeError('Invalid iterator!');\n        }\n        if (this.length === 1) {\n            node.key = key;\n            return true;\n        }\n        if (node === this.header.left) {\n            if (this.cmp(node.next().key, key) > 0) {\n                node.key = key;\n                return true;\n            }\n            return false;\n        }\n        if (node === this.header.right) {\n            if (this.cmp(node.pre().key, key) < 0) {\n                node.key = key;\n                return true;\n            }\n            return false;\n        }\n        const preKey = node.pre().key;\n        if (this.cmp(preKey, key) >= 0)\n            return false;\n        const nextKey = node.next().key;\n        if (this.cmp(nextKey, key) <= 0)\n            return false;\n        node.key = key;\n        return true;\n    }\n    eraseElementByPos(pos) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n        let index = 0;\n        this.inOrderTraversal(this.root, curNode => {\n            if (pos === index) {\n                this.eraseNode(curNode);\n                return true;\n            }\n            index += 1;\n            return false;\n        });\n    }\n    /**\n     * @description Remove the element of the specified key.\n     * @param key The key you want to remove.\n     */\n    eraseElementByKey(key) {\n        if (!this.length)\n            return;\n        const curNode = this.findElementNode(this.root, key);\n        if (curNode === undefined)\n            return;\n        this.eraseNode(curNode);\n    }\n    eraseElementByIterator(iter) {\n        // @ts-ignore\n        const node = iter.node;\n        if (node === this.header) {\n            throw new RangeError('Invalid iterator');\n        }\n        if (node.right === undefined) {\n            iter = iter.next();\n        }\n        this.eraseNode(node);\n        return iter;\n    }\n    /**\n     * @description Get the height of the tree.\n     * @return Number about the height of the RB-tree.\n     */\n    getHeight() {\n        if (!this.length)\n            return 0;\n        const traversal = (curNode) => {\n            if (!curNode)\n                return 0;\n            return Math.max(traversal(curNode.left), traversal(curNode.right)) + 1;\n        };\n        return traversal(this.root);\n    }\n}\nexports.default = TreeContainer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}