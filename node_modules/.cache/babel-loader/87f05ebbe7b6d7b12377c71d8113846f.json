{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transformClass;\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\n\nvar _core = require(\"@babel/core\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nvar _inlineCreateSuperHelpers = require(\"./inline-createSuper-helpers\");\n\nfunction buildConstructor(classRef, constructorBody, node) {\n  const func = _core.types.functionDeclaration(_core.types.cloneNode(classRef), [], constructorBody);\n\n  _core.types.inherits(func, node);\n\n  return func;\n}\n\nfunction transformClass(path, file, builtinClasses, isLoose, assumptions, supportUnicodeId) {\n  const classState = {\n    parent: undefined,\n    scope: undefined,\n    node: undefined,\n    path: undefined,\n    file: undefined,\n    classId: undefined,\n    classRef: undefined,\n    superFnId: undefined,\n    superName: null,\n    superReturns: [],\n    isDerived: false,\n    extendsNative: false,\n    construct: undefined,\n    constructorBody: undefined,\n    userConstructor: undefined,\n    userConstructorPath: undefined,\n    hasConstructor: false,\n    body: [],\n    superThises: [],\n    pushedConstructor: false,\n    pushedInherits: false,\n    pushedCreateClass: false,\n    protoAlias: null,\n    isLoose: false,\n    dynamicKeys: new Map(),\n    methods: {\n      instance: {\n        hasComputed: false,\n        list: [],\n        map: new Map()\n      },\n      static: {\n        hasComputed: false,\n        list: [],\n        map: new Map()\n      }\n    }\n  };\n\n  const setState = newState => {\n    Object.assign(classState, newState);\n  };\n\n  const findThisesVisitor = _core.traverse.visitors.merge([_helperEnvironmentVisitor.default, {\n    ThisExpression(path) {\n      classState.superThises.push(path);\n    }\n\n  }]);\n\n  function createClassHelper(args) {\n    return _core.types.callExpression(classState.file.addHelper(\"createClass\"), args);\n  }\n\n  function maybeCreateConstructor() {\n    let hasConstructor = false;\n    const paths = classState.path.get(\"body.body\");\n\n    for (const path of paths) {\n      hasConstructor = path.equals(\"kind\", \"constructor\");\n      if (hasConstructor) break;\n    }\n\n    if (hasConstructor) return;\n    let params, body;\n\n    if (classState.isDerived) {\n      const constructor = _core.template.expression.ast`\n        (function () {\n          super(...arguments);\n        })\n      `;\n      params = constructor.params;\n      body = constructor.body;\n    } else {\n      params = [];\n      body = _core.types.blockStatement([]);\n    }\n\n    classState.path.get(\"body\").unshiftContainer(\"body\", _core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), params, body));\n  }\n\n  function buildBody() {\n    maybeCreateConstructor();\n    pushBody();\n    verifyConstructor();\n\n    if (classState.userConstructor) {\n      const {\n        constructorBody,\n        userConstructor,\n        construct\n      } = classState;\n      constructorBody.body.push(...userConstructor.body.body);\n\n      _core.types.inherits(construct, userConstructor);\n\n      _core.types.inherits(constructorBody, userConstructor.body);\n    }\n\n    pushDescriptors();\n  }\n\n  function pushBody() {\n    const classBodyPaths = classState.path.get(\"body.body\");\n\n    for (const path of classBodyPaths) {\n      const node = path.node;\n\n      if (path.isClassProperty()) {\n        throw path.buildCodeFrameError(\"Missing class properties transform.\");\n      }\n\n      if (node.decorators) {\n        throw path.buildCodeFrameError(\"Method has decorators, put the decorator plugin before the classes one.\");\n      }\n\n      if (_core.types.isClassMethod(node)) {\n        const isConstructor = node.kind === \"constructor\";\n        const replaceSupers = new _helperReplaceSupers.default({\n          methodPath: path,\n          objectRef: classState.classRef,\n          superRef: classState.superName,\n          constantSuper: assumptions.constantSuper,\n          file: classState.file,\n          refToPreserve: classState.classRef\n        });\n        replaceSupers.replace();\n        const superReturns = [];\n        path.traverse(_core.traverse.visitors.merge([_helperEnvironmentVisitor.default, {\n          ReturnStatement(path) {\n            if (!path.getFunctionParent().isArrowFunctionExpression()) {\n              superReturns.push(path);\n            }\n          }\n\n        }]));\n\n        if (isConstructor) {\n          pushConstructor(superReturns, node, path);\n        } else {\n          pushMethod(node, path);\n        }\n      }\n    }\n  }\n\n  function pushDescriptors() {\n    pushInheritsToBody();\n    const {\n      body\n    } = classState;\n    const props = {\n      instance: null,\n      static: null\n    };\n\n    for (const placement of [\"static\", \"instance\"]) {\n      if (classState.methods[placement].list.length) {\n        props[placement] = classState.methods[placement].list.map(desc => {\n          const obj = _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier(\"key\"), desc.key)]);\n\n          for (const kind of [\"get\", \"set\", \"value\"]) {\n            if (desc[kind] != null) {\n              obj.properties.push(_core.types.objectProperty(_core.types.identifier(kind), desc[kind]));\n            }\n          }\n\n          return obj;\n        });\n      }\n    }\n\n    if (props.instance || props.static) {\n      let args = [_core.types.cloneNode(classState.classRef), props.instance ? _core.types.arrayExpression(props.instance) : _core.types.nullLiteral(), props.static ? _core.types.arrayExpression(props.static) : _core.types.nullLiteral()];\n      let lastNonNullIndex = 0;\n\n      for (let i = 0; i < args.length; i++) {\n        if (!_core.types.isNullLiteral(args[i])) lastNonNullIndex = i;\n      }\n\n      args = args.slice(0, lastNonNullIndex + 1);\n      body.push(_core.types.expressionStatement(createClassHelper(args)));\n      classState.pushedCreateClass = true;\n    }\n  }\n\n  function wrapSuperCall(bareSuper, superRef, thisRef, body) {\n    const bareSuperNode = bareSuper.node;\n    let call;\n\n    if (assumptions.superIsCallableConstructor) {\n      bareSuperNode.arguments.unshift(_core.types.thisExpression());\n\n      if (bareSuperNode.arguments.length === 2 && _core.types.isSpreadElement(bareSuperNode.arguments[1]) && _core.types.isIdentifier(bareSuperNode.arguments[1].argument, {\n        name: \"arguments\"\n      })) {\n        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;\n        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier(\"apply\"));\n      } else {\n        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier(\"call\"));\n      }\n\n      call = _core.types.logicalExpression(\"||\", bareSuperNode, _core.types.thisExpression());\n    } else {\n      call = (0, _helperOptimiseCallExpression.default)(_core.types.cloneNode(classState.superFnId), _core.types.thisExpression(), bareSuperNode.arguments, false);\n    }\n\n    if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {\n      if (classState.superThises.length) {\n        call = _core.types.assignmentExpression(\"=\", thisRef(), call);\n      }\n\n      bareSuper.parentPath.replaceWith(_core.types.returnStatement(call));\n    } else {\n      bareSuper.replaceWith(_core.types.assignmentExpression(\"=\", thisRef(), call));\n    }\n  }\n\n  function verifyConstructor() {\n    if (!classState.isDerived) return;\n    const path = classState.userConstructorPath;\n    const body = path.get(\"body\");\n    path.traverse(findThisesVisitor);\n\n    let thisRef = function () {\n      const ref = path.scope.generateDeclaredUidIdentifier(\"this\");\n\n      thisRef = () => _core.types.cloneNode(ref);\n\n      return ref;\n    };\n\n    for (const thisPath of classState.superThises) {\n      const {\n        node,\n        parentPath\n      } = thisPath;\n\n      if (parentPath.isMemberExpression({\n        object: node\n      })) {\n        thisPath.replaceWith(thisRef());\n        continue;\n      }\n\n      thisPath.replaceWith(_core.types.callExpression(classState.file.addHelper(\"assertThisInitialized\"), [thisRef()]));\n    }\n\n    const bareSupers = [];\n    path.traverse(_core.traverse.visitors.merge([_helperEnvironmentVisitor.default, {\n      Super(path) {\n        const {\n          node,\n          parentPath\n        } = path;\n\n        if (parentPath.isCallExpression({\n          callee: node\n        })) {\n          bareSupers.unshift(parentPath);\n        }\n      }\n\n    }]));\n    let guaranteedSuperBeforeFinish = !!bareSupers.length;\n\n    for (const bareSuper of bareSupers) {\n      wrapSuperCall(bareSuper, classState.superName, thisRef, body);\n\n      if (guaranteedSuperBeforeFinish) {\n        bareSuper.find(function (parentPath) {\n          if (parentPath === path) {\n            return true;\n          }\n\n          if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {\n            guaranteedSuperBeforeFinish = false;\n            return true;\n          }\n        });\n      }\n    }\n\n    let wrapReturn;\n\n    if (classState.isLoose) {\n      wrapReturn = returnArg => {\n        const thisExpr = _core.types.callExpression(classState.file.addHelper(\"assertThisInitialized\"), [thisRef()]);\n\n        return returnArg ? _core.types.logicalExpression(\"||\", returnArg, thisExpr) : thisExpr;\n      };\n    } else {\n      wrapReturn = returnArg => {\n        const returnParams = [thisRef()];\n\n        if (returnArg != null) {\n          returnParams.push(returnArg);\n        }\n\n        return _core.types.callExpression(classState.file.addHelper(\"possibleConstructorReturn\"), returnParams);\n      };\n    }\n\n    const bodyPaths = body.get(\"body\");\n\n    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {\n      body.pushContainer(\"body\", _core.types.returnStatement(guaranteedSuperBeforeFinish ? thisRef() : wrapReturn()));\n    }\n\n    for (const returnPath of classState.superReturns) {\n      returnPath.get(\"argument\").replaceWith(wrapReturn(returnPath.node.argument));\n    }\n  }\n\n  function pushMethod(node, path) {\n    const scope = path ? path.scope : classState.scope;\n\n    if (node.kind === \"method\") {\n      if (processMethod(node, scope)) return;\n    }\n\n    const placement = node.static ? \"static\" : \"instance\";\n    const methods = classState.methods[placement];\n    const descKey = node.kind === \"method\" ? \"value\" : node.kind;\n    const key = _core.types.isNumericLiteral(node.key) || _core.types.isBigIntLiteral(node.key) ? _core.types.stringLiteral(String(node.key.value)) : _core.types.toComputedKey(node);\n\n    let fn = _core.types.toExpression(node);\n\n    if (_core.types.isStringLiteral(key)) {\n      if (node.kind === \"method\") {\n        var _nameFunction;\n\n        fn = (_nameFunction = (0, _helperFunctionName.default)({\n          id: key,\n          node: node,\n          scope\n        }, undefined, supportUnicodeId)) != null ? _nameFunction : fn;\n      }\n    } else {\n      methods.hasComputed = true;\n    }\n\n    let descriptor;\n\n    if (!methods.hasComputed && methods.map.has(key.value)) {\n      descriptor = methods.map.get(key.value);\n      descriptor[descKey] = fn;\n\n      if (descKey === \"value\") {\n        descriptor.get = null;\n        descriptor.set = null;\n      } else {\n        descriptor.value = null;\n      }\n    } else {\n      descriptor = {\n        key: key,\n        [descKey]: fn\n      };\n      methods.list.push(descriptor);\n\n      if (!methods.hasComputed) {\n        methods.map.set(key.value, descriptor);\n      }\n    }\n  }\n\n  function processMethod(node, scope) {\n    if (assumptions.setClassMethods && !node.decorators) {\n      let {\n        classRef\n      } = classState;\n\n      if (!node.static) {\n        insertProtoAliasOnce();\n        classRef = classState.protoAlias;\n      }\n\n      const methodName = _core.types.memberExpression(_core.types.cloneNode(classRef), node.key, node.computed || _core.types.isLiteral(node.key));\n\n      let func = _core.types.functionExpression(null, node.params, node.body, node.generator, node.async);\n\n      _core.types.inherits(func, node);\n\n      const key = _core.types.toComputedKey(node, node.key);\n\n      if (_core.types.isStringLiteral(key)) {\n        var _nameFunction2;\n\n        func = (_nameFunction2 = (0, _helperFunctionName.default)({\n          node: func,\n          id: key,\n          scope\n        }, undefined, supportUnicodeId)) != null ? _nameFunction2 : func;\n      }\n\n      const expr = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", methodName, func));\n\n      _core.types.inheritsComments(expr, node);\n\n      classState.body.push(expr);\n      return true;\n    }\n\n    return false;\n  }\n\n  function insertProtoAliasOnce() {\n    if (classState.protoAlias === null) {\n      setState({\n        protoAlias: classState.scope.generateUidIdentifier(\"proto\")\n      });\n\n      const classProto = _core.types.memberExpression(classState.classRef, _core.types.identifier(\"prototype\"));\n\n      const protoDeclaration = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(classState.protoAlias, classProto)]);\n\n      classState.body.push(protoDeclaration);\n    }\n  }\n\n  function pushConstructor(superReturns, method, path) {\n    setState({\n      userConstructorPath: path,\n      userConstructor: method,\n      hasConstructor: true,\n      superReturns\n    });\n    const {\n      construct\n    } = classState;\n\n    _core.types.inheritsComments(construct, method);\n\n    construct.params = method.params;\n\n    _core.types.inherits(construct.body, method.body);\n\n    construct.body.directives = method.body.directives;\n    pushConstructorToBody();\n  }\n\n  function pushConstructorToBody() {\n    if (classState.pushedConstructor) return;\n    classState.pushedConstructor = true;\n\n    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {\n      pushDescriptors();\n    }\n\n    classState.body.push(classState.construct);\n    pushInheritsToBody();\n  }\n\n  function pushInheritsToBody() {\n    if (!classState.isDerived || classState.pushedInherits) return;\n    const superFnId = path.scope.generateUidIdentifier(\"super\");\n    setState({\n      pushedInherits: true,\n      superFnId\n    });\n\n    if (!assumptions.superIsCallableConstructor) {\n      classState.body.unshift(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(superFnId, _core.types.callExpression((0, _inlineCreateSuperHelpers.default)(classState.file), [_core.types.cloneNode(classState.classRef)]))]));\n    }\n\n    classState.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(classState.isLoose ? \"inheritsLoose\" : \"inherits\"), [_core.types.cloneNode(classState.classRef), _core.types.cloneNode(classState.superName)])));\n  }\n\n  function extractDynamicKeys() {\n    const {\n      dynamicKeys,\n      node,\n      scope\n    } = classState;\n\n    for (const elem of node.body.body) {\n      if (!_core.types.isClassMethod(elem) || !elem.computed) continue;\n      if (scope.isPure(elem.key, true)) continue;\n      const id = scope.generateUidIdentifierBasedOnNode(elem.key);\n      dynamicKeys.set(id.name, elem.key);\n      elem.key = id;\n    }\n  }\n\n  function setupClosureParamsArgs() {\n    const {\n      superName,\n      dynamicKeys\n    } = classState;\n    const closureParams = [];\n    const closureArgs = [];\n\n    if (classState.isDerived) {\n      let arg = _core.types.cloneNode(superName);\n\n      if (classState.extendsNative) {\n        arg = _core.types.callExpression(classState.file.addHelper(\"wrapNativeSuper\"), [arg]);\n        (0, _helperAnnotateAsPure.default)(arg);\n      }\n\n      const param = classState.scope.generateUidIdentifierBasedOnNode(superName);\n      closureParams.push(param);\n      closureArgs.push(arg);\n      setState({\n        superName: _core.types.cloneNode(param)\n      });\n    }\n\n    for (const [name, value] of dynamicKeys) {\n      closureParams.push(_core.types.identifier(name));\n      closureArgs.push(value);\n    }\n\n    return {\n      closureParams,\n      closureArgs\n    };\n  }\n\n  function classTransformer(path, file, builtinClasses, isLoose) {\n    setState({\n      parent: path.parent,\n      scope: path.scope,\n      node: path.node,\n      path,\n      file,\n      isLoose\n    });\n    setState({\n      classId: classState.node.id,\n      classRef: classState.node.id ? _core.types.identifier(classState.node.id.name) : classState.scope.generateUidIdentifier(\"class\"),\n      superName: classState.node.superClass,\n      isDerived: !!classState.node.superClass,\n      constructorBody: _core.types.blockStatement([])\n    });\n    setState({\n      extendsNative: _core.types.isIdentifier(classState.superName) && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)\n    });\n    const {\n      classRef,\n      node,\n      constructorBody\n    } = classState;\n    setState({\n      construct: buildConstructor(classRef, constructorBody, node)\n    });\n    extractDynamicKeys();\n    const {\n      body\n    } = classState;\n    const {\n      closureParams,\n      closureArgs\n    } = setupClosureParamsArgs();\n    buildBody();\n\n    if (!assumptions.noClassCalls) {\n      constructorBody.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(\"classCallCheck\"), [_core.types.thisExpression(), _core.types.cloneNode(classState.classRef)])));\n    }\n\n    const isStrict = path.isInStrictMode();\n    let constructorOnly = classState.classId && body.length === 1;\n\n    if (constructorOnly && !isStrict) {\n      for (const param of classState.construct.params) {\n        if (!_core.types.isIdentifier(param)) {\n          constructorOnly = false;\n          break;\n        }\n      }\n    }\n\n    const directives = constructorOnly ? body[0].body.directives : [];\n\n    if (!isStrict) {\n      directives.push(_core.types.directive(_core.types.directiveLiteral(\"use strict\")));\n    }\n\n    if (constructorOnly) {\n      const expr = _core.types.toExpression(body[0]);\n\n      return classState.isLoose ? expr : createClassHelper([expr]);\n    }\n\n    let returnArg = _core.types.cloneNode(classState.classRef);\n\n    if (!classState.pushedCreateClass && !classState.isLoose) {\n      returnArg = createClassHelper([returnArg]);\n    }\n\n    body.push(_core.types.returnStatement(returnArg));\n\n    const container = _core.types.arrowFunctionExpression(closureParams, _core.types.blockStatement(body, directives));\n\n    return _core.types.callExpression(container, closureArgs);\n  }\n\n  return classTransformer(path, file, builtinClasses, isLoose);\n}","map":{"version":3,"mappings":"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","names":["buildConstructor","classRef","constructorBody","node","func","t","functionDeclaration","cloneNode","inherits","transformClass","path","file","builtinClasses","isLoose","assumptions","supportUnicodeId","classState","parent","undefined","scope","classId","superFnId","superName","superReturns","isDerived","extendsNative","construct","userConstructor","userConstructorPath","hasConstructor","body","superThises","pushedConstructor","pushedInherits","pushedCreateClass","protoAlias","dynamicKeys","Map","methods","instance","hasComputed","list","map","static","setState","newState","Object","assign","findThisesVisitor","traverse","visitors","merge","environmentVisitor","ThisExpression","push","createClassHelper","args","callExpression","addHelper","maybeCreateConstructor","paths","get","equals","params","constructor","template","expression","ast","blockStatement","unshiftContainer","classMethod","identifier","buildBody","pushBody","verifyConstructor","pushDescriptors","classBodyPaths","isClassProperty","buildCodeFrameError","decorators","isClassMethod","isConstructor","kind","replaceSupers","ReplaceSupers","methodPath","objectRef","superRef","constantSuper","refToPreserve","replace","ReturnStatement","getFunctionParent","isArrowFunctionExpression","pushConstructor","pushMethod","pushInheritsToBody","props","placement","length","desc","obj","objectExpression","objectProperty","key","properties","arrayExpression","nullLiteral","lastNonNullIndex","i","isNullLiteral","slice","expressionStatement","wrapSuperCall","bareSuper","thisRef","bareSuperNode","call","superIsCallableConstructor","arguments","unshift","thisExpression","isSpreadElement","isIdentifier","argument","name","callee","memberExpression","logicalExpression","parentPath","isExpressionStatement","container","assignmentExpression","replaceWith","returnStatement","ref","generateDeclaredUidIdentifier","thisPath","isMemberExpression","object","bareSupers","Super","isCallExpression","guaranteedSuperBeforeFinish","find","isLoop","isConditional","wrapReturn","returnArg","thisExpr","returnParams","bodyPaths","pop","isReturnStatement","pushContainer","returnPath","processMethod","descKey","isNumericLiteral","isBigIntLiteral","stringLiteral","String","value","toComputedKey","fn","toExpression","isStringLiteral","id","descriptor","has","set","setClassMethods","insertProtoAliasOnce","methodName","computed","isLiteral","functionExpression","generator","async","expr","inheritsComments","generateUidIdentifier","classProto","protoDeclaration","variableDeclaration","variableDeclarator","method","directives","pushConstructorToBody","hasInstanceDescriptors","hasStaticDescriptors","extractDynamicKeys","elem","isPure","generateUidIdentifierBasedOnNode","setupClosureParamsArgs","closureParams","closureArgs","arg","param","classTransformer","superClass","hasBinding","noClassCalls","isStrict","isInStrictMode","constructorOnly","directive","directiveLiteral","arrowFunctionExpression"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-transform-classes\\src\\transformClass.ts"],"sourcesContent":["import type { NodePath, Scope, Visitor } from \"@babel/traverse\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport { traverse, template, types as t, type File } from \"@babel/core\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\n\nimport addCreateSuperHelper from \"./inline-createSuper-helpers\";\n\ntype ClassAssumptions = {\n  setClassMethods: boolean;\n  constantSuper: boolean;\n  superIsCallableConstructor: boolean;\n  noClassCalls: boolean;\n};\n\ntype ClassConstructor = t.ClassMethod & { kind: \"constructor\" };\n\nfunction buildConstructor(\n  classRef: t.Identifier,\n  constructorBody: t.BlockStatement,\n  node: t.Class,\n) {\n  const func = t.functionDeclaration(\n    t.cloneNode(classRef),\n    [],\n    constructorBody,\n  );\n  t.inherits(func, node);\n  return func;\n}\n\ntype Descriptor = {\n  key: t.Expression;\n  get?: t.Expression | null;\n  set?: t.Expression | null;\n  value?: t.Expression | null;\n  constructor?: t.Expression | null;\n};\n\ntype State = {\n  parent: t.Node;\n  scope: Scope;\n  node: t.Class;\n  path: NodePath<t.Class>;\n  file: File;\n\n  classId: t.Identifier | void;\n  classRef: t.Identifier;\n  superFnId: t.Identifier;\n  superName: t.Expression | null;\n  superReturns: NodePath<t.ReturnStatement>[];\n  isDerived: boolean;\n  extendsNative: boolean;\n\n  construct: t.FunctionDeclaration;\n  constructorBody: t.BlockStatement;\n  userConstructor: ClassConstructor;\n  userConstructorPath: NodePath<ClassConstructor>;\n  hasConstructor: boolean;\n\n  body: t.Statement[];\n  superThises: NodePath<t.ThisExpression>[];\n  pushedConstructor: boolean;\n  pushedInherits: boolean;\n  pushedCreateClass: boolean;\n  protoAlias: t.Identifier | null;\n  isLoose: boolean;\n\n  dynamicKeys: Map<string, t.Expression>;\n\n  methods: {\n    // 'list' is in the same order as the elements appear in the class body.\n    // if there aren't computed keys, we can safely reorder class elements\n    // and use 'map' to merge duplicates.\n    instance: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n    static: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n  };\n};\n\ntype PropertyInfo = {\n  instance: t.ObjectExpression[] | null;\n  static: t.ObjectExpression[] | null;\n};\n\nexport default function transformClass(\n  path: NodePath<t.Class>,\n  file: File,\n  builtinClasses: ReadonlySet<string>,\n  isLoose: boolean,\n  assumptions: ClassAssumptions,\n  supportUnicodeId: boolean,\n) {\n  const classState: State = {\n    parent: undefined,\n    scope: undefined,\n    node: undefined,\n    path: undefined,\n    file: undefined,\n\n    classId: undefined,\n    classRef: undefined,\n    superFnId: undefined,\n    superName: null,\n    superReturns: [],\n    isDerived: false,\n    extendsNative: false,\n\n    construct: undefined,\n    constructorBody: undefined,\n    userConstructor: undefined,\n    userConstructorPath: undefined,\n    hasConstructor: false,\n\n    body: [],\n    superThises: [],\n    pushedConstructor: false,\n    pushedInherits: false,\n    pushedCreateClass: false,\n    protoAlias: null,\n    isLoose: false,\n\n    dynamicKeys: new Map(),\n\n    methods: {\n      instance: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n      static: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n    },\n  };\n\n  const setState = (newState: Partial<State>) => {\n    Object.assign(classState, newState);\n  };\n\n  const findThisesVisitor = traverse.visitors.merge([\n    environmentVisitor,\n    {\n      ThisExpression(path) {\n        classState.superThises.push(path);\n      },\n    },\n  ]);\n\n  function createClassHelper(args: t.Expression[]) {\n    return t.callExpression(classState.file.addHelper(\"createClass\"), args);\n  }\n\n  /**\n   * Creates a class constructor or bail out if there is none\n   */\n  function maybeCreateConstructor() {\n    let hasConstructor = false;\n    const paths = classState.path.get(\"body.body\");\n    for (const path of paths) {\n      // @ts-expect-error: StaticBlock does not have `kind` property\n      hasConstructor = path.equals(\"kind\", \"constructor\");\n      if (hasConstructor) break;\n    }\n    if (hasConstructor) return;\n\n    let params: t.FunctionExpression[\"params\"], body;\n\n    if (classState.isDerived) {\n      const constructor = template.expression.ast`\n        (function () {\n          super(...arguments);\n        })\n      ` as t.FunctionExpression;\n      params = constructor.params;\n      body = constructor.body;\n    } else {\n      params = [];\n      body = t.blockStatement([]);\n    }\n\n    classState.path\n      .get(\"body\")\n      .unshiftContainer(\n        \"body\",\n        t.classMethod(\"constructor\", t.identifier(\"constructor\"), params, body),\n      );\n  }\n\n  function buildBody() {\n    maybeCreateConstructor();\n    pushBody();\n    verifyConstructor();\n\n    if (classState.userConstructor) {\n      const { constructorBody, userConstructor, construct } = classState;\n\n      constructorBody.body.push(...userConstructor.body.body);\n      t.inherits(construct, userConstructor);\n      t.inherits(constructorBody, userConstructor.body);\n    }\n\n    pushDescriptors();\n  }\n\n  function pushBody() {\n    const classBodyPaths: Array<any> = classState.path.get(\"body.body\");\n\n    for (const path of classBodyPaths) {\n      const node = path.node;\n\n      if (path.isClassProperty()) {\n        throw path.buildCodeFrameError(\"Missing class properties transform.\");\n      }\n\n      if (node.decorators) {\n        throw path.buildCodeFrameError(\n          \"Method has decorators, put the decorator plugin before the classes one.\",\n        );\n      }\n\n      if (t.isClassMethod(node)) {\n        const isConstructor = node.kind === \"constructor\";\n\n        const replaceSupers = new ReplaceSupers({\n          methodPath: path,\n          objectRef: classState.classRef,\n          superRef: classState.superName,\n          constantSuper: assumptions.constantSuper,\n          file: classState.file,\n          refToPreserve: classState.classRef,\n        });\n\n        replaceSupers.replace();\n\n        const superReturns: NodePath<t.ReturnStatement>[] = [];\n        path.traverse(\n          traverse.visitors.merge([\n            environmentVisitor,\n            {\n              ReturnStatement(path) {\n                if (!path.getFunctionParent().isArrowFunctionExpression()) {\n                  superReturns.push(path);\n                }\n              },\n            },\n          ]),\n        );\n\n        if (isConstructor) {\n          pushConstructor(superReturns, node as ClassConstructor, path);\n        } else {\n          pushMethod(node, path);\n        }\n      }\n    }\n  }\n\n  function pushDescriptors() {\n    pushInheritsToBody();\n\n    const { body } = classState;\n\n    const props: PropertyInfo = {\n      instance: null,\n      static: null,\n    };\n\n    for (const placement of [\"static\", \"instance\"] as const) {\n      if (classState.methods[placement].list.length) {\n        props[placement] = classState.methods[placement].list.map(desc => {\n          const obj = t.objectExpression([\n            t.objectProperty(t.identifier(\"key\"), desc.key),\n          ]);\n\n          for (const kind of [\"get\", \"set\", \"value\"] as const) {\n            if (desc[kind] != null) {\n              obj.properties.push(\n                t.objectProperty(t.identifier(kind), desc[kind]),\n              );\n            }\n          }\n\n          return obj;\n        });\n      }\n    }\n\n    if (props.instance || props.static) {\n      let args = [\n        t.cloneNode(classState.classRef), // Constructor\n        props.instance ? t.arrayExpression(props.instance) : t.nullLiteral(), // instanceDescriptors\n        props.static ? t.arrayExpression(props.static) : t.nullLiteral(), // staticDescriptors\n      ];\n\n      let lastNonNullIndex = 0;\n      for (let i = 0; i < args.length; i++) {\n        if (!t.isNullLiteral(args[i])) lastNonNullIndex = i;\n      }\n      args = args.slice(0, lastNonNullIndex + 1);\n\n      body.push(t.expressionStatement(createClassHelper(args)));\n      classState.pushedCreateClass = true;\n    }\n  }\n\n  function wrapSuperCall(\n    bareSuper: NodePath<t.CallExpression>,\n    superRef: t.Expression,\n    thisRef: () => t.Identifier,\n    body: NodePath<t.BlockStatement>,\n  ) {\n    const bareSuperNode = bareSuper.node;\n    let call;\n\n    if (assumptions.superIsCallableConstructor) {\n      bareSuperNode.arguments.unshift(t.thisExpression());\n      if (\n        bareSuperNode.arguments.length === 2 &&\n        t.isSpreadElement(bareSuperNode.arguments[1]) &&\n        t.isIdentifier(bareSuperNode.arguments[1].argument, {\n          name: \"arguments\",\n        })\n      ) {\n        // special case single arguments spread\n        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"apply\"),\n        );\n      } else {\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"call\"),\n        );\n      }\n\n      call = t.logicalExpression(\"||\", bareSuperNode, t.thisExpression());\n    } else {\n      call = optimiseCall(\n        t.cloneNode(classState.superFnId),\n        t.thisExpression(),\n        bareSuperNode.arguments,\n        false,\n      );\n    }\n\n    if (\n      bareSuper.parentPath.isExpressionStatement() &&\n      bareSuper.parentPath.container === body.node.body &&\n      body.node.body.length - 1 === bareSuper.parentPath.key\n    ) {\n      // this super call is the last statement in the body so we can just straight up\n      // turn it into a return\n\n      if (classState.superThises.length) {\n        call = t.assignmentExpression(\"=\", thisRef(), call);\n      }\n\n      bareSuper.parentPath.replaceWith(t.returnStatement(call));\n    } else {\n      bareSuper.replaceWith(t.assignmentExpression(\"=\", thisRef(), call));\n    }\n  }\n\n  function verifyConstructor() {\n    if (!classState.isDerived) return;\n\n    const path = classState.userConstructorPath;\n    const body = path.get(\"body\");\n\n    path.traverse(findThisesVisitor);\n\n    let thisRef = function () {\n      const ref = path.scope.generateDeclaredUidIdentifier(\"this\");\n      thisRef = () => t.cloneNode(ref);\n      return ref;\n    };\n\n    for (const thisPath of classState.superThises) {\n      const { node, parentPath } = thisPath;\n      if (parentPath.isMemberExpression({ object: node })) {\n        thisPath.replaceWith(thisRef());\n        continue;\n      }\n      thisPath.replaceWith(\n        t.callExpression(classState.file.addHelper(\"assertThisInitialized\"), [\n          thisRef(),\n        ]),\n      );\n    }\n\n    const bareSupers: NodePath<t.CallExpression>[] = [];\n    path.traverse(\n      traverse.visitors.merge([\n        environmentVisitor,\n        {\n          Super(path) {\n            const { node, parentPath } = path;\n            if (parentPath.isCallExpression({ callee: node })) {\n              bareSupers.unshift(parentPath);\n            }\n          },\n        } as Visitor,\n      ]),\n    );\n\n    let guaranteedSuperBeforeFinish = !!bareSupers.length;\n\n    for (const bareSuper of bareSupers) {\n      wrapSuperCall(bareSuper, classState.superName, thisRef, body);\n\n      if (guaranteedSuperBeforeFinish) {\n        bareSuper.find(function (parentPath) {\n          // hit top so short circuit\n          if (parentPath === path) {\n            return true;\n          }\n\n          if (\n            parentPath.isLoop() ||\n            parentPath.isConditional() ||\n            parentPath.isArrowFunctionExpression()\n          ) {\n            guaranteedSuperBeforeFinish = false;\n            return true;\n          }\n        });\n      }\n    }\n\n    let wrapReturn;\n\n    if (classState.isLoose) {\n      wrapReturn = (returnArg: t.Expression | void) => {\n        const thisExpr = t.callExpression(\n          classState.file.addHelper(\"assertThisInitialized\"),\n          [thisRef()],\n        );\n        return returnArg\n          ? t.logicalExpression(\"||\", returnArg, thisExpr)\n          : thisExpr;\n      };\n    } else {\n      wrapReturn = (returnArg: t.Expression | undefined) => {\n        const returnParams: t.Expression[] = [thisRef()];\n        if (returnArg != null) {\n          returnParams.push(returnArg);\n        }\n        return t.callExpression(\n          classState.file.addHelper(\"possibleConstructorReturn\"),\n          returnParams,\n        );\n      };\n    }\n\n    // if we have a return as the last node in the body then we've already caught that\n    // return\n    const bodyPaths = body.get(\"body\");\n    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {\n      body.pushContainer(\n        \"body\",\n        t.returnStatement(\n          guaranteedSuperBeforeFinish ? thisRef() : wrapReturn(),\n        ),\n      );\n    }\n\n    for (const returnPath of classState.superReturns) {\n      returnPath\n        .get(\"argument\")\n        .replaceWith(wrapReturn(returnPath.node.argument));\n    }\n  }\n\n  /**\n   * Push a method to its respective mutatorMap.\n   */\n  function pushMethod(node: t.ClassMethod, path?: NodePath) {\n    const scope = path ? path.scope : classState.scope;\n\n    if (node.kind === \"method\") {\n      if (processMethod(node, scope)) return;\n    }\n\n    const placement = node.static ? \"static\" : \"instance\";\n    const methods = classState.methods[placement];\n\n    const descKey = node.kind === \"method\" ? \"value\" : node.kind;\n    const key =\n      t.isNumericLiteral(node.key) || t.isBigIntLiteral(node.key)\n        ? t.stringLiteral(String(node.key.value))\n        : t.toComputedKey(node);\n\n    let fn: t.Expression = t.toExpression(node);\n\n    if (t.isStringLiteral(key)) {\n      // infer function name\n      if (node.kind === \"method\") {\n        // @ts-expect-error Fixme: we are passing a ClassMethod to nameFunction, but nameFunction\n        // does not seem to support it\n        fn =\n          nameFunction(\n            // @ts-expect-error Fixme: we are passing a ClassMethod to nameFunction, but nameFunction\n            // does not seem to support it\n            { id: key, node: node, scope },\n            undefined,\n            supportUnicodeId,\n          ) ?? fn;\n      }\n    } else {\n      // todo(flow->ts) find a way to avoid \"key as t.StringLiteral\" below which relies on this assignment\n      methods.hasComputed = true;\n    }\n\n    let descriptor: Descriptor;\n    if (\n      !methods.hasComputed &&\n      methods.map.has((key as t.StringLiteral).value)\n    ) {\n      descriptor = methods.map.get((key as t.StringLiteral).value);\n      descriptor[descKey] = fn;\n\n      if (descKey === \"value\") {\n        descriptor.get = null;\n        descriptor.set = null;\n      } else {\n        descriptor.value = null;\n      }\n    } else {\n      descriptor = {\n        key:\n          // private name has been handled in class-properties transform\n          key as t.Expression,\n        [descKey]: fn,\n      } as Descriptor;\n      methods.list.push(descriptor);\n\n      if (!methods.hasComputed) {\n        methods.map.set((key as t.StringLiteral).value, descriptor);\n      }\n    }\n  }\n\n  function processMethod(node: t.ClassMethod, scope: Scope) {\n    if (assumptions.setClassMethods && !node.decorators) {\n      // use assignments instead of define properties for loose classes\n      let { classRef } = classState;\n      if (!node.static) {\n        insertProtoAliasOnce();\n        classRef = classState.protoAlias;\n      }\n      const methodName = t.memberExpression(\n        t.cloneNode(classRef),\n        node.key,\n        node.computed || t.isLiteral(node.key),\n      );\n\n      let func: t.Expression = t.functionExpression(\n        null,\n        // @ts-expect-error Fixme: should throw when we see TSParameterProperty\n        node.params,\n        node.body,\n        node.generator,\n        node.async,\n      );\n      t.inherits(func, node);\n\n      const key = t.toComputedKey(node, node.key);\n      if (t.isStringLiteral(key)) {\n        // @ts-expect-error: requires strictNullCheck\n        func =\n          nameFunction(\n            {\n              node: func,\n              id: key,\n              scope,\n            },\n            undefined,\n            supportUnicodeId,\n          ) ?? func;\n      }\n\n      const expr = t.expressionStatement(\n        t.assignmentExpression(\"=\", methodName, func),\n      );\n      t.inheritsComments(expr, node);\n      classState.body.push(expr);\n      return true;\n    }\n\n    return false;\n  }\n\n  function insertProtoAliasOnce() {\n    if (classState.protoAlias === null) {\n      setState({ protoAlias: classState.scope.generateUidIdentifier(\"proto\") });\n      const classProto = t.memberExpression(\n        classState.classRef,\n        t.identifier(\"prototype\"),\n      );\n      const protoDeclaration = t.variableDeclaration(\"var\", [\n        t.variableDeclarator(classState.protoAlias, classProto),\n      ]);\n\n      classState.body.push(protoDeclaration);\n    }\n  }\n\n  /**\n   * Replace the constructor body of our class.\n   */\n  function pushConstructor(\n    superReturns: NodePath<t.ReturnStatement>[],\n    method: ClassConstructor,\n    path: NodePath<ClassConstructor>,\n  ) {\n    setState({\n      userConstructorPath: path,\n      userConstructor: method,\n      hasConstructor: true,\n      superReturns,\n    });\n\n    const { construct } = classState;\n\n    t.inheritsComments(construct, method);\n\n    // @ts-expect-error Fixme: should throw when we see TSParameterProperty\n    construct.params = method.params;\n\n    t.inherits(construct.body, method.body);\n    construct.body.directives = method.body.directives;\n\n    pushConstructorToBody();\n  }\n\n  function pushConstructorToBody() {\n    if (classState.pushedConstructor) return;\n    classState.pushedConstructor = true;\n\n    // we haven't pushed any descriptors yet\n    // @ts-expect-error todo(flow->ts) maybe remove this block - properties from condition are not used anywhere esle\n    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {\n      pushDescriptors();\n    }\n\n    classState.body.push(classState.construct);\n\n    pushInheritsToBody();\n  }\n\n  /**\n   * Push inherits helper to body.\n   */\n  function pushInheritsToBody() {\n    if (!classState.isDerived || classState.pushedInherits) return;\n\n    const superFnId = path.scope.generateUidIdentifier(\"super\");\n\n    setState({ pushedInherits: true, superFnId });\n\n    // Unshift to ensure that the constructor inheritance is set up before\n    // any properties can be assigned to the prototype.\n\n    if (!assumptions.superIsCallableConstructor) {\n      classState.body.unshift(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(\n            superFnId,\n            t.callExpression(addCreateSuperHelper(classState.file), [\n              t.cloneNode(classState.classRef),\n            ]),\n          ),\n        ]),\n      );\n    }\n\n    classState.body.unshift(\n      t.expressionStatement(\n        t.callExpression(\n          classState.file.addHelper(\n            classState.isLoose ? \"inheritsLoose\" : \"inherits\",\n          ),\n          [t.cloneNode(classState.classRef), t.cloneNode(classState.superName)],\n        ),\n      ),\n    );\n  }\n\n  function extractDynamicKeys() {\n    const { dynamicKeys, node, scope } = classState;\n\n    for (const elem of node.body.body) {\n      if (!t.isClassMethod(elem) || !elem.computed) continue;\n      if (scope.isPure(elem.key, /* constatns only*/ true)) continue;\n\n      const id = scope.generateUidIdentifierBasedOnNode(elem.key);\n      dynamicKeys.set(id.name, elem.key);\n\n      elem.key = id;\n    }\n  }\n\n  function setupClosureParamsArgs() {\n    const { superName, dynamicKeys } = classState;\n    const closureParams = [];\n    const closureArgs = [];\n\n    if (classState.isDerived) {\n      let arg = t.cloneNode(superName);\n      if (classState.extendsNative) {\n        arg = t.callExpression(classState.file.addHelper(\"wrapNativeSuper\"), [\n          arg,\n        ]);\n        annotateAsPure(arg);\n      }\n\n      const param =\n        classState.scope.generateUidIdentifierBasedOnNode(superName);\n\n      closureParams.push(param);\n      closureArgs.push(arg);\n\n      setState({ superName: t.cloneNode(param) });\n    }\n\n    for (const [name, value] of dynamicKeys) {\n      closureParams.push(t.identifier(name));\n      closureArgs.push(value);\n    }\n\n    return { closureParams, closureArgs };\n  }\n\n  function classTransformer(\n    path: NodePath<t.Class>,\n    file: File,\n    builtinClasses: ReadonlySet<string>,\n    isLoose: boolean,\n  ) {\n    setState({\n      parent: path.parent,\n      scope: path.scope,\n      node: path.node,\n      path,\n      file,\n      isLoose,\n    });\n\n    setState({\n      classId: classState.node.id,\n      // this is the name of the binding that will **always** reference the class we've constructed\n      classRef: classState.node.id\n        ? t.identifier(classState.node.id.name)\n        : classState.scope.generateUidIdentifier(\"class\"),\n      superName: classState.node.superClass,\n      isDerived: !!classState.node.superClass,\n      constructorBody: t.blockStatement([]),\n    });\n\n    setState({\n      extendsNative:\n        t.isIdentifier(classState.superName) &&\n        builtinClasses.has(classState.superName.name) &&\n        !classState.scope.hasBinding(\n          classState.superName.name,\n          /* noGlobals */ true,\n        ),\n    });\n\n    const { classRef, node, constructorBody } = classState;\n\n    setState({\n      construct: buildConstructor(classRef, constructorBody, node),\n    });\n\n    extractDynamicKeys();\n\n    const { body } = classState;\n    const { closureParams, closureArgs } = setupClosureParamsArgs();\n\n    buildBody();\n\n    // make sure this class isn't directly called (with A() instead new A())\n    if (!assumptions.noClassCalls) {\n      constructorBody.body.unshift(\n        t.expressionStatement(\n          t.callExpression(classState.file.addHelper(\"classCallCheck\"), [\n            t.thisExpression(),\n            t.cloneNode(classState.classRef),\n          ]),\n        ),\n      );\n    }\n\n    const isStrict = path.isInStrictMode();\n    let constructorOnly = classState.classId && body.length === 1;\n    if (constructorOnly && !isStrict) {\n      for (const param of classState.construct.params) {\n        // It's illegal to put a use strict directive into the body of a function\n        // with non-simple parameters for some reason. So, we have to use a strict\n        // wrapper function.\n        if (!t.isIdentifier(param)) {\n          constructorOnly = false;\n          break;\n        }\n      }\n    }\n\n    const directives = constructorOnly\n      ? (body[0] as t.FunctionExpression | t.FunctionDeclaration).body\n          .directives\n      : [];\n    if (!isStrict) {\n      directives.push(t.directive(t.directiveLiteral(\"use strict\")));\n    }\n\n    if (constructorOnly) {\n      // named class with only a constructor\n      const expr = t.toExpression(\n        body[0] as t.FunctionExpression | t.FunctionDeclaration,\n      );\n      return classState.isLoose ? expr : createClassHelper([expr]);\n    }\n\n    let returnArg: t.Expression = t.cloneNode(classState.classRef);\n    if (!classState.pushedCreateClass && !classState.isLoose) {\n      returnArg = createClassHelper([returnArg]);\n    }\n\n    body.push(t.returnStatement(returnArg));\n    const container = t.arrowFunctionExpression(\n      closureParams,\n      t.blockStatement(body, directives),\n    );\n    return t.callExpression(container, closureArgs);\n  }\n\n  return classTransformer(path, file, builtinClasses, isLoose);\n}\n"]},"metadata":{},"sourceType":"script"}