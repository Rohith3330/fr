{"ast":null,"code":"/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathSegment = require(\"./code-path-segment\"),\n      ForkContext = require(\"./fork-context\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not includes the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments Segments to add.\n * @returns {void}\n */\n\n\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n  for (let i = 0; i < segments.length; ++i) {\n    const segment = segments[i];\n    dest.push(segment);\n\n    if (!others.includes(segment)) {\n      all.push(segment);\n    }\n  }\n}\n/**\n * Gets a loop-context for a `continue` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\n\n\nfunction getContinueContext(state, label) {\n  if (!label) {\n    return state.loopContext;\n  }\n\n  let context = state.loopContext;\n\n  while (context) {\n    if (context.label === label) {\n      return context;\n    }\n\n    context = context.upper;\n  }\n  /* c8 ignore next */\n\n\n  return null;\n}\n/**\n * Gets a context for a `break` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `break` statement.\n * @returns {LoopContext|SwitchContext} A context for a `break` statement.\n */\n\n\nfunction getBreakContext(state, label) {\n  let context = state.breakContext;\n\n  while (context) {\n    if (label ? context.label === label : context.breakable) {\n      return context;\n    }\n\n    context = context.upper;\n  }\n  /* c8 ignore next */\n\n\n  return null;\n}\n/**\n * Gets a context for a `return` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\n\n\nfunction getReturnContext(state) {\n  let context = state.tryContext;\n\n  while (context) {\n    if (context.hasFinalizer && context.position !== \"finally\") {\n      return context;\n    }\n\n    context = context.upper;\n  }\n\n  return state;\n}\n/**\n * Gets a context for a `throw` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\n\n\nfunction getThrowContext(state) {\n  let context = state.tryContext;\n\n  while (context) {\n    if (context.position === \"try\" || context.hasFinalizer && context.position === \"catch\") {\n      return context;\n    }\n\n    context = context.upper;\n  }\n\n  return state;\n}\n/**\n * Removes a given element from a given array.\n * @param {any[]} xs An array to remove the specific element.\n * @param {any} x An element to be removed.\n * @returns {void}\n */\n\n\nfunction remove(xs, x) {\n  xs.splice(xs.indexOf(x), 1);\n}\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.\n * @returns {void}\n */\n\n\nfunction removeConnection(prevSegments, nextSegments) {\n  for (let i = 0; i < prevSegments.length; ++i) {\n    const prevSegment = prevSegments[i];\n    const nextSegment = nextSegments[i];\n    remove(prevSegment.nextSegments, nextSegment);\n    remove(prevSegment.allNextSegments, nextSegment);\n    remove(nextSegment.prevSegments, prevSegment);\n    remove(nextSegment.allPrevSegments, prevSegment);\n  }\n}\n/**\n * Creates looping path.\n * @param {CodePathState} state The instance.\n * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.\n * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.\n * @returns {void}\n */\n\n\nfunction makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {\n  const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);\n  const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);\n  const end = Math.min(fromSegments.length, toSegments.length);\n\n  for (let i = 0; i < end; ++i) {\n    const fromSegment = fromSegments[i];\n    const toSegment = toSegments[i];\n\n    if (toSegment.reachable) {\n      fromSegment.nextSegments.push(toSegment);\n    }\n\n    if (fromSegment.reachable) {\n      toSegment.prevSegments.push(fromSegment);\n    }\n\n    fromSegment.allNextSegments.push(toSegment);\n    toSegment.allPrevSegments.push(fromSegment);\n\n    if (toSegment.allPrevSegments.length >= 2) {\n      CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n    }\n\n    state.notifyLooped(fromSegment, toSegment);\n  }\n}\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n * @param {LoopContext} context A loop context to modify.\n * @param {ChoiceContext} choiceContext A choice context of this loop.\n * @param {CodePathSegment[]} head The current head paths.\n * @returns {void}\n */\n\n\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n  if (!choiceContext.processed) {\n    choiceContext.trueForkContext.add(head);\n    choiceContext.falseForkContext.add(head);\n    choiceContext.qqForkContext.add(head);\n  }\n\n  if (context.test !== true) {\n    context.brokenForkContext.addAll(choiceContext.falseForkContext);\n  }\n\n  context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n */\n\n\nclass CodePathState {\n  /**\n   * @param {IdGenerator} idGenerator An id generator to generate id for code\n   *   path segments.\n   * @param {Function} onLooped A callback function to notify looping.\n   */\n  constructor(idGenerator, onLooped) {\n    this.idGenerator = idGenerator;\n    this.notifyLooped = onLooped;\n    this.forkContext = ForkContext.newRoot(idGenerator);\n    this.choiceContext = null;\n    this.switchContext = null;\n    this.tryContext = null;\n    this.loopContext = null;\n    this.breakContext = null;\n    this.chainContext = null;\n    this.currentSegments = [];\n    this.initialSegment = this.forkContext.head[0]; // returnedSegments and thrownSegments push elements into finalSegments also.\n\n    const final = this.finalSegments = [];\n    const returned = this.returnedForkContext = [];\n    const thrown = this.thrownForkContext = [];\n    returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n    thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n  }\n  /**\n   * The head segments.\n   * @type {CodePathSegment[]}\n   */\n\n\n  get headSegments() {\n    return this.forkContext.head;\n  }\n  /**\n   * The parent forking context.\n   * This is used for the root of new forks.\n   * @type {ForkContext}\n   */\n\n\n  get parentForkContext() {\n    const current = this.forkContext;\n    return current && current.upper;\n  }\n  /**\n   * Creates and stacks new forking context.\n   * @param {boolean} forkLeavingPath A flag which shows being in a\n   *   \"finally\" block.\n   * @returns {ForkContext} The created context.\n   */\n\n\n  pushForkContext(forkLeavingPath) {\n    this.forkContext = ForkContext.newEmpty(this.forkContext, forkLeavingPath);\n    return this.forkContext;\n  }\n  /**\n   * Pops and merges the last forking context.\n   * @returns {ForkContext} The last context.\n   */\n\n\n  popForkContext() {\n    const lastContext = this.forkContext;\n    this.forkContext = lastContext.upper;\n    this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n    return lastContext;\n  }\n  /**\n   * Creates a new path.\n   * @returns {void}\n   */\n\n\n  forkPath() {\n    this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n  }\n  /**\n   * Creates a bypass path.\n   * This is used for such as IfStatement which does not have \"else\" chunk.\n   * @returns {void}\n   */\n\n\n  forkBypassPath() {\n    this.forkContext.add(this.parentForkContext.head);\n  } //--------------------------------------------------------------------------\n  // ConditionalExpression, LogicalExpression, IfStatement\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),\n   * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n   *\n   * LogicalExpressions have cases that it goes different paths between the\n   * `true` case and the `false` case.\n   *\n   * For Example:\n   *\n   *     if (a || b) {\n   *         foo();\n   *     } else {\n   *         bar();\n   *     }\n   *\n   * In this case, `b` is evaluated always in the code path of the `else`\n   * block, but it's not so in the code path of the `if` block.\n   * So there are 3 paths.\n   *\n   *     a -> foo();\n   *     a -> b -> foo();\n   *     a -> b -> bar();\n   * @param {string} kind A kind string.\n   *   If the new context is LogicalExpression's or AssignmentExpression's, this is `\"&&\"` or `\"||\"` or `\"??\"`.\n   *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n   *   Otherwise, this is `\"loop\"`.\n   * @param {boolean} isForkingAsResult A flag that shows that goes different\n   *   paths between `true` and `false`.\n   * @returns {void}\n   */\n\n\n  pushChoiceContext(kind, isForkingAsResult) {\n    this.choiceContext = {\n      upper: this.choiceContext,\n      kind,\n      isForkingAsResult,\n      trueForkContext: ForkContext.newEmpty(this.forkContext),\n      falseForkContext: ForkContext.newEmpty(this.forkContext),\n      qqForkContext: ForkContext.newEmpty(this.forkContext),\n      processed: false\n    };\n  }\n  /**\n   * Pops the last choice context and finalizes it.\n   * @throws {Error} (Unreachable.)\n   * @returns {ChoiceContext} The popped context.\n   */\n\n\n  popChoiceContext() {\n    const context = this.choiceContext;\n    this.choiceContext = context.upper;\n    const forkContext = this.forkContext;\n    const headSegments = forkContext.head;\n\n    switch (context.kind) {\n      case \"&&\":\n      case \"||\":\n      case \"??\":\n        /*\n         * If any result were not transferred from child contexts,\n         * this sets the head segments to both cases.\n         * The head segments are the path of the right-hand operand.\n         */\n        if (!context.processed) {\n          context.trueForkContext.add(headSegments);\n          context.falseForkContext.add(headSegments);\n          context.qqForkContext.add(headSegments);\n        }\n        /*\n         * Transfers results to upper context if this context is in\n         * test chunk.\n         */\n\n\n        if (context.isForkingAsResult) {\n          const parentContext = this.choiceContext;\n          parentContext.trueForkContext.addAll(context.trueForkContext);\n          parentContext.falseForkContext.addAll(context.falseForkContext);\n          parentContext.qqForkContext.addAll(context.qqForkContext);\n          parentContext.processed = true;\n          return context;\n        }\n\n        break;\n\n      case \"test\":\n        if (!context.processed) {\n          /*\n           * The head segments are the path of the `if` block here.\n           * Updates the `true` path with the end of the `if` block.\n           */\n          context.trueForkContext.clear();\n          context.trueForkContext.add(headSegments);\n        } else {\n          /*\n           * The head segments are the path of the `else` block here.\n           * Updates the `false` path with the end of the `else`\n           * block.\n           */\n          context.falseForkContext.clear();\n          context.falseForkContext.add(headSegments);\n        }\n\n        break;\n\n      case \"loop\":\n        /*\n         * Loops are addressed in popLoopContext().\n         * This is called from popLoopContext().\n         */\n        return context;\n\n      /* c8 ignore next */\n\n      default:\n        throw new Error(\"unreachable\");\n    } // Merges all paths.\n\n\n    const prevForkContext = context.trueForkContext;\n    prevForkContext.addAll(context.falseForkContext);\n    forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n    return context;\n  }\n  /**\n   * Makes a code path segment of the right-hand operand of a logical\n   * expression.\n   * @throws {Error} (Unreachable.)\n   * @returns {void}\n   */\n\n\n  makeLogicalRight() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    if (context.processed) {\n      /*\n       * This got segments already from the child choice context.\n       * Creates the next path from own true/false fork context.\n       */\n      let prevForkContext;\n\n      switch (context.kind) {\n        case \"&&\":\n          // if true then go to the right-hand side.\n          prevForkContext = context.trueForkContext;\n          break;\n\n        case \"||\":\n          // if false then go to the right-hand side.\n          prevForkContext = context.falseForkContext;\n          break;\n\n        case \"??\":\n          // Both true/false can short-circuit, so needs the third path to go to the right-hand side. That's qqForkContext.\n          prevForkContext = context.qqForkContext;\n          break;\n\n        default:\n          throw new Error(\"unreachable\");\n      }\n\n      forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n      prevForkContext.clear();\n      context.processed = false;\n    } else {\n      /*\n       * This did not get segments from the child choice context.\n       * So addresses the head segments.\n       * The head segments are the path of the left-hand operand.\n       */\n      switch (context.kind) {\n        case \"&&\":\n          // the false path can short-circuit.\n          context.falseForkContext.add(forkContext.head);\n          break;\n\n        case \"||\":\n          // the true path can short-circuit.\n          context.trueForkContext.add(forkContext.head);\n          break;\n\n        case \"??\":\n          // both can short-circuit.\n          context.trueForkContext.add(forkContext.head);\n          context.falseForkContext.add(forkContext.head);\n          break;\n\n        default:\n          throw new Error(\"unreachable\");\n      }\n\n      forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n  }\n  /**\n   * Makes a code path segment of the `if` block.\n   * @returns {void}\n   */\n\n\n  makeIfConsequent() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n    /*\n     * If any result were not transferred from child contexts,\n     * this sets the head segments to both cases.\n     * The head segments are the path of the test expression.\n     */\n\n    if (!context.processed) {\n      context.trueForkContext.add(forkContext.head);\n      context.falseForkContext.add(forkContext.head);\n      context.qqForkContext.add(forkContext.head);\n    }\n\n    context.processed = false; // Creates new path from the `true` case.\n\n    forkContext.replaceHead(context.trueForkContext.makeNext(0, -1));\n  }\n  /**\n   * Makes a code path segment of the `else` block.\n   * @returns {void}\n   */\n\n\n  makeIfAlternate() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n    /*\n     * The head segments are the path of the `if` block.\n     * Updates the `true` path with the end of the `if` block.\n     */\n\n    context.trueForkContext.clear();\n    context.trueForkContext.add(forkContext.head);\n    context.processed = true; // Creates new path from the `false` case.\n\n    forkContext.replaceHead(context.falseForkContext.makeNext(0, -1));\n  } //--------------------------------------------------------------------------\n  // ChainExpression\n  //--------------------------------------------------------------------------\n\n  /**\n   * Push a new `ChainExpression` context to the stack.\n   * This method is called on entering to each `ChainExpression` node.\n   * This context is used to count forking in the optional chain then merge them on the exiting from the `ChainExpression` node.\n   * @returns {void}\n   */\n\n\n  pushChainContext() {\n    this.chainContext = {\n      upper: this.chainContext,\n      countChoiceContexts: 0\n    };\n  }\n  /**\n   * Pop a `ChainExpression` context from the stack.\n   * This method is called on exiting from each `ChainExpression` node.\n   * This merges all forks of the last optional chaining.\n   * @returns {void}\n   */\n\n\n  popChainContext() {\n    const context = this.chainContext;\n    this.chainContext = context.upper; // pop all choice contexts of this.\n\n    for (let i = context.countChoiceContexts; i > 0; --i) {\n      this.popChoiceContext();\n    }\n  }\n  /**\n   * Create a choice context for optional access.\n   * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.\n   * This creates a choice context as similar to `LogicalExpression[operator=\"??\"]` node.\n   * @returns {void}\n   */\n\n\n  makeOptionalNode() {\n    if (this.chainContext) {\n      this.chainContext.countChoiceContexts += 1;\n      this.pushChoiceContext(\"??\", false);\n    }\n  }\n  /**\n   * Create a fork.\n   * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.\n   * @returns {void}\n   */\n\n\n  makeOptionalRight() {\n    if (this.chainContext) {\n      this.makeLogicalRight();\n    }\n  } //--------------------------------------------------------------------------\n  // SwitchStatement\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context object of SwitchStatement and stacks it.\n   * @param {boolean} hasCase `true` if the switch statement has one or more\n   *   case parts.\n   * @param {string|null} label The label text.\n   * @returns {void}\n   */\n\n\n  pushSwitchContext(hasCase, label) {\n    this.switchContext = {\n      upper: this.switchContext,\n      hasCase,\n      defaultSegments: null,\n      defaultBodySegments: null,\n      foundDefault: false,\n      lastIsDefault: false,\n      countForks: 0\n    };\n    this.pushBreakContext(true, label);\n  }\n  /**\n   * Pops the last context of SwitchStatement and finalizes it.\n   *\n   * - Disposes all forking stack for `case` and `default`.\n   * - Creates the next code path segment from `context.brokenForkContext`.\n   * - If the last `SwitchCase` node is not a `default` part, creates a path\n   *   to the `default` body.\n   * @returns {void}\n   */\n\n\n  popSwitchContext() {\n    const context = this.switchContext;\n    this.switchContext = context.upper;\n    const forkContext = this.forkContext;\n    const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n    if (context.countForks === 0) {\n      /*\n       * When there is only one `default` chunk and there is one or more\n       * `break` statements, even if forks are nothing, it needs to merge\n       * those.\n       */\n      if (!brokenForkContext.empty) {\n        brokenForkContext.add(forkContext.makeNext(-1, -1));\n        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n      }\n\n      return;\n    }\n\n    const lastSegments = forkContext.head;\n    this.forkBypassPath();\n    const lastCaseSegments = forkContext.head;\n    /*\n     * `brokenForkContext` is used to make the next segment.\n     * It must add the last segment into `brokenForkContext`.\n     */\n\n    brokenForkContext.add(lastSegments);\n    /*\n     * A path which is failed in all case test should be connected to path\n     * of `default` chunk.\n     */\n\n    if (!context.lastIsDefault) {\n      if (context.defaultBodySegments) {\n        /*\n         * Remove a link from `default` label to its chunk.\n         * It's false route.\n         */\n        removeConnection(context.defaultSegments, context.defaultBodySegments);\n        makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n      } else {\n        /*\n         * It handles the last case body as broken if `default` chunk\n         * does not exist.\n         */\n        brokenForkContext.add(lastCaseSegments);\n      }\n    } // Pops the segment context stack until the entry segment.\n\n\n    for (let i = 0; i < context.countForks; ++i) {\n      this.forkContext = this.forkContext.upper;\n    }\n    /*\n     * Creates a path from all brokenForkContext paths.\n     * This is a path after switch statement.\n     */\n\n\n    this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n  }\n  /**\n   * Makes a code path segment for a `SwitchCase` node.\n   * @param {boolean} isEmpty `true` if the body is empty.\n   * @param {boolean} isDefault `true` if the body is the default case.\n   * @returns {void}\n   */\n\n\n  makeSwitchCaseBody(isEmpty, isDefault) {\n    const context = this.switchContext;\n\n    if (!context.hasCase) {\n      return;\n    }\n    /*\n     * Merge forks.\n     * The parent fork context has two segments.\n     * Those are from the current case and the body of the previous case.\n     */\n\n\n    const parentForkContext = this.forkContext;\n    const forkContext = this.pushForkContext();\n    forkContext.add(parentForkContext.makeNext(0, -1));\n    /*\n     * Save `default` chunk info.\n     * If the `default` label is not at the last, we must make a path from\n     * the last `case` to the `default` chunk.\n     */\n\n    if (isDefault) {\n      context.defaultSegments = parentForkContext.head;\n\n      if (isEmpty) {\n        context.foundDefault = true;\n      } else {\n        context.defaultBodySegments = forkContext.head;\n      }\n    } else {\n      if (!isEmpty && context.foundDefault) {\n        context.foundDefault = false;\n        context.defaultBodySegments = forkContext.head;\n      }\n    }\n\n    context.lastIsDefault = isDefault;\n    context.countForks += 1;\n  } //--------------------------------------------------------------------------\n  // TryStatement\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context object of TryStatement and stacks it.\n   * @param {boolean} hasFinalizer `true` if the try statement has a\n   *   `finally` block.\n   * @returns {void}\n   */\n\n\n  pushTryContext(hasFinalizer) {\n    this.tryContext = {\n      upper: this.tryContext,\n      position: \"try\",\n      hasFinalizer,\n      returnedForkContext: hasFinalizer ? ForkContext.newEmpty(this.forkContext) : null,\n      thrownForkContext: ForkContext.newEmpty(this.forkContext),\n      lastOfTryIsReachable: false,\n      lastOfCatchIsReachable: false\n    };\n  }\n  /**\n   * Pops the last context of TryStatement and finalizes it.\n   * @returns {void}\n   */\n\n\n  popTryContext() {\n    const context = this.tryContext;\n    this.tryContext = context.upper;\n\n    if (context.position === \"catch\") {\n      // Merges two paths from the `try` block and `catch` block merely.\n      this.popForkContext();\n      return;\n    }\n    /*\n     * The following process is executed only when there is the `finally`\n     * block.\n     */\n\n\n    const returned = context.returnedForkContext;\n    const thrown = context.thrownForkContext;\n\n    if (returned.empty && thrown.empty) {\n      return;\n    } // Separate head to normal paths and leaving paths.\n\n\n    const headSegments = this.forkContext.head;\n    this.forkContext = this.forkContext.upper;\n    const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n    const leavingSegments = headSegments.slice(headSegments.length / 2 | 0); // Forwards the leaving path to upper contexts.\n\n    if (!returned.empty) {\n      getReturnContext(this).returnedForkContext.add(leavingSegments);\n    }\n\n    if (!thrown.empty) {\n      getThrowContext(this).thrownForkContext.add(leavingSegments);\n    } // Sets the normal path as the next.\n\n\n    this.forkContext.replaceHead(normalSegments);\n    /*\n     * If both paths of the `try` block and the `catch` block are\n     * unreachable, the next path becomes unreachable as well.\n     */\n\n    if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n      this.forkContext.makeUnreachable();\n    }\n  }\n  /**\n   * Makes a code path segment for a `catch` block.\n   * @returns {void}\n   */\n\n\n  makeCatchBlock() {\n    const context = this.tryContext;\n    const forkContext = this.forkContext;\n    const thrown = context.thrownForkContext; // Update state.\n\n    context.position = \"catch\";\n    context.thrownForkContext = ForkContext.newEmpty(forkContext);\n    context.lastOfTryIsReachable = forkContext.reachable; // Merge thrown paths.\n\n    thrown.add(forkContext.head);\n    const thrownSegments = thrown.makeNext(0, -1); // Fork to a bypass and the merged thrown path.\n\n    this.pushForkContext();\n    this.forkBypassPath();\n    this.forkContext.add(thrownSegments);\n  }\n  /**\n   * Makes a code path segment for a `finally` block.\n   *\n   * In the `finally` block, parallel paths are created. The parallel paths\n   * are used as leaving-paths. The leaving-paths are paths from `return`\n   * statements and `throw` statements in a `try` block or a `catch` block.\n   * @returns {void}\n   */\n\n\n  makeFinallyBlock() {\n    const context = this.tryContext;\n    let forkContext = this.forkContext;\n    const returned = context.returnedForkContext;\n    const thrown = context.thrownForkContext;\n    const headOfLeavingSegments = forkContext.head; // Update state.\n\n    if (context.position === \"catch\") {\n      // Merges two paths from the `try` block and `catch` block.\n      this.popForkContext();\n      forkContext = this.forkContext;\n      context.lastOfCatchIsReachable = forkContext.reachable;\n    } else {\n      context.lastOfTryIsReachable = forkContext.reachable;\n    }\n\n    context.position = \"finally\";\n\n    if (returned.empty && thrown.empty) {\n      // This path does not leave.\n      return;\n    }\n    /*\n     * Create a parallel segment from merging returned and thrown.\n     * This segment will leave at the end of this finally block.\n     */\n\n\n    const segments = forkContext.makeNext(-1, -1);\n\n    for (let i = 0; i < forkContext.count; ++i) {\n      const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n\n      for (let j = 0; j < returned.segmentsList.length; ++j) {\n        prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\n      }\n\n      for (let j = 0; j < thrown.segmentsList.length; ++j) {\n        prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\n      }\n\n      segments.push(CodePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));\n    }\n\n    this.pushForkContext(true);\n    this.forkContext.add(segments);\n  }\n  /**\n   * Makes a code path segment from the first throwable node to the `catch`\n   * block or the `finally` block.\n   * @returns {void}\n   */\n\n\n  makeFirstThrowablePathInTryBlock() {\n    const forkContext = this.forkContext;\n\n    if (!forkContext.reachable) {\n      return;\n    }\n\n    const context = getThrowContext(this);\n\n    if (context === this || context.position !== \"try\" || !context.thrownForkContext.empty) {\n      return;\n    }\n\n    context.thrownForkContext.add(forkContext.head);\n    forkContext.replaceHead(forkContext.makeNext(-1, -1));\n  } //--------------------------------------------------------------------------\n  // Loop Statements\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context object of a loop statement and stacks it.\n   * @param {string} type The type of the node which was triggered. One of\n   *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n   *   and `ForStatement`.\n   * @param {string|null} label A label of the node which was triggered.\n   * @throws {Error} (Unreachable - unknown type.)\n   * @returns {void}\n   */\n\n\n  pushLoopContext(type, label) {\n    const forkContext = this.forkContext;\n    const breakContext = this.pushBreakContext(true, label);\n\n    switch (type) {\n      case \"WhileStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      case \"DoWhileStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          entrySegments: null,\n          continueForkContext: ForkContext.newEmpty(forkContext),\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      case \"ForStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          endOfInitSegments: null,\n          testSegments: null,\n          endOfTestSegments: null,\n          updateSegments: null,\n          endOfUpdateSegments: null,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          prevSegments: null,\n          leftSegments: null,\n          endOfLeftSegments: null,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      /* c8 ignore next */\n\n      default:\n        throw new Error(`unknown type: \"${type}\"`);\n    }\n  }\n  /**\n   * Pops the last context of a loop statement and finalizes it.\n   * @throws {Error} (Unreachable - unknown type.)\n   * @returns {void}\n   */\n\n\n  popLoopContext() {\n    const context = this.loopContext;\n    this.loopContext = context.upper;\n    const forkContext = this.forkContext;\n    const brokenForkContext = this.popBreakContext().brokenForkContext; // Creates a looped path.\n\n    switch (context.type) {\n      case \"WhileStatement\":\n      case \"ForStatement\":\n        this.popChoiceContext();\n        makeLooped(this, forkContext.head, context.continueDestSegments);\n        break;\n\n      case \"DoWhileStatement\":\n        {\n          const choiceContext = this.popChoiceContext();\n\n          if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n          }\n\n          if (context.test !== true) {\n            brokenForkContext.addAll(choiceContext.falseForkContext);\n          } // `true` paths go to looping.\n\n\n          const segmentsList = choiceContext.trueForkContext.segmentsList;\n\n          for (let i = 0; i < segmentsList.length; ++i) {\n            makeLooped(this, segmentsList[i], context.entrySegments);\n          }\n\n          break;\n        }\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        brokenForkContext.add(forkContext.head);\n        makeLooped(this, forkContext.head, context.leftSegments);\n        break;\n\n      /* c8 ignore next */\n\n      default:\n        throw new Error(\"unreachable\");\n    } // Go next.\n\n\n    if (brokenForkContext.empty) {\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    } else {\n      forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n  }\n  /**\n   * Makes a code path segment for the test part of a WhileStatement.\n   * @param {boolean|undefined} test The test value (only when constant).\n   * @returns {void}\n   */\n\n\n  makeWhileTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const testSegments = forkContext.makeNext(0, -1); // Update state.\n\n    context.test = test;\n    context.continueDestSegments = testSegments;\n    forkContext.replaceHead(testSegments);\n  }\n  /**\n   * Makes a code path segment for the body part of a WhileStatement.\n   * @returns {void}\n   */\n\n\n  makeWhileBody() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    if (!choiceContext.processed) {\n      choiceContext.trueForkContext.add(forkContext.head);\n      choiceContext.falseForkContext.add(forkContext.head);\n    } // Update state.\n\n\n    if (context.test !== true) {\n      context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n\n    forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n  }\n  /**\n   * Makes a code path segment for the body part of a DoWhileStatement.\n   * @returns {void}\n   */\n\n\n  makeDoWhileBody() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const bodySegments = forkContext.makeNext(-1, -1); // Update state.\n\n    context.entrySegments = bodySegments;\n    forkContext.replaceHead(bodySegments);\n  }\n  /**\n   * Makes a code path segment for the test part of a DoWhileStatement.\n   * @param {boolean|undefined} test The test value (only when constant).\n   * @returns {void}\n   */\n\n\n  makeDoWhileTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    context.test = test; // Creates paths of `continue` statements.\n\n    if (!context.continueForkContext.empty) {\n      context.continueForkContext.add(forkContext.head);\n      const testSegments = context.continueForkContext.makeNext(0, -1);\n      forkContext.replaceHead(testSegments);\n    }\n  }\n  /**\n   * Makes a code path segment for the test part of a ForStatement.\n   * @param {boolean|undefined} test The test value (only when constant).\n   * @returns {void}\n   */\n\n\n  makeForTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const endOfInitSegments = forkContext.head;\n    const testSegments = forkContext.makeNext(-1, -1); // Update state.\n\n    context.test = test;\n    context.endOfInitSegments = endOfInitSegments;\n    context.continueDestSegments = context.testSegments = testSegments;\n    forkContext.replaceHead(testSegments);\n  }\n  /**\n   * Makes a code path segment for the update part of a ForStatement.\n   * @returns {void}\n   */\n\n\n  makeForUpdate() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext; // Make the next paths of the test.\n\n    if (context.testSegments) {\n      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);\n    } else {\n      context.endOfInitSegments = forkContext.head;\n    } // Update state.\n\n\n    const updateSegments = forkContext.makeDisconnected(-1, -1);\n    context.continueDestSegments = context.updateSegments = updateSegments;\n    forkContext.replaceHead(updateSegments);\n  }\n  /**\n   * Makes a code path segment for the body part of a ForStatement.\n   * @returns {void}\n   */\n\n\n  makeForBody() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext; // Update state.\n\n    if (context.updateSegments) {\n      context.endOfUpdateSegments = forkContext.head; // `update` -> `test`\n\n      if (context.testSegments) {\n        makeLooped(this, context.endOfUpdateSegments, context.testSegments);\n      }\n    } else if (context.testSegments) {\n      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);\n    } else {\n      context.endOfInitSegments = forkContext.head;\n    }\n\n    let bodySegments = context.endOfTestSegments;\n\n    if (!bodySegments) {\n      /*\n       * If there is not the `test` part, the `body` path comes from the\n       * `init` part and the `update` part.\n       */\n      const prevForkContext = ForkContext.newEmpty(forkContext);\n      prevForkContext.add(context.endOfInitSegments);\n\n      if (context.endOfUpdateSegments) {\n        prevForkContext.add(context.endOfUpdateSegments);\n      }\n\n      bodySegments = prevForkContext.makeNext(0, -1);\n    }\n\n    context.continueDestSegments = context.continueDestSegments || bodySegments;\n    forkContext.replaceHead(bodySegments);\n  }\n  /**\n   * Makes a code path segment for the left part of a ForInStatement and a\n   * ForOfStatement.\n   * @returns {void}\n   */\n\n\n  makeForInOfLeft() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const leftSegments = forkContext.makeDisconnected(-1, -1); // Update state.\n\n    context.prevSegments = forkContext.head;\n    context.leftSegments = context.continueDestSegments = leftSegments;\n    forkContext.replaceHead(leftSegments);\n  }\n  /**\n   * Makes a code path segment for the right part of a ForInStatement and a\n   * ForOfStatement.\n   * @returns {void}\n   */\n\n\n  makeForInOfRight() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const temp = ForkContext.newEmpty(forkContext);\n    temp.add(context.prevSegments);\n    const rightSegments = temp.makeNext(-1, -1); // Update state.\n\n    context.endOfLeftSegments = forkContext.head;\n    forkContext.replaceHead(rightSegments);\n  }\n  /**\n   * Makes a code path segment for the body part of a ForInStatement and a\n   * ForOfStatement.\n   * @returns {void}\n   */\n\n\n  makeForInOfBody() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const temp = ForkContext.newEmpty(forkContext);\n    temp.add(context.endOfLeftSegments);\n    const bodySegments = temp.makeNext(-1, -1); // Make a path: `right` -> `left`.\n\n    makeLooped(this, forkContext.head, context.leftSegments); // Update state.\n\n    context.brokenForkContext.add(forkContext.head);\n    forkContext.replaceHead(bodySegments);\n  } //--------------------------------------------------------------------------\n  // Control Statements\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates new context for BreakStatement.\n   * @param {boolean} breakable The flag to indicate it can break by\n   *      an unlabeled BreakStatement.\n   * @param {string|null} label The label of this context.\n   * @returns {Object} The new context.\n   */\n\n\n  pushBreakContext(breakable, label) {\n    this.breakContext = {\n      upper: this.breakContext,\n      breakable,\n      label,\n      brokenForkContext: ForkContext.newEmpty(this.forkContext)\n    };\n    return this.breakContext;\n  }\n  /**\n   * Removes the top item of the break context stack.\n   * @returns {Object} The removed context.\n   */\n\n\n  popBreakContext() {\n    const context = this.breakContext;\n    const forkContext = this.forkContext;\n    this.breakContext = context.upper; // Process this context here for other than switches and loops.\n\n    if (!context.breakable) {\n      const brokenForkContext = context.brokenForkContext;\n\n      if (!brokenForkContext.empty) {\n        brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n      }\n    }\n\n    return context;\n  }\n  /**\n   * Makes a path for a `break` statement.\n   *\n   * It registers the head segment to a context of `break`.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @param {string} label A label of the break statement.\n   * @returns {void}\n   */\n\n\n  makeBreak(label) {\n    const forkContext = this.forkContext;\n\n    if (!forkContext.reachable) {\n      return;\n    }\n\n    const context = getBreakContext(this, label);\n\n    if (context) {\n      context.brokenForkContext.add(forkContext.head);\n    }\n    /* c8 ignore next */\n\n\n    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n  }\n  /**\n   * Makes a path for a `continue` statement.\n   *\n   * It makes a looping path.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @param {string} label A label of the continue statement.\n   * @returns {void}\n   */\n\n\n  makeContinue(label) {\n    const forkContext = this.forkContext;\n\n    if (!forkContext.reachable) {\n      return;\n    }\n\n    const context = getContinueContext(this, label);\n\n    if (context) {\n      if (context.continueDestSegments) {\n        makeLooped(this, forkContext.head, context.continueDestSegments); // If the context is a for-in/of loop, this effects a break also.\n\n        if (context.type === \"ForInStatement\" || context.type === \"ForOfStatement\") {\n          context.brokenForkContext.add(forkContext.head);\n        }\n      } else {\n        context.continueForkContext.add(forkContext.head);\n      }\n    }\n\n    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n  }\n  /**\n   * Makes a path for a `return` statement.\n   *\n   * It registers the head segment to a context of `return`.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @returns {void}\n   */\n\n\n  makeReturn() {\n    const forkContext = this.forkContext;\n\n    if (forkContext.reachable) {\n      getReturnContext(this).returnedForkContext.add(forkContext.head);\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n  }\n  /**\n   * Makes a path for a `throw` statement.\n   *\n   * It registers the head segment to a context of `throw`.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @returns {void}\n   */\n\n\n  makeThrow() {\n    const forkContext = this.forkContext;\n\n    if (forkContext.reachable) {\n      getThrowContext(this).thrownForkContext.add(forkContext.head);\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n  }\n  /**\n   * Makes the final path.\n   * @returns {void}\n   */\n\n\n  makeFinal() {\n    const segments = this.currentSegments;\n\n    if (segments.length > 0 && segments[0].reachable) {\n      this.returnedForkContext.add(segments);\n    }\n  }\n\n}\n\nmodule.exports = CodePathState;","map":{"version":3,"names":["CodePathSegment","require","ForkContext","addToReturnedOrThrown","dest","others","all","segments","i","length","segment","push","includes","getContinueContext","state","label","loopContext","context","upper","getBreakContext","breakContext","breakable","getReturnContext","tryContext","hasFinalizer","position","getThrowContext","remove","xs","x","splice","indexOf","removeConnection","prevSegments","nextSegments","prevSegment","nextSegment","allNextSegments","allPrevSegments","makeLooped","unflattenedFromSegments","unflattenedToSegments","fromSegments","flattenUnusedSegments","toSegments","end","Math","min","fromSegment","toSegment","reachable","markPrevSegmentAsLooped","notifyLooped","finalizeTestSegmentsOfFor","choiceContext","head","processed","trueForkContext","add","falseForkContext","qqForkContext","test","brokenForkContext","addAll","endOfTestSegments","makeNext","CodePathState","constructor","idGenerator","onLooped","forkContext","newRoot","switchContext","chainContext","currentSegments","initialSegment","final","finalSegments","returned","returnedForkContext","thrown","thrownForkContext","bind","headSegments","parentForkContext","current","pushForkContext","forkLeavingPath","newEmpty","popForkContext","lastContext","replaceHead","forkPath","forkBypassPath","pushChoiceContext","kind","isForkingAsResult","popChoiceContext","parentContext","clear","Error","prevForkContext","makeLogicalRight","makeIfConsequent","makeIfAlternate","pushChainContext","countChoiceContexts","popChainContext","makeOptionalNode","makeOptionalRight","pushSwitchContext","hasCase","defaultSegments","defaultBodySegments","foundDefault","lastIsDefault","countForks","pushBreakContext","popSwitchContext","popBreakContext","empty","lastSegments","lastCaseSegments","makeSwitchCaseBody","isEmpty","isDefault","pushTryContext","lastOfTryIsReachable","lastOfCatchIsReachable","popTryContext","normalSegments","slice","leavingSegments","makeUnreachable","makeCatchBlock","thrownSegments","makeFinallyBlock","headOfLeavingSegments","count","prevSegsOfLeavingSegment","j","segmentsList","newNext","next","makeFirstThrowablePathInTryBlock","pushLoopContext","type","continueDestSegments","entrySegments","continueForkContext","endOfInitSegments","testSegments","updateSegments","endOfUpdateSegments","leftSegments","endOfLeftSegments","popLoopContext","makeWhileTest","makeWhileBody","makeDoWhileBody","bodySegments","makeDoWhileTest","makeForTest","makeForUpdate","makeDisconnected","makeForBody","makeForInOfLeft","makeForInOfRight","temp","rightSegments","makeForInOfBody","makeBreak","makeContinue","makeReturn","makeThrow","makeFinal","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/linter/code-path-analysis/code-path-state.js"],"sourcesContent":["/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathSegment = require(\"./code-path-segment\"),\n    ForkContext = require(\"./fork-context\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not includes the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments Segments to add.\n * @returns {void}\n */\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n    for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        dest.push(segment);\n        if (!others.includes(segment)) {\n            all.push(segment);\n        }\n    }\n}\n\n/**\n * Gets a loop-context for a `continue` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\nfunction getContinueContext(state, label) {\n    if (!label) {\n        return state.loopContext;\n    }\n\n    let context = state.loopContext;\n\n    while (context) {\n        if (context.label === label) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* c8 ignore next */\n    return null;\n}\n\n/**\n * Gets a context for a `break` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `break` statement.\n * @returns {LoopContext|SwitchContext} A context for a `break` statement.\n */\nfunction getBreakContext(state, label) {\n    let context = state.breakContext;\n\n    while (context) {\n        if (label ? context.label === label : context.breakable) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* c8 ignore next */\n    return null;\n}\n\n/**\n * Gets a context for a `return` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\nfunction getReturnContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.hasFinalizer && context.position !== \"finally\") {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Gets a context for a `throw` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\nfunction getThrowContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.position === \"try\" ||\n            (context.hasFinalizer && context.position === \"catch\")\n        ) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Removes a given element from a given array.\n * @param {any[]} xs An array to remove the specific element.\n * @param {any} x An element to be removed.\n * @returns {void}\n */\nfunction remove(xs, x) {\n    xs.splice(xs.indexOf(x), 1);\n}\n\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.\n * @returns {void}\n */\nfunction removeConnection(prevSegments, nextSegments) {\n    for (let i = 0; i < prevSegments.length; ++i) {\n        const prevSegment = prevSegments[i];\n        const nextSegment = nextSegments[i];\n\n        remove(prevSegment.nextSegments, nextSegment);\n        remove(prevSegment.allNextSegments, nextSegment);\n        remove(nextSegment.prevSegments, prevSegment);\n        remove(nextSegment.allPrevSegments, prevSegment);\n    }\n}\n\n/**\n * Creates looping path.\n * @param {CodePathState} state The instance.\n * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.\n * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.\n * @returns {void}\n */\nfunction makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {\n    const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);\n    const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);\n\n    const end = Math.min(fromSegments.length, toSegments.length);\n\n    for (let i = 0; i < end; ++i) {\n        const fromSegment = fromSegments[i];\n        const toSegment = toSegments[i];\n\n        if (toSegment.reachable) {\n            fromSegment.nextSegments.push(toSegment);\n        }\n        if (fromSegment.reachable) {\n            toSegment.prevSegments.push(fromSegment);\n        }\n        fromSegment.allNextSegments.push(toSegment);\n        toSegment.allPrevSegments.push(fromSegment);\n\n        if (toSegment.allPrevSegments.length >= 2) {\n            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n        }\n\n        state.notifyLooped(fromSegment, toSegment);\n    }\n}\n\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n * @param {LoopContext} context A loop context to modify.\n * @param {ChoiceContext} choiceContext A choice context of this loop.\n * @param {CodePathSegment[]} head The current head paths.\n * @returns {void}\n */\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n    if (!choiceContext.processed) {\n        choiceContext.trueForkContext.add(head);\n        choiceContext.falseForkContext.add(head);\n        choiceContext.qqForkContext.add(head);\n    }\n\n    if (context.test !== true) {\n        context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n */\nclass CodePathState {\n\n    /**\n     * @param {IdGenerator} idGenerator An id generator to generate id for code\n     *   path segments.\n     * @param {Function} onLooped A callback function to notify looping.\n     */\n    constructor(idGenerator, onLooped) {\n        this.idGenerator = idGenerator;\n        this.notifyLooped = onLooped;\n        this.forkContext = ForkContext.newRoot(idGenerator);\n        this.choiceContext = null;\n        this.switchContext = null;\n        this.tryContext = null;\n        this.loopContext = null;\n        this.breakContext = null;\n        this.chainContext = null;\n\n        this.currentSegments = [];\n        this.initialSegment = this.forkContext.head[0];\n\n        // returnedSegments and thrownSegments push elements into finalSegments also.\n        const final = this.finalSegments = [];\n        const returned = this.returnedForkContext = [];\n        const thrown = this.thrownForkContext = [];\n\n        returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n        thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get headSegments() {\n        return this.forkContext.head;\n    }\n\n    /**\n     * The parent forking context.\n     * This is used for the root of new forks.\n     * @type {ForkContext}\n     */\n    get parentForkContext() {\n        const current = this.forkContext;\n\n        return current && current.upper;\n    }\n\n    /**\n     * Creates and stacks new forking context.\n     * @param {boolean} forkLeavingPath A flag which shows being in a\n     *   \"finally\" block.\n     * @returns {ForkContext} The created context.\n     */\n    pushForkContext(forkLeavingPath) {\n        this.forkContext = ForkContext.newEmpty(\n            this.forkContext,\n            forkLeavingPath\n        );\n\n        return this.forkContext;\n    }\n\n    /**\n     * Pops and merges the last forking context.\n     * @returns {ForkContext} The last context.\n     */\n    popForkContext() {\n        const lastContext = this.forkContext;\n\n        this.forkContext = lastContext.upper;\n        this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n\n        return lastContext;\n    }\n\n    /**\n     * Creates a new path.\n     * @returns {void}\n     */\n    forkPath() {\n        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n    }\n\n    /**\n     * Creates a bypass path.\n     * This is used for such as IfStatement which does not have \"else\" chunk.\n     * @returns {void}\n     */\n    forkBypassPath() {\n        this.forkContext.add(this.parentForkContext.head);\n    }\n\n    //--------------------------------------------------------------------------\n    // ConditionalExpression, LogicalExpression, IfStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),\n     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n     *\n     * LogicalExpressions have cases that it goes different paths between the\n     * `true` case and the `false` case.\n     *\n     * For Example:\n     *\n     *     if (a || b) {\n     *         foo();\n     *     } else {\n     *         bar();\n     *     }\n     *\n     * In this case, `b` is evaluated always in the code path of the `else`\n     * block, but it's not so in the code path of the `if` block.\n     * So there are 3 paths.\n     *\n     *     a -> foo();\n     *     a -> b -> foo();\n     *     a -> b -> bar();\n     * @param {string} kind A kind string.\n     *   If the new context is LogicalExpression's or AssignmentExpression's, this is `\"&&\"` or `\"||\"` or `\"??\"`.\n     *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n     *   Otherwise, this is `\"loop\"`.\n     * @param {boolean} isForkingAsResult A flag that shows that goes different\n     *   paths between `true` and `false`.\n     * @returns {void}\n     */\n    pushChoiceContext(kind, isForkingAsResult) {\n        this.choiceContext = {\n            upper: this.choiceContext,\n            kind,\n            isForkingAsResult,\n            trueForkContext: ForkContext.newEmpty(this.forkContext),\n            falseForkContext: ForkContext.newEmpty(this.forkContext),\n            qqForkContext: ForkContext.newEmpty(this.forkContext),\n            processed: false\n        };\n    }\n\n    /**\n     * Pops the last choice context and finalizes it.\n     * @throws {Error} (Unreachable.)\n     * @returns {ChoiceContext} The popped context.\n     */\n    popChoiceContext() {\n        const context = this.choiceContext;\n\n        this.choiceContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const headSegments = forkContext.head;\n\n        switch (context.kind) {\n            case \"&&\":\n            case \"||\":\n            case \"??\":\n\n                /*\n                 * If any result were not transferred from child contexts,\n                 * this sets the head segments to both cases.\n                 * The head segments are the path of the right-hand operand.\n                 */\n                if (!context.processed) {\n                    context.trueForkContext.add(headSegments);\n                    context.falseForkContext.add(headSegments);\n                    context.qqForkContext.add(headSegments);\n                }\n\n                /*\n                 * Transfers results to upper context if this context is in\n                 * test chunk.\n                 */\n                if (context.isForkingAsResult) {\n                    const parentContext = this.choiceContext;\n\n                    parentContext.trueForkContext.addAll(context.trueForkContext);\n                    parentContext.falseForkContext.addAll(context.falseForkContext);\n                    parentContext.qqForkContext.addAll(context.qqForkContext);\n                    parentContext.processed = true;\n\n                    return context;\n                }\n\n                break;\n\n            case \"test\":\n                if (!context.processed) {\n\n                    /*\n                     * The head segments are the path of the `if` block here.\n                     * Updates the `true` path with the end of the `if` block.\n                     */\n                    context.trueForkContext.clear();\n                    context.trueForkContext.add(headSegments);\n                } else {\n\n                    /*\n                     * The head segments are the path of the `else` block here.\n                     * Updates the `false` path with the end of the `else`\n                     * block.\n                     */\n                    context.falseForkContext.clear();\n                    context.falseForkContext.add(headSegments);\n                }\n\n                break;\n\n            case \"loop\":\n\n                /*\n                 * Loops are addressed in popLoopContext().\n                 * This is called from popLoopContext().\n                 */\n                return context;\n\n            /* c8 ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Merges all paths.\n        const prevForkContext = context.trueForkContext;\n\n        prevForkContext.addAll(context.falseForkContext);\n        forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n\n        return context;\n    }\n\n    /**\n     * Makes a code path segment of the right-hand operand of a logical\n     * expression.\n     * @throws {Error} (Unreachable.)\n     * @returns {void}\n     */\n    makeLogicalRight() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (context.processed) {\n\n            /*\n             * This got segments already from the child choice context.\n             * Creates the next path from own true/false fork context.\n             */\n            let prevForkContext;\n\n            switch (context.kind) {\n                case \"&&\": // if true then go to the right-hand side.\n                    prevForkContext = context.trueForkContext;\n                    break;\n                case \"||\": // if false then go to the right-hand side.\n                    prevForkContext = context.falseForkContext;\n                    break;\n                case \"??\": // Both true/false can short-circuit, so needs the third path to go to the right-hand side. That's qqForkContext.\n                    prevForkContext = context.qqForkContext;\n                    break;\n                default:\n                    throw new Error(\"unreachable\");\n            }\n\n            forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n            prevForkContext.clear();\n            context.processed = false;\n        } else {\n\n            /*\n             * This did not get segments from the child choice context.\n             * So addresses the head segments.\n             * The head segments are the path of the left-hand operand.\n             */\n            switch (context.kind) {\n                case \"&&\": // the false path can short-circuit.\n                    context.falseForkContext.add(forkContext.head);\n                    break;\n                case \"||\": // the true path can short-circuit.\n                    context.trueForkContext.add(forkContext.head);\n                    break;\n                case \"??\": // both can short-circuit.\n                    context.trueForkContext.add(forkContext.head);\n                    context.falseForkContext.add(forkContext.head);\n                    break;\n                default:\n                    throw new Error(\"unreachable\");\n            }\n\n            forkContext.replaceHead(forkContext.makeNext(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment of the `if` block.\n     * @returns {void}\n     */\n    makeIfConsequent() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * If any result were not transferred from child contexts,\n         * this sets the head segments to both cases.\n         * The head segments are the path of the test expression.\n         */\n        if (!context.processed) {\n            context.trueForkContext.add(forkContext.head);\n            context.falseForkContext.add(forkContext.head);\n            context.qqForkContext.add(forkContext.head);\n        }\n\n        context.processed = false;\n\n        // Creates new path from the `true` case.\n        forkContext.replaceHead(\n            context.trueForkContext.makeNext(0, -1)\n        );\n    }\n\n    /**\n     * Makes a code path segment of the `else` block.\n     * @returns {void}\n     */\n    makeIfAlternate() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * The head segments are the path of the `if` block.\n         * Updates the `true` path with the end of the `if` block.\n         */\n        context.trueForkContext.clear();\n        context.trueForkContext.add(forkContext.head);\n        context.processed = true;\n\n        // Creates new path from the `false` case.\n        forkContext.replaceHead(\n            context.falseForkContext.makeNext(0, -1)\n        );\n    }\n\n    //--------------------------------------------------------------------------\n    // ChainExpression\n    //--------------------------------------------------------------------------\n\n    /**\n     * Push a new `ChainExpression` context to the stack.\n     * This method is called on entering to each `ChainExpression` node.\n     * This context is used to count forking in the optional chain then merge them on the exiting from the `ChainExpression` node.\n     * @returns {void}\n     */\n    pushChainContext() {\n        this.chainContext = {\n            upper: this.chainContext,\n            countChoiceContexts: 0\n        };\n    }\n\n    /**\n     * Pop a `ChainExpression` context from the stack.\n     * This method is called on exiting from each `ChainExpression` node.\n     * This merges all forks of the last optional chaining.\n     * @returns {void}\n     */\n    popChainContext() {\n        const context = this.chainContext;\n\n        this.chainContext = context.upper;\n\n        // pop all choice contexts of this.\n        for (let i = context.countChoiceContexts; i > 0; --i) {\n            this.popChoiceContext();\n        }\n    }\n\n    /**\n     * Create a choice context for optional access.\n     * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.\n     * This creates a choice context as similar to `LogicalExpression[operator=\"??\"]` node.\n     * @returns {void}\n     */\n    makeOptionalNode() {\n        if (this.chainContext) {\n            this.chainContext.countChoiceContexts += 1;\n            this.pushChoiceContext(\"??\", false);\n        }\n    }\n\n    /**\n     * Create a fork.\n     * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.\n     * @returns {void}\n     */\n    makeOptionalRight() {\n        if (this.chainContext) {\n            this.makeLogicalRight();\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // SwitchStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of SwitchStatement and stacks it.\n     * @param {boolean} hasCase `true` if the switch statement has one or more\n     *   case parts.\n     * @param {string|null} label The label text.\n     * @returns {void}\n     */\n    pushSwitchContext(hasCase, label) {\n        this.switchContext = {\n            upper: this.switchContext,\n            hasCase,\n            defaultSegments: null,\n            defaultBodySegments: null,\n            foundDefault: false,\n            lastIsDefault: false,\n            countForks: 0\n        };\n\n        this.pushBreakContext(true, label);\n    }\n\n    /**\n     * Pops the last context of SwitchStatement and finalizes it.\n     *\n     * - Disposes all forking stack for `case` and `default`.\n     * - Creates the next code path segment from `context.brokenForkContext`.\n     * - If the last `SwitchCase` node is not a `default` part, creates a path\n     *   to the `default` body.\n     * @returns {void}\n     */\n    popSwitchContext() {\n        const context = this.switchContext;\n\n        this.switchContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        if (context.countForks === 0) {\n\n            /*\n             * When there is only one `default` chunk and there is one or more\n             * `break` statements, even if forks are nothing, it needs to merge\n             * those.\n             */\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.makeNext(-1, -1));\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n\n            return;\n        }\n\n        const lastSegments = forkContext.head;\n\n        this.forkBypassPath();\n        const lastCaseSegments = forkContext.head;\n\n        /*\n         * `brokenForkContext` is used to make the next segment.\n         * It must add the last segment into `brokenForkContext`.\n         */\n        brokenForkContext.add(lastSegments);\n\n        /*\n         * A path which is failed in all case test should be connected to path\n         * of `default` chunk.\n         */\n        if (!context.lastIsDefault) {\n            if (context.defaultBodySegments) {\n\n                /*\n                 * Remove a link from `default` label to its chunk.\n                 * It's false route.\n                 */\n                removeConnection(context.defaultSegments, context.defaultBodySegments);\n                makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n            } else {\n\n                /*\n                 * It handles the last case body as broken if `default` chunk\n                 * does not exist.\n                 */\n                brokenForkContext.add(lastCaseSegments);\n            }\n        }\n\n        // Pops the segment context stack until the entry segment.\n        for (let i = 0; i < context.countForks; ++i) {\n            this.forkContext = this.forkContext.upper;\n        }\n\n        /*\n         * Creates a path from all brokenForkContext paths.\n         * This is a path after switch statement.\n         */\n        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for a `SwitchCase` node.\n     * @param {boolean} isEmpty `true` if the body is empty.\n     * @param {boolean} isDefault `true` if the body is the default case.\n     * @returns {void}\n     */\n    makeSwitchCaseBody(isEmpty, isDefault) {\n        const context = this.switchContext;\n\n        if (!context.hasCase) {\n            return;\n        }\n\n        /*\n         * Merge forks.\n         * The parent fork context has two segments.\n         * Those are from the current case and the body of the previous case.\n         */\n        const parentForkContext = this.forkContext;\n        const forkContext = this.pushForkContext();\n\n        forkContext.add(parentForkContext.makeNext(0, -1));\n\n        /*\n         * Save `default` chunk info.\n         * If the `default` label is not at the last, we must make a path from\n         * the last `case` to the `default` chunk.\n         */\n        if (isDefault) {\n            context.defaultSegments = parentForkContext.head;\n            if (isEmpty) {\n                context.foundDefault = true;\n            } else {\n                context.defaultBodySegments = forkContext.head;\n            }\n        } else {\n            if (!isEmpty && context.foundDefault) {\n                context.foundDefault = false;\n                context.defaultBodySegments = forkContext.head;\n            }\n        }\n\n        context.lastIsDefault = isDefault;\n        context.countForks += 1;\n    }\n\n    //--------------------------------------------------------------------------\n    // TryStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of TryStatement and stacks it.\n     * @param {boolean} hasFinalizer `true` if the try statement has a\n     *   `finally` block.\n     * @returns {void}\n     */\n    pushTryContext(hasFinalizer) {\n        this.tryContext = {\n            upper: this.tryContext,\n            position: \"try\",\n            hasFinalizer,\n\n            returnedForkContext: hasFinalizer\n                ? ForkContext.newEmpty(this.forkContext)\n                : null,\n\n            thrownForkContext: ForkContext.newEmpty(this.forkContext),\n            lastOfTryIsReachable: false,\n            lastOfCatchIsReachable: false\n        };\n    }\n\n    /**\n     * Pops the last context of TryStatement and finalizes it.\n     * @returns {void}\n     */\n    popTryContext() {\n        const context = this.tryContext;\n\n        this.tryContext = context.upper;\n\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block merely.\n            this.popForkContext();\n            return;\n        }\n\n        /*\n         * The following process is executed only when there is the `finally`\n         * block.\n         */\n\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n\n        if (returned.empty && thrown.empty) {\n            return;\n        }\n\n        // Separate head to normal paths and leaving paths.\n        const headSegments = this.forkContext.head;\n\n        this.forkContext = this.forkContext.upper;\n        const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n        const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);\n\n        // Forwards the leaving path to upper contexts.\n        if (!returned.empty) {\n            getReturnContext(this).returnedForkContext.add(leavingSegments);\n        }\n        if (!thrown.empty) {\n            getThrowContext(this).thrownForkContext.add(leavingSegments);\n        }\n\n        // Sets the normal path as the next.\n        this.forkContext.replaceHead(normalSegments);\n\n        /*\n         * If both paths of the `try` block and the `catch` block are\n         * unreachable, the next path becomes unreachable as well.\n         */\n        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n            this.forkContext.makeUnreachable();\n        }\n    }\n\n    /**\n     * Makes a code path segment for a `catch` block.\n     * @returns {void}\n     */\n    makeCatchBlock() {\n        const context = this.tryContext;\n        const forkContext = this.forkContext;\n        const thrown = context.thrownForkContext;\n\n        // Update state.\n        context.position = \"catch\";\n        context.thrownForkContext = ForkContext.newEmpty(forkContext);\n        context.lastOfTryIsReachable = forkContext.reachable;\n\n        // Merge thrown paths.\n        thrown.add(forkContext.head);\n        const thrownSegments = thrown.makeNext(0, -1);\n\n        // Fork to a bypass and the merged thrown path.\n        this.pushForkContext();\n        this.forkBypassPath();\n        this.forkContext.add(thrownSegments);\n    }\n\n    /**\n     * Makes a code path segment for a `finally` block.\n     *\n     * In the `finally` block, parallel paths are created. The parallel paths\n     * are used as leaving-paths. The leaving-paths are paths from `return`\n     * statements and `throw` statements in a `try` block or a `catch` block.\n     * @returns {void}\n     */\n    makeFinallyBlock() {\n        const context = this.tryContext;\n        let forkContext = this.forkContext;\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n        const headOfLeavingSegments = forkContext.head;\n\n        // Update state.\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block.\n            this.popForkContext();\n            forkContext = this.forkContext;\n\n            context.lastOfCatchIsReachable = forkContext.reachable;\n        } else {\n            context.lastOfTryIsReachable = forkContext.reachable;\n        }\n        context.position = \"finally\";\n\n        if (returned.empty && thrown.empty) {\n\n            // This path does not leave.\n            return;\n        }\n\n        /*\n         * Create a parallel segment from merging returned and thrown.\n         * This segment will leave at the end of this finally block.\n         */\n        const segments = forkContext.makeNext(-1, -1);\n\n        for (let i = 0; i < forkContext.count; ++i) {\n            const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n\n            for (let j = 0; j < returned.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\n            }\n            for (let j = 0; j < thrown.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\n            }\n\n            segments.push(\n                CodePathSegment.newNext(\n                    this.idGenerator.next(),\n                    prevSegsOfLeavingSegment\n                )\n            );\n        }\n\n        this.pushForkContext(true);\n        this.forkContext.add(segments);\n    }\n\n    /**\n     * Makes a code path segment from the first throwable node to the `catch`\n     * block or the `finally` block.\n     * @returns {void}\n     */\n    makeFirstThrowablePathInTryBlock() {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getThrowContext(this);\n\n        if (context === this ||\n            context.position !== \"try\" ||\n            !context.thrownForkContext.empty\n        ) {\n            return;\n        }\n\n        context.thrownForkContext.add(forkContext.head);\n        forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n\n    //--------------------------------------------------------------------------\n    // Loop Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of a loop statement and stacks it.\n     * @param {string} type The type of the node which was triggered. One of\n     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n     *   and `ForStatement`.\n     * @param {string|null} label A label of the node which was triggered.\n     * @throws {Error} (Unreachable - unknown type.)\n     * @returns {void}\n     */\n    pushLoopContext(type, label) {\n        const forkContext = this.forkContext;\n        const breakContext = this.pushBreakContext(true, label);\n\n        switch (type) {\n            case \"WhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"DoWhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    entrySegments: null,\n                    continueForkContext: ForkContext.newEmpty(forkContext),\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    endOfInitSegments: null,\n                    testSegments: null,\n                    endOfTestSegments: null,\n                    updateSegments: null,\n                    endOfUpdateSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    prevSegments: null,\n                    leftSegments: null,\n                    endOfLeftSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            /* c8 ignore next */\n            default:\n                throw new Error(`unknown type: \"${type}\"`);\n        }\n    }\n\n    /**\n     * Pops the last context of a loop statement and finalizes it.\n     * @throws {Error} (Unreachable - unknown type.)\n     * @returns {void}\n     */\n    popLoopContext() {\n        const context = this.loopContext;\n\n        this.loopContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        // Creates a looped path.\n        switch (context.type) {\n            case \"WhileStatement\":\n            case \"ForStatement\":\n                this.popChoiceContext();\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.continueDestSegments\n                );\n                break;\n\n            case \"DoWhileStatement\": {\n                const choiceContext = this.popChoiceContext();\n\n                if (!choiceContext.processed) {\n                    choiceContext.trueForkContext.add(forkContext.head);\n                    choiceContext.falseForkContext.add(forkContext.head);\n                }\n                if (context.test !== true) {\n                    brokenForkContext.addAll(choiceContext.falseForkContext);\n                }\n\n                // `true` paths go to looping.\n                const segmentsList = choiceContext.trueForkContext.segmentsList;\n\n                for (let i = 0; i < segmentsList.length; ++i) {\n                    makeLooped(\n                        this,\n                        segmentsList[i],\n                        context.entrySegments\n                    );\n                }\n                break;\n            }\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                brokenForkContext.add(forkContext.head);\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.leftSegments\n                );\n                break;\n\n            /* c8 ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Go next.\n        if (brokenForkContext.empty) {\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        } else {\n            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a WhileStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const testSegments = forkContext.makeNext(0, -1);\n\n        // Update state.\n        context.test = test;\n        context.continueDestSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a WhileStatement.\n     * @returns {void}\n     */\n    makeWhileBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n        }\n\n        // Update state.\n        if (context.test !== true) {\n            context.brokenForkContext.addAll(choiceContext.falseForkContext);\n        }\n        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for the body part of a DoWhileStatement.\n     * @returns {void}\n     */\n    makeDoWhileBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const bodySegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.entrySegments = bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the test part of a DoWhileStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeDoWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n\n        context.test = test;\n\n        // Creates paths of `continue` statements.\n        if (!context.continueForkContext.empty) {\n            context.continueForkContext.add(forkContext.head);\n            const testSegments = context.continueForkContext.makeNext(0, -1);\n\n            forkContext.replaceHead(testSegments);\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a ForStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeForTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const endOfInitSegments = forkContext.head;\n        const testSegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.test = test;\n        context.endOfInitSegments = endOfInitSegments;\n        context.continueDestSegments = context.testSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the update part of a ForStatement.\n     * @returns {void}\n     */\n    makeForUpdate() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Make the next paths of the test.\n        if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head\n            );\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        // Update state.\n        const updateSegments = forkContext.makeDisconnected(-1, -1);\n\n        context.continueDestSegments = context.updateSegments = updateSegments;\n        forkContext.replaceHead(updateSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForStatement.\n     * @returns {void}\n     */\n    makeForBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Update state.\n        if (context.updateSegments) {\n            context.endOfUpdateSegments = forkContext.head;\n\n            // `update` -> `test`\n            if (context.testSegments) {\n                makeLooped(\n                    this,\n                    context.endOfUpdateSegments,\n                    context.testSegments\n                );\n            }\n        } else if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head\n            );\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        let bodySegments = context.endOfTestSegments;\n\n        if (!bodySegments) {\n\n            /*\n             * If there is not the `test` part, the `body` path comes from the\n             * `init` part and the `update` part.\n             */\n            const prevForkContext = ForkContext.newEmpty(forkContext);\n\n            prevForkContext.add(context.endOfInitSegments);\n            if (context.endOfUpdateSegments) {\n                prevForkContext.add(context.endOfUpdateSegments);\n            }\n\n            bodySegments = prevForkContext.makeNext(0, -1);\n        }\n        context.continueDestSegments = context.continueDestSegments || bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the left part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfLeft() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const leftSegments = forkContext.makeDisconnected(-1, -1);\n\n        // Update state.\n        context.prevSegments = forkContext.head;\n        context.leftSegments = context.continueDestSegments = leftSegments;\n        forkContext.replaceHead(leftSegments);\n    }\n\n    /**\n     * Makes a code path segment for the right part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfRight() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.prevSegments);\n        const rightSegments = temp.makeNext(-1, -1);\n\n        // Update state.\n        context.endOfLeftSegments = forkContext.head;\n        forkContext.replaceHead(rightSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.endOfLeftSegments);\n        const bodySegments = temp.makeNext(-1, -1);\n\n        // Make a path: `right` -> `left`.\n        makeLooped(this, forkContext.head, context.leftSegments);\n\n        // Update state.\n        context.brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(bodySegments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Control Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates new context for BreakStatement.\n     * @param {boolean} breakable The flag to indicate it can break by\n     *      an unlabeled BreakStatement.\n     * @param {string|null} label The label of this context.\n     * @returns {Object} The new context.\n     */\n    pushBreakContext(breakable, label) {\n        this.breakContext = {\n            upper: this.breakContext,\n            breakable,\n            label,\n            brokenForkContext: ForkContext.newEmpty(this.forkContext)\n        };\n        return this.breakContext;\n    }\n\n    /**\n     * Removes the top item of the break context stack.\n     * @returns {Object} The removed context.\n     */\n    popBreakContext() {\n        const context = this.breakContext;\n        const forkContext = this.forkContext;\n\n        this.breakContext = context.upper;\n\n        // Process this context here for other than switches and loops.\n        if (!context.breakable) {\n            const brokenForkContext = context.brokenForkContext;\n\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.head);\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n        }\n\n        return context;\n    }\n\n    /**\n     * Makes a path for a `break` statement.\n     *\n     * It registers the head segment to a context of `break`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @param {string} label A label of the break statement.\n     * @returns {void}\n     */\n    makeBreak(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getBreakContext(this, label);\n\n\n        if (context) {\n            context.brokenForkContext.add(forkContext.head);\n        }\n\n        /* c8 ignore next */\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `continue` statement.\n     *\n     * It makes a looping path.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @param {string} label A label of the continue statement.\n     * @returns {void}\n     */\n    makeContinue(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getContinueContext(this, label);\n\n        if (context) {\n            if (context.continueDestSegments) {\n                makeLooped(this, forkContext.head, context.continueDestSegments);\n\n                // If the context is a for-in/of loop, this effects a break also.\n                if (context.type === \"ForInStatement\" ||\n                    context.type === \"ForOfStatement\"\n                ) {\n                    context.brokenForkContext.add(forkContext.head);\n                }\n            } else {\n                context.continueForkContext.add(forkContext.head);\n            }\n        }\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `return` statement.\n     *\n     * It registers the head segment to a context of `return`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @returns {void}\n     */\n    makeReturn() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getReturnContext(this).returnedForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a path for a `throw` statement.\n     *\n     * It registers the head segment to a context of `throw`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @returns {void}\n     */\n    makeThrow() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getThrowContext(this).thrownForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes the final path.\n     * @returns {void}\n     */\n    makeFinal() {\n        const segments = this.currentSegments;\n\n        if (segments.length > 0 && segments[0].reachable) {\n            this.returnedForkContext.add(segments);\n        }\n    }\n}\n\nmodule.exports = CodePathState;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}