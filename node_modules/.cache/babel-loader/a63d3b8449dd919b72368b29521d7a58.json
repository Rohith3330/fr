{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tsutils_1 = require(\"tsutils\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util_1 = require(\"../util\");\n\nexports.default = (0, util_1.createRule)({\n  name: 'switch-exhaustiveness-check',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Require switch-case statements to be exhaustive with union type',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    hasSuggestions: true,\n    schema: [],\n    messages: {\n      switchIsNotExhaustive: 'Switch is not exhaustive. Cases not matched: {{missingBranches}}',\n      addMissingCases: 'Add branches for missing cases.'\n    }\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const service = (0, util_1.getParserServices)(context);\n    const checker = service.program.getTypeChecker();\n    const compilerOptions = service.program.getCompilerOptions();\n\n    function getNodeType(node) {\n      const tsNode = service.esTreeNodeToTSNodeMap.get(node);\n      return (0, util_1.getConstrainedTypeAtLocation)(checker, tsNode);\n    }\n\n    function fixSwitch(fixer, node, missingBranchTypes, symbolName) {\n      var _a;\n\n      const lastCase = node.cases.length > 0 ? node.cases[node.cases.length - 1] : null;\n      const caseIndent = lastCase ? ' '.repeat(lastCase.loc.start.column) : // if there are no cases, use indentation of the switch statement\n      // and leave it to user to format it correctly\n      ' '.repeat(node.loc.start.column);\n      const missingCases = [];\n\n      for (const missingBranchType of missingBranchTypes) {\n        // While running this rule on checker.ts of TypeScript project\n        // the fix introduced a compiler error due to:\n        //\n        // type __String = (string & {\n        //         __escapedIdentifier: void;\n        //     }) | (void & {\n        //         __escapedIdentifier: void;\n        //     }) | InternalSymbolName;\n        //\n        // The following check fixes it.\n        if (missingBranchType.isIntersection()) {\n          continue;\n        }\n\n        const missingBranchName = (_a = missingBranchType.getSymbol()) === null || _a === void 0 ? void 0 : _a.escapedName;\n        let caseTest = checker.typeToString(missingBranchType);\n\n        if (symbolName && (missingBranchName || missingBranchName === '') && (0, util_1.requiresQuoting)(missingBranchName.toString(), compilerOptions.target)) {\n          caseTest = `${symbolName}['${missingBranchName}']`;\n        }\n\n        const errorMessage = `Not implemented yet: ${caseTest} case`;\n        missingCases.push(`case ${caseTest}: { throw new Error('${errorMessage}') }`);\n      }\n\n      const fixString = missingCases.map(code => `${caseIndent}${code}`).join('\\n');\n\n      if (lastCase) {\n        return fixer.insertTextAfter(lastCase, `\\n${fixString}`);\n      } // there were no existing cases\n\n\n      const openingBrace = sourceCode.getTokenAfter(node.discriminant, util_1.isOpeningBraceToken);\n      const closingBrace = sourceCode.getTokenAfter(node.discriminant, util_1.isClosingBraceToken);\n      return fixer.replaceTextRange([openingBrace.range[0], closingBrace.range[1]], ['{', fixString, `${caseIndent}}`].join('\\n'));\n    }\n\n    function checkSwitchExhaustive(node) {\n      var _a;\n\n      const discriminantType = getNodeType(node.discriminant);\n      const symbolName = (_a = discriminantType.getSymbol()) === null || _a === void 0 ? void 0 : _a.escapedName;\n\n      if (discriminantType.isUnion()) {\n        const unionTypes = (0, tsutils_1.unionTypeParts)(discriminantType);\n        const caseTypes = new Set();\n\n        for (const switchCase of node.cases) {\n          if (switchCase.test === null) {\n            // Switch has 'default' branch - do nothing.\n            return;\n          }\n\n          caseTypes.add(getNodeType(switchCase.test));\n        }\n\n        const missingBranchTypes = unionTypes.filter(unionType => !caseTypes.has(unionType));\n\n        if (missingBranchTypes.length === 0) {\n          // All cases matched - do nothing.\n          return;\n        }\n\n        context.report({\n          node: node.discriminant,\n          messageId: 'switchIsNotExhaustive',\n          data: {\n            missingBranches: missingBranchTypes.map(missingType => {\n              var _a;\n\n              return (0, tsutils_1.isTypeFlagSet)(missingType, ts.TypeFlags.ESSymbolLike) ? `typeof ${(_a = missingType.getSymbol()) === null || _a === void 0 ? void 0 : _a.escapedName}` : checker.typeToString(missingType);\n            }).join(' | ')\n          },\n          suggest: [{\n            messageId: 'addMissingCases',\n\n            fix(fixer) {\n              return fixSwitch(fixer, node, missingBranchTypes, symbolName === null || symbolName === void 0 ? void 0 : symbolName.toString());\n            }\n\n          }]\n        });\n      }\n    }\n\n    return {\n      SwitchStatement: checkSwitchExhaustive\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","name","meta","type","docs","description","recommended","requiresTypeChecking","hasSuggestions","schema","messages","switchIsNotExhaustive","addMissingCases","defaultOptions","create","context","sourceCode","getSourceCode","service","checker","program","getTypeChecker","compilerOptions","getCompilerOptions","getNodeType","node","tsNode","esTreeNodeToTSNodeMap","get","fixSwitch","fixer","missingBranchTypes","symbolName","lastCase","cases","length","caseIndent","repeat","loc","start","column","missingCases","missingBranchType","isIntersection","missingBranchName","getSymbol","_a","escapedName","caseTest","typeToString","toString","target","errorMessage","push","fixString","map","code","join","insertTextAfter","openingBrace","getTokenAfter","discriminant","util_1","closingBrace","replaceTextRange","range","checkSwitchExhaustive","discriminantType","isUnion","unionTypes","caseTypes","Set","switchCase","test","add","filter","unionType","has","report","messageId","data","missingBranches","missingType","ts","TypeFlags","ESSymbolLike","suggest","fix","SwitchStatement"],"sources":["../../src/rules/switch-exhaustiveness-check.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}