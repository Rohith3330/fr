{"ast":null,"code":"const flagSymbol = Symbol('arg flag');\n\nclass ArgError extends Error {\n  constructor(msg, code) {\n    super(msg);\n    this.name = 'ArgError';\n    this.code = code;\n    Object.setPrototypeOf(this, ArgError.prototype);\n  }\n\n}\n\nfunction arg(opts) {\n  let {\n    argv = process.argv.slice(2),\n    permissive = false,\n    stopAtPositional = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!opts) {\n    throw new ArgError('argument specification object is required', 'ARG_CONFIG_NO_SPEC');\n  }\n\n  const result = {\n    _: []\n  };\n  const aliases = {};\n  const handlers = {};\n\n  for (const key of Object.keys(opts)) {\n    if (!key) {\n      throw new ArgError('argument key cannot be an empty string', 'ARG_CONFIG_EMPTY_KEY');\n    }\n\n    if (key[0] !== '-') {\n      throw new ArgError(`argument key must start with '-' but found: '${key}'`, 'ARG_CONFIG_NONOPT_KEY');\n    }\n\n    if (key.length === 1) {\n      throw new ArgError(`argument key must have a name; singular '-' keys are not allowed: ${key}`, 'ARG_CONFIG_NONAME_KEY');\n    }\n\n    if (typeof opts[key] === 'string') {\n      aliases[key] = opts[key];\n      continue;\n    }\n\n    let type = opts[key];\n    let isFlag = false;\n\n    if (Array.isArray(type) && type.length === 1 && typeof type[0] === 'function') {\n      const [fn] = type;\n\n      type = function (value, name) {\n        let prev = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        prev.push(fn(value, name, prev[prev.length - 1]));\n        return prev;\n      };\n\n      isFlag = fn === Boolean || fn[flagSymbol] === true;\n    } else if (typeof type === 'function') {\n      isFlag = type === Boolean || type[flagSymbol] === true;\n    } else {\n      throw new ArgError(`type missing or not a function or valid array type: ${key}`, 'ARG_CONFIG_VAD_TYPE');\n    }\n\n    if (key[1] !== '-' && key.length > 2) {\n      throw new ArgError(`short argument keys (with a single hyphen) must have only one character: ${key}`, 'ARG_CONFIG_SHORTOPT_TOOLONG');\n    }\n\n    handlers[key] = [type, isFlag];\n  }\n\n  for (let i = 0, len = argv.length; i < len; i++) {\n    const wholeArg = argv[i];\n\n    if (stopAtPositional && result._.length > 0) {\n      result._ = result._.concat(argv.slice(i));\n      break;\n    }\n\n    if (wholeArg === '--') {\n      result._ = result._.concat(argv.slice(i + 1));\n      break;\n    }\n\n    if (wholeArg.length > 1 && wholeArg[0] === '-') {\n      /* eslint-disable operator-linebreak */\n      const separatedArguments = wholeArg[1] === '-' || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split('').map(a => `-${a}`);\n      /* eslint-enable operator-linebreak */\n\n      for (let j = 0; j < separatedArguments.length; j++) {\n        const arg = separatedArguments[j];\n        const [originalArgName, argStr] = arg[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];\n        let argName = originalArgName;\n\n        while (argName in aliases) {\n          argName = aliases[argName];\n        }\n\n        if (!(argName in handlers)) {\n          if (permissive) {\n            result._.push(arg);\n\n            continue;\n          } else {\n            throw new ArgError(`unknown or unexpected option: ${originalArgName}`, 'ARG_UNKNOWN_OPTION');\n          }\n        }\n\n        const [type, isFlag] = handlers[argName];\n\n        if (!isFlag && j + 1 < separatedArguments.length) {\n          throw new ArgError(`option requires argument (but was followed by another short argument): ${originalArgName}`, 'ARG_MISSING_REQUIRED_SHORTARG');\n        }\n\n        if (isFlag) {\n          result[argName] = type(true, argName, result[argName]);\n        } else if (argStr === undefined) {\n          if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === '-' && !(argv[i + 1].match(/^-?\\d*(\\.(?=\\d))?\\d*$/) && (type === Number || // eslint-disable-next-line no-undef\n          typeof BigInt !== 'undefined' && type === BigInt))) {\n            const extended = originalArgName === argName ? '' : ` (alias for ${argName})`;\n            throw new ArgError(`option requires argument: ${originalArgName}${extended}`, 'ARG_MISSING_REQUIRED_LONGARG');\n          }\n\n          result[argName] = type(argv[i + 1], argName, result[argName]);\n          ++i;\n        } else {\n          result[argName] = type(argStr, argName, result[argName]);\n        }\n      }\n    } else {\n      result._.push(wholeArg);\n    }\n  }\n\n  return result;\n}\n\narg.flag = fn => {\n  fn[flagSymbol] = true;\n  return fn;\n}; // Utility types\n\n\narg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1); // Expose error class\n\narg.ArgError = ArgError;\nmodule.exports = arg;","map":{"version":3,"names":["flagSymbol","Symbol","ArgError","Error","constructor","msg","code","name","Object","setPrototypeOf","prototype","arg","opts","argv","process","slice","permissive","stopAtPositional","result","_","aliases","handlers","key","keys","length","type","isFlag","Array","isArray","fn","value","prev","push","Boolean","i","len","wholeArg","concat","separatedArguments","split","map","a","j","originalArgName","argStr","undefined","argName","match","Number","BigInt","extended","flag","COUNT","v","existingCount","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/arg/index.js"],"sourcesContent":["const flagSymbol = Symbol('arg flag');\n\nclass ArgError extends Error {\n\tconstructor(msg, code) {\n\t\tsuper(msg);\n\t\tthis.name = 'ArgError';\n\t\tthis.code = code;\n\n\t\tObject.setPrototypeOf(this, ArgError.prototype);\n\t}\n}\n\nfunction arg(\n\topts,\n\t{\n\t\targv = process.argv.slice(2),\n\t\tpermissive = false,\n\t\tstopAtPositional = false\n\t} = {}\n) {\n\tif (!opts) {\n\t\tthrow new ArgError(\n\t\t\t'argument specification object is required',\n\t\t\t'ARG_CONFIG_NO_SPEC'\n\t\t);\n\t}\n\n\tconst result = { _: [] };\n\n\tconst aliases = {};\n\tconst handlers = {};\n\n\tfor (const key of Object.keys(opts)) {\n\t\tif (!key) {\n\t\t\tthrow new ArgError(\n\t\t\t\t'argument key cannot be an empty string',\n\t\t\t\t'ARG_CONFIG_EMPTY_KEY'\n\t\t\t);\n\t\t}\n\n\t\tif (key[0] !== '-') {\n\t\t\tthrow new ArgError(\n\t\t\t\t`argument key must start with '-' but found: '${key}'`,\n\t\t\t\t'ARG_CONFIG_NONOPT_KEY'\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tthrow new ArgError(\n\t\t\t\t`argument key must have a name; singular '-' keys are not allowed: ${key}`,\n\t\t\t\t'ARG_CONFIG_NONAME_KEY'\n\t\t\t);\n\t\t}\n\n\t\tif (typeof opts[key] === 'string') {\n\t\t\taliases[key] = opts[key];\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet type = opts[key];\n\t\tlet isFlag = false;\n\n\t\tif (\n\t\t\tArray.isArray(type) &&\n\t\t\ttype.length === 1 &&\n\t\t\ttypeof type[0] === 'function'\n\t\t) {\n\t\t\tconst [fn] = type;\n\t\t\ttype = (value, name, prev = []) => {\n\t\t\t\tprev.push(fn(value, name, prev[prev.length - 1]));\n\t\t\t\treturn prev;\n\t\t\t};\n\t\t\tisFlag = fn === Boolean || fn[flagSymbol] === true;\n\t\t} else if (typeof type === 'function') {\n\t\t\tisFlag = type === Boolean || type[flagSymbol] === true;\n\t\t} else {\n\t\t\tthrow new ArgError(\n\t\t\t\t`type missing or not a function or valid array type: ${key}`,\n\t\t\t\t'ARG_CONFIG_VAD_TYPE'\n\t\t\t);\n\t\t}\n\n\t\tif (key[1] !== '-' && key.length > 2) {\n\t\t\tthrow new ArgError(\n\t\t\t\t`short argument keys (with a single hyphen) must have only one character: ${key}`,\n\t\t\t\t'ARG_CONFIG_SHORTOPT_TOOLONG'\n\t\t\t);\n\t\t}\n\n\t\thandlers[key] = [type, isFlag];\n\t}\n\n\tfor (let i = 0, len = argv.length; i < len; i++) {\n\t\tconst wholeArg = argv[i];\n\n\t\tif (stopAtPositional && result._.length > 0) {\n\t\t\tresult._ = result._.concat(argv.slice(i));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wholeArg === '--') {\n\t\t\tresult._ = result._.concat(argv.slice(i + 1));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wholeArg.length > 1 && wholeArg[0] === '-') {\n\t\t\t/* eslint-disable operator-linebreak */\n\t\t\tconst separatedArguments =\n\t\t\t\twholeArg[1] === '-' || wholeArg.length === 2\n\t\t\t\t\t? [wholeArg]\n\t\t\t\t\t: wholeArg\n\t\t\t\t\t\t\t.slice(1)\n\t\t\t\t\t\t\t.split('')\n\t\t\t\t\t\t\t.map((a) => `-${a}`);\n\t\t\t/* eslint-enable operator-linebreak */\n\n\t\t\tfor (let j = 0; j < separatedArguments.length; j++) {\n\t\t\t\tconst arg = separatedArguments[j];\n\t\t\t\tconst [originalArgName, argStr] =\n\t\t\t\t\targ[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];\n\n\t\t\t\tlet argName = originalArgName;\n\t\t\t\twhile (argName in aliases) {\n\t\t\t\t\targName = aliases[argName];\n\t\t\t\t}\n\n\t\t\t\tif (!(argName in handlers)) {\n\t\t\t\t\tif (permissive) {\n\t\t\t\t\t\tresult._.push(arg);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new ArgError(\n\t\t\t\t\t\t\t`unknown or unexpected option: ${originalArgName}`,\n\t\t\t\t\t\t\t'ARG_UNKNOWN_OPTION'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst [type, isFlag] = handlers[argName];\n\n\t\t\t\tif (!isFlag && j + 1 < separatedArguments.length) {\n\t\t\t\t\tthrow new ArgError(\n\t\t\t\t\t\t`option requires argument (but was followed by another short argument): ${originalArgName}`,\n\t\t\t\t\t\t'ARG_MISSING_REQUIRED_SHORTARG'\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (isFlag) {\n\t\t\t\t\tresult[argName] = type(true, argName, result[argName]);\n\t\t\t\t} else if (argStr === undefined) {\n\t\t\t\t\tif (\n\t\t\t\t\t\targv.length < i + 2 ||\n\t\t\t\t\t\t(argv[i + 1].length > 1 &&\n\t\t\t\t\t\t\targv[i + 1][0] === '-' &&\n\t\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t\targv[i + 1].match(/^-?\\d*(\\.(?=\\d))?\\d*$/) &&\n\t\t\t\t\t\t\t\t(type === Number ||\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line no-undef\n\t\t\t\t\t\t\t\t\t(typeof BigInt !== 'undefined' && type === BigInt))\n\t\t\t\t\t\t\t))\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst extended =\n\t\t\t\t\t\t\toriginalArgName === argName ? '' : ` (alias for ${argName})`;\n\t\t\t\t\t\tthrow new ArgError(\n\t\t\t\t\t\t\t`option requires argument: ${originalArgName}${extended}`,\n\t\t\t\t\t\t\t'ARG_MISSING_REQUIRED_LONGARG'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[argName] = type(argv[i + 1], argName, result[argName]);\n\t\t\t\t\t++i;\n\t\t\t\t} else {\n\t\t\t\t\tresult[argName] = type(argStr, argName, result[argName]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tresult._.push(wholeArg);\n\t\t}\n\t}\n\n\treturn result;\n}\n\narg.flag = (fn) => {\n\tfn[flagSymbol] = true;\n\treturn fn;\n};\n\n// Utility types\narg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);\n\n// Expose error class\narg.ArgError = ArgError;\n\nmodule.exports = arg;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}