{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst regexpp_1 = require(\"regexpp\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util_1 = require(\"../util\");\n\nexports.default = (0, util_1.createRule)({\n  name: 'prefer-includes',\n  defaultOptions: [],\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce `includes` method over `indexOf` method',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    fixable: 'code',\n    messages: {\n      preferIncludes: \"Use 'includes()' method instead.\",\n      preferStringIncludes: 'Use `String#includes()` method with a string instead.'\n    },\n    schema: []\n  },\n\n  create(context) {\n    const globalScope = context.getScope();\n    const services = (0, util_1.getParserServices)(context);\n    const types = services.program.getTypeChecker();\n\n    function isNumber(node, value) {\n      const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n      return evaluated !== null && evaluated.value === value;\n    }\n\n    function isPositiveCheck(node) {\n      switch (node.operator) {\n        case '!==':\n        case '!=':\n        case '>':\n          return isNumber(node.right, -1);\n\n        case '>=':\n          return isNumber(node.right, 0);\n\n        default:\n          return false;\n      }\n    }\n\n    function isNegativeCheck(node) {\n      switch (node.operator) {\n        case '===':\n        case '==':\n        case '<=':\n          return isNumber(node.right, -1);\n\n        case '<':\n          return isNumber(node.right, 0);\n\n        default:\n          return false;\n      }\n    }\n\n    function hasSameParameters(nodeA, nodeB) {\n      if (!ts.isFunctionLike(nodeA) || !ts.isFunctionLike(nodeB)) {\n        return false;\n      }\n\n      const paramsA = nodeA.parameters;\n      const paramsB = nodeB.parameters;\n\n      if (paramsA.length !== paramsB.length) {\n        return false;\n      }\n\n      for (let i = 0; i < paramsA.length; ++i) {\n        const paramA = paramsA[i];\n        const paramB = paramsB[i]; // Check name, type, and question token once.\n\n        if (paramA.getText() !== paramB.getText()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Parse a given node if it's a `RegExp` instance.\n     * @param node The node to parse.\n     */\n\n\n    function parseRegExp(node) {\n      const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n\n      if (evaluated == null || !(evaluated.value instanceof RegExp)) {\n        return null;\n      }\n\n      const {\n        pattern,\n        flags\n      } = (0, regexpp_1.parseRegExpLiteral)(evaluated.value);\n\n      if (pattern.alternatives.length !== 1 || flags.ignoreCase || flags.global) {\n        return null;\n      } // Check if it can determine a unique string.\n\n\n      const chars = pattern.alternatives[0].elements;\n\n      if (!chars.every(c => c.type === 'Character')) {\n        return null;\n      } // To string.\n\n\n      return String.fromCodePoint(...chars.map(c => c.value));\n    }\n\n    function checkArrayIndexOf(node, allowFixing) {\n      var _a, _b, _c; // Check if the comparison is equivalent to `includes()`.\n\n\n      const callNode = node.parent;\n      const compareNode = ((_a = callNode.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ChainExpression ? callNode.parent.parent : callNode.parent;\n      const negative = isNegativeCheck(compareNode);\n\n      if (!negative && !isPositiveCheck(compareNode)) {\n        return;\n      } // Get the symbol of `indexOf` method.\n\n\n      const tsNode = services.esTreeNodeToTSNodeMap.get(node.property);\n      const indexofMethodDeclarations = (_b = types.getSymbolAtLocation(tsNode)) === null || _b === void 0 ? void 0 : _b.getDeclarations();\n\n      if (indexofMethodDeclarations == null || indexofMethodDeclarations.length === 0) {\n        return;\n      } // Check if every declaration of `indexOf` method has `includes` method\n      // and the two methods have the same parameters.\n\n\n      for (const instanceofMethodDecl of indexofMethodDeclarations) {\n        const typeDecl = instanceofMethodDecl.parent;\n        const type = types.getTypeAtLocation(typeDecl);\n        const includesMethodDecl = (_c = type.getProperty('includes')) === null || _c === void 0 ? void 0 : _c.getDeclarations();\n\n        if (includesMethodDecl == null || !includesMethodDecl.some(includesMethodDecl => hasSameParameters(includesMethodDecl, instanceofMethodDecl))) {\n          return;\n        }\n      } // Report it.\n\n\n      context.report(Object.assign({\n        node: compareNode,\n        messageId: 'preferIncludes'\n      }, allowFixing && {\n        *fix(fixer) {\n          if (negative) {\n            yield fixer.insertTextBefore(callNode, '!');\n          }\n\n          yield fixer.replaceText(node.property, 'includes');\n          yield fixer.removeRange([callNode.range[1], compareNode.range[1]]);\n        }\n\n      }));\n    }\n\n    return {\n      // a.indexOf(b) !== 1\n      \"BinaryExpression > CallExpression.left > MemberExpression.callee[property.name='indexOf'][computed=false]\"(node) {\n        checkArrayIndexOf(node,\n        /* allowFixing */\n        true);\n      },\n\n      // a?.indexOf(b) !== 1\n      \"BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name='indexOf'][computed=false]\"(node) {\n        checkArrayIndexOf(node,\n        /* allowFixing */\n        false);\n      },\n\n      // /bar/.test(foo)\n      'CallExpression > MemberExpression.callee[property.name=\"test\"][computed=false]'(node) {\n        var _a;\n\n        const callNode = node.parent;\n        const text = callNode.arguments.length === 1 ? parseRegExp(node.object) : null;\n\n        if (text == null) {\n          return;\n        } //check the argument type of test methods\n\n\n        const argument = callNode.arguments[0];\n        const tsNode = services.esTreeNodeToTSNodeMap.get(argument);\n        const type = (0, util_1.getConstrainedTypeAtLocation)(types, tsNode);\n        const includesMethodDecl = (_a = type.getProperty('includes')) === null || _a === void 0 ? void 0 : _a.getDeclarations();\n\n        if (includesMethodDecl == null) {\n          return;\n        }\n\n        context.report({\n          node: callNode,\n          messageId: 'preferStringIncludes',\n\n          *fix(fixer) {\n            const argNode = callNode.arguments[0];\n            const needsParen = argNode.type !== utils_1.AST_NODE_TYPES.Literal && argNode.type !== utils_1.AST_NODE_TYPES.TemplateLiteral && argNode.type !== utils_1.AST_NODE_TYPES.Identifier && argNode.type !== utils_1.AST_NODE_TYPES.MemberExpression && argNode.type !== utils_1.AST_NODE_TYPES.CallExpression;\n            yield fixer.removeRange([callNode.range[0], argNode.range[0]]);\n\n            if (needsParen) {\n              yield fixer.insertTextBefore(argNode, '(');\n              yield fixer.insertTextAfter(argNode, ')');\n            }\n\n            yield fixer.insertTextAfter(argNode, `${node.optional ? '?.' : '.'}includes('${text}'`);\n          }\n\n        });\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","name","defaultOptions","meta","type","docs","description","recommended","requiresTypeChecking","fixable","messages","preferIncludes","preferStringIncludes","schema","create","context","globalScope","getScope","services","types","program","getTypeChecker","isNumber","node","value","evaluated","isPositiveCheck","operator","right","isNegativeCheck","hasSameParameters","nodeA","nodeB","ts","isFunctionLike","paramsA","parameters","paramsB","length","i","paramA","paramB","getText","parseRegExp","RegExp","pattern","flags","alternatives","ignoreCase","global","chars","elements","every","c","String","fromCodePoint","map","checkArrayIndexOf","allowFixing","callNode","parent","compareNode","_a","utils_1","ChainExpression","negative","tsNode","esTreeNodeToTSNodeMap","get","property","indexofMethodDeclarations","getSymbolAtLocation","_b","getDeclarations","instanceofMethodDecl","typeDecl","getTypeAtLocation","includesMethodDecl","getProperty","_c","some","report","Object","messageId","fix","fixer","insertTextBefore","replaceText","removeRange","range","text","arguments","object","argument","argNode","needsParen","Literal","TemplateLiteral","Identifier","MemberExpression","CallExpression","insertTextAfter","optional"],"sources":["../../src/rules/prefer-includes.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}