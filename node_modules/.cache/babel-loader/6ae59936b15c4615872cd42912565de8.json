{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createValidator = void 0;\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../../util\"));\n\nconst enums_1 = require(\"./enums\");\n\nconst format_1 = require(\"./format\");\n\nconst shared_1 = require(\"./shared\");\n\nfunction createValidator(type, context, allConfigs) {\n  // make sure the \"highest priority\" configs are checked first\n  const selectorType = enums_1.Selectors[type];\n  const configs = allConfigs // gather all of the applicable selectors\n  .filter(c => (c.selector & selectorType) !== 0 || c.selector === enums_1.MetaSelectors.default).sort((a, b) => {\n    if (a.selector === b.selector) {\n      // in the event of the same selector, order by modifier weight\n      // sort descending - the type modifiers are \"more important\"\n      return b.modifierWeight - a.modifierWeight;\n    }\n\n    const aIsMeta = (0, shared_1.isMetaSelector)(a.selector);\n    const bIsMeta = (0, shared_1.isMetaSelector)(b.selector); // non-meta selectors should go ahead of meta selectors\n\n    if (aIsMeta && !bIsMeta) {\n      return 1;\n    }\n\n    if (!aIsMeta && bIsMeta) {\n      return -1;\n    }\n\n    const aIsMethodOrProperty = (0, shared_1.isMethodOrPropertySelector)(a.selector);\n    const bIsMethodOrProperty = (0, shared_1.isMethodOrPropertySelector)(b.selector); // for backward compatibility, method and property have higher precedence than other meta selectors\n\n    if (aIsMethodOrProperty && !bIsMethodOrProperty) {\n      return -1;\n    }\n\n    if (!aIsMethodOrProperty && bIsMethodOrProperty) {\n      return 1;\n    } // both aren't meta selectors\n    // sort descending - the meta selectors are \"least important\"\n\n\n    return b.selector - a.selector;\n  });\n  return function (node) {\n    let modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n\n    var _a, _b, _c;\n\n    const originalName = node.type === utils_1.AST_NODE_TYPES.Identifier || node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier ? node.name : `${node.value}`; // return will break the loop and stop checking configs\n    // it is only used when the name is known to have failed or succeeded a config.\n\n    for (const config of configs) {\n      if (((_a = config.filter) === null || _a === void 0 ? void 0 : _a.regex.test(originalName)) !== ((_b = config.filter) === null || _b === void 0 ? void 0 : _b.match)) {\n        // name does not match the filter\n        continue;\n      }\n\n      if ((_c = config.modifiers) === null || _c === void 0 ? void 0 : _c.some(modifier => !modifiers.has(modifier))) {\n        // does not have the required modifiers\n        continue;\n      }\n\n      if (!isCorrectType(node, config, context, selectorType)) {\n        // is not the correct type\n        continue;\n      }\n\n      let name = originalName;\n      name = validateUnderscore('leading', config, name, node, originalName);\n\n      if (name === null) {\n        // fail\n        return;\n      }\n\n      name = validateUnderscore('trailing', config, name, node, originalName);\n\n      if (name === null) {\n        // fail\n        return;\n      }\n\n      name = validateAffix('prefix', config, name, node, originalName);\n\n      if (name === null) {\n        // fail\n        return;\n      }\n\n      name = validateAffix('suffix', config, name, node, originalName);\n\n      if (name === null) {\n        // fail\n        return;\n      }\n\n      if (!validateCustom(config, name, node, originalName)) {\n        // fail\n        return;\n      }\n\n      if (!validatePredefinedFormat(config, name, node, originalName, modifiers)) {\n        // fail\n        return;\n      } // it's valid for this config, so we don't need to check any more configs\n\n\n      return;\n    }\n  }; // centralizes the logic for formatting the report data\n\n  function formatReportData(_ref) {\n    let {\n      affixes,\n      formats,\n      originalName,\n      processedName,\n      position,\n      custom,\n      count\n    } = _ref;\n\n    var _a;\n\n    return {\n      type: (0, shared_1.selectorTypeToMessageString)(type),\n      name: originalName,\n      processedName,\n      position,\n      count,\n      affixes: affixes === null || affixes === void 0 ? void 0 : affixes.join(', '),\n      formats: formats === null || formats === void 0 ? void 0 : formats.map(f => enums_1.PredefinedFormats[f]).join(', '),\n      regex: (_a = custom === null || custom === void 0 ? void 0 : custom.regex) === null || _a === void 0 ? void 0 : _a.toString(),\n      regexMatch: (custom === null || custom === void 0 ? void 0 : custom.match) === true ? 'match' : (custom === null || custom === void 0 ? void 0 : custom.match) === false ? 'not match' : null\n    };\n  }\n  /**\n   * @returns the name with the underscore removed, if it is valid according to the specified underscore option, null otherwise\n   */\n\n\n  function validateUnderscore(position, config, name, node, originalName) {\n    const option = position === 'leading' ? config.leadingUnderscore : config.trailingUnderscore;\n\n    if (!option) {\n      return name;\n    }\n\n    const hasSingleUnderscore = position === 'leading' ? () => name.startsWith('_') : () => name.endsWith('_');\n    const trimSingleUnderscore = position === 'leading' ? () => name.slice(1) : () => name.slice(0, -1);\n    const hasDoubleUnderscore = position === 'leading' ? () => name.startsWith('__') : () => name.endsWith('__');\n    const trimDoubleUnderscore = position === 'leading' ? () => name.slice(2) : () => name.slice(0, -2);\n\n    switch (option) {\n      // ALLOW - no conditions as the user doesn't care if it's there or not\n      case enums_1.UnderscoreOptions.allow:\n        {\n          if (hasSingleUnderscore()) {\n            return trimSingleUnderscore();\n          }\n\n          return name;\n        }\n\n      case enums_1.UnderscoreOptions.allowDouble:\n        {\n          if (hasDoubleUnderscore()) {\n            return trimDoubleUnderscore();\n          }\n\n          return name;\n        }\n\n      case enums_1.UnderscoreOptions.allowSingleOrDouble:\n        {\n          if (hasDoubleUnderscore()) {\n            return trimDoubleUnderscore();\n          }\n\n          if (hasSingleUnderscore()) {\n            return trimSingleUnderscore();\n          }\n\n          return name;\n        }\n      // FORBID\n\n      case enums_1.UnderscoreOptions.forbid:\n        {\n          if (hasSingleUnderscore()) {\n            context.report({\n              node,\n              messageId: 'unexpectedUnderscore',\n              data: formatReportData({\n                originalName,\n                position,\n                count: 'one'\n              })\n            });\n            return null;\n          }\n\n          return name;\n        }\n      // REQUIRE\n\n      case enums_1.UnderscoreOptions.require:\n        {\n          if (!hasSingleUnderscore()) {\n            context.report({\n              node,\n              messageId: 'missingUnderscore',\n              data: formatReportData({\n                originalName,\n                position,\n                count: 'one'\n              })\n            });\n            return null;\n          }\n\n          return trimSingleUnderscore();\n        }\n\n      case enums_1.UnderscoreOptions.requireDouble:\n        {\n          if (!hasDoubleUnderscore()) {\n            context.report({\n              node,\n              messageId: 'missingUnderscore',\n              data: formatReportData({\n                originalName,\n                position,\n                count: 'two'\n              })\n            });\n            return null;\n          }\n\n          return trimDoubleUnderscore();\n        }\n    }\n  }\n  /**\n   * @returns the name with the affix removed, if it is valid according to the specified affix option, null otherwise\n   */\n\n\n  function validateAffix(position, config, name, node, originalName) {\n    const affixes = config[position];\n\n    if (!affixes || affixes.length === 0) {\n      return name;\n    }\n\n    for (const affix of affixes) {\n      const hasAffix = position === 'prefix' ? name.startsWith(affix) : name.endsWith(affix);\n      const trimAffix = position === 'prefix' ? () => name.slice(affix.length) : () => name.slice(0, -affix.length);\n\n      if (hasAffix) {\n        // matches, so trim it and return\n        return trimAffix();\n      }\n    }\n\n    context.report({\n      node,\n      messageId: 'missingAffix',\n      data: formatReportData({\n        originalName,\n        position,\n        affixes\n      })\n    });\n    return null;\n  }\n  /**\n   * @returns true if the name is valid according to the `regex` option, false otherwise\n   */\n\n\n  function validateCustom(config, name, node, originalName) {\n    const custom = config.custom;\n\n    if (!custom) {\n      return true;\n    }\n\n    const result = custom.regex.test(name);\n\n    if (custom.match && result) {\n      return true;\n    }\n\n    if (!custom.match && !result) {\n      return true;\n    }\n\n    context.report({\n      node,\n      messageId: 'satisfyCustom',\n      data: formatReportData({\n        originalName,\n        custom\n      })\n    });\n    return false;\n  }\n  /**\n   * @returns true if the name is valid according to the `format` option, false otherwise\n   */\n\n\n  function validatePredefinedFormat(config, name, node, originalName, modifiers) {\n    const formats = config.format;\n\n    if (formats === null || formats.length === 0) {\n      return true;\n    }\n\n    if (!modifiers.has(enums_1.Modifiers.requiresQuotes)) {\n      for (const format of formats) {\n        const checker = format_1.PredefinedFormatToCheckFunction[format];\n\n        if (checker(name)) {\n          return true;\n        }\n      }\n    }\n\n    context.report({\n      node,\n      messageId: originalName === name ? 'doesNotMatchFormat' : 'doesNotMatchFormatTrimmed',\n      data: formatReportData({\n        originalName,\n        processedName: name,\n        formats\n      })\n    });\n    return false;\n  }\n}\n\nexports.createValidator = createValidator;\nconst SelectorsAllowedToHaveTypes = enums_1.Selectors.variable | enums_1.Selectors.parameter | enums_1.Selectors.classProperty | enums_1.Selectors.objectLiteralProperty | enums_1.Selectors.typeProperty | enums_1.Selectors.parameterProperty | enums_1.Selectors.accessor;\n\nfunction isCorrectType(node, config, context, selector) {\n  if (config.types === null) {\n    return true;\n  }\n\n  if ((SelectorsAllowedToHaveTypes & selector) === 0) {\n    return true;\n  }\n\n  const {\n    esTreeNodeToTSNodeMap,\n    program\n  } = util.getParserServices(context);\n  const checker = program.getTypeChecker();\n  const tsNode = esTreeNodeToTSNodeMap.get(node);\n  const type = checker.getTypeAtLocation(tsNode) // remove null and undefined from the type, as we don't care about it here\n  .getNonNullableType();\n\n  for (const allowedType of config.types) {\n    switch (allowedType) {\n      case enums_1.TypeModifiers.array:\n        if (isAllTypesMatch(type, t => checker.isArrayType(t) || checker.isTupleType(t))) {\n          return true;\n        }\n\n        break;\n\n      case enums_1.TypeModifiers.function:\n        if (isAllTypesMatch(type, t => t.getCallSignatures().length > 0)) {\n          return true;\n        }\n\n        break;\n\n      case enums_1.TypeModifiers.boolean:\n      case enums_1.TypeModifiers.number:\n      case enums_1.TypeModifiers.string:\n        {\n          const typeString = checker.typeToString( // this will resolve things like true => boolean, 'a' => string and 1 => number\n          checker.getWidenedType(checker.getBaseTypeOfLiteralType(type)));\n          const allowedTypeString = enums_1.TypeModifiers[allowedType];\n\n          if (typeString === allowedTypeString) {\n            return true;\n          }\n\n          break;\n        }\n    }\n  }\n\n  return false;\n}\n/**\n * @returns `true` if the type (or all union types) in the given type return true for the callback\n */\n\n\nfunction isAllTypesMatch(type, cb) {\n  if (type.isUnion()) {\n    return type.types.every(t => cb(t));\n  }\n\n  return cb(type);\n}","map":{"version":3,"mappings":"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","names":["createValidator","type","context","allConfigs","selectorType","enums_1","configs","filter","c","selector","default","sort","a","b","modifierWeight","aIsMeta","bIsMeta","aIsMethodOrProperty","bIsMethodOrProperty","node","modifiers","Set","originalName","utils_1","Identifier","PrivateIdentifier","name","value","config","_a","regex","test","_b","match","_c","some","modifier","has","isCorrectType","validateUnderscore","validateAffix","validateCustom","validatePredefinedFormat","formatReportData","affixes","formats","processedName","position","custom","count","join","map","f","toString","regexMatch","option","leadingUnderscore","trailingUnderscore","hasSingleUnderscore","startsWith","endsWith","trimSingleUnderscore","slice","hasDoubleUnderscore","trimDoubleUnderscore","allow","allowDouble","allowSingleOrDouble","forbid","report","messageId","data","require","requireDouble","length","affix","hasAffix","trimAffix","result","format","requiresQuotes","checker","format_1","exports","SelectorsAllowedToHaveTypes","variable","parameter","classProperty","objectLiteralProperty","typeProperty","parameterProperty","accessor","types","esTreeNodeToTSNodeMap","program","util","getParserServices","getTypeChecker","tsNode","get","getTypeAtLocation","getNonNullableType","allowedType","array","isAllTypesMatch","t","isArrayType","isTupleType","function","getCallSignatures","boolean","number","string","typeString","typeToString","getWidenedType","getBaseTypeOfLiteralType","allowedTypeString","cb","isUnion","every"],"sources":["../../../src/rules/naming-convention-utils/validator.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}