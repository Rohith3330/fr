{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchFromURL = fetchFromURL;\nexports.flattenSourceMap = flattenSourceMap;\nexports.getSourceMappingURL = getSourceMappingURL;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _sourceMapJs = _interopRequireDefault(require(\"source-map-js\"));\n\nvar _iconvLite = require(\"iconv-lite\");\n\nvar _parseDataUrl = _interopRequireDefault(require(\"./parse-data-url\"));\n\nvar _labelsToNames = _interopRequireDefault(require(\"./labels-to-names\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Matches only the last occurrence of sourceMappingURL\n\n\nconst innerRegex = /\\s*[#@]\\s*sourceMappingURL\\s*=\\s*([^\\s'\"]*)\\s*/;\n/* eslint-disable prefer-template */\n\nconst sourceMappingURLRegex = RegExp(\"(?:\" + \"/\\\\*\" + \"(?:\\\\s*\\r?\\n(?://)?)?\" + \"(?:\" + innerRegex.source + \")\" + \"\\\\s*\" + \"\\\\*/\" + \"|\" + \"//(?:\" + innerRegex.source + \")\" + \")\" + \"\\\\s*\");\n/* eslint-enable prefer-template */\n\nfunction labelToName(label) {\n  const labelLowercase = String(label).trim().toLowerCase();\n  return _labelsToNames.default[labelLowercase] || null;\n}\n\nasync function flattenSourceMap(map) {\n  const consumer = await new _sourceMapJs.default.SourceMapConsumer(map);\n  const generatedMap = map.file ? new _sourceMapJs.default.SourceMapGenerator({\n    file: map.file\n  }) : new _sourceMapJs.default.SourceMapGenerator();\n  consumer.sources.forEach(sourceFile => {\n    const sourceContent = consumer.sourceContentFor(sourceFile, true);\n    generatedMap.setSourceContent(sourceFile, sourceContent);\n  });\n  consumer.eachMapping(mapping => {\n    const {\n      source\n    } = consumer.originalPositionFor({\n      line: mapping.generatedLine,\n      column: mapping.generatedColumn\n    });\n    const mappings = {\n      source,\n      original: {\n        line: mapping.originalLine,\n        column: mapping.originalColumn\n      },\n      generated: {\n        line: mapping.generatedLine,\n        column: mapping.generatedColumn\n      }\n    };\n\n    if (source) {\n      generatedMap.addMapping(mappings);\n    }\n  });\n  return generatedMap.toJSON();\n}\n\nfunction getSourceMappingURL(code) {\n  const lines = code.split(/^/m);\n  let match;\n\n  for (let i = lines.length - 1; i >= 0; i--) {\n    match = lines[i].match(sourceMappingURLRegex);\n\n    if (match) {\n      break;\n    }\n  }\n\n  const sourceMappingURL = match ? match[1] || match[2] || \"\" : null;\n  return {\n    sourceMappingURL: sourceMappingURL ? decodeURI(sourceMappingURL) : sourceMappingURL,\n    replacementString: match ? match[0] : null\n  };\n}\n\nfunction getAbsolutePath(context, request, sourceRoot) {\n  if (sourceRoot) {\n    if (_path.default.isAbsolute(sourceRoot)) {\n      return _path.default.join(sourceRoot, request);\n    }\n\n    return _path.default.join(context, sourceRoot, request);\n  }\n\n  return _path.default.join(context, request);\n}\n\nfunction fetchFromDataURL(loaderContext, sourceURL) {\n  const dataURL = (0, _parseDataUrl.default)(sourceURL);\n\n  if (dataURL) {\n    // https://tools.ietf.org/html/rfc4627\n    // JSON text SHALL be encoded in Unicode. The default encoding is UTF-8.\n    const encodingName = labelToName(dataURL.parameters.get(\"charset\")) || \"UTF-8\";\n    return (0, _iconvLite.decode)(dataURL.body, encodingName);\n  }\n\n  throw new Error(`Failed to parse source map from \"data\" URL: ${sourceURL}`);\n}\n\nasync function fetchFromFilesystem(loaderContext, sourceURL) {\n  let buffer;\n\n  try {\n    buffer = await new Promise((resolve, reject) => {\n      loaderContext.fs.readFile(sourceURL, (error, data) => {\n        if (error) {\n          return reject(error);\n        }\n\n        return resolve(data);\n      });\n    });\n  } catch (error) {\n    throw new Error(`Failed to parse source map from '${sourceURL}' file: ${error}`);\n  }\n\n  return {\n    path: sourceURL,\n    data: buffer.toString()\n  };\n}\n\nasync function fetchPathsFromFilesystem(loaderContext, possibleRequests) {\n  let errorsAccumulator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  let result;\n\n  try {\n    result = await fetchFromFilesystem(loaderContext, possibleRequests[0], errorsAccumulator);\n  } catch (error) {\n    // eslint-disable-next-line no-param-reassign\n    errorsAccumulator += `${error.message}\\n\\n`;\n    const [, ...tailPossibleRequests] = possibleRequests;\n\n    if (tailPossibleRequests.length === 0) {\n      error.message = errorsAccumulator;\n      throw error;\n    }\n\n    return fetchPathsFromFilesystem(loaderContext, tailPossibleRequests, errorsAccumulator);\n  }\n\n  return result;\n}\n\nasync function fetchFromURL(loaderContext, context, url, sourceRoot) {\n  let skipReading = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // 1. It's an absolute url and it is not `windows` path like `C:\\dir\\file`\n  if (/^[a-z][a-z0-9+.-]*:/i.test(url) && !_path.default.win32.isAbsolute(url)) {\n    const {\n      protocol\n    } = _url.default.parse(url);\n\n    if (protocol === \"data:\") {\n      if (skipReading) {\n        return {\n          sourceURL: \"\"\n        };\n      }\n\n      const sourceContent = fetchFromDataURL(loaderContext, url);\n      return {\n        sourceURL: \"\",\n        sourceContent\n      };\n    }\n\n    if (skipReading) {\n      return {\n        sourceURL: url\n      };\n    }\n\n    if (protocol === \"file:\") {\n      const pathFromURL = _url.default.fileURLToPath(url);\n\n      const sourceURL = _path.default.normalize(pathFromURL);\n\n      const {\n        data: sourceContent\n      } = await fetchFromFilesystem(loaderContext, sourceURL);\n      return {\n        sourceURL,\n        sourceContent\n      };\n    }\n\n    throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n  } // 2. It's a scheme-relative\n\n\n  if (/^\\/\\//.test(url)) {\n    throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n  } // 3. Absolute path\n\n\n  if (_path.default.isAbsolute(url)) {\n    let sourceURL = _path.default.normalize(url);\n\n    let sourceContent;\n\n    if (!skipReading) {\n      const possibleRequests = [sourceURL];\n\n      if (url.startsWith(\"/\")) {\n        possibleRequests.push(getAbsolutePath(context, sourceURL.slice(1), sourceRoot));\n      }\n\n      const result = await fetchPathsFromFilesystem(loaderContext, possibleRequests);\n      sourceURL = result.path;\n      sourceContent = result.data;\n    }\n\n    return {\n      sourceURL,\n      sourceContent\n    };\n  } // 4. Relative path\n\n\n  const sourceURL = getAbsolutePath(context, url, sourceRoot);\n  let sourceContent;\n\n  if (!skipReading) {\n    const {\n      data\n    } = await fetchFromFilesystem(loaderContext, sourceURL);\n    sourceContent = data;\n  }\n\n  return {\n    sourceURL,\n    sourceContent\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","fetchFromURL","flattenSourceMap","getSourceMappingURL","_path","_interopRequireDefault","require","_url","_sourceMapJs","_iconvLite","_parseDataUrl","_labelsToNames","obj","__esModule","default","innerRegex","sourceMappingURLRegex","RegExp","source","labelToName","label","labelLowercase","String","trim","toLowerCase","map","consumer","SourceMapConsumer","generatedMap","file","SourceMapGenerator","sources","forEach","sourceFile","sourceContent","sourceContentFor","setSourceContent","eachMapping","mapping","originalPositionFor","line","generatedLine","column","generatedColumn","mappings","original","originalLine","originalColumn","generated","addMapping","toJSON","code","lines","split","match","i","length","sourceMappingURL","decodeURI","replacementString","getAbsolutePath","context","request","sourceRoot","isAbsolute","join","fetchFromDataURL","loaderContext","sourceURL","dataURL","encodingName","parameters","get","decode","body","Error","fetchFromFilesystem","buffer","Promise","resolve","reject","fs","readFile","error","data","path","toString","fetchPathsFromFilesystem","possibleRequests","errorsAccumulator","result","message","tailPossibleRequests","url","skipReading","test","win32","protocol","parse","pathFromURL","fileURLToPath","normalize","startsWith","push","slice"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/source-map-loader/dist/utils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchFromURL = fetchFromURL;\nexports.flattenSourceMap = flattenSourceMap;\nexports.getSourceMappingURL = getSourceMappingURL;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _sourceMapJs = _interopRequireDefault(require(\"source-map-js\"));\n\nvar _iconvLite = require(\"iconv-lite\");\n\nvar _parseDataUrl = _interopRequireDefault(require(\"./parse-data-url\"));\n\nvar _labelsToNames = _interopRequireDefault(require(\"./labels-to-names\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Matches only the last occurrence of sourceMappingURL\nconst innerRegex = /\\s*[#@]\\s*sourceMappingURL\\s*=\\s*([^\\s'\"]*)\\s*/;\n/* eslint-disable prefer-template */\n\nconst sourceMappingURLRegex = RegExp(\"(?:\" + \"/\\\\*\" + \"(?:\\\\s*\\r?\\n(?://)?)?\" + \"(?:\" + innerRegex.source + \")\" + \"\\\\s*\" + \"\\\\*/\" + \"|\" + \"//(?:\" + innerRegex.source + \")\" + \")\" + \"\\\\s*\");\n/* eslint-enable prefer-template */\n\nfunction labelToName(label) {\n  const labelLowercase = String(label).trim().toLowerCase();\n  return _labelsToNames.default[labelLowercase] || null;\n}\n\nasync function flattenSourceMap(map) {\n  const consumer = await new _sourceMapJs.default.SourceMapConsumer(map);\n  const generatedMap = map.file ? new _sourceMapJs.default.SourceMapGenerator({\n    file: map.file\n  }) : new _sourceMapJs.default.SourceMapGenerator();\n  consumer.sources.forEach(sourceFile => {\n    const sourceContent = consumer.sourceContentFor(sourceFile, true);\n    generatedMap.setSourceContent(sourceFile, sourceContent);\n  });\n  consumer.eachMapping(mapping => {\n    const {\n      source\n    } = consumer.originalPositionFor({\n      line: mapping.generatedLine,\n      column: mapping.generatedColumn\n    });\n    const mappings = {\n      source,\n      original: {\n        line: mapping.originalLine,\n        column: mapping.originalColumn\n      },\n      generated: {\n        line: mapping.generatedLine,\n        column: mapping.generatedColumn\n      }\n    };\n\n    if (source) {\n      generatedMap.addMapping(mappings);\n    }\n  });\n  return generatedMap.toJSON();\n}\n\nfunction getSourceMappingURL(code) {\n  const lines = code.split(/^/m);\n  let match;\n\n  for (let i = lines.length - 1; i >= 0; i--) {\n    match = lines[i].match(sourceMappingURLRegex);\n\n    if (match) {\n      break;\n    }\n  }\n\n  const sourceMappingURL = match ? match[1] || match[2] || \"\" : null;\n  return {\n    sourceMappingURL: sourceMappingURL ? decodeURI(sourceMappingURL) : sourceMappingURL,\n    replacementString: match ? match[0] : null\n  };\n}\n\nfunction getAbsolutePath(context, request, sourceRoot) {\n  if (sourceRoot) {\n    if (_path.default.isAbsolute(sourceRoot)) {\n      return _path.default.join(sourceRoot, request);\n    }\n\n    return _path.default.join(context, sourceRoot, request);\n  }\n\n  return _path.default.join(context, request);\n}\n\nfunction fetchFromDataURL(loaderContext, sourceURL) {\n  const dataURL = (0, _parseDataUrl.default)(sourceURL);\n\n  if (dataURL) {\n    // https://tools.ietf.org/html/rfc4627\n    // JSON text SHALL be encoded in Unicode. The default encoding is UTF-8.\n    const encodingName = labelToName(dataURL.parameters.get(\"charset\")) || \"UTF-8\";\n    return (0, _iconvLite.decode)(dataURL.body, encodingName);\n  }\n\n  throw new Error(`Failed to parse source map from \"data\" URL: ${sourceURL}`);\n}\n\nasync function fetchFromFilesystem(loaderContext, sourceURL) {\n  let buffer;\n\n  try {\n    buffer = await new Promise((resolve, reject) => {\n      loaderContext.fs.readFile(sourceURL, (error, data) => {\n        if (error) {\n          return reject(error);\n        }\n\n        return resolve(data);\n      });\n    });\n  } catch (error) {\n    throw new Error(`Failed to parse source map from '${sourceURL}' file: ${error}`);\n  }\n\n  return {\n    path: sourceURL,\n    data: buffer.toString()\n  };\n}\n\nasync function fetchPathsFromFilesystem(loaderContext, possibleRequests, errorsAccumulator = \"\") {\n  let result;\n\n  try {\n    result = await fetchFromFilesystem(loaderContext, possibleRequests[0], errorsAccumulator);\n  } catch (error) {\n    // eslint-disable-next-line no-param-reassign\n    errorsAccumulator += `${error.message}\\n\\n`;\n    const [, ...tailPossibleRequests] = possibleRequests;\n\n    if (tailPossibleRequests.length === 0) {\n      error.message = errorsAccumulator;\n      throw error;\n    }\n\n    return fetchPathsFromFilesystem(loaderContext, tailPossibleRequests, errorsAccumulator);\n  }\n\n  return result;\n}\n\nasync function fetchFromURL(loaderContext, context, url, sourceRoot, skipReading = false) {\n  // 1. It's an absolute url and it is not `windows` path like `C:\\dir\\file`\n  if (/^[a-z][a-z0-9+.-]*:/i.test(url) && !_path.default.win32.isAbsolute(url)) {\n    const {\n      protocol\n    } = _url.default.parse(url);\n\n    if (protocol === \"data:\") {\n      if (skipReading) {\n        return {\n          sourceURL: \"\"\n        };\n      }\n\n      const sourceContent = fetchFromDataURL(loaderContext, url);\n      return {\n        sourceURL: \"\",\n        sourceContent\n      };\n    }\n\n    if (skipReading) {\n      return {\n        sourceURL: url\n      };\n    }\n\n    if (protocol === \"file:\") {\n      const pathFromURL = _url.default.fileURLToPath(url);\n\n      const sourceURL = _path.default.normalize(pathFromURL);\n\n      const {\n        data: sourceContent\n      } = await fetchFromFilesystem(loaderContext, sourceURL);\n      return {\n        sourceURL,\n        sourceContent\n      };\n    }\n\n    throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n  } // 2. It's a scheme-relative\n\n\n  if (/^\\/\\//.test(url)) {\n    throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n  } // 3. Absolute path\n\n\n  if (_path.default.isAbsolute(url)) {\n    let sourceURL = _path.default.normalize(url);\n\n    let sourceContent;\n\n    if (!skipReading) {\n      const possibleRequests = [sourceURL];\n\n      if (url.startsWith(\"/\")) {\n        possibleRequests.push(getAbsolutePath(context, sourceURL.slice(1), sourceRoot));\n      }\n\n      const result = await fetchPathsFromFilesystem(loaderContext, possibleRequests);\n      sourceURL = result.path;\n      sourceContent = result.data;\n    }\n\n    return {\n      sourceURL,\n      sourceContent\n    };\n  } // 4. Relative path\n\n\n  const sourceURL = getAbsolutePath(context, url, sourceRoot);\n  let sourceContent;\n\n  if (!skipReading) {\n    const {\n      data\n    } = await fetchFromFilesystem(loaderContext, sourceURL);\n    sourceContent = data;\n  }\n\n  return {\n    sourceURL,\n    sourceContent\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}