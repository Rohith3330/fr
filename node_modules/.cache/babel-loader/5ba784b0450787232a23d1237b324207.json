{"ast":null,"code":"/**\n * @fileoverview Rule to require parens in arrow function arguments.\n * @author Jxck\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given arrow function has block body.\n * @param {ASTNode} node `ArrowFunctionExpression` node.\n * @returns {boolean} `true` if the function has block body.\n */\n\n\nfunction hasBlockBody(node) {\n  return node.body.type === \"BlockStatement\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"Require parentheses around arrow function arguments\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/arrow-parens\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"always\", \"as-needed\"]\n    }, {\n      type: \"object\",\n      properties: {\n        requireForBlockBody: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedParens: \"Unexpected parentheses around single function argument.\",\n      expectedParens: \"Expected parentheses around arrow function argument.\",\n      unexpectedParensInline: \"Unexpected parentheses around single function argument having a body with no curly braces.\",\n      expectedParensBlock: \"Expected parentheses around arrow function argument having a body with curly braces.\"\n    }\n  },\n\n  create(context) {\n    const asNeeded = context.options[0] === \"as-needed\";\n    const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Finds opening paren of parameters for the given arrow function, if it exists.\n     * It is assumed that the given arrow function has exactly one parameter.\n     * @param {ASTNode} node `ArrowFunctionExpression` node.\n     * @returns {Token|null} the opening paren, or `null` if the given arrow function doesn't have parens of parameters.\n     */\n\n    function findOpeningParenOfParams(node) {\n      const tokenBeforeParams = sourceCode.getTokenBefore(node.params[0]);\n\n      if (tokenBeforeParams && astUtils.isOpeningParenToken(tokenBeforeParams) && node.range[0] <= tokenBeforeParams.range[0]) {\n        return tokenBeforeParams;\n      }\n\n      return null;\n    }\n    /**\n     * Finds closing paren of parameters for the given arrow function.\n     * It is assumed that the given arrow function has parens of parameters and that it has exactly one parameter.\n     * @param {ASTNode} node `ArrowFunctionExpression` node.\n     * @returns {Token} the closing paren of parameters.\n     */\n\n\n    function getClosingParenOfParams(node) {\n      return sourceCode.getTokenAfter(node.params[0], astUtils.isClosingParenToken);\n    }\n    /**\n     * Determines whether the given arrow function has comments inside parens of parameters.\n     * It is assumed that the given arrow function has parens of parameters.\n     * @param {ASTNode} node `ArrowFunctionExpression` node.\n     * @param {Token} openingParen Opening paren of parameters.\n     * @returns {boolean} `true` if the function has at least one comment inside of parens of parameters.\n     */\n\n\n    function hasCommentsInParensOfParams(node, openingParen) {\n      return sourceCode.commentsExistBetween(openingParen, getClosingParenOfParams(node));\n    }\n    /**\n     * Determines whether the given arrow function has unexpected tokens before opening paren of parameters,\n     * in which case it will be assumed that the existing parens of parameters are necessary.\n     * Only tokens within the range of the arrow function (tokens that are part of the arrow function) are taken into account.\n     * Example: <T>(a) => b\n     * @param {ASTNode} node `ArrowFunctionExpression` node.\n     * @param {Token} openingParen Opening paren of parameters.\n     * @returns {boolean} `true` if the function has at least one unexpected token.\n     */\n\n\n    function hasUnexpectedTokensBeforeOpeningParen(node, openingParen) {\n      const expectedCount = node.async ? 1 : 0;\n      return sourceCode.getFirstToken(node, {\n        skip: expectedCount\n      }) !== openingParen;\n    }\n\n    return {\n      \"ArrowFunctionExpression[params.length=1]\"(node) {\n        const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node);\n        const openingParen = findOpeningParenOfParams(node);\n        const hasParens = openingParen !== null;\n        const [param] = node.params;\n\n        if (shouldHaveParens && !hasParens) {\n          context.report({\n            node,\n            messageId: requireForBlockBody ? \"expectedParensBlock\" : \"expectedParens\",\n            loc: param.loc,\n\n            *fix(fixer) {\n              yield fixer.insertTextBefore(param, \"(\");\n              yield fixer.insertTextAfter(param, \")\");\n            }\n\n          });\n        }\n\n        if (!shouldHaveParens && hasParens && param.type === \"Identifier\" && !param.typeAnnotation && !node.returnType && !hasCommentsInParensOfParams(node, openingParen) && !hasUnexpectedTokensBeforeOpeningParen(node, openingParen)) {\n          context.report({\n            node,\n            messageId: requireForBlockBody ? \"unexpectedParensInline\" : \"unexpectedParens\",\n            loc: param.loc,\n\n            *fix(fixer) {\n              const tokenBeforeOpeningParen = sourceCode.getTokenBefore(openingParen);\n              const closingParen = getClosingParenOfParams(node);\n\n              if (tokenBeforeOpeningParen && tokenBeforeOpeningParen.range[1] === openingParen.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeOpeningParen, sourceCode.getFirstToken(param))) {\n                yield fixer.insertTextBefore(openingParen, \" \");\n              } // remove parens, whitespace inside parens, and possible trailing comma\n\n\n              yield fixer.removeRange([openingParen.range[0], param.range[0]]);\n              yield fixer.removeRange([param.range[1], closingParen.range[1]]);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","hasBlockBody","node","body","type","module","exports","meta","docs","description","recommended","url","fixable","schema","enum","properties","requireForBlockBody","default","additionalProperties","messages","unexpectedParens","expectedParens","unexpectedParensInline","expectedParensBlock","create","context","asNeeded","options","sourceCode","getSourceCode","findOpeningParenOfParams","tokenBeforeParams","getTokenBefore","params","isOpeningParenToken","range","getClosingParenOfParams","getTokenAfter","isClosingParenToken","hasCommentsInParensOfParams","openingParen","commentsExistBetween","hasUnexpectedTokensBeforeOpeningParen","expectedCount","async","getFirstToken","skip","shouldHaveParens","hasParens","param","report","messageId","loc","fix","fixer","insertTextBefore","insertTextAfter","typeAnnotation","returnType","tokenBeforeOpeningParen","closingParen","canTokensBeAdjacent","removeRange"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/arrow-parens.js"],"sourcesContent":["/**\n * @fileoverview Rule to require parens in arrow function arguments.\n * @author Jxck\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given arrow function has block body.\n * @param {ASTNode} node `ArrowFunctionExpression` node.\n * @returns {boolean} `true` if the function has block body.\n */\nfunction hasBlockBody(node) {\n    return node.body.type === \"BlockStatement\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"Require parentheses around arrow function arguments\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-parens\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    requireForBlockBody: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedParens: \"Unexpected parentheses around single function argument.\",\n            expectedParens: \"Expected parentheses around arrow function argument.\",\n\n            unexpectedParensInline: \"Unexpected parentheses around single function argument having a body with no curly braces.\",\n            expectedParensBlock: \"Expected parentheses around arrow function argument having a body with curly braces.\"\n        }\n    },\n\n    create(context) {\n        const asNeeded = context.options[0] === \"as-needed\";\n        const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Finds opening paren of parameters for the given arrow function, if it exists.\n         * It is assumed that the given arrow function has exactly one parameter.\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @returns {Token|null} the opening paren, or `null` if the given arrow function doesn't have parens of parameters.\n         */\n        function findOpeningParenOfParams(node) {\n            const tokenBeforeParams = sourceCode.getTokenBefore(node.params[0]);\n\n            if (\n                tokenBeforeParams &&\n                astUtils.isOpeningParenToken(tokenBeforeParams) &&\n                node.range[0] <= tokenBeforeParams.range[0]\n            ) {\n                return tokenBeforeParams;\n            }\n\n            return null;\n        }\n\n        /**\n         * Finds closing paren of parameters for the given arrow function.\n         * It is assumed that the given arrow function has parens of parameters and that it has exactly one parameter.\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @returns {Token} the closing paren of parameters.\n         */\n        function getClosingParenOfParams(node) {\n            return sourceCode.getTokenAfter(node.params[0], astUtils.isClosingParenToken);\n        }\n\n        /**\n         * Determines whether the given arrow function has comments inside parens of parameters.\n         * It is assumed that the given arrow function has parens of parameters.\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @param {Token} openingParen Opening paren of parameters.\n         * @returns {boolean} `true` if the function has at least one comment inside of parens of parameters.\n         */\n        function hasCommentsInParensOfParams(node, openingParen) {\n            return sourceCode.commentsExistBetween(openingParen, getClosingParenOfParams(node));\n        }\n\n        /**\n         * Determines whether the given arrow function has unexpected tokens before opening paren of parameters,\n         * in which case it will be assumed that the existing parens of parameters are necessary.\n         * Only tokens within the range of the arrow function (tokens that are part of the arrow function) are taken into account.\n         * Example: <T>(a) => b\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @param {Token} openingParen Opening paren of parameters.\n         * @returns {boolean} `true` if the function has at least one unexpected token.\n         */\n        function hasUnexpectedTokensBeforeOpeningParen(node, openingParen) {\n            const expectedCount = node.async ? 1 : 0;\n\n            return sourceCode.getFirstToken(node, { skip: expectedCount }) !== openingParen;\n        }\n\n        return {\n            \"ArrowFunctionExpression[params.length=1]\"(node) {\n                const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node);\n                const openingParen = findOpeningParenOfParams(node);\n                const hasParens = openingParen !== null;\n                const [param] = node.params;\n\n                if (shouldHaveParens && !hasParens) {\n                    context.report({\n                        node,\n                        messageId: requireForBlockBody ? \"expectedParensBlock\" : \"expectedParens\",\n                        loc: param.loc,\n                        *fix(fixer) {\n                            yield fixer.insertTextBefore(param, \"(\");\n                            yield fixer.insertTextAfter(param, \")\");\n                        }\n                    });\n                }\n\n                if (\n                    !shouldHaveParens &&\n                    hasParens &&\n                    param.type === \"Identifier\" &&\n                    !param.typeAnnotation &&\n                    !node.returnType &&\n                    !hasCommentsInParensOfParams(node, openingParen) &&\n                    !hasUnexpectedTokensBeforeOpeningParen(node, openingParen)\n                ) {\n                    context.report({\n                        node,\n                        messageId: requireForBlockBody ? \"unexpectedParensInline\" : \"unexpectedParens\",\n                        loc: param.loc,\n                        *fix(fixer) {\n                            const tokenBeforeOpeningParen = sourceCode.getTokenBefore(openingParen);\n                            const closingParen = getClosingParenOfParams(node);\n\n                            if (\n                                tokenBeforeOpeningParen &&\n                                tokenBeforeOpeningParen.range[1] === openingParen.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBeforeOpeningParen, sourceCode.getFirstToken(param))\n                            ) {\n                                yield fixer.insertTextBefore(openingParen, \" \");\n                            }\n\n                            // remove parens, whitespace inside parens, and possible trailing comma\n                            yield fixer.removeRange([openingParen.range[0], param.range[0]]);\n                            yield fixer.removeRange([param.range[1], closingParen.range[1]]);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}