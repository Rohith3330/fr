{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _helperCompilationTargets = require(\"@babel/helper-compilation-targets\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar _core = require(\"@babel/core\");\n\nvar _globals = require(\"globals\");\n\nvar _transformClass = require(\"./transformClass\");\n\nconst getBuiltinClasses = category => Object.keys(_globals[category]).filter(name => /^[A-Z]/.test(name));\n\nconst builtinClasses = new Set([...getBuiltinClasses(\"builtin\"), ...getBuiltinClasses(\"browser\")]);\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;\n\n  api.assertVersion(7);\n  const {\n    loose = false\n  } = options;\n  const setClassMethods = (_api$assumption = api.assumption(\"setClassMethods\")) != null ? _api$assumption : loose;\n  const constantSuper = (_api$assumption2 = api.assumption(\"constantSuper\")) != null ? _api$assumption2 : loose;\n  const superIsCallableConstructor = (_api$assumption3 = api.assumption(\"superIsCallableConstructor\")) != null ? _api$assumption3 : loose;\n  const noClassCalls = (_api$assumption4 = api.assumption(\"noClassCalls\")) != null ? _api$assumption4 : loose;\n  const supportUnicodeId = !(0, _helperCompilationTargets.isRequired)(\"transform-unicode-escapes\", api.targets());\n  const VISITED = new WeakSet();\n  return {\n    name: \"transform-classes\",\n    visitor: {\n      ExportDefaultDeclaration(path) {\n        if (!path.get(\"declaration\").isClassDeclaration()) return;\n        (0, _helperSplitExportDeclaration.default)(path);\n      },\n\n      ClassDeclaration(path) {\n        const {\n          node\n        } = path;\n        const ref = node.id || path.scope.generateUidIdentifier(\"class\");\n        path.replaceWith(_core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(ref, _core.types.toExpression(node))]));\n      },\n\n      ClassExpression(path, state) {\n        const {\n          node\n        } = path;\n        if (VISITED.has(node)) return;\n        const inferred = (0, _helperFunctionName.default)(path, undefined, supportUnicodeId);\n\n        if (inferred && inferred !== node) {\n          path.replaceWith(inferred);\n          return;\n        }\n\n        VISITED.add(node);\n        const [replacedPath] = path.replaceWith((0, _transformClass.default)(path, state.file, builtinClasses, loose, {\n          setClassMethods,\n          constantSuper,\n          superIsCallableConstructor,\n          noClassCalls\n        }, supportUnicodeId));\n\n        if (replacedPath.isCallExpression()) {\n          (0, _helperAnnotateAsPure.default)(replacedPath);\n          const callee = replacedPath.get(\"callee\");\n\n          if (callee.isArrowFunctionExpression()) {\n            callee.arrowFunctionToExpression();\n          }\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["getBuiltinClasses","category","Object","keys","globals","filter","name","test","builtinClasses","Set","api","options","assertVersion","loose","setClassMethods","assumption","constantSuper","superIsCallableConstructor","noClassCalls","supportUnicodeId","targets","VISITED","WeakSet","visitor","ExportDefaultDeclaration","path","get","isClassDeclaration","ClassDeclaration","node","ref","id","scope","generateUidIdentifier","replaceWith","t","variableDeclaration","variableDeclarator","toExpression","ClassExpression","state","has","inferred","undefined","add","replacedPath","file","isCallExpression","callee","isArrowFunctionExpression","arrowFunctionToExpression"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-transform-classes\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { isRequired } from \"@babel/helper-compilation-targets\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport { types as t } from \"@babel/core\";\nimport globals from \"globals\";\nimport transformClass from \"./transformClass\";\n\nconst getBuiltinClasses = (category: keyof typeof globals) =>\n  Object.keys(globals[category]).filter(name => /^[A-Z]/.test(name));\n\nconst builtinClasses = new Set([\n  ...getBuiltinClasses(\"builtin\"),\n  ...getBuiltinClasses(\"browser\"),\n]);\n\nexport interface Options {\n  loose?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(7);\n\n  const { loose = false } = options;\n\n  const setClassMethods = (api.assumption(\"setClassMethods\") ??\n    loose) as boolean;\n  const constantSuper = (api.assumption(\"constantSuper\") ?? loose) as boolean;\n  const superIsCallableConstructor = (api.assumption(\n    \"superIsCallableConstructor\",\n  ) ?? loose) as boolean;\n  const noClassCalls = (api.assumption(\"noClassCalls\") ?? loose) as boolean;\n  const supportUnicodeId = !isRequired(\n    \"transform-unicode-escapes\",\n    api.targets(),\n  );\n\n  // todo: investigate traversal requeueing\n  const VISITED = new WeakSet();\n\n  return {\n    name: \"transform-classes\",\n\n    visitor: {\n      ExportDefaultDeclaration(path) {\n        if (!path.get(\"declaration\").isClassDeclaration()) return;\n        splitExportDeclaration(path);\n      },\n\n      ClassDeclaration(path) {\n        const { node } = path;\n\n        const ref = node.id || path.scope.generateUidIdentifier(\"class\");\n\n        path.replaceWith(\n          t.variableDeclaration(\"let\", [\n            t.variableDeclarator(ref, t.toExpression(node)),\n          ]),\n        );\n      },\n\n      ClassExpression(path, state) {\n        const { node } = path;\n        if (VISITED.has(node)) return;\n\n        const inferred = nameFunction(path, undefined, supportUnicodeId);\n        if (inferred && inferred !== node) {\n          path.replaceWith(inferred);\n          return;\n        }\n\n        VISITED.add(node);\n\n        const [replacedPath] = path.replaceWith(\n          transformClass(\n            path,\n            state.file,\n            builtinClasses,\n            loose,\n            {\n              setClassMethods,\n              constantSuper,\n              superIsCallableConstructor,\n              noClassCalls,\n            },\n            supportUnicodeId,\n          ),\n        );\n\n        if (replacedPath.isCallExpression()) {\n          annotateAsPure(replacedPath);\n          const callee = replacedPath.get(\"callee\");\n          if (callee.isArrowFunctionExpression()) {\n            // This is an IIFE, so we don't need to worry about the noNewArrows assumption\n            callee.arrowFunctionToExpression();\n          }\n        }\n      },\n    },\n  };\n});\n"]},"metadata":{},"sourceType":"script"}