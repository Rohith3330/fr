{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst isBooleanLiteral = node => node.type === _experimentalUtils.AST_NODE_TYPES.Literal && typeof node.value === 'boolean';\n/**\n * Checks if the given `ParsedExpectMatcher` is a call to one of the equality matchers,\n * with a boolean literal as the sole argument.\n *\n * @example javascript\n * toBe(true);\n * toEqual(false);\n *\n * @param {ParsedExpectMatcher} matcher\n *\n * @return {matcher is ParsedBooleanEqualityMatcher}\n */\n\n\nconst isBooleanEqualityMatcher = matcher => (0, _utils.isParsedEqualityMatcherCall)(matcher) && isBooleanLiteral((0, _utils.followTypeAssertionChain)(matcher.arguments[0]));\n\nconst isString = node => {\n  return (0, _utils.isStringNode)(node) || node.type === _experimentalUtils.AST_NODE_TYPES.TemplateLiteral;\n};\n\nconst isComparingToString = expression => {\n  return isString(expression.left) || isString(expression.right);\n};\n\nconst invertOperator = operator => {\n  switch (operator) {\n    case '>':\n      return '<=';\n\n    case '<':\n      return '>=';\n\n    case '>=':\n      return '<';\n\n    case '<=':\n      return '>';\n  }\n\n  return null;\n};\n\nconst determineMatcher = (operator, negated) => {\n  const op = negated ? invertOperator(operator) : operator;\n\n  switch (op) {\n    case '>':\n      return 'toBeGreaterThan';\n\n    case '<':\n      return 'toBeLessThan';\n\n    case '>=':\n      return 'toBeGreaterThanOrEqual';\n\n    case '<=':\n      return 'toBeLessThanOrEqual';\n  }\n\n  return null;\n};\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Suggest using the built-in comparison matchers',\n      recommended: false\n    },\n    messages: {\n      useToBeComparison: 'Prefer using `{{ preferredMatcher }}` instead'\n    },\n    fixable: 'code',\n    type: 'suggestion',\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        if (!(0, _utils.isExpectCall)(node)) {\n          return;\n        }\n\n        const {\n          expect: {\n            arguments: [comparison],\n            range: [, expectCallEnd]\n          },\n          matcher,\n          modifier\n        } = (0, _utils.parseExpectCall)(node);\n\n        if (!matcher || (comparison === null || comparison === void 0 ? void 0 : comparison.type) !== _experimentalUtils.AST_NODE_TYPES.BinaryExpression || isComparingToString(comparison) || !isBooleanEqualityMatcher(matcher)) {\n          return;\n        }\n\n        const preferredMatcher = determineMatcher(comparison.operator, (0, _utils.followTypeAssertionChain)(matcher.arguments[0]).value === !!modifier);\n\n        if (!preferredMatcher) {\n          return;\n        }\n\n        context.report({\n          fix(fixer) {\n            const sourceCode = context.getSourceCode();\n            return [// replace the comparison argument with the left-hand side of the comparison\n            fixer.replaceText(comparison, sourceCode.getText(comparison.left)), // replace the current matcher & modifier with the preferred matcher\n            fixer.replaceTextRange([expectCallEnd, matcher.node.range[1]], `.${preferredMatcher}`), // replace the matcher argument with the right-hand side of the comparison\n            fixer.replaceText(matcher.arguments[0], sourceCode.getText(comparison.right))];\n          },\n\n          messageId: 'useToBeComparison',\n          data: {\n            preferredMatcher\n          },\n          node: (modifier || matcher).node.property\n        });\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_experimentalUtils","require","_utils","isBooleanLiteral","node","type","AST_NODE_TYPES","Literal","isBooleanEqualityMatcher","matcher","isParsedEqualityMatcherCall","followTypeAssertionChain","arguments","isString","isStringNode","TemplateLiteral","isComparingToString","expression","left","right","invertOperator","operator","determineMatcher","negated","op","_default","createRule","name","__filename","meta","docs","category","description","recommended","messages","useToBeComparison","fixable","schema","defaultOptions","create","context","CallExpression","isExpectCall","expect","comparison","range","expectCallEnd","modifier","parseExpectCall","BinaryExpression","preferredMatcher","report","fix","fixer","sourceCode","getSourceCode","replaceText","getText","replaceTextRange","messageId","data","property"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-jest/lib/rules/prefer-comparison-matcher.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst isBooleanLiteral = node => node.type === _experimentalUtils.AST_NODE_TYPES.Literal && typeof node.value === 'boolean';\n\n/**\n * Checks if the given `ParsedExpectMatcher` is a call to one of the equality matchers,\n * with a boolean literal as the sole argument.\n *\n * @example javascript\n * toBe(true);\n * toEqual(false);\n *\n * @param {ParsedExpectMatcher} matcher\n *\n * @return {matcher is ParsedBooleanEqualityMatcher}\n */\nconst isBooleanEqualityMatcher = matcher => (0, _utils.isParsedEqualityMatcherCall)(matcher) && isBooleanLiteral((0, _utils.followTypeAssertionChain)(matcher.arguments[0]));\n\nconst isString = node => {\n  return (0, _utils.isStringNode)(node) || node.type === _experimentalUtils.AST_NODE_TYPES.TemplateLiteral;\n};\n\nconst isComparingToString = expression => {\n  return isString(expression.left) || isString(expression.right);\n};\n\nconst invertOperator = operator => {\n  switch (operator) {\n    case '>':\n      return '<=';\n\n    case '<':\n      return '>=';\n\n    case '>=':\n      return '<';\n\n    case '<=':\n      return '>';\n  }\n\n  return null;\n};\n\nconst determineMatcher = (operator, negated) => {\n  const op = negated ? invertOperator(operator) : operator;\n\n  switch (op) {\n    case '>':\n      return 'toBeGreaterThan';\n\n    case '<':\n      return 'toBeLessThan';\n\n    case '>=':\n      return 'toBeGreaterThanOrEqual';\n\n    case '<=':\n      return 'toBeLessThanOrEqual';\n  }\n\n  return null;\n};\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Suggest using the built-in comparison matchers',\n      recommended: false\n    },\n    messages: {\n      useToBeComparison: 'Prefer using `{{ preferredMatcher }}` instead'\n    },\n    fixable: 'code',\n    type: 'suggestion',\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        if (!(0, _utils.isExpectCall)(node)) {\n          return;\n        }\n\n        const {\n          expect: {\n            arguments: [comparison],\n            range: [, expectCallEnd]\n          },\n          matcher,\n          modifier\n        } = (0, _utils.parseExpectCall)(node);\n\n        if (!matcher || (comparison === null || comparison === void 0 ? void 0 : comparison.type) !== _experimentalUtils.AST_NODE_TYPES.BinaryExpression || isComparingToString(comparison) || !isBooleanEqualityMatcher(matcher)) {\n          return;\n        }\n\n        const preferredMatcher = determineMatcher(comparison.operator, (0, _utils.followTypeAssertionChain)(matcher.arguments[0]).value === !!modifier);\n\n        if (!preferredMatcher) {\n          return;\n        }\n\n        context.report({\n          fix(fixer) {\n            const sourceCode = context.getSourceCode();\n            return [// replace the comparison argument with the left-hand side of the comparison\n            fixer.replaceText(comparison, sourceCode.getText(comparison.left)), // replace the current matcher & modifier with the preferred matcher\n            fixer.replaceTextRange([expectCallEnd, matcher.node.range[1]], `.${preferredMatcher}`), // replace the matcher argument with the right-hand side of the comparison\n            fixer.replaceText(matcher.arguments[0], sourceCode.getText(comparison.right))];\n          },\n\n          messageId: 'useToBeComparison',\n          data: {\n            preferredMatcher\n          },\n          node: (modifier || matcher).node.property\n        });\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}