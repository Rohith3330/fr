{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _isSimpleType = _interopRequireDefault(require(\"./isSimpleType\"));\n\nvar _needWrap = _interopRequireDefault(require(\"./needWrap\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst schema = [{\n  enum: ['verbose', 'shorthand'],\n  type: 'string'\n}];\n\nconst inlineType = type => {\n  const inlined = type.replace(/\\s+/ug, ' ');\n\n  if (inlined.length <= 50) {\n    return inlined;\n  }\n\n  return 'Type';\n};\n\nvar _default = (defaultConfig, simpleType) => {\n  const create = context => {\n    const verbose = (context.options[0] || defaultConfig) === 'verbose';\n    return {\n      // shorthand\n      ArrayTypeAnnotation(node) {\n        const rawElementType = context.getSourceCode().getText(node.elementType);\n        const inlinedType = inlineType(rawElementType);\n        const wrappedInlinedType = (0, _needWrap.default)(node.elementType) ? '(' + inlinedType + ')' : inlinedType;\n\n        if ((0, _isSimpleType.default)(node.elementType) === simpleType && verbose) {\n          context.report({\n            data: {\n              type: inlinedType,\n              wrappedType: wrappedInlinedType\n            },\n\n            fix(fixer) {\n              return fixer.replaceText(node, 'Array<' + rawElementType + '>');\n            },\n\n            message: 'Use \"Array<{{ type }}>\", not \"{{ wrappedType }}[]\"',\n            node\n          });\n        }\n      },\n\n      // verbose\n      GenericTypeAnnotation(node) {\n        // Don't report on un-parameterized Array annotations. There are valid cases for this,\n        // but regardless, we must NOT crash when encountering them.\n        if (node.id.name === 'Array' && node.typeParameters && node.typeParameters.params.length === 1) {\n          const elementTypeNode = node.typeParameters.params[0];\n          const rawElementType = context.getSourceCode().getText(elementTypeNode);\n          const inlinedType = inlineType(rawElementType);\n          const wrappedInlinedType = (0, _needWrap.default)(elementTypeNode) ? '(' + inlinedType + ')' : inlinedType;\n\n          if ((0, _isSimpleType.default)(elementTypeNode) === simpleType && !verbose) {\n            context.report({\n              data: {\n                type: inlinedType,\n                wrappedType: wrappedInlinedType\n              },\n\n              fix(fixer) {\n                if ((0, _needWrap.default)(elementTypeNode)) {\n                  return fixer.replaceText(node, '(' + rawElementType + ')[]');\n                }\n\n                return fixer.replaceText(node, rawElementType + '[]');\n              },\n\n              message: 'Use \"{{ wrappedType }}[]\", not \"Array<{{ type }}>\"',\n              node\n            });\n          }\n        }\n      }\n\n    };\n  };\n\n  return {\n    create,\n    meta: {\n      fixable: 'code'\n    },\n    schema\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_isSimpleType","_interopRequireDefault","require","_needWrap","obj","__esModule","schema","enum","type","inlineType","inlined","replace","length","_default","defaultConfig","simpleType","create","context","verbose","options","ArrayTypeAnnotation","node","rawElementType","getSourceCode","getText","elementType","inlinedType","wrappedInlinedType","report","data","wrappedType","fix","fixer","replaceText","message","GenericTypeAnnotation","id","name","typeParameters","params","elementTypeNode","meta","fixable","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-flowtype/dist/rules/arrayStyle/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _isSimpleType = _interopRequireDefault(require(\"./isSimpleType\"));\n\nvar _needWrap = _interopRequireDefault(require(\"./needWrap\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst schema = [{\n  enum: ['verbose', 'shorthand'],\n  type: 'string'\n}];\n\nconst inlineType = type => {\n  const inlined = type.replace(/\\s+/ug, ' ');\n\n  if (inlined.length <= 50) {\n    return inlined;\n  }\n\n  return 'Type';\n};\n\nvar _default = (defaultConfig, simpleType) => {\n  const create = context => {\n    const verbose = (context.options[0] || defaultConfig) === 'verbose';\n    return {\n      // shorthand\n      ArrayTypeAnnotation(node) {\n        const rawElementType = context.getSourceCode().getText(node.elementType);\n        const inlinedType = inlineType(rawElementType);\n        const wrappedInlinedType = (0, _needWrap.default)(node.elementType) ? '(' + inlinedType + ')' : inlinedType;\n\n        if ((0, _isSimpleType.default)(node.elementType) === simpleType && verbose) {\n          context.report({\n            data: {\n              type: inlinedType,\n              wrappedType: wrappedInlinedType\n            },\n\n            fix(fixer) {\n              return fixer.replaceText(node, 'Array<' + rawElementType + '>');\n            },\n\n            message: 'Use \"Array<{{ type }}>\", not \"{{ wrappedType }}[]\"',\n            node\n          });\n        }\n      },\n\n      // verbose\n      GenericTypeAnnotation(node) {\n        // Don't report on un-parameterized Array annotations. There are valid cases for this,\n        // but regardless, we must NOT crash when encountering them.\n        if (node.id.name === 'Array' && node.typeParameters && node.typeParameters.params.length === 1) {\n          const elementTypeNode = node.typeParameters.params[0];\n          const rawElementType = context.getSourceCode().getText(elementTypeNode);\n          const inlinedType = inlineType(rawElementType);\n          const wrappedInlinedType = (0, _needWrap.default)(elementTypeNode) ? '(' + inlinedType + ')' : inlinedType;\n\n          if ((0, _isSimpleType.default)(elementTypeNode) === simpleType && !verbose) {\n            context.report({\n              data: {\n                type: inlinedType,\n                wrappedType: wrappedInlinedType\n              },\n\n              fix(fixer) {\n                if ((0, _needWrap.default)(elementTypeNode)) {\n                  return fixer.replaceText(node, '(' + rawElementType + ')[]');\n                }\n\n                return fixer.replaceText(node, rawElementType + '[]');\n              },\n\n              message: 'Use \"{{ wrappedType }}[]\", not \"Array<{{ type }}>\"',\n              node\n            });\n          }\n        }\n      }\n\n    };\n  };\n\n  return {\n    create,\n    meta: {\n      fixable: 'code'\n    },\n    schema\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}