{"ast":null,"code":"const v4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\nconst v4Size = 4;\nconst v6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\nconst v6Size = 16;\nexport const v4 = {\n  name: 'v4',\n  size: v4Size,\n  isFormat: ip => v4Regex.test(ip),\n\n  encode(ip, buff, offset) {\n    offset = ~~offset;\n    buff = buff || new Uint8Array(offset + v4Size);\n    const max = ip.length;\n    let n = 0;\n\n    for (let i = 0; i < max;) {\n      const c = ip.charCodeAt(i++);\n\n      if (c === 46) {\n        // \".\"\n        buff[offset++] = n;\n        n = 0;\n      } else {\n        n = n * 10 + (c - 48);\n      }\n    }\n\n    buff[offset] = n;\n    return buff;\n  },\n\n  decode(buff, offset) {\n    offset = ~~offset;\n    return `${buff[offset++]}.${buff[offset++]}.${buff[offset++]}.${buff[offset]}`;\n  }\n\n};\nexport const v6 = {\n  name: 'v6',\n  size: v6Size,\n  isFormat: ip => ip.length > 0 && v6Regex.test(ip),\n\n  encode(ip, buff, offset) {\n    offset = ~~offset;\n    let end = offset + v6Size;\n    let fill = -1;\n    let hexN = 0;\n    let decN = 0;\n    let prevColon = true;\n    let useDec = false;\n    buff = buff || new Uint8Array(offset + v6Size); // Note: This algorithm needs to check if the offset\n    // could exceed the buffer boundaries as it supports\n    // non-standard compliant encodings that may go beyond\n    // the boundary limits. if (offset < end) checks should\n    // not be necessary...\n\n    for (let i = 0; i < ip.length; i++) {\n      let c = ip.charCodeAt(i);\n\n      if (c === 58) {\n        // :\n        if (prevColon) {\n          if (fill !== -1) {\n            // Not Standard! (standard doesn't allow multiple ::)\n            // We need to treat\n            if (offset < end) buff[offset] = 0;\n            if (offset < end - 1) buff[offset + 1] = 0;\n            offset += 2;\n          } else if (offset < end) {\n            // :: in the middle\n            fill = offset;\n          }\n        } else {\n          // : ends the previous number\n          if (useDec === true) {\n            // Non-standard! (ipv4 should be at end only)\n            // A ipv4 address should not be found anywhere else but at\n            // the end. This codec also support putting characters\n            // after the ipv4 address..\n            if (offset < end) buff[offset] = decN;\n            offset++;\n          } else {\n            if (offset < end) buff[offset] = hexN >> 8;\n            if (offset < end - 1) buff[offset + 1] = hexN & 0xff;\n            offset += 2;\n          }\n\n          hexN = 0;\n          decN = 0;\n        }\n\n        prevColon = true;\n        useDec = false;\n      } else if (c === 46) {\n        // . indicates IPV4 notation\n        if (offset < end) buff[offset] = decN;\n        offset++;\n        decN = 0;\n        hexN = 0;\n        prevColon = false;\n        useDec = true;\n      } else {\n        prevColon = false;\n\n        if (c >= 97) {\n          c -= 87; // a-f ... 97~102 -87 => 10~15\n        } else if (c >= 65) {\n          c -= 55; // A-F ... 65~70 -55 => 10~15\n        } else {\n          c -= 48; // 0-9 ... starting from charCode 48\n\n          decN = decN * 10 + c;\n        } // We don't know yet if its a dec or hex number\n\n\n        hexN = (hexN << 4) + c;\n      }\n    }\n\n    if (prevColon === false) {\n      // Commiting last number\n      if (useDec === true) {\n        if (offset < end) buff[offset] = decN;\n        offset++;\n      } else {\n        if (offset < end) buff[offset] = hexN >> 8;\n        if (offset < end - 1) buff[offset + 1] = hexN & 0xff;\n        offset += 2;\n      }\n    } else if (fill === 0) {\n      // Not Standard! (standard doesn't allow multiple ::)\n      // This means that a : was found at the start AND end which means the\n      // end needs to be treated as 0 entry...\n      if (offset < end) buff[offset] = 0;\n      if (offset < end - 1) buff[offset + 1] = 0;\n      offset += 2;\n    } else if (fill !== -1) {\n      // Non-standard! (standard doens't allow multiple ::)\n      // Here we find that there has been a :: somewhere in the middle\n      // and the end. To treat the end with priority we need to move all\n      // written data two bytes to the right.\n      offset += 2;\n\n      for (let i = Math.min(offset - 1, end - 1); i >= fill + 2; i--) {\n        buff[i] = buff[i - 2];\n      }\n\n      buff[fill] = 0;\n      buff[fill + 1] = 0;\n      fill = offset;\n    }\n\n    if (fill !== offset && fill !== -1) {\n      // Move the written numbers to the end while filling the everything\n      // \"fill\" to the bytes with zeros.\n      if (offset > end - 2) {\n        // Non Standard support, when the cursor exceeds bounds.\n        offset = end - 2;\n      }\n\n      while (end > fill) {\n        buff[--end] = offset < end && offset > fill ? buff[--offset] : 0;\n      }\n    } else {\n      // Fill the rest with zeros\n      while (offset < end) {\n        buff[offset++] = 0;\n      }\n    }\n\n    return buff;\n  },\n\n  decode(buff, offset) {\n    offset = ~~offset;\n    let result = '';\n\n    for (let i = 0; i < v6Size; i += 2) {\n      if (i !== 0) {\n        result += ':';\n      }\n\n      result += (buff[offset + i] << 8 | buff[offset + i + 1]).toString(16);\n    }\n\n    return result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3').replace(/:{3,4}/, '::');\n  }\n\n};\nexport const name = 'ip';\nexport function sizeOf(ip) {\n  if (v4.isFormat(ip)) return v4.size;\n  if (v6.isFormat(ip)) return v6.size;\n  throw Error(`Invalid ip address: ${ip}`);\n}\nexport function familyOf(string) {\n  return sizeOf(string) === v4.size ? 1 : 2;\n}\nexport function encode(ip, buff, offset) {\n  offset = ~~offset;\n  const size = sizeOf(ip);\n\n  if (typeof buff === 'function') {\n    buff = buff(offset + size);\n  }\n\n  if (size === v4.size) {\n    return v4.encode(ip, buff, offset);\n  }\n\n  return v6.encode(ip, buff, offset);\n}\nexport function decode(buff, offset, length) {\n  offset = ~~offset;\n  length = length || buff.length - offset;\n\n  if (length === v4.size) {\n    return v4.decode(buff, offset, length);\n  }\n\n  if (length === v6.size) {\n    return v6.decode(buff, offset, length);\n  }\n\n  throw Error(`Invalid buffer size needs to be ${v4.size} for v4 or ${v6.size} for v6.`);\n}","map":{"version":3,"names":["v4Regex","v4Size","v6Regex","v6Size","v4","name","size","isFormat","ip","test","encode","buff","offset","Uint8Array","max","length","n","i","c","charCodeAt","decode","v6","end","fill","hexN","decN","prevColon","useDec","Math","min","result","toString","replace","sizeOf","Error","familyOf","string"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@leichtgewicht/ip-codec/index.mjs"],"sourcesContent":["const v4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/\nconst v4Size = 4\nconst v6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i\nconst v6Size = 16\n\nexport const v4 = {\n  name: 'v4',\n  size: v4Size,\n  isFormat: ip => v4Regex.test(ip),\n  encode (ip, buff, offset) {\n    offset = ~~offset\n    buff = buff || new Uint8Array(offset + v4Size)\n    const max = ip.length\n    let n = 0\n    for (let i = 0; i < max;) {\n      const c = ip.charCodeAt(i++)\n      if (c === 46) { // \".\"\n        buff[offset++] = n\n        n = 0\n      } else {\n        n = n * 10 + (c - 48)\n      }\n    }\n    buff[offset] = n\n    return buff\n  },\n  decode (buff, offset) {\n    offset = ~~offset\n    return `${buff[offset++]}.${buff[offset++]}.${buff[offset++]}.${buff[offset]}`\n  }\n}\n\nexport const v6 = {\n  name: 'v6',\n  size: v6Size,\n  isFormat: ip => ip.length > 0 && v6Regex.test(ip),\n  encode (ip, buff, offset) {\n    offset = ~~offset\n    let end = offset + v6Size\n    let fill = -1\n    let hexN = 0\n    let decN = 0\n    let prevColon = true\n    let useDec = false\n    buff = buff || new Uint8Array(offset + v6Size)\n    // Note: This algorithm needs to check if the offset\n    // could exceed the buffer boundaries as it supports\n    // non-standard compliant encodings that may go beyond\n    // the boundary limits. if (offset < end) checks should\n    // not be necessary...\n    for (let i = 0; i < ip.length; i++) {\n      let c = ip.charCodeAt(i)\n      if (c === 58) { // :\n        if (prevColon) {\n          if (fill !== -1) {\n            // Not Standard! (standard doesn't allow multiple ::)\n            // We need to treat\n            if (offset < end) buff[offset] = 0\n            if (offset < end - 1) buff[offset + 1] = 0\n            offset += 2\n          } else if (offset < end) {\n            // :: in the middle\n            fill = offset\n          }\n        } else {\n          // : ends the previous number\n          if (useDec === true) {\n            // Non-standard! (ipv4 should be at end only)\n            // A ipv4 address should not be found anywhere else but at\n            // the end. This codec also support putting characters\n            // after the ipv4 address..\n            if (offset < end) buff[offset] = decN\n            offset++\n          } else {\n            if (offset < end) buff[offset] = hexN >> 8\n            if (offset < end - 1) buff[offset + 1] = hexN & 0xff\n            offset += 2\n          }\n          hexN = 0\n          decN = 0\n        }\n        prevColon = true\n        useDec = false\n      } else if (c === 46) { // . indicates IPV4 notation\n        if (offset < end) buff[offset] = decN\n        offset++\n        decN = 0\n        hexN = 0\n        prevColon = false\n        useDec = true\n      } else {\n        prevColon = false\n        if (c >= 97) {\n          c -= 87 // a-f ... 97~102 -87 => 10~15\n        } else if (c >= 65) {\n          c -= 55 // A-F ... 65~70 -55 => 10~15\n        } else {\n          c -= 48 // 0-9 ... starting from charCode 48\n          decN = decN * 10 + c\n        }\n        // We don't know yet if its a dec or hex number\n        hexN = (hexN << 4) + c\n      }\n    }\n    if (prevColon === false) {\n      // Commiting last number\n      if (useDec === true) {\n        if (offset < end) buff[offset] = decN\n        offset++\n      } else {\n        if (offset < end) buff[offset] = hexN >> 8\n        if (offset < end - 1) buff[offset + 1] = hexN & 0xff\n        offset += 2\n      }\n    } else if (fill === 0) {\n      // Not Standard! (standard doesn't allow multiple ::)\n      // This means that a : was found at the start AND end which means the\n      // end needs to be treated as 0 entry...\n      if (offset < end) buff[offset] = 0\n      if (offset < end - 1) buff[offset + 1] = 0\n      offset += 2\n    } else if (fill !== -1) {\n      // Non-standard! (standard doens't allow multiple ::)\n      // Here we find that there has been a :: somewhere in the middle\n      // and the end. To treat the end with priority we need to move all\n      // written data two bytes to the right.\n      offset += 2\n      for (let i = Math.min(offset - 1, end - 1); i >= fill + 2; i--) {\n        buff[i] = buff[i - 2]\n      }\n      buff[fill] = 0\n      buff[fill + 1] = 0\n      fill = offset\n    }\n    if (fill !== offset && fill !== -1) {\n      // Move the written numbers to the end while filling the everything\n      // \"fill\" to the bytes with zeros.\n      if (offset > end - 2) {\n        // Non Standard support, when the cursor exceeds bounds.\n        offset = end - 2\n      }\n      while (end > fill) {\n        buff[--end] = offset < end && offset > fill ? buff[--offset] : 0\n      }\n    } else {\n      // Fill the rest with zeros\n      while (offset < end) {\n        buff[offset++] = 0\n      }\n    }\n    return buff\n  },\n  decode (buff, offset) {\n    offset = ~~offset\n    let result = ''\n    for (let i = 0; i < v6Size; i += 2) {\n      if (i !== 0) {\n        result += ':'\n      }\n      result += (buff[offset + i] << 8 | buff[offset + i + 1]).toString(16)\n    }\n    return result\n      .replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')\n      .replace(/:{3,4}/, '::')\n  }\n}\n\nexport const name = 'ip'\nexport function sizeOf (ip) {\n  if (v4.isFormat(ip)) return v4.size\n  if (v6.isFormat(ip)) return v6.size\n  throw Error(`Invalid ip address: ${ip}`)\n}\n\nexport function familyOf (string) {\n  return sizeOf(string) === v4.size ? 1 : 2\n}\n\nexport function encode (ip, buff, offset) {\n  offset = ~~offset\n  const size = sizeOf(ip)\n  if (typeof buff === 'function') {\n    buff = buff(offset + size)\n  }\n  if (size === v4.size) {\n    return v4.encode(ip, buff, offset)\n  }\n  return v6.encode(ip, buff, offset)\n}\n\nexport function decode (buff, offset, length) {\n  offset = ~~offset\n  length = length || (buff.length - offset)\n  if (length === v4.size) {\n    return v4.decode(buff, offset, length)\n  }\n  if (length === v6.size) {\n    return v6.decode(buff, offset, length)\n  }\n  throw Error(`Invalid buffer size needs to be ${v4.size} for v4 or ${v6.size} for v6.`)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}