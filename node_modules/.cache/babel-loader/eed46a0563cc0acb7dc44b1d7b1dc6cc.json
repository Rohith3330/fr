{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils_1 = require(\"tsutils\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util_1 = require(\"../util\"); // Truthiness utilities\n// #region\n\n\nconst isTruthyLiteral = type => (0, tsutils_1.isBooleanLiteralType)(type, true) || (0, tsutils_1.isLiteralType)(type) && !!type.value;\n\nconst isPossiblyFalsy = type => (0, tsutils_1.unionTypeParts)(type) // PossiblyFalsy flag includes literal values, so exclude ones that\n// are definitely truthy\n.filter(t => !isTruthyLiteral(t)).some(type => (0, util_1.isTypeFlagSet)(type, ts.TypeFlags.PossiblyFalsy));\n\nconst isPossiblyTruthy = type => (0, tsutils_1.unionTypeParts)(type).some(type => !(0, tsutils_1.isFalsyType)(type)); // Nullish utilities\n\n\nconst nullishFlag = ts.TypeFlags.Undefined | ts.TypeFlags.Null;\n\nconst isNullishType = type => (0, util_1.isTypeFlagSet)(type, nullishFlag);\n\nconst isPossiblyNullish = type => (0, tsutils_1.unionTypeParts)(type).some(isNullishType);\n\nconst isAlwaysNullish = type => (0, tsutils_1.unionTypeParts)(type).every(isNullishType); // isLiteralType only covers numbers and strings, this is a more exhaustive check.\n\n\nconst isLiteral = type => (0, tsutils_1.isBooleanLiteralType)(type, true) || (0, tsutils_1.isBooleanLiteralType)(type, false) || type.flags === ts.TypeFlags.Undefined || type.flags === ts.TypeFlags.Null || type.flags === ts.TypeFlags.Void || (0, tsutils_1.isLiteralType)(type);\n\nexports.default = (0, util_1.createRule)({\n  name: 'no-unnecessary-condition',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow conditionals where the type is always truthy or always falsy',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowConstantLoopConditions: {\n          description: 'Whether to ignore constant loop conditions, such as `while (true)`.',\n          type: 'boolean'\n        },\n        allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {\n          description: 'Whether to not error when running with a tsconfig that has strictNullChecks turned.',\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: 'code',\n    messages: {\n      alwaysTruthy: 'Unnecessary conditional, value is always truthy.',\n      alwaysFalsy: 'Unnecessary conditional, value is always falsy.',\n      alwaysTruthyFunc: 'This callback should return a conditional, but return is always truthy.',\n      alwaysFalsyFunc: 'This callback should return a conditional, but return is always falsy.',\n      neverNullish: 'Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.',\n      alwaysNullish: 'Unnecessary conditional, left-hand side of `??` operator is always `null` or `undefined`.',\n      literalBooleanExpression: 'Unnecessary conditional, both sides of the expression are literal values.',\n      noOverlapBooleanExpression: 'Unnecessary conditional, the types have no overlap.',\n      never: 'Unnecessary conditional, value is `never`.',\n      neverOptionalChain: 'Unnecessary optional chain on a non-nullish value.',\n      noStrictNullCheck: 'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.'\n    }\n  },\n  defaultOptions: [{\n    allowConstantLoopConditions: false,\n    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false\n  }],\n\n  create(context, _ref) {\n    let [{\n      allowConstantLoopConditions,\n      allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing\n    }] = _ref;\n    const service = (0, util_1.getParserServices)(context);\n    const checker = service.program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n    const compilerOptions = service.program.getCompilerOptions();\n    const isStrictNullChecks = (0, tsutils_1.isStrictCompilerOptionEnabled)(compilerOptions, 'strictNullChecks');\n\n    if (!isStrictNullChecks && allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {\n      context.report({\n        loc: {\n          start: {\n            line: 0,\n            column: 0\n          },\n          end: {\n            line: 0,\n            column: 0\n          }\n        },\n        messageId: 'noStrictNullCheck'\n      });\n    }\n\n    function getNodeType(node) {\n      const tsNode = service.esTreeNodeToTSNodeMap.get(node);\n      return (0, util_1.getConstrainedTypeAtLocation)(checker, tsNode);\n    }\n\n    function nodeIsArrayType(node) {\n      const nodeType = getNodeType(node);\n      return checker.isArrayType(nodeType);\n    }\n\n    function nodeIsTupleType(node) {\n      const nodeType = getNodeType(node);\n      return checker.isTupleType(nodeType);\n    }\n\n    function isArrayIndexExpression(node) {\n      return (// Is an index signature\n        node.type === utils_1.AST_NODE_TYPES.MemberExpression && node.computed && ( // ...into an array type\n        nodeIsArrayType(node.object) || // ... or a tuple type\n        nodeIsTupleType(node.object) && // Exception: literal index into a tuple - will have a sound type\n        node.property.type !== utils_1.AST_NODE_TYPES.Literal)\n      );\n    }\n    /**\n     * Checks if a conditional node is necessary:\n     * if the type of the node is always true or always false, it's not necessary.\n     */\n\n\n    function checkNode(node) {\n      let isUnaryNotArgument = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // Check if the node is Unary Negation expression and handle it\n      if (node.type === utils_1.AST_NODE_TYPES.UnaryExpression && node.operator === '!') {\n        return checkNode(node.argument, true);\n      } // Since typescript array index signature types don't represent the\n      //  possibility of out-of-bounds access, if we're indexing into an array\n      //  just skip the check, to avoid false positives\n\n\n      if (isArrayIndexExpression(node)) {\n        return;\n      } // When checking logical expressions, only check the right side\n      //  as the left side has been checked by checkLogicalExpressionForUnnecessaryConditionals\n      //\n      // Unless the node is nullish coalescing, as it's common to use patterns like `nullBool ?? true` to to strict\n      //  boolean checks if we inspect the right here, it'll usually be a constant condition on purpose.\n      // In this case it's better to inspect the type of the expression as a whole.\n\n\n      if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression && node.operator !== '??') {\n        return checkNode(node.right);\n      }\n\n      const type = getNodeType(node); // Conditional is always necessary if it involves:\n      //    `any` or `unknown` or a naked type parameter\n\n      if ((0, tsutils_1.unionTypeParts)(type).some(part => (0, util_1.isTypeAnyType)(part) || (0, util_1.isTypeUnknownType)(part) || (0, util_1.isTypeFlagSet)(part, ts.TypeFlags.TypeParameter))) {\n        return;\n      }\n\n      let messageId = null;\n\n      if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {\n        messageId = 'never';\n      } else if (!isPossiblyTruthy(type)) {\n        messageId = !isUnaryNotArgument ? 'alwaysFalsy' : 'alwaysTruthy';\n      } else if (!isPossiblyFalsy(type)) {\n        messageId = !isUnaryNotArgument ? 'alwaysTruthy' : 'alwaysFalsy';\n      }\n\n      if (messageId) {\n        context.report({\n          node,\n          messageId\n        });\n      }\n    }\n\n    function checkNodeForNullish(node) {\n      const type = getNodeType(node); // Conditional is always necessary if it involves `any` or `unknown`\n\n      if ((0, util_1.isTypeAnyType)(type) || (0, util_1.isTypeUnknownType)(type)) {\n        return;\n      }\n\n      let messageId = null;\n\n      if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {\n        messageId = 'never';\n      } else if (!isPossiblyNullish(type)) {\n        // Since typescript array index signature types don't represent the\n        //  possibility of out-of-bounds access, if we're indexing into an array\n        //  just skip the check, to avoid false positives\n        if (!isArrayIndexExpression(node) && !(node.type === utils_1.AST_NODE_TYPES.ChainExpression && node.expression.type !== utils_1.AST_NODE_TYPES.TSNonNullExpression && optionChainContainsOptionArrayIndex(node.expression))) {\n          messageId = 'neverNullish';\n        }\n      } else if (isAlwaysNullish(type)) {\n        messageId = 'alwaysNullish';\n      }\n\n      if (messageId) {\n        context.report({\n          node,\n          messageId\n        });\n      }\n    }\n    /**\n     * Checks that a binary expression is necessarily conditional, reports otherwise.\n     * If both sides of the binary expression are literal values, it's not a necessary condition.\n     *\n     * NOTE: It's also unnecessary if the types that don't overlap at all\n     *    but that case is handled by the Typescript compiler itself.\n     *    Known exceptions:\n     *      * https://github.com/microsoft/TypeScript/issues/32627\n     *      * https://github.com/microsoft/TypeScript/issues/37160 (handled)\n     */\n\n\n    const BOOL_OPERATORS = new Set(['<', '>', '<=', '>=', '==', '===', '!=', '!==']);\n\n    function checkIfBinaryExpressionIsNecessaryConditional(node) {\n      if (!BOOL_OPERATORS.has(node.operator)) {\n        return;\n      }\n\n      const leftType = getNodeType(node.left);\n      const rightType = getNodeType(node.right);\n\n      if (isLiteral(leftType) && isLiteral(rightType)) {\n        context.report({\n          node,\n          messageId: 'literalBooleanExpression'\n        });\n        return;\n      } // Workaround for https://github.com/microsoft/TypeScript/issues/37160\n\n\n      if (isStrictNullChecks) {\n        const UNDEFINED = ts.TypeFlags.Undefined;\n        const NULL = ts.TypeFlags.Null;\n\n        const isComparable = (type, flag) => {\n          // Allow comparison to `any`, `unknown` or a naked type parameter.\n          flag |= ts.TypeFlags.Any | ts.TypeFlags.Unknown | ts.TypeFlags.TypeParameter; // Allow loose comparison to nullish values.\n\n          if (node.operator === '==' || node.operator === '!=') {\n            flag |= NULL | UNDEFINED;\n          }\n\n          return (0, util_1.isTypeFlagSet)(type, flag);\n        };\n\n        if (leftType.flags === UNDEFINED && !isComparable(rightType, UNDEFINED) || rightType.flags === UNDEFINED && !isComparable(leftType, UNDEFINED) || leftType.flags === NULL && !isComparable(rightType, NULL) || rightType.flags === NULL && !isComparable(leftType, NULL)) {\n          context.report({\n            node,\n            messageId: 'noOverlapBooleanExpression'\n          });\n          return;\n        }\n      }\n    }\n    /**\n     * Checks that a logical expression contains a boolean, reports otherwise.\n     */\n\n\n    function checkLogicalExpressionForUnnecessaryConditionals(node) {\n      if (node.operator === '??') {\n        checkNodeForNullish(node.left);\n        return;\n      } // Only checks the left side, since the right side might not be \"conditional\" at all.\n      // The right side will be checked if the LogicalExpression is used in a conditional context\n\n\n      checkNode(node.left);\n    }\n    /**\n     * Checks that a testable expression of a loop is necessarily conditional, reports otherwise.\n     */\n\n\n    function checkIfLoopIsNecessaryConditional(node) {\n      if (node.test === null) {\n        // e.g. `for(;;)`\n        return;\n      }\n      /**\n       * Allow:\n       *   while (true) {}\n       *   for (;true;) {}\n       *   do {} while (true)\n       */\n\n\n      if (allowConstantLoopConditions && (0, tsutils_1.isBooleanLiteralType)(getNodeType(node.test), true)) {\n        return;\n      }\n\n      checkNode(node.test);\n    }\n\n    const ARRAY_PREDICATE_FUNCTIONS = new Set(['filter', 'find', 'some', 'every']);\n\n    function isArrayPredicateFunction(node) {\n      const {\n        callee\n      } = node;\n      return (// looks like `something.filter` or `something.find`\n        callee.type === utils_1.AST_NODE_TYPES.MemberExpression && callee.property.type === utils_1.AST_NODE_TYPES.Identifier && ARRAY_PREDICATE_FUNCTIONS.has(callee.property.name) && ( // and the left-hand side is an array, according to the types\n        nodeIsArrayType(callee.object) || nodeIsTupleType(callee.object))\n      );\n    }\n\n    function checkCallExpression(node) {\n      // If this is something like arr.filter(x => /*condition*/), check `condition`\n      if (isArrayPredicateFunction(node) && node.arguments.length) {\n        const callback = node.arguments[0]; // Inline defined functions\n\n        if ((callback.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression || callback.type === utils_1.AST_NODE_TYPES.FunctionExpression) && callback.body) {\n          // Two special cases, where we can directly check the node that's returned:\n          // () => something\n          if (callback.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {\n            return checkNode(callback.body);\n          } // () => { return something; }\n\n\n          const callbackBody = callback.body.body;\n\n          if (callbackBody.length === 1 && callbackBody[0].type === utils_1.AST_NODE_TYPES.ReturnStatement && callbackBody[0].argument) {\n            return checkNode(callbackBody[0].argument);\n          } // Potential enhancement: could use code-path analysis to check\n          //   any function with a single return statement\n          // (Value to complexity ratio is dubious however)\n\n        } // Otherwise just do type analysis on the function as a whole.\n\n\n        const returnTypes = (0, tsutils_1.getCallSignaturesOfType)(getNodeType(callback)).map(sig => sig.getReturnType());\n        /* istanbul ignore if */\n\n        if (returnTypes.length === 0) {\n          // Not a callable function\n          return;\n        } // Predicate is always necessary if it involves `any` or `unknown`\n\n\n        if (returnTypes.some(t => (0, util_1.isTypeAnyType)(t) || (0, util_1.isTypeUnknownType)(t))) {\n          return;\n        }\n\n        if (!returnTypes.some(isPossiblyFalsy)) {\n          return context.report({\n            node: callback,\n            messageId: 'alwaysTruthyFunc'\n          });\n        }\n\n        if (!returnTypes.some(isPossiblyTruthy)) {\n          return context.report({\n            node: callback,\n            messageId: 'alwaysFalsyFunc'\n          });\n        }\n      }\n    } // Recursively searches an optional chain for an array index expression\n    //  Has to search the entire chain, because an array index will \"infect\" the rest of the types\n    //  Example:\n    //  ```\n    //  [{x: {y: \"z\"} }][n] // type is {x: {y: \"z\"}}\n    //    ?.x // type is {y: \"z\"}\n    //    ?.y // This access is considered \"unnecessary\" according to the types\n    //  ```\n\n\n    function optionChainContainsOptionArrayIndex(node) {\n      const lhsNode = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;\n\n      if (node.optional && isArrayIndexExpression(lhsNode)) {\n        return true;\n      }\n\n      if (lhsNode.type === utils_1.AST_NODE_TYPES.MemberExpression || lhsNode.type === utils_1.AST_NODE_TYPES.CallExpression) {\n        return optionChainContainsOptionArrayIndex(lhsNode);\n      }\n\n      return false;\n    }\n\n    function isNullablePropertyType(objType, propertyType) {\n      if (propertyType.isUnion()) {\n        return propertyType.types.some(type => isNullablePropertyType(objType, type));\n      }\n\n      if (propertyType.isNumberLiteral() || propertyType.isStringLiteral()) {\n        const propType = (0, util_1.getTypeOfPropertyOfName)(checker, objType, propertyType.value.toString());\n\n        if (propType) {\n          return (0, util_1.isNullableType)(propType, {\n            allowUndefined: true\n          });\n        }\n      }\n\n      const typeName = (0, util_1.getTypeName)(checker, propertyType);\n      return !!(typeName === 'string' && checker.getIndexInfoOfType(objType, ts.IndexKind.String) || typeName === 'number' && checker.getIndexInfoOfType(objType, ts.IndexKind.Number));\n    } // Checks whether a member expression is nullable or not regardless of it's previous node.\n    //  Example:\n    //  ```\n    //  // 'bar' is nullable if 'foo' is null.\n    //  // but this function checks regardless of 'foo' type, so returns 'true'.\n    //  declare const foo: { bar : { baz: string } } | null\n    //  foo?.bar;\n    //  ```\n\n\n    function isNullableOriginFromPrev(node) {\n      const prevType = getNodeType(node.object);\n      const property = node.property;\n\n      if (prevType.isUnion() && (0, util_1.isIdentifier)(property)) {\n        const isOwnNullable = prevType.types.some(type => {\n          if (node.computed) {\n            const propertyType = getNodeType(node.property);\n            return isNullablePropertyType(type, propertyType);\n          }\n\n          const propType = (0, util_1.getTypeOfPropertyOfName)(checker, type, property.name);\n          return propType && (0, util_1.isNullableType)(propType, {\n            allowUndefined: true\n          });\n        });\n        return !isOwnNullable && (0, util_1.isNullableType)(prevType, {\n          allowUndefined: true\n        });\n      }\n\n      return false;\n    }\n\n    function isOptionableExpression(node) {\n      const type = getNodeType(node);\n      const isOwnNullable = node.type === utils_1.AST_NODE_TYPES.MemberExpression ? !isNullableOriginFromPrev(node) : true;\n      return (0, util_1.isTypeAnyType)(type) || (0, util_1.isTypeUnknownType)(type) || (0, util_1.isNullableType)(type, {\n        allowUndefined: true\n      }) && isOwnNullable;\n    }\n\n    function checkOptionalChain(node, beforeOperator, fix) {\n      // We only care if this step in the chain is optional. If just descend\n      // from an optional chain, then that's fine.\n      if (!node.optional) {\n        return;\n      } // Since typescript array index signature types don't represent the\n      //  possibility of out-of-bounds access, if we're indexing into an array\n      //  just skip the check, to avoid false positives\n\n\n      if (optionChainContainsOptionArrayIndex(node)) {\n        return;\n      }\n\n      const nodeToCheck = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;\n\n      if (isOptionableExpression(nodeToCheck)) {\n        return;\n      }\n\n      const questionDotOperator = (0, util_1.nullThrows)(sourceCode.getTokenAfter(beforeOperator, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator && token.value === '?.'), util_1.NullThrowsReasons.MissingToken('operator', node.type));\n      context.report({\n        node,\n        loc: questionDotOperator.loc,\n        messageId: 'neverOptionalChain',\n\n        fix(fixer) {\n          return fixer.replaceText(questionDotOperator, fix);\n        }\n\n      });\n    }\n\n    function checkOptionalMemberExpression(node) {\n      checkOptionalChain(node, node.object, node.computed ? '' : '.');\n    }\n\n    function checkOptionalCallExpression(node) {\n      checkOptionalChain(node, node.callee, '');\n    }\n\n    return {\n      BinaryExpression: checkIfBinaryExpressionIsNecessaryConditional,\n      CallExpression: checkCallExpression,\n      ConditionalExpression: node => checkNode(node.test),\n      DoWhileStatement: checkIfLoopIsNecessaryConditional,\n      ForStatement: checkIfLoopIsNecessaryConditional,\n      IfStatement: node => checkNode(node.test),\n      LogicalExpression: checkLogicalExpressionForUnnecessaryConditionals,\n      WhileStatement: checkIfLoopIsNecessaryConditional,\n      'MemberExpression[optional = true]': checkOptionalMemberExpression,\n      'CallExpression[optional = true]': checkOptionalCallExpression\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["isTruthyLiteral","type","value","isPossiblyFalsy","filter","t","some","ts","TypeFlags","PossiblyFalsy","isPossiblyTruthy","nullishFlag","Undefined","Null","isNullishType","isPossiblyNullish","isAlwaysNullish","every","isLiteral","flags","Void","exports","name","meta","docs","description","recommended","requiresTypeChecking","schema","properties","allowConstantLoopConditions","allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing","additionalProperties","fixable","messages","alwaysTruthy","alwaysFalsy","alwaysTruthyFunc","alwaysFalsyFunc","neverNullish","alwaysNullish","literalBooleanExpression","noOverlapBooleanExpression","never","neverOptionalChain","noStrictNullCheck","defaultOptions","create","context","service","checker","program","getTypeChecker","sourceCode","getSourceCode","compilerOptions","getCompilerOptions","isStrictNullChecks","report","loc","start","line","column","end","messageId","getNodeType","node","tsNode","esTreeNodeToTSNodeMap","get","nodeIsArrayType","nodeType","isArrayType","nodeIsTupleType","isTupleType","isArrayIndexExpression","utils_1","MemberExpression","computed","object","property","Literal","checkNode","isUnaryNotArgument","UnaryExpression","operator","argument","LogicalExpression","right","part","TypeParameter","Never","checkNodeForNullish","ChainExpression","expression","TSNonNullExpression","optionChainContainsOptionArrayIndex","BOOL_OPERATORS","Set","checkIfBinaryExpressionIsNecessaryConditional","has","leftType","left","rightType","UNDEFINED","NULL","isComparable","flag","Any","Unknown","checkLogicalExpressionForUnnecessaryConditionals","checkIfLoopIsNecessaryConditional","test","ARRAY_PREDICATE_FUNCTIONS","isArrayPredicateFunction","callee","Identifier","checkCallExpression","arguments","length","callback","ArrowFunctionExpression","FunctionExpression","body","BlockStatement","callbackBody","ReturnStatement","returnTypes","map","sig","getReturnType","lhsNode","CallExpression","optional","isNullablePropertyType","objType","propertyType","isUnion","types","isNumberLiteral","isStringLiteral","propType","toString","allowUndefined","typeName","getIndexInfoOfType","IndexKind","String","Number","isNullableOriginFromPrev","prevType","isOwnNullable","isOptionableExpression","checkOptionalChain","beforeOperator","fix","nodeToCheck","questionDotOperator","getTokenAfter","token","Punctuator","util_1","MissingToken","fixer","replaceText","checkOptionalMemberExpression","checkOptionalCallExpression","BinaryExpression","ConditionalExpression","DoWhileStatement","ForStatement","IfStatement","WhileStatement"],"sources":["../../src/rules/no-unnecessary-condition.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}