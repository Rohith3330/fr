{"ast":null,"code":"/**\n * @fileoverview Prefer destructuring from arrays and objects\n * @author Alex LaFroscia\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils.getPrecedence({\n  type: \"AssignmentExpression\"\n}); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Require destructuring from arrays and/or objects\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-destructuring\"\n    },\n    fixable: \"code\",\n    schema: [{\n      /*\n       * old support {array: Boolean, object: Boolean}\n       * new support {VariableDeclarator: {}, AssignmentExpression: {}}\n       */\n      oneOf: [{\n        type: \"object\",\n        properties: {\n          VariableDeclarator: {\n            type: \"object\",\n            properties: {\n              array: {\n                type: \"boolean\"\n              },\n              object: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          AssignmentExpression: {\n            type: \"object\",\n            properties: {\n              array: {\n                type: \"boolean\"\n              },\n              object: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          array: {\n            type: \"boolean\"\n          },\n          object: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        enforceForRenamedProperties: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      preferDestructuring: \"Use {{type}} destructuring.\"\n    }\n  },\n\n  create(context) {\n    const enabledTypes = context.options[0];\n    const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;\n    let normalizedOptions = {\n      VariableDeclarator: {\n        array: true,\n        object: true\n      },\n      AssignmentExpression: {\n        array: true,\n        object: true\n      }\n    };\n\n    if (enabledTypes) {\n      normalizedOptions = typeof enabledTypes.array !== \"undefined\" || typeof enabledTypes.object !== \"undefined\" ? {\n        VariableDeclarator: enabledTypes,\n        AssignmentExpression: enabledTypes\n      } : enabledTypes;\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Checks if destructuring type should be checked.\n     * @param {string} nodeType \"AssignmentExpression\" or \"VariableDeclarator\"\n     * @param {string} destructuringType \"array\" or \"object\"\n     * @returns {boolean} `true` if the destructuring type should be checked for the given node\n     */\n\n\n    function shouldCheck(nodeType, destructuringType) {\n      return normalizedOptions && normalizedOptions[nodeType] && normalizedOptions[nodeType][destructuringType];\n    }\n    /**\n     * Determines if the given node is accessing an array index\n     *\n     * This is used to differentiate array index access from object property\n     * access.\n     * @param {ASTNode} node the node to evaluate\n     * @returns {boolean} whether or not the node is an integer\n     */\n\n\n    function isArrayIndexAccess(node) {\n      return Number.isInteger(node.property.value);\n    }\n    /**\n     * Report that the given node should use destructuring\n     * @param {ASTNode} reportNode the node to report\n     * @param {string} type the type of destructuring that should have been done\n     * @param {Function|null} fix the fix function or null to pass to context.report\n     * @returns {void}\n     */\n\n\n    function report(reportNode, type, fix) {\n      context.report({\n        node: reportNode,\n        messageId: \"preferDestructuring\",\n        data: {\n          type\n        },\n        fix\n      });\n    }\n    /**\n     * Determines if a node should be fixed into object destructuring\n     *\n     * The fixer only fixes the simplest case of object destructuring,\n     * like: `let x = a.x`;\n     *\n     * Assignment expression is not fixed.\n     * Array destructuring is not fixed.\n     * Renamed property is not fixed.\n     * @param {ASTNode} node the node to evaluate\n     * @returns {boolean} whether or not the node should be fixed\n     */\n\n\n    function shouldFix(node) {\n      return node.type === \"VariableDeclarator\" && node.id.type === \"Identifier\" && node.init.type === \"MemberExpression\" && !node.init.computed && node.init.property.type === \"Identifier\" && node.id.name === node.init.property.name;\n    }\n    /**\n     * Fix a node into object destructuring.\n     * This function only handles the simplest case of object destructuring,\n     * see {@link shouldFix}.\n     * @param {SourceCodeFixer} fixer the fixer object\n     * @param {ASTNode} node the node to be fixed.\n     * @returns {Object} a fix for the node\n     */\n\n\n    function fixIntoObjectDestructuring(fixer, node) {\n      const rightNode = node.init;\n      const sourceCode = context.getSourceCode(); // Don't fix if that would remove any comments. Only comments inside `rightNode.object` can be preserved.\n\n      if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(rightNode.object).length) {\n        return null;\n      }\n\n      let objectText = sourceCode.getText(rightNode.object);\n\n      if (astUtils.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n        objectText = `(${objectText})`;\n      }\n\n      return fixer.replaceText(node, `{${rightNode.property.name}} = ${objectText}`);\n    }\n    /**\n     * Check that the `prefer-destructuring` rules are followed based on the\n     * given left- and right-hand side of the assignment.\n     *\n     * Pulled out into a separate method so that VariableDeclarators and\n     * AssignmentExpressions can share the same verification logic.\n     * @param {ASTNode} leftNode the left-hand side of the assignment\n     * @param {ASTNode} rightNode the right-hand side of the assignment\n     * @param {ASTNode} reportNode the node to report the error on\n     * @returns {void}\n     */\n\n\n    function performCheck(leftNode, rightNode, reportNode) {\n      if (rightNode.type !== \"MemberExpression\" || rightNode.object.type === \"Super\" || rightNode.property.type === \"PrivateIdentifier\") {\n        return;\n      }\n\n      if (isArrayIndexAccess(rightNode)) {\n        if (shouldCheck(reportNode.type, \"array\")) {\n          report(reportNode, \"array\", null);\n        }\n\n        return;\n      }\n\n      const fix = shouldFix(reportNode) ? fixer => fixIntoObjectDestructuring(fixer, reportNode) : null;\n\n      if (shouldCheck(reportNode.type, \"object\") && enforceForRenamedProperties) {\n        report(reportNode, \"object\", fix);\n        return;\n      }\n\n      if (shouldCheck(reportNode.type, \"object\")) {\n        const property = rightNode.property;\n\n        if (property.type === \"Literal\" && leftNode.name === property.value || property.type === \"Identifier\" && leftNode.name === property.name && !rightNode.computed) {\n          report(reportNode, \"object\", fix);\n        }\n      }\n    }\n    /**\n     * Check if a given variable declarator is coming from an property access\n     * that should be using destructuring instead\n     * @param {ASTNode} node the variable declarator to check\n     * @returns {void}\n     */\n\n\n    function checkVariableDeclarator(node) {\n      // Skip if variable is declared without assignment\n      if (!node.init) {\n        return;\n      } // We only care about member expressions past this point\n\n\n      if (node.init.type !== \"MemberExpression\") {\n        return;\n      }\n\n      performCheck(node.id, node.init, node);\n    }\n    /**\n     * Run the `prefer-destructuring` check on an AssignmentExpression\n     * @param {ASTNode} node the AssignmentExpression node\n     * @returns {void}\n     */\n\n\n    function checkAssignmentExpression(node) {\n      if (node.operator === \"=\") {\n        performCheck(node.left, node.right, node);\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      VariableDeclarator: checkVariableDeclarator,\n      AssignmentExpression: checkAssignmentExpression\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","PRECEDENCE_OF_ASSIGNMENT_EXPR","getPrecedence","type","module","exports","meta","docs","description","recommended","url","fixable","schema","oneOf","properties","VariableDeclarator","array","object","additionalProperties","AssignmentExpression","enforceForRenamedProperties","messages","preferDestructuring","create","context","enabledTypes","options","normalizedOptions","shouldCheck","nodeType","destructuringType","isArrayIndexAccess","node","Number","isInteger","property","value","report","reportNode","fix","messageId","data","shouldFix","id","init","computed","name","fixIntoObjectDestructuring","fixer","rightNode","sourceCode","getSourceCode","getCommentsInside","length","objectText","getText","replaceText","performCheck","leftNode","checkVariableDeclarator","checkAssignmentExpression","operator","left","right"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/prefer-destructuring.js"],"sourcesContent":["/**\n * @fileoverview Prefer destructuring from arrays and objects\n * @author Alex LaFroscia\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils.getPrecedence({ type: \"AssignmentExpression\" });\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require destructuring from arrays and/or objects\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-destructuring\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n\n                /*\n                 * old support {array: Boolean, object: Boolean}\n                 * new support {VariableDeclarator: {}, AssignmentExpression: {}}\n                 */\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            VariableDeclarator: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            },\n                            AssignmentExpression: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            array: {\n                                type: \"boolean\"\n                            },\n                            object: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    enforceForRenamedProperties: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            preferDestructuring: \"Use {{type}} destructuring.\"\n        }\n    },\n    create(context) {\n\n        const enabledTypes = context.options[0];\n        const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;\n        let normalizedOptions = {\n            VariableDeclarator: { array: true, object: true },\n            AssignmentExpression: { array: true, object: true }\n        };\n\n        if (enabledTypes) {\n            normalizedOptions = typeof enabledTypes.array !== \"undefined\" || typeof enabledTypes.object !== \"undefined\"\n                ? { VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes }\n                : enabledTypes;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks if destructuring type should be checked.\n         * @param {string} nodeType \"AssignmentExpression\" or \"VariableDeclarator\"\n         * @param {string} destructuringType \"array\" or \"object\"\n         * @returns {boolean} `true` if the destructuring type should be checked for the given node\n         */\n        function shouldCheck(nodeType, destructuringType) {\n            return normalizedOptions &&\n                normalizedOptions[nodeType] &&\n                normalizedOptions[nodeType][destructuringType];\n        }\n\n        /**\n         * Determines if the given node is accessing an array index\n         *\n         * This is used to differentiate array index access from object property\n         * access.\n         * @param {ASTNode} node the node to evaluate\n         * @returns {boolean} whether or not the node is an integer\n         */\n        function isArrayIndexAccess(node) {\n            return Number.isInteger(node.property.value);\n        }\n\n        /**\n         * Report that the given node should use destructuring\n         * @param {ASTNode} reportNode the node to report\n         * @param {string} type the type of destructuring that should have been done\n         * @param {Function|null} fix the fix function or null to pass to context.report\n         * @returns {void}\n         */\n        function report(reportNode, type, fix) {\n            context.report({\n                node: reportNode,\n                messageId: \"preferDestructuring\",\n                data: { type },\n                fix\n            });\n        }\n\n        /**\n         * Determines if a node should be fixed into object destructuring\n         *\n         * The fixer only fixes the simplest case of object destructuring,\n         * like: `let x = a.x`;\n         *\n         * Assignment expression is not fixed.\n         * Array destructuring is not fixed.\n         * Renamed property is not fixed.\n         * @param {ASTNode} node the node to evaluate\n         * @returns {boolean} whether or not the node should be fixed\n         */\n        function shouldFix(node) {\n            return node.type === \"VariableDeclarator\" &&\n                node.id.type === \"Identifier\" &&\n                node.init.type === \"MemberExpression\" &&\n                !node.init.computed &&\n                node.init.property.type === \"Identifier\" &&\n                node.id.name === node.init.property.name;\n        }\n\n        /**\n         * Fix a node into object destructuring.\n         * This function only handles the simplest case of object destructuring,\n         * see {@link shouldFix}.\n         * @param {SourceCodeFixer} fixer the fixer object\n         * @param {ASTNode} node the node to be fixed.\n         * @returns {Object} a fix for the node\n         */\n        function fixIntoObjectDestructuring(fixer, node) {\n            const rightNode = node.init;\n            const sourceCode = context.getSourceCode();\n\n            // Don't fix if that would remove any comments. Only comments inside `rightNode.object` can be preserved.\n            if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(rightNode.object).length) {\n                return null;\n            }\n\n            let objectText = sourceCode.getText(rightNode.object);\n\n            if (astUtils.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                objectText = `(${objectText})`;\n            }\n\n            return fixer.replaceText(\n                node,\n                `{${rightNode.property.name}} = ${objectText}`\n            );\n        }\n\n        /**\n         * Check that the `prefer-destructuring` rules are followed based on the\n         * given left- and right-hand side of the assignment.\n         *\n         * Pulled out into a separate method so that VariableDeclarators and\n         * AssignmentExpressions can share the same verification logic.\n         * @param {ASTNode} leftNode the left-hand side of the assignment\n         * @param {ASTNode} rightNode the right-hand side of the assignment\n         * @param {ASTNode} reportNode the node to report the error on\n         * @returns {void}\n         */\n        function performCheck(leftNode, rightNode, reportNode) {\n            if (\n                rightNode.type !== \"MemberExpression\" ||\n                rightNode.object.type === \"Super\" ||\n                rightNode.property.type === \"PrivateIdentifier\"\n            ) {\n                return;\n            }\n\n            if (isArrayIndexAccess(rightNode)) {\n                if (shouldCheck(reportNode.type, \"array\")) {\n                    report(reportNode, \"array\", null);\n                }\n                return;\n            }\n\n            const fix = shouldFix(reportNode)\n                ? fixer => fixIntoObjectDestructuring(fixer, reportNode)\n                : null;\n\n            if (shouldCheck(reportNode.type, \"object\") && enforceForRenamedProperties) {\n                report(reportNode, \"object\", fix);\n                return;\n            }\n\n            if (shouldCheck(reportNode.type, \"object\")) {\n                const property = rightNode.property;\n\n                if (\n                    (property.type === \"Literal\" && leftNode.name === property.value) ||\n                    (property.type === \"Identifier\" && leftNode.name === property.name && !rightNode.computed)\n                ) {\n                    report(reportNode, \"object\", fix);\n                }\n            }\n        }\n\n        /**\n         * Check if a given variable declarator is coming from an property access\n         * that should be using destructuring instead\n         * @param {ASTNode} node the variable declarator to check\n         * @returns {void}\n         */\n        function checkVariableDeclarator(node) {\n\n            // Skip if variable is declared without assignment\n            if (!node.init) {\n                return;\n            }\n\n            // We only care about member expressions past this point\n            if (node.init.type !== \"MemberExpression\") {\n                return;\n            }\n\n            performCheck(node.id, node.init, node);\n        }\n\n        /**\n         * Run the `prefer-destructuring` check on an AssignmentExpression\n         * @param {ASTNode} node the AssignmentExpression node\n         * @returns {void}\n         */\n        function checkAssignmentExpression(node) {\n            if (node.operator === \"=\") {\n                performCheck(node.left, node.right, node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator: checkVariableDeclarator,\n            AssignmentExpression: checkAssignmentExpression\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}