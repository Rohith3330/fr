{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst types_1 = require(\"./types\");\n\nconst __1 = require(\"..\");\n\nconst codegen_1 = require(\"../codegen\");\n\nconst ref_error_1 = require(\"../ref_error\");\n\nconst names_1 = require(\"../names\");\n\nconst code_1 = require(\"../../vocabularies/code\");\n\nconst ref_1 = require(\"../../vocabularies/jtd/ref\");\n\nconst util_1 = require(\"../util\");\n\nconst quote_1 = require(\"../../runtime/quote\");\n\nconst genSerialize = {\n  elements: serializeElements,\n  values: serializeValues,\n  discriminator: serializeDiscriminator,\n  properties: serializeProperties,\n  optionalProperties: serializeProperties,\n  enum: serializeString,\n  type: serializeType,\n  ref: serializeRef\n};\n\nfunction compileSerializer(sch, definitions) {\n  const _sch = __1.getCompilingSchema.call(this, sch);\n\n  if (_sch) return _sch;\n  const {\n    es5,\n    lines\n  } = this.opts.code;\n  const {\n    ownProperties\n  } = this.opts;\n  const gen = new codegen_1.CodeGen(this.scope, {\n    es5,\n    lines,\n    ownProperties\n  });\n  const serializeName = gen.scopeName(\"serialize\");\n  const cxt = {\n    self: this,\n    gen,\n    schema: sch.schema,\n    schemaEnv: sch,\n    definitions,\n    data: names_1.default.data\n  };\n  let sourceCode;\n\n  try {\n    this._compilations.add(sch);\n\n    sch.serializeName = serializeName;\n    gen.func(serializeName, names_1.default.data, false, () => {\n      gen.let(names_1.default.json, (0, codegen_1.str)``);\n      serializeCode(cxt);\n      gen.return(names_1.default.json);\n    });\n    gen.optimize(this.opts.code.optimize);\n    const serializeFuncCode = gen.toString();\n    sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${serializeFuncCode}`;\n    const makeSerialize = new Function(`${names_1.default.scope}`, sourceCode);\n    const serialize = makeSerialize(this.scope.get());\n    this.scope.value(serializeName, {\n      ref: serialize\n    });\n    sch.serialize = serialize;\n  } catch (e) {\n    if (sourceCode) this.logger.error(\"Error compiling serializer, function code:\", sourceCode);\n    delete sch.serialize;\n    delete sch.serializeName;\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n\n  return sch;\n}\n\nexports.default = compileSerializer;\n\nfunction serializeCode(cxt) {\n  let form;\n\n  for (const key of types_1.jtdForms) {\n    if (key in cxt.schema) {\n      form = key;\n      break;\n    }\n  }\n\n  serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);\n}\n\nfunction serializeNullable(cxt, serializeForm) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  if (!schema.nullable) return serializeForm(cxt);\n  gen.if((0, codegen_1._)`${data} === undefined || ${data} === null`, () => gen.add(names_1.default.json, (0, codegen_1._)`\"null\"`), () => serializeForm(cxt));\n}\n\nfunction serializeElements(cxt) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  gen.add(names_1.default.json, (0, codegen_1.str)`[`);\n  const first = gen.let(\"first\", true);\n  gen.forOf(\"el\", data, el => {\n    addComma(cxt, first);\n    serializeCode({ ...cxt,\n      schema: schema.elements,\n      data: el\n    });\n  });\n  gen.add(names_1.default.json, (0, codegen_1.str)`]`);\n}\n\nfunction serializeValues(cxt) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  gen.add(names_1.default.json, (0, codegen_1.str)`{`);\n  const first = gen.let(\"first\", true);\n  gen.forIn(\"key\", data, key => serializeKeyValue(cxt, key, schema.values, first));\n  gen.add(names_1.default.json, (0, codegen_1.str)`}`);\n}\n\nfunction serializeKeyValue(cxt, key, schema, first) {\n  const {\n    gen,\n    data\n  } = cxt;\n  addComma(cxt, first);\n  serializeString({ ...cxt,\n    data: key\n  });\n  gen.add(names_1.default.json, (0, codegen_1.str)`:`);\n  const value = gen.const(\"value\", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(key)}`);\n  serializeCode({ ...cxt,\n    schema,\n    data: value\n  });\n}\n\nfunction serializeDiscriminator(cxt) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  const {\n    discriminator\n  } = schema;\n  gen.add(names_1.default.json, (0, codegen_1.str)`{${JSON.stringify(discriminator)}:`);\n  const tag = gen.const(\"tag\", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(discriminator)}`);\n  serializeString({ ...cxt,\n    data: tag\n  });\n  gen.if(false);\n\n  for (const tagValue in schema.mapping) {\n    gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);\n    const sch = schema.mapping[tagValue];\n    serializeSchemaProperties({ ...cxt,\n      schema: sch\n    }, discriminator);\n  }\n\n  gen.endIf();\n  gen.add(names_1.default.json, (0, codegen_1.str)`}`);\n}\n\nfunction serializeProperties(cxt) {\n  const {\n    gen\n  } = cxt;\n  gen.add(names_1.default.json, (0, codegen_1.str)`{`);\n  serializeSchemaProperties(cxt);\n  gen.add(names_1.default.json, (0, codegen_1.str)`}`);\n}\n\nfunction serializeSchemaProperties(cxt, discriminator) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  const {\n    properties,\n    optionalProperties\n  } = schema;\n  const props = keys(properties);\n  const optProps = keys(optionalProperties);\n  const allProps = allProperties(props.concat(optProps));\n  let first = !discriminator;\n\n  for (const key of props) {\n    serializeProperty(key, properties[key], keyValue(key));\n  }\n\n  for (const key of optProps) {\n    const value = keyValue(key);\n    gen.if((0, codegen_1.and)((0, codegen_1._)`${value} !== undefined`, (0, code_1.isOwnProperty)(gen, data, key)), () => serializeProperty(key, optionalProperties[key], value));\n  }\n\n  if (schema.additionalProperties) {\n    gen.forIn(\"key\", data, key => gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, gen.let(\"first\", first))));\n  }\n\n  function keys(ps) {\n    return ps ? Object.keys(ps) : [];\n  }\n\n  function allProperties(ps) {\n    if (discriminator) ps.push(discriminator);\n\n    if (new Set(ps).size !== ps.length) {\n      throw new Error(\"JTD: properties/optionalProperties/disciminator overlap\");\n    }\n\n    return ps;\n  }\n\n  function keyValue(key) {\n    return gen.const(\"value\", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(key)}`);\n  }\n\n  function serializeProperty(key, propSchema, value) {\n    if (first) first = false;else gen.add(names_1.default.json, (0, codegen_1.str)`,`);\n    gen.add(names_1.default.json, (0, codegen_1.str)`${JSON.stringify(key)}:`);\n    serializeCode({ ...cxt,\n      schema: propSchema,\n      data: value\n    });\n  }\n\n  function isAdditional(key, ps) {\n    return ps.length ? (0, codegen_1.and)(...ps.map(p => (0, codegen_1._)`${key} !== ${p}`)) : true;\n  }\n}\n\nfunction serializeType(cxt) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n\n  switch (schema.type) {\n    case \"boolean\":\n      gen.add(names_1.default.json, (0, codegen_1._)`${data} ? \"true\" : \"false\"`);\n      break;\n\n    case \"string\":\n      serializeString(cxt);\n      break;\n\n    case \"timestamp\":\n      gen.if((0, codegen_1._)`${data} instanceof Date`, () => gen.add(names_1.default.json, (0, codegen_1._)`'\"' + ${data}.toISOString() + '\"'`), () => serializeString(cxt));\n      break;\n\n    default:\n      serializeNumber(cxt);\n  }\n}\n\nfunction serializeString(_ref) {\n  let {\n    gen,\n    data\n  } = _ref;\n  gen.add(names_1.default.json, (0, codegen_1._)`${(0, util_1.useFunc)(gen, quote_1.default)}(${data})`);\n}\n\nfunction serializeNumber(_ref2) {\n  let {\n    gen,\n    data\n  } = _ref2;\n  gen.add(names_1.default.json, (0, codegen_1._)`\"\" + ${data}`);\n}\n\nfunction serializeRef(cxt) {\n  const {\n    gen,\n    self,\n    data,\n    definitions,\n    schema,\n    schemaEnv\n  } = cxt;\n  const {\n    ref\n  } = schema;\n  const refSchema = definitions[ref];\n  if (!refSchema) throw new ref_error_1.default(self.opts.uriResolver, \"\", ref, `No definition ${ref}`);\n  if (!(0, ref_1.hasRef)(refSchema)) return serializeCode({ ...cxt,\n    schema: refSchema\n  });\n  const {\n    root\n  } = schemaEnv;\n  const sch = compileSerializer.call(self, new __1.SchemaEnv({\n    schema: refSchema,\n    root\n  }), definitions);\n  gen.add(names_1.default.json, (0, codegen_1._)`${getSerialize(gen, sch)}(${data})`);\n}\n\nfunction getSerialize(gen, sch) {\n  return sch.serialize ? gen.scopeValue(\"serialize\", {\n    ref: sch.serialize\n  }) : (0, codegen_1._)`${gen.scopeValue(\"wrapper\", {\n    ref: sch\n  })}.serialize`;\n}\n\nfunction serializeEmpty(_ref3) {\n  let {\n    gen,\n    data\n  } = _ref3;\n  gen.add(names_1.default.json, (0, codegen_1._)`JSON.stringify(${data})`);\n}\n\nfunction addComma(_ref4, first) {\n  let {\n    gen\n  } = _ref4;\n  gen.if(first, () => gen.assign(first, false), () => gen.add(names_1.default.json, (0, codegen_1.str)`,`));\n}","map":{"version":3,"mappings":"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","names":["genSerialize","elements","serializeElements","values","serializeValues","discriminator","serializeDiscriminator","properties","serializeProperties","optionalProperties","enum","serializeString","type","serializeType","ref","serializeRef","compileSerializer","sch","definitions","_sch","__1","call","es5","lines","opts","code","ownProperties","gen","codegen_1","scope","serializeName","scopeName","cxt","self","schema","schemaEnv","data","names_1","sourceCode","_compilations","add","func","let","json","serializeCode","return","optimize","serializeFuncCode","toString","scopeRefs","makeSerialize","Function","serialize","get","value","e","logger","error","delete","exports","form","key","types_1","serializeNullable","serializeEmpty","serializeForm","nullable","if","first","forOf","el","addComma","forIn","serializeKeyValue","const","JSON","stringify","tag","tagValue","mapping","elseIf","serializeSchemaProperties","endIf","props","keys","optProps","allProps","allProperties","concat","serializeProperty","keyValue","additionalProperties","isAdditional","ps","Object","push","Set","size","length","Error","propSchema","map","p","serializeNumber","quote_1","refSchema","ref_error_1","uriResolver","root","getSerialize","scopeValue","assign"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-webpack-plugin\\node_modules\\ajv\\lib\\compile\\jtd\\serialize.ts"],"sourcesContent":["import type Ajv from \"../../core\"\nimport type {SchemaObject} from \"../../types\"\nimport {jtdForms, JTDForm, SchemaObjectMap} from \"./types\"\nimport {SchemaEnv, getCompilingSchema} from \"..\"\nimport {_, str, and, getProperty, CodeGen, Code, Name} from \"../codegen\"\nimport MissingRefError from \"../ref_error\"\nimport N from \"../names\"\nimport {isOwnProperty} from \"../../vocabularies/code\"\nimport {hasRef} from \"../../vocabularies/jtd/ref\"\nimport {useFunc} from \"../util\"\nimport quote from \"../../runtime/quote\"\n\nconst genSerialize: {[F in JTDForm]: (cxt: SerializeCxt) => void} = {\n  elements: serializeElements,\n  values: serializeValues,\n  discriminator: serializeDiscriminator,\n  properties: serializeProperties,\n  optionalProperties: serializeProperties,\n  enum: serializeString,\n  type: serializeType,\n  ref: serializeRef,\n}\n\ninterface SerializeCxt {\n  readonly gen: CodeGen\n  readonly self: Ajv // current Ajv instance\n  readonly schemaEnv: SchemaEnv\n  readonly definitions: SchemaObjectMap\n  schema: SchemaObject\n  data: Code\n}\n\nexport default function compileSerializer(\n  this: Ajv,\n  sch: SchemaEnv,\n  definitions: SchemaObjectMap\n): SchemaEnv {\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  const serializeName = gen.scopeName(\"serialize\")\n  const cxt: SerializeCxt = {\n    self: this,\n    gen,\n    schema: sch.schema as SchemaObject,\n    schemaEnv: sch,\n    definitions,\n    data: N.data,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    sch.serializeName = serializeName\n    gen.func(serializeName, N.data, false, () => {\n      gen.let(N.json, str``)\n      serializeCode(cxt)\n      gen.return(N.json)\n    })\n    gen.optimize(this.opts.code.optimize)\n    const serializeFuncCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${serializeFuncCode}`\n    const makeSerialize = new Function(`${N.scope}`, sourceCode)\n    const serialize: (data: unknown) => string = makeSerialize(this.scope.get())\n    this.scope.value(serializeName, {ref: serialize})\n    sch.serialize = serialize\n  } catch (e) {\n    if (sourceCode) this.logger.error(\"Error compiling serializer, function code:\", sourceCode)\n    delete sch.serialize\n    delete sch.serializeName\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n  return sch\n}\n\nfunction serializeCode(cxt: SerializeCxt): void {\n  let form: JTDForm | undefined\n  for (const key of jtdForms) {\n    if (key in cxt.schema) {\n      form = key\n      break\n    }\n  }\n  serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty)\n}\n\nfunction serializeNullable(cxt: SerializeCxt, serializeForm: (_cxt: SerializeCxt) => void): void {\n  const {gen, schema, data} = cxt\n  if (!schema.nullable) return serializeForm(cxt)\n  gen.if(\n    _`${data} === undefined || ${data} === null`,\n    () => gen.add(N.json, _`\"null\"`),\n    () => serializeForm(cxt)\n  )\n}\n\nfunction serializeElements(cxt: SerializeCxt): void {\n  const {gen, schema, data} = cxt\n  gen.add(N.json, str`[`)\n  const first = gen.let(\"first\", true)\n  gen.forOf(\"el\", data, (el) => {\n    addComma(cxt, first)\n    serializeCode({...cxt, schema: schema.elements, data: el})\n  })\n  gen.add(N.json, str`]`)\n}\n\nfunction serializeValues(cxt: SerializeCxt): void {\n  const {gen, schema, data} = cxt\n  gen.add(N.json, str`{`)\n  const first = gen.let(\"first\", true)\n  gen.forIn(\"key\", data, (key) => serializeKeyValue(cxt, key, schema.values, first))\n  gen.add(N.json, str`}`)\n}\n\nfunction serializeKeyValue(cxt: SerializeCxt, key: Name, schema: SchemaObject, first: Name): void {\n  const {gen, data} = cxt\n  addComma(cxt, first)\n  serializeString({...cxt, data: key})\n  gen.add(N.json, str`:`)\n  const value = gen.const(\"value\", _`${data}${getProperty(key)}`)\n  serializeCode({...cxt, schema, data: value})\n}\n\nfunction serializeDiscriminator(cxt: SerializeCxt): void {\n  const {gen, schema, data} = cxt\n  const {discriminator} = schema\n  gen.add(N.json, str`{${JSON.stringify(discriminator)}:`)\n  const tag = gen.const(\"tag\", _`${data}${getProperty(discriminator)}`)\n  serializeString({...cxt, data: tag})\n  gen.if(false)\n  for (const tagValue in schema.mapping) {\n    gen.elseIf(_`${tag} === ${tagValue}`)\n    const sch = schema.mapping[tagValue]\n    serializeSchemaProperties({...cxt, schema: sch}, discriminator)\n  }\n  gen.endIf()\n  gen.add(N.json, str`}`)\n}\n\nfunction serializeProperties(cxt: SerializeCxt): void {\n  const {gen} = cxt\n  gen.add(N.json, str`{`)\n  serializeSchemaProperties(cxt)\n  gen.add(N.json, str`}`)\n}\n\nfunction serializeSchemaProperties(cxt: SerializeCxt, discriminator?: string): void {\n  const {gen, schema, data} = cxt\n  const {properties, optionalProperties} = schema\n  const props = keys(properties)\n  const optProps = keys(optionalProperties)\n  const allProps = allProperties(props.concat(optProps))\n  let first = !discriminator\n  for (const key of props) {\n    serializeProperty(key, properties[key], keyValue(key))\n  }\n  for (const key of optProps) {\n    const value = keyValue(key)\n    gen.if(and(_`${value} !== undefined`, isOwnProperty(gen, data, key)), () =>\n      serializeProperty(key, optionalProperties[key], value)\n    )\n  }\n  if (schema.additionalProperties) {\n    gen.forIn(\"key\", data, (key) =>\n      gen.if(isAdditional(key, allProps), () =>\n        serializeKeyValue(cxt, key, {}, gen.let(\"first\", first))\n      )\n    )\n  }\n\n  function keys(ps?: SchemaObjectMap): string[] {\n    return ps ? Object.keys(ps) : []\n  }\n\n  function allProperties(ps: string[]): string[] {\n    if (discriminator) ps.push(discriminator)\n    if (new Set(ps).size !== ps.length) {\n      throw new Error(\"JTD: properties/optionalProperties/disciminator overlap\")\n    }\n    return ps\n  }\n\n  function keyValue(key: string): Name {\n    return gen.const(\"value\", _`${data}${getProperty(key)}`)\n  }\n\n  function serializeProperty(key: string, propSchema: SchemaObject, value: Name): void {\n    if (first) first = false\n    else gen.add(N.json, str`,`)\n    gen.add(N.json, str`${JSON.stringify(key)}:`)\n    serializeCode({...cxt, schema: propSchema, data: value})\n  }\n\n  function isAdditional(key: Name, ps: string[]): Code | true {\n    return ps.length ? and(...ps.map((p) => _`${key} !== ${p}`)) : true\n  }\n}\n\nfunction serializeType(cxt: SerializeCxt): void {\n  const {gen, schema, data} = cxt\n  switch (schema.type) {\n    case \"boolean\":\n      gen.add(N.json, _`${data} ? \"true\" : \"false\"`)\n      break\n    case \"string\":\n      serializeString(cxt)\n      break\n    case \"timestamp\":\n      gen.if(\n        _`${data} instanceof Date`,\n        () => gen.add(N.json, _`'\"' + ${data}.toISOString() + '\"'`),\n        () => serializeString(cxt)\n      )\n      break\n    default:\n      serializeNumber(cxt)\n  }\n}\n\nfunction serializeString({gen, data}: SerializeCxt): void {\n  gen.add(N.json, _`${useFunc(gen, quote)}(${data})`)\n}\n\nfunction serializeNumber({gen, data}: SerializeCxt): void {\n  gen.add(N.json, _`\"\" + ${data}`)\n}\n\nfunction serializeRef(cxt: SerializeCxt): void {\n  const {gen, self, data, definitions, schema, schemaEnv} = cxt\n  const {ref} = schema\n  const refSchema = definitions[ref]\n  if (!refSchema) throw new MissingRefError(self.opts.uriResolver, \"\", ref, `No definition ${ref}`)\n  if (!hasRef(refSchema)) return serializeCode({...cxt, schema: refSchema})\n  const {root} = schemaEnv\n  const sch = compileSerializer.call(self, new SchemaEnv({schema: refSchema, root}), definitions)\n  gen.add(N.json, _`${getSerialize(gen, sch)}(${data})`)\n}\n\nfunction getSerialize(gen: CodeGen, sch: SchemaEnv): Code {\n  return sch.serialize\n    ? gen.scopeValue(\"serialize\", {ref: sch.serialize})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.serialize`\n}\n\nfunction serializeEmpty({gen, data}: SerializeCxt): void {\n  gen.add(N.json, _`JSON.stringify(${data})`)\n}\n\nfunction addComma({gen}: SerializeCxt, first: Name): void {\n  gen.if(\n    first,\n    () => gen.assign(first, false),\n    () => gen.add(N.json, str`,`)\n  )\n}\n"]},"metadata":{},"sourceType":"script"}