{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'non-nullable-type-assertion-style',\n  meta: {\n    docs: {\n      description: 'Enforce non-null assertions over explicit type casts',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    fixable: 'code',\n    messages: {\n      preferNonNullAssertion: 'Use a ! assertion to more succinctly remove null and undefined from the type.'\n    },\n    schema: [],\n    type: 'suggestion'\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n\n    const getTypesIfNotLoose = node => {\n      const type = checker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node));\n\n      if (tsutils.isTypeFlagSet(type, ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {\n        return undefined;\n      }\n\n      return tsutils.unionTypeParts(type);\n    };\n\n    const couldBeNullish = type => {\n      if (type.flags & ts.TypeFlags.TypeParameter) {\n        const constraint = type.getConstraint();\n        return constraint == null || couldBeNullish(constraint);\n      } else if (tsutils.isUnionType(type)) {\n        for (const part of type.types) {\n          if (couldBeNullish(part)) {\n            return true;\n          }\n        }\n\n        return false;\n      } else {\n        return (type.flags & (ts.TypeFlags.Null | ts.TypeFlags.Undefined)) !== 0;\n      }\n    };\n\n    const sameTypeWithoutNullish = (assertedTypes, originalTypes) => {\n      const nonNullishOriginalTypes = originalTypes.filter(type => (type.flags & (ts.TypeFlags.Null | ts.TypeFlags.Undefined)) === 0);\n\n      if (nonNullishOriginalTypes.length === originalTypes.length) {\n        return false;\n      }\n\n      for (const assertedType of assertedTypes) {\n        if (couldBeNullish(assertedType) || !nonNullishOriginalTypes.includes(assertedType)) {\n          return false;\n        }\n      }\n\n      for (const originalType of nonNullishOriginalTypes) {\n        if (!assertedTypes.includes(originalType)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    const isConstAssertion = node => {\n      return node.typeAnnotation.type === utils_1.AST_NODE_TYPES.TSTypeReference && node.typeAnnotation.typeName.type === utils_1.AST_NODE_TYPES.Identifier && node.typeAnnotation.typeName.name === 'const';\n    };\n\n    return {\n      'TSAsExpression, TSTypeAssertion'(node) {\n        if (isConstAssertion(node)) {\n          return;\n        }\n\n        const originalTypes = getTypesIfNotLoose(node.expression);\n\n        if (!originalTypes) {\n          return;\n        }\n\n        const assertedTypes = getTypesIfNotLoose(node.typeAnnotation);\n\n        if (!assertedTypes) {\n          return;\n        }\n\n        if (sameTypeWithoutNullish(assertedTypes, originalTypes)) {\n          context.report({\n            fix(fixer) {\n              return fixer.replaceText(node, `${sourceCode.getText(node.expression)}!`);\n            },\n\n            messageId: 'preferNonNullAssertion',\n            node\n          });\n        }\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","docs","description","recommended","requiresTypeChecking","fixable","messages","preferNonNullAssertion","schema","type","defaultOptions","create","context","parserServices","getParserServices","checker","program","getTypeChecker","sourceCode","getSourceCode","getTypesIfNotLoose","node","getTypeAtLocation","esTreeNodeToTSNodeMap","get","tsutils","isTypeFlagSet","ts","TypeFlags","Any","Unknown","undefined","unionTypeParts","couldBeNullish","flags","TypeParameter","constraint","getConstraint","isUnionType","part","types","Null","Undefined","sameTypeWithoutNullish","assertedTypes","originalTypes","nonNullishOriginalTypes","filter","length","assertedType","includes","originalType","isConstAssertion","typeAnnotation","utils_1","TSTypeReference","typeName","Identifier","expression","report","fix","fixer","replaceText","getText","messageId"],"sources":["../../src/rules/non-nullable-type-assertion-style.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}