{"ast":null,"code":"// Copyright (C) 2011-2012 Software Languages Lab, Vrije Universiteit Brussel\n// This code is dual-licensed under both the Apache License and the MPL\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is a shim for the ES-Harmony reflection module\n *\n * The Initial Developer of the Original Code is\n * Tom Van Cutsem, Vrije Universiteit Brussel.\n * Portions created by the Initial Developer are Copyright (C) 2011-2012\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n */\n// ----------------------------------------------------------------------------\n// This file is a polyfill for the upcoming ECMAScript Reflect API,\n// including support for Proxies. See the draft specification at:\n// http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n// For an implementation of the Handler API, see handlers.js, which implements:\n// http://wiki.ecmascript.org/doku.php?id=harmony:virtual_object_api\n// This implementation supersedes the earlier polyfill at:\n// code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js\n// This code was tested on tracemonkey / Firefox 12\n//  (and should run fine on older Firefox versions starting with FF4)\n// The code also works correctly on\n//   v8 --harmony_proxies --harmony_weakmaps (v3.6.5.1)\n// Language Dependencies:\n//  - ECMAScript 5/strict\n//  - \"old\" (i.e. non-direct) Harmony Proxies\n//  - Harmony WeakMaps\n// Patches:\n//  - Object.{freeze,seal,preventExtensions}\n//  - Object.{isFrozen,isSealed,isExtensible}\n//  - Object.getPrototypeOf\n//  - Object.keys\n//  - Object.prototype.valueOf\n//  - Object.prototype.isPrototypeOf\n//  - Object.prototype.toString\n//  - Object.prototype.hasOwnProperty\n//  - Object.getOwnPropertyDescriptor\n//  - Object.defineProperty\n//  - Object.defineProperties\n//  - Object.getOwnPropertyNames\n//  - Object.getOwnPropertySymbols\n//  - Object.getPrototypeOf\n//  - Object.setPrototypeOf\n//  - Object.assign\n//  - Function.prototype.toString\n//  - Date.prototype.toString\n//  - Array.isArray\n//  - Array.prototype.concat\n//  - Proxy\n// Adds new globals:\n//  - Reflect\n// Direct proxies can be created via Proxy(target, handler)\n// ----------------------------------------------------------------------------\n(function (global) {\n  // function-as-module pattern\n  \"use strict\"; // === Direct Proxies: Invariant Enforcement ===\n  // Direct proxies build on non-direct proxies by automatically wrapping\n  // all user-defined proxy handlers in a Validator handler that checks and\n  // enforces ES5 invariants.\n  // A direct proxy is a proxy for an existing object called the target object.\n  // A Validator handler is a wrapper for a target proxy handler H.\n  // The Validator forwards all operations to H, but additionally\n  // performs a number of integrity checks on the results of some traps,\n  // to make sure H does not violate the ES5 invariants w.r.t. non-configurable\n  // properties and non-extensible, sealed or frozen objects.\n  // For each property that H exposes as own, non-configurable\n  // (e.g. by returning a descriptor from a call to getOwnPropertyDescriptor)\n  // the Validator handler defines those properties on the target object.\n  // When the proxy becomes non-extensible, also configurable own properties\n  // are checked against the target.\n  // We will call properties that are defined on the target object\n  // \"fixed properties\".\n  // We will name fixed non-configurable properties \"sealed properties\".\n  // We will name fixed non-configurable non-writable properties \"frozen\n  // properties\".\n  // The Validator handler upholds the following invariants w.r.t. non-configurability:\n  // - getOwnPropertyDescriptor cannot report sealed properties as non-existent\n  // - getOwnPropertyDescriptor cannot report incompatible changes to the\n  //   attributes of a sealed property (e.g. reporting a non-configurable\n  //   property as configurable, or reporting a non-configurable, non-writable\n  //   property as writable)\n  // - getPropertyDescriptor cannot report sealed properties as non-existent\n  // - getPropertyDescriptor cannot report incompatible changes to the\n  //   attributes of a sealed property. It _can_ report incompatible changes\n  //   to the attributes of non-own, inherited properties.\n  // - defineProperty cannot make incompatible changes to the attributes of\n  //   sealed properties\n  // - deleteProperty cannot report a successful deletion of a sealed property\n  // - hasOwn cannot report a sealed property as non-existent\n  // - has cannot report a sealed property as non-existent\n  // - get cannot report inconsistent values for frozen data\n  //   properties, and must report undefined for sealed accessors with an\n  //   undefined getter\n  // - set cannot report a successful assignment for frozen data\n  //   properties or sealed accessors with an undefined setter.\n  // - get{Own}PropertyNames lists all sealed properties of the target.\n  // - keys lists all enumerable sealed properties of the target.\n  // - enumerate lists all enumerable sealed properties of the target.\n  // - if a property of a non-extensible proxy is reported as non-existent,\n  //   then it must forever be reported as non-existent. This applies to\n  //   own and inherited properties and is enforced in the\n  //   deleteProperty, get{Own}PropertyDescriptor, has{Own},\n  //   get{Own}PropertyNames, keys and enumerate traps\n  // Violation of any of these invariants by H will result in TypeError being\n  // thrown.\n  // Additionally, once Object.preventExtensions, Object.seal or Object.freeze\n  // is invoked on the proxy, the set of own property names for the proxy is\n  // fixed. Any property name that is not fixed is called a 'new' property.\n  // The Validator upholds the following invariants regarding extensibility:\n  // - getOwnPropertyDescriptor cannot report new properties as existent\n  //   (it must report them as non-existent by returning undefined)\n  // - defineProperty cannot successfully add a new property (it must reject)\n  // - getOwnPropertyNames cannot list new properties\n  // - hasOwn cannot report true for new properties (it must report false)\n  // - keys cannot list new properties\n  // Invariants currently not enforced:\n  // - getOwnPropertyNames lists only own property names\n  // - keys lists only enumerable own property names\n  // Both traps may list more property names than are actually defined on the\n  // target.\n  // Invariants with regard to inheritance are currently not enforced.\n  // - a non-configurable potentially inherited property on a proxy with\n  //   non-mutable ancestry cannot be reported as non-existent\n  // (An object with non-mutable ancestry is a non-extensible object whose\n  // [[Prototype]] is either null or an object with non-mutable ancestry.)\n  // Changes in Handler API compared to previous harmony:proxies, see:\n  // http://wiki.ecmascript.org/doku.php?id=strawman:direct_proxies\n  // http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n  // ----------------------------------------------------------------------------\n  // ---- WeakMap polyfill ----\n  // TODO: find a proper WeakMap polyfill\n  // define an empty WeakMap so that at least the Reflect module code\n  // will work in the absence of WeakMaps. Proxy emulation depends on\n  // actual WeakMaps, so will not work with this little shim.\n\n  if (typeof WeakMap === \"undefined\") {\n    global.WeakMap = function () {};\n\n    global.WeakMap.prototype = {\n      get: function (k) {\n        return undefined;\n      },\n      set: function (k, v) {\n        throw new Error(\"WeakMap not supported\");\n      }\n    };\n  } // ---- Normalization functions for property descriptors ----\n\n\n  function isStandardAttribute(name) {\n    return /^(get|set|value|writable|enumerable|configurable)$/.test(name);\n  } // Adapted from ES5 section 8.10.5\n\n\n  function toPropertyDescriptor(obj) {\n    if (Object(obj) !== obj) {\n      throw new TypeError(\"property descriptor should be an Object, given: \" + obj);\n    }\n\n    var desc = {};\n\n    if ('enumerable' in obj) {\n      desc.enumerable = !!obj.enumerable;\n    }\n\n    if ('configurable' in obj) {\n      desc.configurable = !!obj.configurable;\n    }\n\n    if ('value' in obj) {\n      desc.value = obj.value;\n    }\n\n    if ('writable' in obj) {\n      desc.writable = !!obj.writable;\n    }\n\n    if ('get' in obj) {\n      var getter = obj.get;\n\n      if (getter !== undefined && typeof getter !== \"function\") {\n        throw new TypeError(\"property descriptor 'get' attribute must be \" + \"callable or undefined, given: \" + getter);\n      }\n\n      desc.get = getter;\n    }\n\n    if ('set' in obj) {\n      var setter = obj.set;\n\n      if (setter !== undefined && typeof setter !== \"function\") {\n        throw new TypeError(\"property descriptor 'set' attribute must be \" + \"callable or undefined, given: \" + setter);\n      }\n\n      desc.set = setter;\n    }\n\n    if ('get' in desc || 'set' in desc) {\n      if ('value' in desc || 'writable' in desc) {\n        throw new TypeError(\"property descriptor cannot be both a data and an \" + \"accessor descriptor: \" + obj);\n      }\n    }\n\n    return desc;\n  }\n\n  function isAccessorDescriptor(desc) {\n    if (desc === undefined) return false;\n    return 'get' in desc || 'set' in desc;\n  }\n\n  function isDataDescriptor(desc) {\n    if (desc === undefined) return false;\n    return 'value' in desc || 'writable' in desc;\n  }\n\n  function isGenericDescriptor(desc) {\n    if (desc === undefined) return false;\n    return !isAccessorDescriptor(desc) && !isDataDescriptor(desc);\n  }\n\n  function toCompletePropertyDescriptor(desc) {\n    var internalDesc = toPropertyDescriptor(desc);\n\n    if (isGenericDescriptor(internalDesc) || isDataDescriptor(internalDesc)) {\n      if (!('value' in internalDesc)) {\n        internalDesc.value = undefined;\n      }\n\n      if (!('writable' in internalDesc)) {\n        internalDesc.writable = false;\n      }\n    } else {\n      if (!('get' in internalDesc)) {\n        internalDesc.get = undefined;\n      }\n\n      if (!('set' in internalDesc)) {\n        internalDesc.set = undefined;\n      }\n    }\n\n    if (!('enumerable' in internalDesc)) {\n      internalDesc.enumerable = false;\n    }\n\n    if (!('configurable' in internalDesc)) {\n      internalDesc.configurable = false;\n    }\n\n    return internalDesc;\n  }\n\n  function isEmptyDescriptor(desc) {\n    return !('get' in desc) && !('set' in desc) && !('value' in desc) && !('writable' in desc) && !('enumerable' in desc) && !('configurable' in desc);\n  }\n\n  function isEquivalentDescriptor(desc1, desc2) {\n    return sameValue(desc1.get, desc2.get) && sameValue(desc1.set, desc2.set) && sameValue(desc1.value, desc2.value) && sameValue(desc1.writable, desc2.writable) && sameValue(desc1.enumerable, desc2.enumerable) && sameValue(desc1.configurable, desc2.configurable);\n  } // copied from http://wiki.ecmascript.org/doku.php?id=harmony:egal\n\n\n  function sameValue(x, y) {\n    if (x === y) {\n      // 0 === -0, but they are not identical\n      return x !== 0 || 1 / x === 1 / y;\n    } // NaN !== NaN, but they are identical.\n    // NaNs are the only non-reflexive value, i.e., if x !== x,\n    // then x is a NaN.\n    // isNaN is broken: it converts its argument to number, so\n    // isNaN(\"foo\") => true\n\n\n    return x !== x && y !== y;\n  }\n  /**\n   * Returns a fresh property descriptor that is guaranteed\n   * to be complete (i.e. contain all the standard attributes).\n   * Additionally, any non-standard enumerable properties of\n   * attributes are copied over to the fresh descriptor.\n   *\n   * If attributes is undefined, returns undefined.\n   *\n   * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n   */\n\n\n  function normalizeAndCompletePropertyDescriptor(attributes) {\n    if (attributes === undefined) {\n      return undefined;\n    }\n\n    var desc = toCompletePropertyDescriptor(attributes); // Note: no need to call FromPropertyDescriptor(desc), as we represent\n    // \"internal\" property descriptors as proper Objects from the start\n\n    for (var name in attributes) {\n      if (!isStandardAttribute(name)) {\n        Object.defineProperty(desc, name, {\n          value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n\n    return desc;\n  }\n  /**\n   * Returns a fresh property descriptor whose standard\n   * attributes are guaranteed to be data properties of the right type.\n   * Additionally, any non-standard enumerable properties of\n   * attributes are copied over to the fresh descriptor.\n   *\n   * If attributes is undefined, will throw a TypeError.\n   *\n   * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n   */\n\n\n  function normalizePropertyDescriptor(attributes) {\n    var desc = toPropertyDescriptor(attributes); // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n    // \"internal\" property descriptors as proper Objects from the start\n\n    for (var name in attributes) {\n      if (!isStandardAttribute(name)) {\n        Object.defineProperty(desc, name, {\n          value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n\n    return desc;\n  } // store a reference to the real ES5 primitives before patching them later\n\n\n  var prim_preventExtensions = Object.preventExtensions,\n      prim_seal = Object.seal,\n      prim_freeze = Object.freeze,\n      prim_isExtensible = Object.isExtensible,\n      prim_isSealed = Object.isSealed,\n      prim_isFrozen = Object.isFrozen,\n      prim_getPrototypeOf = Object.getPrototypeOf,\n      prim_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n      prim_defineProperty = Object.defineProperty,\n      prim_defineProperties = Object.defineProperties,\n      prim_keys = Object.keys,\n      prim_getOwnPropertyNames = Object.getOwnPropertyNames,\n      prim_getOwnPropertySymbols = Object.getOwnPropertySymbols,\n      prim_assign = Object.assign,\n      prim_isArray = Array.isArray,\n      prim_concat = Array.prototype.concat,\n      prim_isPrototypeOf = Object.prototype.isPrototypeOf,\n      prim_hasOwnProperty = Object.prototype.hasOwnProperty; // these will point to the patched versions of the respective methods on\n  // Object. They are used within this module as the \"intrinsic\" bindings\n  // of these methods (i.e. the \"original\" bindings as defined in the spec)\n\n  var Object_isFrozen, Object_isSealed, Object_isExtensible, Object_getPrototypeOf, Object_getOwnPropertyNames;\n  /**\n   * A property 'name' is fixed if it is an own property of the target.\n   */\n\n  function isFixed(name, target) {\n    return {}.hasOwnProperty.call(target, name);\n  }\n\n  function isSealed(name, target) {\n    var desc = Object.getOwnPropertyDescriptor(target, name);\n\n    if (desc === undefined) {\n      return false;\n    }\n\n    return desc.configurable === false;\n  }\n\n  function isSealedDesc(desc) {\n    return desc !== undefined && desc.configurable === false;\n  }\n  /**\n   * Performs all validation that Object.defineProperty performs,\n   * without actually defining the property. Returns a boolean\n   * indicating whether validation succeeded.\n   *\n   * Implementation transliterated from ES5.1 section 8.12.9\n   */\n\n\n  function isCompatibleDescriptor(extensible, current, desc) {\n    if (current === undefined && extensible === false) {\n      return false;\n    }\n\n    if (current === undefined && extensible === true) {\n      return true;\n    }\n\n    if (isEmptyDescriptor(desc)) {\n      return true;\n    }\n\n    if (isEquivalentDescriptor(current, desc)) {\n      return true;\n    }\n\n    if (current.configurable === false) {\n      if (desc.configurable === true) {\n        return false;\n      }\n\n      if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n        return false;\n      }\n    }\n\n    if (isGenericDescriptor(desc)) {\n      return true;\n    }\n\n    if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        return false;\n      }\n\n      return true;\n    }\n\n    if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        if (current.writable === false && desc.writable === true) {\n          return false;\n        }\n\n        if (current.writable === false) {\n          if ('value' in desc && !sameValue(desc.value, current.value)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n      if (current.configurable === false) {\n        if ('set' in desc && !sameValue(desc.set, current.set)) {\n          return false;\n        }\n\n        if ('get' in desc && !sameValue(desc.get, current.get)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  } // ES6 7.3.11 SetIntegrityLevel\n  // level is one of \"sealed\" or \"frozen\"\n\n\n  function setIntegrityLevel(target, level) {\n    var ownProps = Object_getOwnPropertyNames(target);\n    var pendingException = undefined;\n\n    if (level === \"sealed\") {\n      var l = +ownProps.length;\n      var k;\n\n      for (var i = 0; i < l; i++) {\n        k = String(ownProps[i]);\n\n        try {\n          Object.defineProperty(target, k, {\n            configurable: false\n          });\n        } catch (e) {\n          if (pendingException === undefined) {\n            pendingException = e;\n          }\n        }\n      }\n    } else {\n      // level === \"frozen\"\n      var l = +ownProps.length;\n      var k;\n\n      for (var i = 0; i < l; i++) {\n        k = String(ownProps[i]);\n\n        try {\n          var currentDesc = Object.getOwnPropertyDescriptor(target, k);\n\n          if (currentDesc !== undefined) {\n            var desc;\n\n            if (isAccessorDescriptor(currentDesc)) {\n              desc = {\n                configurable: false\n              };\n            } else {\n              desc = {\n                configurable: false,\n                writable: false\n              };\n            }\n\n            Object.defineProperty(target, k, desc);\n          }\n        } catch (e) {\n          if (pendingException === undefined) {\n            pendingException = e;\n          }\n        }\n      }\n    }\n\n    if (pendingException !== undefined) {\n      throw pendingException;\n    }\n\n    return Reflect.preventExtensions(target);\n  } // ES6 7.3.12 TestIntegrityLevel\n  // level is one of \"sealed\" or \"frozen\"\n\n\n  function testIntegrityLevel(target, level) {\n    var isExtensible = Object_isExtensible(target);\n    if (isExtensible) return false;\n    var ownProps = Object_getOwnPropertyNames(target);\n    var pendingException = undefined;\n    var configurable = false;\n    var writable = false;\n    var l = +ownProps.length;\n    var k;\n    var currentDesc;\n\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n\n      try {\n        currentDesc = Object.getOwnPropertyDescriptor(target, k);\n        configurable = configurable || currentDesc.configurable;\n\n        if (isDataDescriptor(currentDesc)) {\n          writable = writable || currentDesc.writable;\n        }\n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n          configurable = true;\n        }\n      }\n    }\n\n    if (pendingException !== undefined) {\n      throw pendingException;\n    }\n\n    if (level === \"frozen\" && writable === true) {\n      return false;\n    }\n\n    if (configurable === true) {\n      return false;\n    }\n\n    return true;\n  } // ---- The Validator handler wrapper around user handlers ----\n\n  /**\n   * @param target the object wrapped by this proxy.\n   * As long as the proxy is extensible, only non-configurable properties\n   * are checked against the target. Once the proxy becomes non-extensible,\n   * invariants w.r.t. non-extensibility are also enforced.\n   *\n   * @param handler the handler of the direct proxy. The object emulated by\n   * this handler is validated against the target object of the direct proxy.\n   * Any violations that the handler makes against the invariants\n   * of the target will cause a TypeError to be thrown.\n   *\n   * Both target and handler must be proper Objects at initialization time.\n   */\n\n\n  function Validator(target, handler) {\n    // for non-revokable proxies, these are const references\n    // for revokable proxies, on revocation:\n    // - this.target is set to null\n    // - this.handler is set to a handler that throws on all traps\n    this.target = target;\n    this.handler = handler;\n  }\n\n  Validator.prototype = {\n    /**\n     * If getTrap returns undefined, the caller should perform the\n     * default forwarding behavior.\n     * If getTrap returns normally otherwise, the return value\n     * will be a callable trap function. When calling the trap function,\n     * the caller is responsible for binding its |this| to |this.handler|.\n     */\n    getTrap: function (trapName) {\n      var trap = this.handler[trapName];\n\n      if (trap === undefined) {\n        // the trap was not defined,\n        // perform the default forwarding behavior\n        return undefined;\n      }\n\n      if (typeof trap !== \"function\") {\n        throw new TypeError(trapName + \" trap is not callable: \" + trap);\n      }\n\n      return trap;\n    },\n    // === fundamental traps ===\n\n    /**\n     * If name denotes a fixed property, check:\n     *   - whether targetHandler reports it as existent\n     *   - whether the returned descriptor is compatible with the fixed property\n     * If the proxy is non-extensible, check:\n     *   - whether name is not a new property\n     * Additionally, the returned descriptor is normalized and completed.\n     */\n    getOwnPropertyDescriptor: function (name) {\n      \"use strict\";\n\n      var trap = this.getTrap(\"getOwnPropertyDescriptor\");\n\n      if (trap === undefined) {\n        return Reflect.getOwnPropertyDescriptor(this.target, name);\n      }\n\n      name = String(name);\n      var desc = trap.call(this.handler, this.target, name);\n      desc = normalizeAndCompletePropertyDescriptor(desc);\n      var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      var extensible = Object.isExtensible(this.target);\n\n      if (desc === undefined) {\n        if (isSealedDesc(targetDesc)) {\n          throw new TypeError(\"cannot report non-configurable property '\" + name + \"' as non-existent\");\n        }\n\n        if (!extensible && targetDesc !== undefined) {\n          // if handler is allowed to return undefined, we cannot guarantee\n          // that it will not return a descriptor for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\" + name + \"' as non-existent on a non-extensible object\");\n        }\n\n        return undefined;\n      } // at this point, we know (desc !== undefined), i.e.\n      // targetHandler reports 'name' as an existing property\n      // Note: we could collapse the following two if-tests into a single\n      // test. Separating out the cases to improve error reporting.\n\n\n      if (!extensible) {\n        if (targetDesc === undefined) {\n          throw new TypeError(\"cannot report a new own property '\" + name + \"' on a non-extensible object\");\n        }\n      }\n\n      if (name !== undefined) {\n        if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n          throw new TypeError(\"cannot report incompatible property descriptor \" + \"for property '\" + name + \"'\");\n        }\n      }\n\n      if (desc.configurable === false) {\n        if (targetDesc === undefined || targetDesc.configurable === true) {\n          // if the property is configurable or non-existent on the target,\n          // but is reported as a non-configurable property, it may later be\n          // reported as configurable or non-existent, which violates the\n          // invariant that if the property might change or disappear, the\n          // configurable attribute must be true.\n          throw new TypeError(\"cannot report a non-configurable descriptor \" + \"for configurable or non-existent property '\" + name + \"'\");\n        }\n\n        if ('writable' in desc && desc.writable === false) {\n          if (targetDesc.writable === true) {\n            // if the property is non-configurable, writable on the target,\n            // but is reported as non-configurable, non-writable, it may later\n            // be reported as non-configurable, writable again, which violates\n            // the invariant that a non-configurable, non-writable property\n            // may not change state.\n            throw new TypeError(\"cannot report non-configurable, writable property '\" + name + \"' as non-configurable, non-writable\");\n          }\n        }\n      }\n\n      return desc;\n    },\n\n    /**\n     * In the direct proxies design with refactored prototype climbing,\n     * this trap is deprecated. For proxies-as-prototypes, instead\n     * of calling this trap, the get, set, has or enumerate traps are\n     * called instead.\n     *\n     * In this implementation, we \"abuse\" getPropertyDescriptor to\n     * support trapping the get or set traps for proxies-as-prototypes.\n     * We do this by returning a getter/setter pair that invokes\n     * the corresponding traps.\n     *\n     * While this hack works for inherited property access, it has some\n     * quirks:\n     *\n     * In Firefox, this trap is only called after a prior invocation\n     * of the 'has' trap has returned true. Hence, expect the following\n     * behavior:\n     * <code>\n     * var child = Object.create(Proxy(target, handler));\n     * child[name] // triggers handler.has(target, name)\n     * // if that returns true, triggers handler.get(target, name, child)\n     * </code>\n     *\n     * On v8, the 'in' operator, when applied to an object that inherits\n     * from a proxy, will call getPropertyDescriptor and walk the proto-chain.\n     * That calls the below getPropertyDescriptor trap on the proxy. The\n     * result of the 'in'-operator is then determined by whether this trap\n     * returns undefined or a property descriptor object. That is why\n     * we first explicitly trigger the 'has' trap to determine whether\n     * the property exists.\n     *\n     * This has the side-effect that when enumerating properties on\n     * an object that inherits from a proxy in v8, only properties\n     * for which 'has' returns true are returned:\n     *\n     * <code>\n     * var child = Object.create(Proxy(target, handler));\n     * for (var prop in child) {\n     *   // only enumerates prop if (prop in child) returns true\n     * }\n     * </code>\n     */\n    getPropertyDescriptor: function (name) {\n      var handler = this;\n      if (!handler.has(name)) return undefined;\n      return {\n        get: function () {\n          return handler.get(this, name);\n        },\n        set: function (val) {\n          if (handler.set(this, name, val)) {\n            return val;\n          } else {\n            throw new TypeError(\"failed assignment to \" + name);\n          }\n        },\n        enumerable: true,\n        configurable: true\n      };\n    },\n\n    /**\n     * If name denotes a fixed property, check for incompatible changes.\n     * If the proxy is non-extensible, check that new properties are rejected.\n     */\n    defineProperty: function (name, desc) {\n      // TODO(tvcutsem): the current tracemonkey implementation of proxies\n      // auto-completes 'desc', which is not correct. 'desc' should be\n      // normalized, but not completed. Consider:\n      // Object.defineProperty(proxy, 'foo', {enumerable:false})\n      // This trap will receive desc =\n      //  {value:undefined,writable:false,enumerable:false,configurable:false}\n      // This will also set all other attributes to their default value,\n      // which is unexpected and different from [[DefineOwnProperty]].\n      // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n      var trap = this.getTrap(\"defineProperty\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.defineProperty(this.target, name, desc);\n      }\n\n      name = String(name);\n      var descObj = normalizePropertyDescriptor(desc);\n      var success = trap.call(this.handler, this.target, name, descObj);\n      success = !!success; // coerce to Boolean\n\n      if (success === true) {\n        var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n        var extensible = Object.isExtensible(this.target); // Note: we could collapse the following two if-tests into a single\n        // test. Separating out the cases to improve error reporting.\n\n        if (!extensible) {\n          if (targetDesc === undefined) {\n            throw new TypeError(\"cannot successfully add a new property '\" + name + \"' to a non-extensible object\");\n          }\n        }\n\n        if (targetDesc !== undefined) {\n          if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n            throw new TypeError(\"cannot define incompatible property \" + \"descriptor for property '\" + name + \"'\");\n          }\n\n          if (isDataDescriptor(targetDesc) && targetDesc.configurable === false && targetDesc.writable === true) {\n            if (desc.configurable === false && desc.writable === false) {\n              // if the property is non-configurable, writable on the target\n              // but was successfully reported to be updated to\n              // non-configurable, non-writable, it can later be reported\n              // again as non-configurable, writable, which violates\n              // the invariant that non-configurable, non-writable properties\n              // cannot change state\n              throw new TypeError(\"cannot successfully define non-configurable, writable \" + \" property '\" + name + \"' as non-configurable, non-writable\");\n            }\n          }\n        }\n\n        if (desc.configurable === false && !isSealedDesc(targetDesc)) {\n          // if the property is configurable or non-existent on the target,\n          // but is successfully being redefined as a non-configurable property,\n          // it may later be reported as configurable or non-existent, which violates\n          // the invariant that if the property might change or disappear, the\n          // configurable attribute must be true.\n          throw new TypeError(\"cannot successfully define a non-configurable \" + \"descriptor for configurable or non-existent property '\" + name + \"'\");\n        }\n      }\n\n      return success;\n    },\n\n    /**\n     * On success, check whether the target object is indeed non-extensible.\n     */\n    preventExtensions: function () {\n      var trap = this.getTrap(\"preventExtensions\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.preventExtensions(this.target);\n      }\n\n      var success = trap.call(this.handler, this.target);\n      success = !!success; // coerce to Boolean\n\n      if (success) {\n        if (Object_isExtensible(this.target)) {\n          throw new TypeError(\"can't report extensible object as non-extensible: \" + this.target);\n        }\n      }\n\n      return success;\n    },\n\n    /**\n     * If name denotes a sealed property, check whether handler rejects.\n     */\n    delete: function (name) {\n      \"use strict\";\n\n      var trap = this.getTrap(\"deleteProperty\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.deleteProperty(this.target, name);\n      }\n\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name);\n      res = !!res; // coerce to Boolean\n\n      var targetDesc;\n\n      if (res === true) {\n        targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n\n        if (targetDesc !== undefined && targetDesc.configurable === false) {\n          throw new TypeError(\"property '\" + name + \"' is non-configurable \" + \"and can't be deleted\");\n        }\n\n        if (targetDesc !== undefined && !Object_isExtensible(this.target)) {\n          // if the property still exists on a non-extensible target but\n          // is reported as successfully deleted, it may later be reported\n          // as present, which violates the invariant that an own property,\n          // deleted from a non-extensible object cannot reappear.\n          throw new TypeError(\"cannot successfully delete existing property '\" + name + \"' on a non-extensible object\");\n        }\n      }\n\n      return res;\n    },\n\n    /**\n     * The getOwnPropertyNames trap was replaced by the ownKeys trap,\n     * which now also returns an array (of strings or symbols) and\n     * which performs the same rigorous invariant checks as getOwnPropertyNames\n     *\n     * See issue #48 on how this trap can still get invoked by external libs\n     * that don't use the patched Object.getOwnPropertyNames function.\n     */\n    getOwnPropertyNames: function () {\n      // Note: removed deprecation warning to avoid dependency on 'console'\n      // (and on node, should anyway use util.deprecate). Deprecation warnings\n      // can also be annoying when they are outside of the user's control, e.g.\n      // when an external library calls unpatched Object.getOwnPropertyNames.\n      // Since there is a clean fallback to `ownKeys`, the fact that the\n      // deprecated method is still called is mostly harmless anyway.\n      // See also issues #65 and #66.\n      // console.warn(\"getOwnPropertyNames trap is deprecated. Use ownKeys instead\");\n      return this.ownKeys();\n    },\n\n    /**\n     * Checks whether the trap result does not contain any new properties\n     * if the proxy is non-extensible.\n     *\n     * Any own non-configurable properties of the target that are not included\n     * in the trap result give rise to a TypeError. As such, we check whether the\n     * returned result contains at least all sealed properties of the target\n     * object.\n     *\n     * Additionally, the trap result is normalized.\n     * Instead of returning the trap result directly:\n     *  - create and return a fresh Array,\n     *  - of which each element is coerced to a String\n     *\n     * This trap is called a.o. by Reflect.ownKeys, Object.getOwnPropertyNames\n     * and Object.keys (the latter filters out only the enumerable own properties).\n     */\n    ownKeys: function () {\n      var trap = this.getTrap(\"ownKeys\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.ownKeys(this.target);\n      }\n\n      var trapResult = trap.call(this.handler, this.target); // propNames is used as a set of strings\n\n      var propNames = Object.create(null);\n      var numProps = +trapResult.length;\n      var result = new Array(numProps);\n\n      for (var i = 0; i < numProps; i++) {\n        var s = String(trapResult[i]);\n\n        if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n          // non-extensible proxies don't tolerate new own property names\n          throw new TypeError(\"ownKeys trap cannot list a new \" + \"property '\" + s + \"' on a non-extensible object\");\n        }\n\n        propNames[s] = true;\n        result[i] = s;\n      }\n\n      var ownProps = Object_getOwnPropertyNames(this.target);\n      var target = this.target;\n      ownProps.forEach(function (ownProp) {\n        if (!propNames[ownProp]) {\n          if (isSealed(ownProp, target)) {\n            throw new TypeError(\"ownKeys trap failed to include \" + \"non-configurable property '\" + ownProp + \"'\");\n          }\n\n          if (!Object.isExtensible(target) && isFixed(ownProp, target)) {\n            // if handler is allowed to report ownProp as non-existent,\n            // we cannot guarantee that it will never later report it as\n            // existent. Once a property has been reported as non-existent\n            // on a non-extensible object, it should forever be reported as\n            // non-existent\n            throw new TypeError(\"ownKeys trap cannot report existing own property '\" + ownProp + \"' as non-existent on a non-extensible object\");\n          }\n        }\n      });\n      return result;\n    },\n\n    /**\n     * Checks whether the trap result is consistent with the state of the\n     * wrapped target.\n     */\n    isExtensible: function () {\n      var trap = this.getTrap(\"isExtensible\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.isExtensible(this.target);\n      }\n\n      var result = trap.call(this.handler, this.target);\n      result = !!result; // coerce to Boolean\n\n      var state = Object_isExtensible(this.target);\n\n      if (result !== state) {\n        if (result) {\n          throw new TypeError(\"cannot report non-extensible object as extensible: \" + this.target);\n        } else {\n          throw new TypeError(\"cannot report extensible object as non-extensible: \" + this.target);\n        }\n      }\n\n      return state;\n    },\n\n    /**\n     * Check whether the trap result corresponds to the target's [[Prototype]]\n     */\n    getPrototypeOf: function () {\n      var trap = this.getTrap(\"getPrototypeOf\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.getPrototypeOf(this.target);\n      }\n\n      var allegedProto = trap.call(this.handler, this.target);\n\n      if (!Object_isExtensible(this.target)) {\n        var actualProto = Object_getPrototypeOf(this.target);\n\n        if (!sameValue(allegedProto, actualProto)) {\n          throw new TypeError(\"prototype value does not match: \" + this.target);\n        }\n      }\n\n      return allegedProto;\n    },\n\n    /**\n     * If target is non-extensible and setPrototypeOf trap returns true,\n     * check whether the trap result corresponds to the target's [[Prototype]]\n     */\n    setPrototypeOf: function (newProto) {\n      var trap = this.getTrap(\"setPrototypeOf\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.setPrototypeOf(this.target, newProto);\n      }\n\n      var success = trap.call(this.handler, this.target, newProto);\n      success = !!success;\n\n      if (success && !Object_isExtensible(this.target)) {\n        var actualProto = Object_getPrototypeOf(this.target);\n\n        if (!sameValue(newProto, actualProto)) {\n          throw new TypeError(\"prototype value does not match: \" + this.target);\n        }\n      }\n\n      return success;\n    },\n\n    /**\n     * In the direct proxies design with refactored prototype climbing,\n     * this trap is deprecated. For proxies-as-prototypes, for-in will\n     * call the enumerate() trap. If that trap is not defined, the\n     * operation is forwarded to the target, no more fallback on this\n     * fundamental trap.\n     */\n    getPropertyNames: function () {\n      throw new TypeError(\"getPropertyNames trap is deprecated\");\n    },\n    // === derived traps ===\n\n    /**\n     * If name denotes a fixed property, check whether the trap returns true.\n     */\n    has: function (name) {\n      var trap = this.getTrap(\"has\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.has(this.target, name);\n      }\n\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name);\n      res = !!res; // coerce to Boolean\n\n      if (res === false) {\n        if (isSealed(name, this.target)) {\n          throw new TypeError(\"cannot report existing non-configurable own \" + \"property '\" + name + \"' as a non-existent \" + \"property\");\n        }\n\n        if (!Object.isExtensible(this.target) && isFixed(name, this.target)) {\n          // if handler is allowed to return false, we cannot guarantee\n          // that it will not return true for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\" + name + \"' as non-existent on a non-extensible object\");\n        }\n      } // if res === true, we don't need to check for extensibility\n      // even for a non-extensible proxy that has no own name property,\n      // the property may have been inherited\n\n\n      return res;\n    },\n\n    /**\n     * If name denotes a fixed non-configurable, non-writable data property,\n     * check its return value against the previously asserted value of the\n     * fixed property.\n     */\n    get: function (receiver, name) {\n      // experimental support for invoke() trap on platforms that\n      // support __noSuchMethod__\n\n      /*\n      if (name === '__noSuchMethod__') {\n        var handler = this;\n        return function(name, args) {\n          return handler.invoke(receiver, name, args);\n        }\n      }\n      */\n      var trap = this.getTrap(\"get\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.get(this.target, name, receiver);\n      }\n\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name, receiver);\n      var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name); // check consistency of the returned value\n\n      if (fixedDesc !== undefined) {\n        // getting an existing property\n        if (isDataDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.writable === false) {\n          // own frozen data property\n          if (!sameValue(res, fixedDesc.value)) {\n            throw new TypeError(\"cannot report inconsistent value for \" + \"non-writable, non-configurable property '\" + name + \"'\");\n          }\n        } else {\n          // it's an accessor property\n          if (isAccessorDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.get === undefined) {\n            if (res !== undefined) {\n              throw new TypeError(\"must report undefined for non-configurable \" + \"accessor property '\" + name + \"' without getter\");\n            }\n          }\n        }\n      }\n\n      return res;\n    },\n\n    /**\n     * If name denotes a fixed non-configurable, non-writable data property,\n     * check that the trap rejects the assignment.\n     */\n    set: function (receiver, name, val) {\n      var trap = this.getTrap(\"set\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.set(this.target, name, val, receiver);\n      }\n\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name, val, receiver);\n      res = !!res; // coerce to Boolean\n      // if success is reported, check whether property is truly assignable\n\n      if (res === true) {\n        var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n\n        if (fixedDesc !== undefined) {\n          // setting an existing property\n          if (isDataDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.writable === false) {\n            if (!sameValue(val, fixedDesc.value)) {\n              throw new TypeError(\"cannot successfully assign to a \" + \"non-writable, non-configurable property '\" + name + \"'\");\n            }\n          } else {\n            if (isAccessorDescriptor(fixedDesc) && fixedDesc.configurable === false && // non-configurable\n            fixedDesc.set === undefined) {\n              // accessor with undefined setter\n              throw new TypeError(\"setting a property '\" + name + \"' that has \" + \" only a getter\");\n            }\n          }\n        }\n      }\n\n      return res;\n    },\n\n    /**\n     * Any own enumerable non-configurable properties of the target that are not\n     * included in the trap result give rise to a TypeError. As such, we check\n     * whether the returned result contains at least all sealed enumerable properties\n     * of the target object.\n     *\n     * The trap should return an iterator.\n     *\n     * However, as implementations of pre-direct proxies still expect enumerate\n     * to return an array of strings, we convert the iterator into an array.\n     */\n    enumerate: function () {\n      var trap = this.getTrap(\"enumerate\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        var trapResult = Reflect.enumerate(this.target);\n        var result = [];\n        var nxt = trapResult.next();\n\n        while (!nxt.done) {\n          result.push(String(nxt.value));\n          nxt = trapResult.next();\n        }\n\n        return result;\n      }\n\n      var trapResult = trap.call(this.handler, this.target);\n\n      if (trapResult === null || trapResult === undefined || trapResult.next === undefined) {\n        throw new TypeError(\"enumerate trap should return an iterator, got: \" + trapResult);\n      } // propNames is used as a set of strings\n\n\n      var propNames = Object.create(null); // var numProps = +trapResult.length;\n\n      var result = []; // new Array(numProps);\n      // trapResult is supposed to be an iterator\n      // drain iterator to array as current implementations still expect\n      // enumerate to return an array of strings\n\n      var nxt = trapResult.next();\n\n      while (!nxt.done) {\n        var s = String(nxt.value);\n\n        if (propNames[s]) {\n          throw new TypeError(\"enumerate trap cannot list a \" + \"duplicate property '\" + s + \"'\");\n        }\n\n        propNames[s] = true;\n        result.push(s);\n        nxt = trapResult.next();\n      }\n      /*for (var i = 0; i < numProps; i++) {\n        var s = String(trapResult[i]);\n        if (propNames[s]) {\n          throw new TypeError(\"enumerate trap cannot list a \"+\n                              \"duplicate property '\"+s+\"'\");\n        }\n         propNames[s] = true;\n        result[i] = s;\n      } */\n\n\n      var ownEnumerableProps = Object.keys(this.target);\n      var target = this.target;\n      ownEnumerableProps.forEach(function (ownEnumerableProp) {\n        if (!propNames[ownEnumerableProp]) {\n          if (isSealed(ownEnumerableProp, target)) {\n            throw new TypeError(\"enumerate trap failed to include \" + \"non-configurable enumerable property '\" + ownEnumerableProp + \"'\");\n          }\n\n          if (!Object.isExtensible(target) && isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\" + ownEnumerableProp + \"' as non-existent on a \" + \"non-extensible object\");\n          }\n        }\n      });\n      return result;\n    },\n\n    /**\n     * The iterate trap is deprecated by the enumerate trap.\n     */\n    iterate: Validator.prototype.enumerate,\n\n    /**\n     * Any own non-configurable properties of the target that are not included\n     * in the trap result give rise to a TypeError. As such, we check whether the\n     * returned result contains at least all sealed properties of the target\n     * object.\n     *\n     * The trap result is normalized.\n     * The trap result is not returned directly. Instead:\n     *  - create and return a fresh Array,\n     *  - of which each element is coerced to String,\n     *  - which does not contain duplicates\n     *\n     * FIXME: keys trap is deprecated\n     */\n\n    /*\n    keys: function() {\n      var trap = this.getTrap(\"keys\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.keys(this.target);\n      }\n       var trapResult = trap.call(this.handler, this.target);\n       // propNames is used as a set of strings\n      var propNames = Object.create(null);\n      var numProps = +trapResult.length;\n      var result = new Array(numProps);\n       for (var i = 0; i < numProps; i++) {\n       var s = String(trapResult[i]);\n       if (propNames[s]) {\n         throw new TypeError(\"keys trap cannot list a \"+\n                             \"duplicate property '\"+s+\"'\");\n       }\n       if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n         // non-extensible proxies don't tolerate new own property names\n         throw new TypeError(\"keys trap cannot list a new \"+\n                             \"property '\"+s+\"' on a non-extensible object\");\n       }\n        propNames[s] = true;\n       result[i] = s;\n      }\n       var ownEnumerableProps = Object.keys(this.target);\n      var target = this.target;\n      ownEnumerableProps.forEach(function (ownEnumerableProp) {\n        if (!propNames[ownEnumerableProp]) {\n          if (isSealed(ownEnumerableProp, target)) {\n            throw new TypeError(\"keys trap failed to include \"+\n                                \"non-configurable enumerable property '\"+\n                                ownEnumerableProp+\"'\");\n          }\n          if (!Object.isExtensible(target) &&\n              isFixed(ownEnumerableProp, target)) {\n              // if handler is allowed not to report ownEnumerableProp as an own\n              // property, we cannot guarantee that it will never report it as\n              // an own property later. Once a property has been reported as\n              // non-existent on a non-extensible object, it should forever be\n              // reported as non-existent\n              throw new TypeError(\"cannot report existing own property '\"+\n                                  ownEnumerableProp+\"' as non-existent on a \"+\n                                  \"non-extensible object\");\n          }\n        }\n      });\n       return result;\n    },\n    */\n\n    /**\n     * New trap that reifies [[Call]].\n     * If the target is a function, then a call to\n     *   proxy(...args)\n     * Triggers this trap\n     */\n    apply: function (target, thisBinding, args) {\n      var trap = this.getTrap(\"apply\");\n\n      if (trap === undefined) {\n        return Reflect.apply(target, thisBinding, args);\n      }\n\n      if (typeof this.target === \"function\") {\n        return trap.call(this.handler, target, thisBinding, args);\n      } else {\n        throw new TypeError(\"apply: \" + target + \" is not a function\");\n      }\n    },\n\n    /**\n     * New trap that reifies [[Construct]].\n     * If the target is a function, then a call to\n     *   new proxy(...args)\n     * Triggers this trap\n     */\n    construct: function (target, args, newTarget) {\n      var trap = this.getTrap(\"construct\");\n\n      if (trap === undefined) {\n        return Reflect.construct(target, args, newTarget);\n      }\n\n      if (typeof target !== \"function\") {\n        throw new TypeError(\"new: \" + target + \" is not a function\");\n      }\n\n      if (newTarget === undefined) {\n        newTarget = target;\n      } else {\n        if (typeof newTarget !== \"function\") {\n          throw new TypeError(\"new: \" + newTarget + \" is not a function\");\n        }\n      }\n\n      return trap.call(this.handler, target, args, newTarget);\n    }\n  }; // ---- end of the Validator handler wrapper handler ----\n  // In what follows, a 'direct proxy' is a proxy\n  // whose handler is a Validator. Such proxies can be made non-extensible,\n  // sealed or frozen without losing the ability to trap.\n  // maps direct proxies to their Validator handlers\n\n  var directProxies = new WeakMap(); // patch Object.{preventExtensions,seal,freeze} so that\n  // they recognize fixable proxies and act accordingly\n\n  Object.preventExtensions = function (subject) {\n    var vhandler = directProxies.get(subject);\n\n    if (vhandler !== undefined) {\n      if (vhandler.preventExtensions()) {\n        return subject;\n      } else {\n        throw new TypeError(\"preventExtensions on \" + subject + \" rejected\");\n      }\n    } else {\n      return prim_preventExtensions(subject);\n    }\n  };\n\n  Object.seal = function (subject) {\n    setIntegrityLevel(subject, \"sealed\");\n    return subject;\n  };\n\n  Object.freeze = function (subject) {\n    setIntegrityLevel(subject, \"frozen\");\n    return subject;\n  };\n\n  Object.isExtensible = Object_isExtensible = function (subject) {\n    var vHandler = directProxies.get(subject);\n\n    if (vHandler !== undefined) {\n      return vHandler.isExtensible();\n    } else {\n      return prim_isExtensible(subject);\n    }\n  };\n\n  Object.isSealed = Object_isSealed = function (subject) {\n    return testIntegrityLevel(subject, \"sealed\");\n  };\n\n  Object.isFrozen = Object_isFrozen = function (subject) {\n    return testIntegrityLevel(subject, \"frozen\");\n  };\n\n  Object.getPrototypeOf = Object_getPrototypeOf = function (subject) {\n    var vHandler = directProxies.get(subject);\n\n    if (vHandler !== undefined) {\n      return vHandler.getPrototypeOf();\n    } else {\n      return prim_getPrototypeOf(subject);\n    }\n  }; // patch Object.getOwnPropertyDescriptor to directly call\n  // the Validator.prototype.getOwnPropertyDescriptor trap\n  // This is to circumvent an assertion in the built-in Proxy\n  // trapping mechanism of v8, which disallows that trap to\n  // return non-configurable property descriptors (as per the\n  // old Proxy design)\n\n\n  Object.getOwnPropertyDescriptor = function (subject, name) {\n    var vhandler = directProxies.get(subject);\n\n    if (vhandler !== undefined) {\n      return vhandler.getOwnPropertyDescriptor(name);\n    } else {\n      return prim_getOwnPropertyDescriptor(subject, name);\n    }\n  }; // patch Object.defineProperty to directly call\n  // the Validator.prototype.defineProperty trap\n  // This is to circumvent two issues with the built-in\n  // trap mechanism:\n  // 1) the current tracemonkey implementation of proxies\n  // auto-completes 'desc', which is not correct. 'desc' should be\n  // normalized, but not completed. Consider:\n  // Object.defineProperty(proxy, 'foo', {enumerable:false})\n  // This trap will receive desc =\n  //  {value:undefined,writable:false,enumerable:false,configurable:false}\n  // This will also set all other attributes to their default value,\n  // which is unexpected and different from [[DefineOwnProperty]].\n  // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n  // 2) the current spidermonkey implementation does not\n  // throw an exception when this trap returns 'false', but instead silently\n  // ignores the operation (this is regardless of strict-mode)\n  // 2a) v8 does throw an exception for this case, but includes the rather\n  //     unhelpful error message:\n  // 'Proxy handler #<Object> returned false from 'defineProperty' trap'\n\n\n  Object.defineProperty = function (subject, name, desc) {\n    var vhandler = directProxies.get(subject);\n\n    if (vhandler !== undefined) {\n      var normalizedDesc = normalizePropertyDescriptor(desc);\n      var success = vhandler.defineProperty(name, normalizedDesc);\n\n      if (success === false) {\n        throw new TypeError(\"can't redefine property '\" + name + \"'\");\n      }\n\n      return subject;\n    } else {\n      return prim_defineProperty(subject, name, desc);\n    }\n  };\n\n  Object.defineProperties = function (subject, descs) {\n    var vhandler = directProxies.get(subject);\n\n    if (vhandler !== undefined) {\n      var names = Object.keys(descs);\n\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        var normalizedDesc = normalizePropertyDescriptor(descs[name]);\n        var success = vhandler.defineProperty(name, normalizedDesc);\n\n        if (success === false) {\n          throw new TypeError(\"can't redefine property '\" + name + \"'\");\n        }\n      }\n\n      return subject;\n    } else {\n      return prim_defineProperties(subject, descs);\n    }\n  };\n\n  Object.keys = function (subject) {\n    var vHandler = directProxies.get(subject);\n\n    if (vHandler !== undefined) {\n      var ownKeys = vHandler.ownKeys();\n      var result = [];\n\n      for (var i = 0; i < ownKeys.length; i++) {\n        var k = String(ownKeys[i]);\n        var desc = Object.getOwnPropertyDescriptor(subject, k);\n\n        if (desc !== undefined && desc.enumerable === true) {\n          result.push(k);\n        }\n      }\n\n      return result;\n    } else {\n      return prim_keys(subject);\n    }\n  };\n\n  Object.getOwnPropertyNames = Object_getOwnPropertyNames = function (subject) {\n    var vHandler = directProxies.get(subject);\n\n    if (vHandler !== undefined) {\n      return vHandler.ownKeys();\n    } else {\n      return prim_getOwnPropertyNames(subject);\n    }\n  }; // fixes issue #71 (Calling Object.getOwnPropertySymbols() on a Proxy\n  // throws an error)\n\n\n  if (prim_getOwnPropertySymbols !== undefined) {\n    Object.getOwnPropertySymbols = function (subject) {\n      var vHandler = directProxies.get(subject);\n\n      if (vHandler !== undefined) {\n        // as this shim does not support symbols, a Proxy never advertises\n        // any symbol-valued own properties\n        return [];\n      } else {\n        return prim_getOwnPropertySymbols(subject);\n      }\n    };\n  } // fixes issue #72 ('Illegal access' error when using Object.assign)\n  // Object.assign polyfill based on a polyfill posted on MDN: \n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\\\n  //  Global_Objects/Object/assign\n  // Note that this polyfill does not support Symbols, but this Proxy Shim\n  // does not support Symbols anyway.\n\n\n  if (prim_assign !== undefined) {\n    Object.assign = function (target) {\n      // check if any argument is a proxy object\n      var noProxies = true;\n\n      for (var i = 0; i < arguments.length; i++) {\n        var vHandler = directProxies.get(arguments[i]);\n\n        if (vHandler !== undefined) {\n          noProxies = false;\n          break;\n        }\n      }\n\n      if (noProxies) {\n        // not a single argument is a proxy, perform built-in algorithm\n        return prim_assign.apply(Object, arguments);\n      } // there is at least one proxy argument, use the polyfill\n\n\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var output = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n\n      return output;\n    };\n  } // returns whether an argument is a reference to an object,\n  // which is legal as a WeakMap key.\n\n\n  function isObject(arg) {\n    var type = typeof arg;\n    return type === 'object' && arg !== null || type === 'function';\n  }\n\n  ; // a wrapper for WeakMap.get which returns the undefined value\n  // for keys that are not objects (in which case the underlying\n  // WeakMap would have thrown a TypeError).\n\n  function safeWeakMapGet(map, key) {\n    return isObject(key) ? map.get(key) : undefined;\n  }\n\n  ; // returns a new function of zero arguments that recursively\n  // unwraps any proxies specified as the |this|-value.\n  // The primitive is assumed to be a zero-argument method\n  // that uses its |this|-binding.\n\n  function makeUnwrapping0ArgMethod(primitive) {\n    return function builtin() {\n      var vHandler = safeWeakMapGet(directProxies, this);\n\n      if (vHandler !== undefined) {\n        return builtin.call(vHandler.target);\n      } else {\n        return primitive.call(this);\n      }\n    };\n  }\n\n  ; // returns a new function of 1 arguments that recursively\n  // unwraps any proxies specified as the |this|-value.\n  // The primitive is assumed to be a 1-argument method\n  // that uses its |this|-binding.\n\n  function makeUnwrapping1ArgMethod(primitive) {\n    return function builtin(arg) {\n      var vHandler = safeWeakMapGet(directProxies, this);\n\n      if (vHandler !== undefined) {\n        return builtin.call(vHandler.target, arg);\n      } else {\n        return primitive.call(this, arg);\n      }\n    };\n  }\n\n  ;\n  Object.prototype.valueOf = makeUnwrapping0ArgMethod(Object.prototype.valueOf);\n  Object.prototype.toString = makeUnwrapping0ArgMethod(Object.prototype.toString);\n  Function.prototype.toString = makeUnwrapping0ArgMethod(Function.prototype.toString);\n  Date.prototype.toString = makeUnwrapping0ArgMethod(Date.prototype.toString);\n\n  Object.prototype.isPrototypeOf = function builtin(arg) {\n    // bugfix thanks to Bill Mark:\n    // built-in isPrototypeOf does not unwrap proxies used\n    // as arguments. So, we implement the builtin ourselves,\n    // based on the ECMAScript 6 spec. Our encoding will\n    // make sure that if a proxy is used as an argument,\n    // its getPrototypeOf trap will be called.\n    while (true) {\n      var vHandler2 = safeWeakMapGet(directProxies, arg);\n\n      if (vHandler2 !== undefined) {\n        arg = vHandler2.getPrototypeOf();\n\n        if (arg === null) {\n          return false;\n        } else if (sameValue(arg, this)) {\n          return true;\n        }\n      } else {\n        return prim_isPrototypeOf.call(this, arg);\n      }\n    }\n  };\n\n  Array.isArray = function (subject) {\n    var vHandler = safeWeakMapGet(directProxies, subject);\n\n    if (vHandler !== undefined) {\n      return Array.isArray(vHandler.target);\n    } else {\n      return prim_isArray(subject);\n    }\n  };\n\n  function isProxyArray(arg) {\n    var vHandler = safeWeakMapGet(directProxies, arg);\n\n    if (vHandler !== undefined) {\n      return Array.isArray(vHandler.target);\n    }\n\n    return false;\n  } // Array.prototype.concat internally tests whether one of its\n  // arguments is an Array, by checking whether [[Class]] == \"Array\"\n  // As such, it will fail to recognize proxies-for-arrays as arrays.\n  // We patch Array.prototype.concat so that it \"unwraps\" proxies-for-arrays\n  // by making a copy. This will trigger the exact same sequence of\n  // traps on the proxy-for-array as if we would not have unwrapped it.\n  // See <https://github.com/tvcutsem/harmony-reflect/issues/19> for more.\n\n\n  Array.prototype.concat = function\n    /*...args*/\n  () {\n    var length;\n\n    for (var i = 0; i < arguments.length; i++) {\n      if (isProxyArray(arguments[i])) {\n        length = arguments[i].length;\n        arguments[i] = Array.prototype.slice.call(arguments[i], 0, length);\n      }\n    }\n\n    return prim_concat.apply(this, arguments);\n  }; // setPrototypeOf support on platforms that support __proto__\n\n\n  var prim_setPrototypeOf = Object.setPrototypeOf; // patch and extract original __proto__ setter\n\n  var __proto__setter = function () {\n    var protoDesc = prim_getOwnPropertyDescriptor(Object.prototype, '__proto__');\n\n    if (protoDesc === undefined || typeof protoDesc.set !== \"function\") {\n      return function () {\n        throw new TypeError(\"setPrototypeOf not supported on this platform\");\n      };\n    } // see if we can actually mutate a prototype with the generic setter\n    // (e.g. Chrome v28 doesn't allow setting __proto__ via the generic setter)\n\n\n    try {\n      protoDesc.set.call({}, {});\n    } catch (e) {\n      return function () {\n        throw new TypeError(\"setPrototypeOf not supported on this platform\");\n      };\n    }\n\n    prim_defineProperty(Object.prototype, '__proto__', {\n      set: function (newProto) {\n        return Object.setPrototypeOf(this, Object(newProto));\n      }\n    });\n    return protoDesc.set;\n  }();\n\n  Object.setPrototypeOf = function (target, newProto) {\n    var handler = directProxies.get(target);\n\n    if (handler !== undefined) {\n      if (handler.setPrototypeOf(newProto)) {\n        return target;\n      } else {\n        throw new TypeError(\"proxy rejected prototype mutation\");\n      }\n    } else {\n      if (!Object_isExtensible(target)) {\n        throw new TypeError(\"can't set prototype on non-extensible object: \" + target);\n      }\n\n      if (prim_setPrototypeOf) return prim_setPrototypeOf(target, newProto);\n\n      if (Object(newProto) !== newProto || newProto === null) {\n        throw new TypeError(\"Object prototype may only be an Object or null: \" + newProto); // throw new TypeError(\"prototype must be an object or null\")\n      }\n\n      __proto__setter.call(target, newProto);\n\n      return target;\n    }\n  };\n\n  Object.prototype.hasOwnProperty = function (name) {\n    var handler = safeWeakMapGet(directProxies, this);\n\n    if (handler !== undefined) {\n      var desc = handler.getOwnPropertyDescriptor(name);\n      return desc !== undefined;\n    } else {\n      return prim_hasOwnProperty.call(this, name);\n    }\n  }; // ============= Reflection module =============\n  // see http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n\n\n  var Reflect = {\n    getOwnPropertyDescriptor: function (target, name) {\n      return Object.getOwnPropertyDescriptor(target, name);\n    },\n    defineProperty: function (target, name, desc) {\n      // if target is a proxy, invoke its \"defineProperty\" trap\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.defineProperty(target, name, desc);\n      } // Implementation transliterated from [[DefineOwnProperty]]\n      // see ES5.1 section 8.12.9\n      // this is the _exact same algorithm_ as the isCompatibleDescriptor\n      // algorithm defined above, except that at every place it\n      // returns true, this algorithm actually does define the property.\n\n\n      var current = Object.getOwnPropertyDescriptor(target, name);\n      var extensible = Object.isExtensible(target);\n\n      if (current === undefined && extensible === false) {\n        return false;\n      }\n\n      if (current === undefined && extensible === true) {\n        Object.defineProperty(target, name, desc); // should never fail\n\n        return true;\n      }\n\n      if (isEmptyDescriptor(desc)) {\n        return true;\n      }\n\n      if (isEquivalentDescriptor(current, desc)) {\n        return true;\n      }\n\n      if (current.configurable === false) {\n        if (desc.configurable === true) {\n          return false;\n        }\n\n        if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n          return false;\n        }\n      }\n\n      if (isGenericDescriptor(desc)) {// no further validation necessary\n      } else if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n        if (current.configurable === false) {\n          return false;\n        }\n      } else if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n        if (current.configurable === false) {\n          if (current.writable === false && desc.writable === true) {\n            return false;\n          }\n\n          if (current.writable === false) {\n            if ('value' in desc && !sameValue(desc.value, current.value)) {\n              return false;\n            }\n          }\n        }\n      } else if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n        if (current.configurable === false) {\n          if ('set' in desc && !sameValue(desc.set, current.set)) {\n            return false;\n          }\n\n          if ('get' in desc && !sameValue(desc.get, current.get)) {\n            return false;\n          }\n        }\n      }\n\n      Object.defineProperty(target, name, desc); // should never fail\n\n      return true;\n    },\n    deleteProperty: function (target, name) {\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.delete(name);\n      }\n\n      var desc = Object.getOwnPropertyDescriptor(target, name);\n\n      if (desc === undefined) {\n        return true;\n      }\n\n      if (desc.configurable === true) {\n        delete target[name];\n        return true;\n      }\n\n      return false;\n    },\n    getPrototypeOf: function (target) {\n      return Object.getPrototypeOf(target);\n    },\n    setPrototypeOf: function (target, newProto) {\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.setPrototypeOf(newProto);\n      }\n\n      if (Object(newProto) !== newProto || newProto === null) {\n        throw new TypeError(\"Object prototype may only be an Object or null: \" + newProto);\n      }\n\n      if (!Object_isExtensible(target)) {\n        return false;\n      }\n\n      var current = Object.getPrototypeOf(target);\n\n      if (sameValue(current, newProto)) {\n        return true;\n      }\n\n      if (prim_setPrototypeOf) {\n        try {\n          prim_setPrototypeOf(target, newProto);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      __proto__setter.call(target, newProto);\n\n      return true;\n    },\n    preventExtensions: function (target) {\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.preventExtensions();\n      }\n\n      prim_preventExtensions(target);\n      return true;\n    },\n    isExtensible: function (target) {\n      return Object.isExtensible(target);\n    },\n    has: function (target, name) {\n      return name in target;\n    },\n    get: function (target, name, receiver) {\n      receiver = receiver || target; // if target is a proxy, invoke its \"get\" trap\n\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.get(receiver, name);\n      }\n\n      var desc = Object.getOwnPropertyDescriptor(target, name);\n\n      if (desc === undefined) {\n        var proto = Object.getPrototypeOf(target);\n\n        if (proto === null) {\n          return undefined;\n        }\n\n        return Reflect.get(proto, name, receiver);\n      }\n\n      if (isDataDescriptor(desc)) {\n        return desc.value;\n      }\n\n      var getter = desc.get;\n\n      if (getter === undefined) {\n        return undefined;\n      }\n\n      return desc.get.call(receiver);\n    },\n    // Reflect.set implementation based on latest version of [[SetP]] at\n    // http://wiki.ecmascript.org/doku.php?id=harmony:proto_climbing_refactoring\n    set: function (target, name, value, receiver) {\n      receiver = receiver || target; // if target is a proxy, invoke its \"set\" trap\n\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.set(receiver, name, value);\n      } // first, check whether target has a non-writable property\n      // shadowing name on receiver\n\n\n      var ownDesc = Object.getOwnPropertyDescriptor(target, name);\n\n      if (ownDesc === undefined) {\n        // name is not defined in target, search target's prototype\n        var proto = Object.getPrototypeOf(target);\n\n        if (proto !== null) {\n          // continue the search in target's prototype\n          return Reflect.set(proto, name, value, receiver);\n        } // Rev16 change. Cf. https://bugs.ecmascript.org/show_bug.cgi?id=1549\n        // target was the last prototype, now we know that 'name' is not shadowed\n        // by an existing (accessor or data) property, so we can add the property\n        // to the initial receiver object\n        // (this branch will intentionally fall through to the code below)\n\n\n        ownDesc = {\n          value: undefined,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        };\n      } // we now know that ownDesc !== undefined\n\n\n      if (isAccessorDescriptor(ownDesc)) {\n        var setter = ownDesc.set;\n        if (setter === undefined) return false;\n        setter.call(receiver, value); // assumes Function.prototype.call\n\n        return true;\n      } // otherwise, isDataDescriptor(ownDesc) must be true\n\n\n      if (ownDesc.writable === false) return false; // we found an existing writable data property on the prototype chain.\n      // Now update or add the data property on the receiver, depending on\n      // whether the receiver already defines the property or not.\n\n      var existingDesc = Object.getOwnPropertyDescriptor(receiver, name);\n\n      if (existingDesc !== undefined) {\n        var updateDesc = {\n          value: value,\n          // FIXME: it should not be necessary to describe the following\n          // attributes. Added to circumvent a bug in tracemonkey:\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n          writable: existingDesc.writable,\n          enumerable: existingDesc.enumerable,\n          configurable: existingDesc.configurable\n        };\n        Object.defineProperty(receiver, name, updateDesc);\n        return true;\n      } else {\n        if (!Object.isExtensible(receiver)) return false;\n        var newDesc = {\n          value: value,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        };\n        Object.defineProperty(receiver, name, newDesc);\n        return true;\n      }\n    },\n\n    /*invoke: function(target, name, args, receiver) {\n      receiver = receiver || target;\n       var handler = directProxies.get(target);\n      if (handler !== undefined) {\n        return handler.invoke(receiver, name, args);\n      }\n       var fun = Reflect.get(target, name, receiver);\n      return Function.prototype.apply.call(fun, receiver, args);\n    },*/\n    enumerate: function (target) {\n      var handler = directProxies.get(target);\n      var result;\n\n      if (handler !== undefined) {\n        // handler.enumerate should return an iterator directly, but the\n        // iterator gets converted to an array for backward-compat reasons,\n        // so we must re-iterate over the array\n        result = handler.enumerate(handler.target);\n      } else {\n        result = [];\n\n        for (var name in target) {\n          result.push(name);\n        }\n\n        ;\n      }\n\n      var l = +result.length;\n      var idx = 0;\n      return {\n        next: function () {\n          if (idx === l) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: result[idx++]\n          };\n        }\n      };\n    },\n    // imperfect ownKeys implementation: in ES6, should also include\n    // symbol-keyed properties.\n    ownKeys: function (target) {\n      return Object_getOwnPropertyNames(target);\n    },\n    apply: function (target, receiver, args) {\n      // target.apply(receiver, args)\n      return Function.prototype.apply.call(target, receiver, args);\n    },\n    construct: function (target, args, newTarget) {\n      // return new target(...args);\n      // if target is a proxy, invoke its \"construct\" trap\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.construct(handler.target, args, newTarget);\n      }\n\n      if (typeof target !== \"function\") {\n        throw new TypeError(\"target is not a function: \" + target);\n      }\n\n      if (newTarget === undefined || newTarget === target) {\n        // If newTarget is undefined, then newTarget is set to `target` and\n        // `Reflect.construct(target, ...args)` becomes equivalent to\n        // `new target(...args)`\n        // if `target` is an ES2015 Class constructor, it must be called using\n        // the `new` operator. Hence we use the new operator on a bound function\n        // to trigger the [[Construct]] internal method. This technique will work \n        // for both plain constructor functions and ES2015 classes\n        return new (Function.prototype.bind.apply(target, [null].concat(args)))();\n      } else {\n        if (typeof newTarget !== \"function\") {\n          throw new TypeError(\"newTarget is not a function: \" + target);\n        } // if newTarget is a *different* constructor function, we need to\n        // emulate [[Construct]] by falling back to [[Call]] with a hand-crafted\n        // new instance inheriting from newTarget.prototype\n        // Unfortunately this won't work if target is an ES2015 Constructor\n        // function, whose [[Call]] method throws an error (it must be invoked\n        // using the `new` operator)\n\n\n        var proto = newTarget.prototype;\n        var instance = Object(proto) === proto ? Object.create(proto) : {};\n        var result = Function.prototype.apply.call(target, instance, args);\n        return Object(result) === result ? result : instance;\n      }\n    }\n  }; // feature-test whether the Reflect global exists\n\n  if (global.Reflect !== undefined) {\n    // Reflect exists, add/override the shimmed methods\n    Object.getOwnPropertyNames(Reflect).forEach(function (key) {\n      global.Reflect[key] = Reflect[key];\n    });\n  } else {\n    // Reflect doesn't exist, define it as the shimmed Reflect object\n    global.Reflect = Reflect;\n  } // feature-test whether the Proxy global exists, with\n  // the harmony-era Proxy.create API\n\n\n  if (typeof Proxy !== \"undefined\" && typeof Proxy.create !== \"undefined\") {\n    var primCreate = Proxy.create,\n        primCreateFunction = Proxy.createFunction;\n    var revokedHandler = primCreate({\n      get: function () {\n        throw new TypeError(\"proxy is revoked\");\n      }\n    });\n\n    global.Proxy = function (target, handler) {\n      // check that target is an Object\n      if (Object(target) !== target) {\n        throw new TypeError(\"Proxy target must be an Object, given \" + target);\n      } // check that handler is an Object\n\n\n      if (Object(handler) !== handler) {\n        throw new TypeError(\"Proxy handler must be an Object, given \" + handler);\n      }\n\n      var vHandler = new Validator(target, handler);\n      var proxy;\n\n      if (typeof target === \"function\") {\n        proxy = primCreateFunction(vHandler, // call trap\n        function () {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.apply(target, this, args);\n        }, // construct trap\n        function () {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.construct(target, args);\n        });\n      } else {\n        proxy = primCreate(vHandler, Object.getPrototypeOf(target));\n      }\n\n      directProxies.set(proxy, vHandler);\n      return proxy;\n    };\n\n    global.Proxy.revocable = function (target, handler) {\n      var proxy = new Proxy(target, handler);\n\n      var revoke = function () {\n        var vHandler = directProxies.get(proxy);\n\n        if (vHandler !== null) {\n          vHandler.target = null;\n          vHandler.handler = revokedHandler;\n        }\n\n        return undefined;\n      };\n\n      return {\n        proxy: proxy,\n        revoke: revoke\n      };\n    }; // add the old Proxy.create and Proxy.createFunction methods\n    // so old code that still depends on the harmony-era Proxy object\n    // is not broken. Also ensures that multiple versions of this\n    // library should load fine\n\n\n    global.Proxy.create = primCreate;\n    global.Proxy.createFunction = primCreateFunction;\n  } else {\n    // Proxy global not defined, or old API not available\n    if (typeof Proxy === \"undefined\") {\n      // Proxy global not defined, add a Proxy function stub\n      global.Proxy = function (_target, _handler) {\n        throw new Error(\"proxies not supported on this platform. On v8/node/iojs, make sure to pass the --harmony_proxies flag\");\n      };\n    } // Proxy global defined but old API not available\n    // presumably Proxy global already supports new API, leave untouched\n\n  } // for node.js modules, export every property in the Reflect object\n  // as part of the module interface\n\n\n  if (typeof exports !== 'undefined') {\n    Object.keys(Reflect).forEach(function (key) {\n      exports[key] = Reflect[key];\n    });\n  } // function-as-module pattern\n\n})(typeof exports !== 'undefined' ? global : this);","map":{"version":3,"names":["global","WeakMap","prototype","get","k","undefined","set","v","Error","isStandardAttribute","name","test","toPropertyDescriptor","obj","Object","TypeError","desc","enumerable","configurable","value","writable","getter","setter","isAccessorDescriptor","isDataDescriptor","isGenericDescriptor","toCompletePropertyDescriptor","internalDesc","isEmptyDescriptor","isEquivalentDescriptor","desc1","desc2","sameValue","x","y","normalizeAndCompletePropertyDescriptor","attributes","defineProperty","normalizePropertyDescriptor","prim_preventExtensions","preventExtensions","prim_seal","seal","prim_freeze","freeze","prim_isExtensible","isExtensible","prim_isSealed","isSealed","prim_isFrozen","isFrozen","prim_getPrototypeOf","getPrototypeOf","prim_getOwnPropertyDescriptor","getOwnPropertyDescriptor","prim_defineProperty","prim_defineProperties","defineProperties","prim_keys","keys","prim_getOwnPropertyNames","getOwnPropertyNames","prim_getOwnPropertySymbols","getOwnPropertySymbols","prim_assign","assign","prim_isArray","Array","isArray","prim_concat","concat","prim_isPrototypeOf","isPrototypeOf","prim_hasOwnProperty","hasOwnProperty","Object_isFrozen","Object_isSealed","Object_isExtensible","Object_getPrototypeOf","Object_getOwnPropertyNames","isFixed","target","call","isSealedDesc","isCompatibleDescriptor","extensible","current","setIntegrityLevel","level","ownProps","pendingException","l","length","i","String","e","currentDesc","Reflect","testIntegrityLevel","Validator","handler","getTrap","trapName","trap","targetDesc","getPropertyDescriptor","has","val","descObj","success","delete","deleteProperty","res","ownKeys","trapResult","propNames","create","numProps","result","s","forEach","ownProp","state","allegedProto","actualProto","setPrototypeOf","newProto","getPropertyNames","receiver","fixedDesc","enumerate","nxt","next","done","push","ownEnumerableProps","ownEnumerableProp","iterate","apply","thisBinding","args","construct","newTarget","directProxies","subject","vhandler","vHandler","normalizedDesc","descs","names","noProxies","arguments","output","index","source","nextKey","isObject","arg","type","safeWeakMapGet","map","key","makeUnwrapping0ArgMethod","primitive","builtin","makeUnwrapping1ArgMethod","valueOf","toString","Function","Date","vHandler2","isProxyArray","slice","prim_setPrototypeOf","__proto__setter","protoDesc","proto","ownDesc","existingDesc","updateDesc","newDesc","idx","bind","instance","Proxy","primCreate","primCreateFunction","createFunction","revokedHandler","proxy","revocable","revoke","_target","_handler","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/harmony-reflect/reflect.js"],"sourcesContent":["// Copyright (C) 2011-2012 Software Languages Lab, Vrije Universiteit Brussel\n// This code is dual-licensed under both the Apache License and the MPL\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is a shim for the ES-Harmony reflection module\n *\n * The Initial Developer of the Original Code is\n * Tom Van Cutsem, Vrije Universiteit Brussel.\n * Portions created by the Initial Developer are Copyright (C) 2011-2012\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n */\n\n // ----------------------------------------------------------------------------\n\n // This file is a polyfill for the upcoming ECMAScript Reflect API,\n // including support for Proxies. See the draft specification at:\n // http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n // http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n // For an implementation of the Handler API, see handlers.js, which implements:\n // http://wiki.ecmascript.org/doku.php?id=harmony:virtual_object_api\n\n // This implementation supersedes the earlier polyfill at:\n // code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js\n\n // This code was tested on tracemonkey / Firefox 12\n//  (and should run fine on older Firefox versions starting with FF4)\n // The code also works correctly on\n //   v8 --harmony_proxies --harmony_weakmaps (v3.6.5.1)\n\n // Language Dependencies:\n //  - ECMAScript 5/strict\n //  - \"old\" (i.e. non-direct) Harmony Proxies\n //  - Harmony WeakMaps\n // Patches:\n //  - Object.{freeze,seal,preventExtensions}\n //  - Object.{isFrozen,isSealed,isExtensible}\n //  - Object.getPrototypeOf\n //  - Object.keys\n //  - Object.prototype.valueOf\n //  - Object.prototype.isPrototypeOf\n //  - Object.prototype.toString\n //  - Object.prototype.hasOwnProperty\n //  - Object.getOwnPropertyDescriptor\n //  - Object.defineProperty\n //  - Object.defineProperties\n //  - Object.getOwnPropertyNames\n //  - Object.getOwnPropertySymbols\n //  - Object.getPrototypeOf\n //  - Object.setPrototypeOf\n //  - Object.assign\n //  - Function.prototype.toString\n //  - Date.prototype.toString\n //  - Array.isArray\n //  - Array.prototype.concat\n //  - Proxy\n // Adds new globals:\n //  - Reflect\n\n // Direct proxies can be created via Proxy(target, handler)\n\n // ----------------------------------------------------------------------------\n\n(function(global){ // function-as-module pattern\n\"use strict\";\n\n// === Direct Proxies: Invariant Enforcement ===\n\n// Direct proxies build on non-direct proxies by automatically wrapping\n// all user-defined proxy handlers in a Validator handler that checks and\n// enforces ES5 invariants.\n\n// A direct proxy is a proxy for an existing object called the target object.\n\n// A Validator handler is a wrapper for a target proxy handler H.\n// The Validator forwards all operations to H, but additionally\n// performs a number of integrity checks on the results of some traps,\n// to make sure H does not violate the ES5 invariants w.r.t. non-configurable\n// properties and non-extensible, sealed or frozen objects.\n\n// For each property that H exposes as own, non-configurable\n// (e.g. by returning a descriptor from a call to getOwnPropertyDescriptor)\n// the Validator handler defines those properties on the target object.\n// When the proxy becomes non-extensible, also configurable own properties\n// are checked against the target.\n// We will call properties that are defined on the target object\n// \"fixed properties\".\n\n// We will name fixed non-configurable properties \"sealed properties\".\n// We will name fixed non-configurable non-writable properties \"frozen\n// properties\".\n\n// The Validator handler upholds the following invariants w.r.t. non-configurability:\n// - getOwnPropertyDescriptor cannot report sealed properties as non-existent\n// - getOwnPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property (e.g. reporting a non-configurable\n//   property as configurable, or reporting a non-configurable, non-writable\n//   property as writable)\n// - getPropertyDescriptor cannot report sealed properties as non-existent\n// - getPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property. It _can_ report incompatible changes\n//   to the attributes of non-own, inherited properties.\n// - defineProperty cannot make incompatible changes to the attributes of\n//   sealed properties\n// - deleteProperty cannot report a successful deletion of a sealed property\n// - hasOwn cannot report a sealed property as non-existent\n// - has cannot report a sealed property as non-existent\n// - get cannot report inconsistent values for frozen data\n//   properties, and must report undefined for sealed accessors with an\n//   undefined getter\n// - set cannot report a successful assignment for frozen data\n//   properties or sealed accessors with an undefined setter.\n// - get{Own}PropertyNames lists all sealed properties of the target.\n// - keys lists all enumerable sealed properties of the target.\n// - enumerate lists all enumerable sealed properties of the target.\n// - if a property of a non-extensible proxy is reported as non-existent,\n//   then it must forever be reported as non-existent. This applies to\n//   own and inherited properties and is enforced in the\n//   deleteProperty, get{Own}PropertyDescriptor, has{Own},\n//   get{Own}PropertyNames, keys and enumerate traps\n\n// Violation of any of these invariants by H will result in TypeError being\n// thrown.\n\n// Additionally, once Object.preventExtensions, Object.seal or Object.freeze\n// is invoked on the proxy, the set of own property names for the proxy is\n// fixed. Any property name that is not fixed is called a 'new' property.\n\n// The Validator upholds the following invariants regarding extensibility:\n// - getOwnPropertyDescriptor cannot report new properties as existent\n//   (it must report them as non-existent by returning undefined)\n// - defineProperty cannot successfully add a new property (it must reject)\n// - getOwnPropertyNames cannot list new properties\n// - hasOwn cannot report true for new properties (it must report false)\n// - keys cannot list new properties\n\n// Invariants currently not enforced:\n// - getOwnPropertyNames lists only own property names\n// - keys lists only enumerable own property names\n// Both traps may list more property names than are actually defined on the\n// target.\n\n// Invariants with regard to inheritance are currently not enforced.\n// - a non-configurable potentially inherited property on a proxy with\n//   non-mutable ancestry cannot be reported as non-existent\n// (An object with non-mutable ancestry is a non-extensible object whose\n// [[Prototype]] is either null or an object with non-mutable ancestry.)\n\n// Changes in Handler API compared to previous harmony:proxies, see:\n// http://wiki.ecmascript.org/doku.php?id=strawman:direct_proxies\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n// ----------------------------------------------------------------------------\n\n// ---- WeakMap polyfill ----\n\n// TODO: find a proper WeakMap polyfill\n\n// define an empty WeakMap so that at least the Reflect module code\n// will work in the absence of WeakMaps. Proxy emulation depends on\n// actual WeakMaps, so will not work with this little shim.\nif (typeof WeakMap === \"undefined\") {\n  global.WeakMap = function(){};\n  global.WeakMap.prototype = {\n    get: function(k) { return undefined; },\n    set: function(k,v) { throw new Error(\"WeakMap not supported\"); }\n  };\n}\n\n// ---- Normalization functions for property descriptors ----\n\nfunction isStandardAttribute(name) {\n  return /^(get|set|value|writable|enumerable|configurable)$/.test(name);\n}\n\n// Adapted from ES5 section 8.10.5\nfunction toPropertyDescriptor(obj) {\n  if (Object(obj) !== obj) {\n    throw new TypeError(\"property descriptor should be an Object, given: \"+\n                        obj);\n  }\n  var desc = {};\n  if ('enumerable' in obj) { desc.enumerable = !!obj.enumerable; }\n  if ('configurable' in obj) { desc.configurable = !!obj.configurable; }\n  if ('value' in obj) { desc.value = obj.value; }\n  if ('writable' in obj) { desc.writable = !!obj.writable; }\n  if ('get' in obj) {\n    var getter = obj.get;\n    if (getter !== undefined && typeof getter !== \"function\") {\n      throw new TypeError(\"property descriptor 'get' attribute must be \"+\n                          \"callable or undefined, given: \"+getter);\n    }\n    desc.get = getter;\n  }\n  if ('set' in obj) {\n    var setter = obj.set;\n    if (setter !== undefined && typeof setter !== \"function\") {\n      throw new TypeError(\"property descriptor 'set' attribute must be \"+\n                          \"callable or undefined, given: \"+setter);\n    }\n    desc.set = setter;\n  }\n  if ('get' in desc || 'set' in desc) {\n    if ('value' in desc || 'writable' in desc) {\n      throw new TypeError(\"property descriptor cannot be both a data and an \"+\n                          \"accessor descriptor: \"+obj);\n    }\n  }\n  return desc;\n}\n\nfunction isAccessorDescriptor(desc) {\n  if (desc === undefined) return false;\n  return ('get' in desc || 'set' in desc);\n}\nfunction isDataDescriptor(desc) {\n  if (desc === undefined) return false;\n  return ('value' in desc || 'writable' in desc);\n}\nfunction isGenericDescriptor(desc) {\n  if (desc === undefined) return false;\n  return !isAccessorDescriptor(desc) && !isDataDescriptor(desc);\n}\n\nfunction toCompletePropertyDescriptor(desc) {\n  var internalDesc = toPropertyDescriptor(desc);\n  if (isGenericDescriptor(internalDesc) || isDataDescriptor(internalDesc)) {\n    if (!('value' in internalDesc)) { internalDesc.value = undefined; }\n    if (!('writable' in internalDesc)) { internalDesc.writable = false; }\n  } else {\n    if (!('get' in internalDesc)) { internalDesc.get = undefined; }\n    if (!('set' in internalDesc)) { internalDesc.set = undefined; }\n  }\n  if (!('enumerable' in internalDesc)) { internalDesc.enumerable = false; }\n  if (!('configurable' in internalDesc)) { internalDesc.configurable = false; }\n  return internalDesc;\n}\n\nfunction isEmptyDescriptor(desc) {\n  return !('get' in desc) &&\n         !('set' in desc) &&\n         !('value' in desc) &&\n         !('writable' in desc) &&\n         !('enumerable' in desc) &&\n         !('configurable' in desc);\n}\n\nfunction isEquivalentDescriptor(desc1, desc2) {\n  return sameValue(desc1.get, desc2.get) &&\n         sameValue(desc1.set, desc2.set) &&\n         sameValue(desc1.value, desc2.value) &&\n         sameValue(desc1.writable, desc2.writable) &&\n         sameValue(desc1.enumerable, desc2.enumerable) &&\n         sameValue(desc1.configurable, desc2.configurable);\n}\n\n// copied from http://wiki.ecmascript.org/doku.php?id=harmony:egal\nfunction sameValue(x, y) {\n  if (x === y) {\n    // 0 === -0, but they are not identical\n    return x !== 0 || 1 / x === 1 / y;\n  }\n\n  // NaN !== NaN, but they are identical.\n  // NaNs are the only non-reflexive value, i.e., if x !== x,\n  // then x is a NaN.\n  // isNaN is broken: it converts its argument to number, so\n  // isNaN(\"foo\") => true\n  return x !== x && y !== y;\n}\n\n/**\n * Returns a fresh property descriptor that is guaranteed\n * to be complete (i.e. contain all the standard attributes).\n * Additionally, any non-standard enumerable properties of\n * attributes are copied over to the fresh descriptor.\n *\n * If attributes is undefined, returns undefined.\n *\n * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n */\nfunction normalizeAndCompletePropertyDescriptor(attributes) {\n  if (attributes === undefined) { return undefined; }\n  var desc = toCompletePropertyDescriptor(attributes);\n  // Note: no need to call FromPropertyDescriptor(desc), as we represent\n  // \"internal\" property descriptors as proper Objects from the start\n  for (var name in attributes) {\n    if (!isStandardAttribute(name)) {\n      Object.defineProperty(desc, name,\n        { value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true });\n    }\n  }\n  return desc;\n}\n\n/**\n * Returns a fresh property descriptor whose standard\n * attributes are guaranteed to be data properties of the right type.\n * Additionally, any non-standard enumerable properties of\n * attributes are copied over to the fresh descriptor.\n *\n * If attributes is undefined, will throw a TypeError.\n *\n * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n */\nfunction normalizePropertyDescriptor(attributes) {\n  var desc = toPropertyDescriptor(attributes);\n  // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n  // \"internal\" property descriptors as proper Objects from the start\n  for (var name in attributes) {\n    if (!isStandardAttribute(name)) {\n      Object.defineProperty(desc, name,\n        { value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true });\n    }\n  }\n  return desc;\n}\n\n// store a reference to the real ES5 primitives before patching them later\nvar prim_preventExtensions =        Object.preventExtensions,\n    prim_seal =                     Object.seal,\n    prim_freeze =                   Object.freeze,\n    prim_isExtensible =             Object.isExtensible,\n    prim_isSealed =                 Object.isSealed,\n    prim_isFrozen =                 Object.isFrozen,\n    prim_getPrototypeOf =           Object.getPrototypeOf,\n    prim_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n    prim_defineProperty =           Object.defineProperty,\n    prim_defineProperties =         Object.defineProperties,\n    prim_keys =                     Object.keys,\n    prim_getOwnPropertyNames =      Object.getOwnPropertyNames,\n    prim_getOwnPropertySymbols =    Object.getOwnPropertySymbols,\n    prim_assign =                   Object.assign,\n    prim_isArray =                  Array.isArray,\n    prim_concat =                   Array.prototype.concat,\n    prim_isPrototypeOf =            Object.prototype.isPrototypeOf,\n    prim_hasOwnProperty =           Object.prototype.hasOwnProperty;\n\n// these will point to the patched versions of the respective methods on\n// Object. They are used within this module as the \"intrinsic\" bindings\n// of these methods (i.e. the \"original\" bindings as defined in the spec)\nvar Object_isFrozen,\n    Object_isSealed,\n    Object_isExtensible,\n    Object_getPrototypeOf,\n    Object_getOwnPropertyNames;\n\n/**\n * A property 'name' is fixed if it is an own property of the target.\n */\nfunction isFixed(name, target) {\n  return ({}).hasOwnProperty.call(target, name);\n}\nfunction isSealed(name, target) {\n  var desc = Object.getOwnPropertyDescriptor(target, name);\n  if (desc === undefined) { return false; }\n  return desc.configurable === false;\n}\nfunction isSealedDesc(desc) {\n  return desc !== undefined && desc.configurable === false;\n}\n\n/**\n * Performs all validation that Object.defineProperty performs,\n * without actually defining the property. Returns a boolean\n * indicating whether validation succeeded.\n *\n * Implementation transliterated from ES5.1 section 8.12.9\n */\nfunction isCompatibleDescriptor(extensible, current, desc) {\n  if (current === undefined && extensible === false) {\n    return false;\n  }\n  if (current === undefined && extensible === true) {\n    return true;\n  }\n  if (isEmptyDescriptor(desc)) {\n    return true;\n  }\n  if (isEquivalentDescriptor(current, desc)) {\n    return true;\n  }\n  if (current.configurable === false) {\n    if (desc.configurable === true) {\n      return false;\n    }\n    if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n      return false;\n    }\n  }\n  if (isGenericDescriptor(desc)) {\n    return true;\n  }\n  if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n    if (current.configurable === false) {\n      return false;\n    }\n    return true;\n  }\n  if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n    if (current.configurable === false) {\n      if (current.writable === false && desc.writable === true) {\n        return false;\n      }\n      if (current.writable === false) {\n        if ('value' in desc && !sameValue(desc.value, current.value)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n    if (current.configurable === false) {\n      if ('set' in desc && !sameValue(desc.set, current.set)) {\n        return false;\n      }\n      if ('get' in desc && !sameValue(desc.get, current.get)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// ES6 7.3.11 SetIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\nfunction setIntegrityLevel(target, level) {\n  var ownProps = Object_getOwnPropertyNames(target);\n  var pendingException = undefined;\n  if (level === \"sealed\") {\n    var l = +ownProps.length;\n    var k;\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n      try {\n        Object.defineProperty(target, k, { configurable: false });\n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n        }\n      }\n    }\n  } else {\n    // level === \"frozen\"\n    var l = +ownProps.length;\n    var k;\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n      try {\n        var currentDesc = Object.getOwnPropertyDescriptor(target, k);\n        if (currentDesc !== undefined) {\n          var desc;\n          if (isAccessorDescriptor(currentDesc)) {\n            desc = { configurable: false }\n          } else {\n            desc = { configurable: false, writable: false }\n          }\n          Object.defineProperty(target, k, desc);\n        }        \n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n        }\n      }\n    }\n  }\n  if (pendingException !== undefined) {\n    throw pendingException;\n  }\n  return Reflect.preventExtensions(target);\n}\n\n// ES6 7.3.12 TestIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\nfunction testIntegrityLevel(target, level) {\n  var isExtensible = Object_isExtensible(target);\n  if (isExtensible) return false;\n  \n  var ownProps = Object_getOwnPropertyNames(target);\n  var pendingException = undefined;\n  var configurable = false;\n  var writable = false;\n  \n  var l = +ownProps.length;\n  var k;\n  var currentDesc;\n  for (var i = 0; i < l; i++) {\n    k = String(ownProps[i]);\n    try {\n      currentDesc = Object.getOwnPropertyDescriptor(target, k);\n      configurable = configurable || currentDesc.configurable;\n      if (isDataDescriptor(currentDesc)) {\n        writable = writable || currentDesc.writable;\n      }\n    } catch (e) {\n      if (pendingException === undefined) {\n        pendingException = e;\n        configurable = true;\n      }\n    }\n  }\n  if (pendingException !== undefined) {\n    throw pendingException;\n  }\n  if (level === \"frozen\" && writable === true) {\n    return false;\n  }\n  if (configurable === true) {\n    return false;\n  }\n  return true;\n}\n\n// ---- The Validator handler wrapper around user handlers ----\n\n/**\n * @param target the object wrapped by this proxy.\n * As long as the proxy is extensible, only non-configurable properties\n * are checked against the target. Once the proxy becomes non-extensible,\n * invariants w.r.t. non-extensibility are also enforced.\n *\n * @param handler the handler of the direct proxy. The object emulated by\n * this handler is validated against the target object of the direct proxy.\n * Any violations that the handler makes against the invariants\n * of the target will cause a TypeError to be thrown.\n *\n * Both target and handler must be proper Objects at initialization time.\n */\nfunction Validator(target, handler) {\n  // for non-revokable proxies, these are const references\n  // for revokable proxies, on revocation:\n  // - this.target is set to null\n  // - this.handler is set to a handler that throws on all traps\n  this.target  = target;\n  this.handler = handler;\n}\n\nValidator.prototype = {\n\n  /**\n   * If getTrap returns undefined, the caller should perform the\n   * default forwarding behavior.\n   * If getTrap returns normally otherwise, the return value\n   * will be a callable trap function. When calling the trap function,\n   * the caller is responsible for binding its |this| to |this.handler|.\n   */\n  getTrap: function(trapName) {\n    var trap = this.handler[trapName];\n    if (trap === undefined) {\n      // the trap was not defined,\n      // perform the default forwarding behavior\n      return undefined;\n    }\n\n    if (typeof trap !== \"function\") {\n      throw new TypeError(trapName + \" trap is not callable: \"+trap);\n    }\n\n    return trap;\n  },\n\n  // === fundamental traps ===\n\n  /**\n   * If name denotes a fixed property, check:\n   *   - whether targetHandler reports it as existent\n   *   - whether the returned descriptor is compatible with the fixed property\n   * If the proxy is non-extensible, check:\n   *   - whether name is not a new property\n   * Additionally, the returned descriptor is normalized and completed.\n   */\n  getOwnPropertyDescriptor: function(name) {\n    \"use strict\";\n\n    var trap = this.getTrap(\"getOwnPropertyDescriptor\");\n    if (trap === undefined) {\n      return Reflect.getOwnPropertyDescriptor(this.target, name);\n    }\n\n    name = String(name);\n    var desc = trap.call(this.handler, this.target, name);\n    desc = normalizeAndCompletePropertyDescriptor(desc);\n\n    var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n    var extensible = Object.isExtensible(this.target);\n\n    if (desc === undefined) {\n      if (isSealedDesc(targetDesc)) {\n        throw new TypeError(\"cannot report non-configurable property '\"+name+\n                            \"' as non-existent\");\n      }\n      if (!extensible && targetDesc !== undefined) {\n          // if handler is allowed to return undefined, we cannot guarantee\n          // that it will not return a descriptor for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\"+name+\n                              \"' as non-existent on a non-extensible object\");\n      }\n      return undefined;\n    }\n\n    // at this point, we know (desc !== undefined), i.e.\n    // targetHandler reports 'name' as an existing property\n\n    // Note: we could collapse the following two if-tests into a single\n    // test. Separating out the cases to improve error reporting.\n\n    if (!extensible) {\n      if (targetDesc === undefined) {\n        throw new TypeError(\"cannot report a new own property '\"+\n                            name + \"' on a non-extensible object\");\n      }\n    }\n\n    if (name !== undefined) {\n      if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n        throw new TypeError(\"cannot report incompatible property descriptor \"+\n                            \"for property '\"+name+\"'\");\n      }\n    }\n    \n    if (desc.configurable === false) {\n      if (targetDesc === undefined || targetDesc.configurable === true) {\n        // if the property is configurable or non-existent on the target,\n        // but is reported as a non-configurable property, it may later be\n        // reported as configurable or non-existent, which violates the\n        // invariant that if the property might change or disappear, the\n        // configurable attribute must be true.\n        throw new TypeError(\n          \"cannot report a non-configurable descriptor \" +\n          \"for configurable or non-existent property '\" + name + \"'\");\n      }\n      if ('writable' in desc && desc.writable === false) {\n        if (targetDesc.writable === true) {\n          // if the property is non-configurable, writable on the target,\n          // but is reported as non-configurable, non-writable, it may later\n          // be reported as non-configurable, writable again, which violates\n          // the invariant that a non-configurable, non-writable property\n          // may not change state.\n          throw new TypeError(\n            \"cannot report non-configurable, writable property '\" + name +\n            \"' as non-configurable, non-writable\");\n        }\n      }\n    }\n\n    return desc;\n  },\n\n  /**\n   * In the direct proxies design with refactored prototype climbing,\n   * this trap is deprecated. For proxies-as-prototypes, instead\n   * of calling this trap, the get, set, has or enumerate traps are\n   * called instead.\n   *\n   * In this implementation, we \"abuse\" getPropertyDescriptor to\n   * support trapping the get or set traps for proxies-as-prototypes.\n   * We do this by returning a getter/setter pair that invokes\n   * the corresponding traps.\n   *\n   * While this hack works for inherited property access, it has some\n   * quirks:\n   *\n   * In Firefox, this trap is only called after a prior invocation\n   * of the 'has' trap has returned true. Hence, expect the following\n   * behavior:\n   * <code>\n   * var child = Object.create(Proxy(target, handler));\n   * child[name] // triggers handler.has(target, name)\n   * // if that returns true, triggers handler.get(target, name, child)\n   * </code>\n   *\n   * On v8, the 'in' operator, when applied to an object that inherits\n   * from a proxy, will call getPropertyDescriptor and walk the proto-chain.\n   * That calls the below getPropertyDescriptor trap on the proxy. The\n   * result of the 'in'-operator is then determined by whether this trap\n   * returns undefined or a property descriptor object. That is why\n   * we first explicitly trigger the 'has' trap to determine whether\n   * the property exists.\n   *\n   * This has the side-effect that when enumerating properties on\n   * an object that inherits from a proxy in v8, only properties\n   * for which 'has' returns true are returned:\n   *\n   * <code>\n   * var child = Object.create(Proxy(target, handler));\n   * for (var prop in child) {\n   *   // only enumerates prop if (prop in child) returns true\n   * }\n   * </code>\n   */\n  getPropertyDescriptor: function(name) {\n    var handler = this;\n\n    if (!handler.has(name)) return undefined;\n\n    return {\n      get: function() {\n        return handler.get(this, name);\n      },\n      set: function(val) {\n        if (handler.set(this, name, val)) {\n          return val;\n        } else {\n          throw new TypeError(\"failed assignment to \"+name);\n        }\n      },\n      enumerable: true,\n      configurable: true\n    };\n  },\n\n  /**\n   * If name denotes a fixed property, check for incompatible changes.\n   * If the proxy is non-extensible, check that new properties are rejected.\n   */\n  defineProperty: function(name, desc) {\n    // TODO(tvcutsem): the current tracemonkey implementation of proxies\n    // auto-completes 'desc', which is not correct. 'desc' should be\n    // normalized, but not completed. Consider:\n    // Object.defineProperty(proxy, 'foo', {enumerable:false})\n    // This trap will receive desc =\n    //  {value:undefined,writable:false,enumerable:false,configurable:false}\n    // This will also set all other attributes to their default value,\n    // which is unexpected and different from [[DefineOwnProperty]].\n    // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n\n    var trap = this.getTrap(\"defineProperty\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.defineProperty(this.target, name, desc);\n    }\n\n    name = String(name);\n    var descObj = normalizePropertyDescriptor(desc);\n    var success = trap.call(this.handler, this.target, name, descObj);\n    success = !!success; // coerce to Boolean\n\n    if (success === true) {\n\n      var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      var extensible = Object.isExtensible(this.target);\n\n      // Note: we could collapse the following two if-tests into a single\n      // test. Separating out the cases to improve error reporting.\n\n      if (!extensible) {\n        if (targetDesc === undefined) {\n          throw new TypeError(\"cannot successfully add a new property '\"+\n                              name + \"' to a non-extensible object\");\n        }\n      }\n\n      if (targetDesc !== undefined) {\n        if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n          throw new TypeError(\"cannot define incompatible property \"+\n                              \"descriptor for property '\"+name+\"'\");\n        }\n        if (isDataDescriptor(targetDesc) &&\n            targetDesc.configurable === false &&\n            targetDesc.writable === true) {\n            if (desc.configurable === false && desc.writable === false) {\n              // if the property is non-configurable, writable on the target\n              // but was successfully reported to be updated to\n              // non-configurable, non-writable, it can later be reported\n              // again as non-configurable, writable, which violates\n              // the invariant that non-configurable, non-writable properties\n              // cannot change state\n              throw new TypeError(\n                \"cannot successfully define non-configurable, writable \" +\n                \" property '\" + name + \"' as non-configurable, non-writable\");\n            }\n          }\n      }\n\n      if (desc.configurable === false && !isSealedDesc(targetDesc)) {\n        // if the property is configurable or non-existent on the target,\n        // but is successfully being redefined as a non-configurable property,\n        // it may later be reported as configurable or non-existent, which violates\n        // the invariant that if the property might change or disappear, the\n        // configurable attribute must be true.\n        throw new TypeError(\n          \"cannot successfully define a non-configurable \" +\n          \"descriptor for configurable or non-existent property '\" +\n          name + \"'\");\n      }\n\n    }\n\n    return success;\n  },\n\n  /**\n   * On success, check whether the target object is indeed non-extensible.\n   */\n  preventExtensions: function() {\n    var trap = this.getTrap(\"preventExtensions\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.preventExtensions(this.target);\n    }\n\n    var success = trap.call(this.handler, this.target);\n    success = !!success; // coerce to Boolean\n    if (success) {\n      if (Object_isExtensible(this.target)) {\n        throw new TypeError(\"can't report extensible object as non-extensible: \"+\n                            this.target);\n      }\n    }\n    return success;\n  },\n\n  /**\n   * If name denotes a sealed property, check whether handler rejects.\n   */\n  delete: function(name) {\n    \"use strict\";\n    var trap = this.getTrap(\"deleteProperty\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.deleteProperty(this.target, name);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name);\n    res = !!res; // coerce to Boolean\n\n    var targetDesc;\n    if (res === true) {\n      targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      if (targetDesc !== undefined && targetDesc.configurable === false) {\n        throw new TypeError(\"property '\" + name + \"' is non-configurable \"+\n                            \"and can't be deleted\");\n      }\n      if (targetDesc !== undefined && !Object_isExtensible(this.target)) {\n        // if the property still exists on a non-extensible target but\n        // is reported as successfully deleted, it may later be reported\n        // as present, which violates the invariant that an own property,\n        // deleted from a non-extensible object cannot reappear.\n        throw new TypeError(\n          \"cannot successfully delete existing property '\" + name +\n          \"' on a non-extensible object\");\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * The getOwnPropertyNames trap was replaced by the ownKeys trap,\n   * which now also returns an array (of strings or symbols) and\n   * which performs the same rigorous invariant checks as getOwnPropertyNames\n   *\n   * See issue #48 on how this trap can still get invoked by external libs\n   * that don't use the patched Object.getOwnPropertyNames function.\n   */\n  getOwnPropertyNames: function() {\n    // Note: removed deprecation warning to avoid dependency on 'console'\n    // (and on node, should anyway use util.deprecate). Deprecation warnings\n    // can also be annoying when they are outside of the user's control, e.g.\n    // when an external library calls unpatched Object.getOwnPropertyNames.\n    // Since there is a clean fallback to `ownKeys`, the fact that the\n    // deprecated method is still called is mostly harmless anyway.\n    // See also issues #65 and #66.\n    // console.warn(\"getOwnPropertyNames trap is deprecated. Use ownKeys instead\");\n    return this.ownKeys();\n  },\n\n  /**\n   * Checks whether the trap result does not contain any new properties\n   * if the proxy is non-extensible.\n   *\n   * Any own non-configurable properties of the target that are not included\n   * in the trap result give rise to a TypeError. As such, we check whether the\n   * returned result contains at least all sealed properties of the target\n   * object.\n   *\n   * Additionally, the trap result is normalized.\n   * Instead of returning the trap result directly:\n   *  - create and return a fresh Array,\n   *  - of which each element is coerced to a String\n   *\n   * This trap is called a.o. by Reflect.ownKeys, Object.getOwnPropertyNames\n   * and Object.keys (the latter filters out only the enumerable own properties).\n   */\n  ownKeys: function() {\n    var trap = this.getTrap(\"ownKeys\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.ownKeys(this.target);\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n\n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    var numProps = +trapResult.length;\n    var result = new Array(numProps);\n\n    for (var i = 0; i < numProps; i++) {\n      var s = String(trapResult[i]);\n      if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n        // non-extensible proxies don't tolerate new own property names\n        throw new TypeError(\"ownKeys trap cannot list a new \"+\n                            \"property '\"+s+\"' on a non-extensible object\");\n      }\n\n      propNames[s] = true;\n      result[i] = s;\n    }\n\n    var ownProps = Object_getOwnPropertyNames(this.target);\n    var target = this.target;\n    ownProps.forEach(function (ownProp) {\n      if (!propNames[ownProp]) {\n        if (isSealed(ownProp, target)) {\n          throw new TypeError(\"ownKeys trap failed to include \"+\n                              \"non-configurable property '\"+ownProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownProp, target)) {\n            // if handler is allowed to report ownProp as non-existent,\n            // we cannot guarantee that it will never later report it as\n            // existent. Once a property has been reported as non-existent\n            // on a non-extensible object, it should forever be reported as\n            // non-existent\n            throw new TypeError(\"ownKeys trap cannot report existing own property '\"+\n                                ownProp+\"' as non-existent on a non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * Checks whether the trap result is consistent with the state of the\n   * wrapped target.\n   */\n  isExtensible: function() {\n    var trap = this.getTrap(\"isExtensible\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.isExtensible(this.target);\n    }\n\n    var result = trap.call(this.handler, this.target);\n    result = !!result; // coerce to Boolean\n    var state = Object_isExtensible(this.target);\n    if (result !== state) {\n      if (result) {\n        throw new TypeError(\"cannot report non-extensible object as extensible: \"+\n                             this.target);\n      } else {\n        throw new TypeError(\"cannot report extensible object as non-extensible: \"+\n                             this.target);\n      }\n    }\n    return state;\n  },\n\n  /**\n   * Check whether the trap result corresponds to the target's [[Prototype]]\n   */\n  getPrototypeOf: function() {\n    var trap = this.getTrap(\"getPrototypeOf\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.getPrototypeOf(this.target);\n    }\n\n    var allegedProto = trap.call(this.handler, this.target);\n\n    if (!Object_isExtensible(this.target)) {\n      var actualProto = Object_getPrototypeOf(this.target);\n      if (!sameValue(allegedProto, actualProto)) {\n        throw new TypeError(\"prototype value does not match: \" + this.target);\n      }\n    }\n\n    return allegedProto;\n  },\n\n  /**\n   * If target is non-extensible and setPrototypeOf trap returns true,\n   * check whether the trap result corresponds to the target's [[Prototype]]\n   */\n  setPrototypeOf: function(newProto) {\n    var trap = this.getTrap(\"setPrototypeOf\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.setPrototypeOf(this.target, newProto);\n    }\n\n    var success = trap.call(this.handler, this.target, newProto);\n\n    success = !!success;\n    if (success && !Object_isExtensible(this.target)) {\n      var actualProto = Object_getPrototypeOf(this.target);\n      if (!sameValue(newProto, actualProto)) {\n        throw new TypeError(\"prototype value does not match: \" + this.target);\n      }\n    }\n\n    return success;\n  },\n\n  /**\n   * In the direct proxies design with refactored prototype climbing,\n   * this trap is deprecated. For proxies-as-prototypes, for-in will\n   * call the enumerate() trap. If that trap is not defined, the\n   * operation is forwarded to the target, no more fallback on this\n   * fundamental trap.\n   */\n  getPropertyNames: function() {\n    throw new TypeError(\"getPropertyNames trap is deprecated\");\n  },\n\n  // === derived traps ===\n\n  /**\n   * If name denotes a fixed property, check whether the trap returns true.\n   */\n  has: function(name) {\n    var trap = this.getTrap(\"has\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.has(this.target, name);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name);\n    res = !!res; // coerce to Boolean\n\n    if (res === false) {\n      if (isSealed(name, this.target)) {\n        throw new TypeError(\"cannot report existing non-configurable own \"+\n                            \"property '\"+ name + \"' as a non-existent \"+\n                            \"property\");\n      }\n      if (!Object.isExtensible(this.target) &&\n          isFixed(name, this.target)) {\n          // if handler is allowed to return false, we cannot guarantee\n          // that it will not return true for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\"+name+\n                              \"' as non-existent on a non-extensible object\");\n      }\n    }\n\n    // if res === true, we don't need to check for extensibility\n    // even for a non-extensible proxy that has no own name property,\n    // the property may have been inherited\n\n    return res;\n  },\n\n  /**\n   * If name denotes a fixed non-configurable, non-writable data property,\n   * check its return value against the previously asserted value of the\n   * fixed property.\n   */\n  get: function(receiver, name) {\n\n    // experimental support for invoke() trap on platforms that\n    // support __noSuchMethod__\n    /*\n    if (name === '__noSuchMethod__') {\n      var handler = this;\n      return function(name, args) {\n        return handler.invoke(receiver, name, args);\n      }\n    }\n    */\n\n    var trap = this.getTrap(\"get\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.get(this.target, name, receiver);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name, receiver);\n\n    var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n    // check consistency of the returned value\n    if (fixedDesc !== undefined) { // getting an existing property\n      if (isDataDescriptor(fixedDesc) &&\n          fixedDesc.configurable === false &&\n          fixedDesc.writable === false) { // own frozen data property\n        if (!sameValue(res, fixedDesc.value)) {\n          throw new TypeError(\"cannot report inconsistent value for \"+\n                              \"non-writable, non-configurable property '\"+\n                              name+\"'\");\n        }\n      } else { // it's an accessor property\n        if (isAccessorDescriptor(fixedDesc) &&\n            fixedDesc.configurable === false &&\n            fixedDesc.get === undefined) {\n          if (res !== undefined) {\n            throw new TypeError(\"must report undefined for non-configurable \"+\n                                \"accessor property '\"+name+\"' without getter\");\n          }\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * If name denotes a fixed non-configurable, non-writable data property,\n   * check that the trap rejects the assignment.\n   */\n  set: function(receiver, name, val) {\n    var trap = this.getTrap(\"set\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.set(this.target, name, val, receiver);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name, val, receiver);\n    res = !!res; // coerce to Boolean\n\n    // if success is reported, check whether property is truly assignable\n    if (res === true) {\n      var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      if (fixedDesc !== undefined) { // setting an existing property\n        if (isDataDescriptor(fixedDesc) &&\n            fixedDesc.configurable === false &&\n            fixedDesc.writable === false) {\n          if (!sameValue(val, fixedDesc.value)) {\n            throw new TypeError(\"cannot successfully assign to a \"+\n                                \"non-writable, non-configurable property '\"+\n                                name+\"'\");\n          }\n        } else {\n          if (isAccessorDescriptor(fixedDesc) &&\n              fixedDesc.configurable === false && // non-configurable\n              fixedDesc.set === undefined) {      // accessor with undefined setter\n            throw new TypeError(\"setting a property '\"+name+\"' that has \"+\n                                \" only a getter\");\n          }\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * Any own enumerable non-configurable properties of the target that are not\n   * included in the trap result give rise to a TypeError. As such, we check\n   * whether the returned result contains at least all sealed enumerable properties\n   * of the target object.\n   *\n   * The trap should return an iterator.\n   *\n   * However, as implementations of pre-direct proxies still expect enumerate\n   * to return an array of strings, we convert the iterator into an array.\n   */\n  enumerate: function() {\n    var trap = this.getTrap(\"enumerate\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      var trapResult = Reflect.enumerate(this.target);\n      var result = [];\n      var nxt = trapResult.next();\n      while (!nxt.done) {\n        result.push(String(nxt.value));\n        nxt = trapResult.next();\n      }\n      return result;\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n    \n    if (trapResult === null ||\n        trapResult === undefined ||\n        trapResult.next === undefined) {\n      throw new TypeError(\"enumerate trap should return an iterator, got: \"+\n                          trapResult);    \n    }\n    \n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    \n    // var numProps = +trapResult.length;\n    var result = []; // new Array(numProps);\n    \n    // trapResult is supposed to be an iterator\n    // drain iterator to array as current implementations still expect\n    // enumerate to return an array of strings\n    var nxt = trapResult.next();\n    \n    while (!nxt.done) {\n      var s = String(nxt.value);\n      if (propNames[s]) {\n        throw new TypeError(\"enumerate trap cannot list a \"+\n                            \"duplicate property '\"+s+\"'\");\n      }\n      propNames[s] = true;\n      result.push(s);\n      nxt = trapResult.next();\n    }\n    \n    /*for (var i = 0; i < numProps; i++) {\n      var s = String(trapResult[i]);\n      if (propNames[s]) {\n        throw new TypeError(\"enumerate trap cannot list a \"+\n                            \"duplicate property '\"+s+\"'\");\n      }\n\n      propNames[s] = true;\n      result[i] = s;\n    } */\n\n    var ownEnumerableProps = Object.keys(this.target);\n    var target = this.target;\n    ownEnumerableProps.forEach(function (ownEnumerableProp) {\n      if (!propNames[ownEnumerableProp]) {\n        if (isSealed(ownEnumerableProp, target)) {\n          throw new TypeError(\"enumerate trap failed to include \"+\n                              \"non-configurable enumerable property '\"+\n                              ownEnumerableProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\"+\n                                ownEnumerableProp+\"' as non-existent on a \"+\n                                \"non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * The iterate trap is deprecated by the enumerate trap.\n   */\n  iterate: Validator.prototype.enumerate,\n\n  /**\n   * Any own non-configurable properties of the target that are not included\n   * in the trap result give rise to a TypeError. As such, we check whether the\n   * returned result contains at least all sealed properties of the target\n   * object.\n   *\n   * The trap result is normalized.\n   * The trap result is not returned directly. Instead:\n   *  - create and return a fresh Array,\n   *  - of which each element is coerced to String,\n   *  - which does not contain duplicates\n   *\n   * FIXME: keys trap is deprecated\n   */\n  /*\n  keys: function() {\n    var trap = this.getTrap(\"keys\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.keys(this.target);\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n\n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    var numProps = +trapResult.length;\n    var result = new Array(numProps);\n\n    for (var i = 0; i < numProps; i++) {\n     var s = String(trapResult[i]);\n     if (propNames[s]) {\n       throw new TypeError(\"keys trap cannot list a \"+\n                           \"duplicate property '\"+s+\"'\");\n     }\n     if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n       // non-extensible proxies don't tolerate new own property names\n       throw new TypeError(\"keys trap cannot list a new \"+\n                           \"property '\"+s+\"' on a non-extensible object\");\n     }\n\n     propNames[s] = true;\n     result[i] = s;\n    }\n\n    var ownEnumerableProps = Object.keys(this.target);\n    var target = this.target;\n    ownEnumerableProps.forEach(function (ownEnumerableProp) {\n      if (!propNames[ownEnumerableProp]) {\n        if (isSealed(ownEnumerableProp, target)) {\n          throw new TypeError(\"keys trap failed to include \"+\n                              \"non-configurable enumerable property '\"+\n                              ownEnumerableProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\"+\n                                ownEnumerableProp+\"' as non-existent on a \"+\n                                \"non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n  */\n  \n  /**\n   * New trap that reifies [[Call]].\n   * If the target is a function, then a call to\n   *   proxy(...args)\n   * Triggers this trap\n   */\n  apply: function(target, thisBinding, args) {\n    var trap = this.getTrap(\"apply\");\n    if (trap === undefined) {\n      return Reflect.apply(target, thisBinding, args);\n    }\n\n    if (typeof this.target === \"function\") {\n      return trap.call(this.handler, target, thisBinding, args);\n    } else {\n      throw new TypeError(\"apply: \"+ target + \" is not a function\");\n    }\n  },\n\n  /**\n   * New trap that reifies [[Construct]].\n   * If the target is a function, then a call to\n   *   new proxy(...args)\n   * Triggers this trap\n   */\n  construct: function(target, args, newTarget) {\n    var trap = this.getTrap(\"construct\");\n    if (trap === undefined) {\n      return Reflect.construct(target, args, newTarget);\n    }\n\n    if (typeof target !== \"function\") {\n      throw new TypeError(\"new: \"+ target + \" is not a function\");\n    }\n\n    if (newTarget === undefined) {\n      newTarget = target;\n    } else {\n      if (typeof newTarget !== \"function\") {\n        throw new TypeError(\"new: \"+ newTarget + \" is not a function\");\n      }      \n    }\n    return trap.call(this.handler, target, args, newTarget);\n  }\n};\n\n// ---- end of the Validator handler wrapper handler ----\n\n// In what follows, a 'direct proxy' is a proxy\n// whose handler is a Validator. Such proxies can be made non-extensible,\n// sealed or frozen without losing the ability to trap.\n\n// maps direct proxies to their Validator handlers\nvar directProxies = new WeakMap();\n\n// patch Object.{preventExtensions,seal,freeze} so that\n// they recognize fixable proxies and act accordingly\nObject.preventExtensions = function(subject) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    if (vhandler.preventExtensions()) {\n      return subject;\n    } else {\n      throw new TypeError(\"preventExtensions on \"+subject+\" rejected\");\n    }\n  } else {\n    return prim_preventExtensions(subject);\n  }\n};\nObject.seal = function(subject) {\n  setIntegrityLevel(subject, \"sealed\");\n  return subject;\n};\nObject.freeze = function(subject) {\n  setIntegrityLevel(subject, \"frozen\");\n  return subject;\n};\nObject.isExtensible = Object_isExtensible = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.isExtensible();\n  } else {\n    return prim_isExtensible(subject);\n  }\n};\nObject.isSealed = Object_isSealed = function(subject) {\n  return testIntegrityLevel(subject, \"sealed\");\n};\nObject.isFrozen = Object_isFrozen = function(subject) {\n  return testIntegrityLevel(subject, \"frozen\");\n};\nObject.getPrototypeOf = Object_getPrototypeOf = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.getPrototypeOf();\n  } else {\n    return prim_getPrototypeOf(subject);\n  }\n};\n\n// patch Object.getOwnPropertyDescriptor to directly call\n// the Validator.prototype.getOwnPropertyDescriptor trap\n// This is to circumvent an assertion in the built-in Proxy\n// trapping mechanism of v8, which disallows that trap to\n// return non-configurable property descriptors (as per the\n// old Proxy design)\nObject.getOwnPropertyDescriptor = function(subject, name) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    return vhandler.getOwnPropertyDescriptor(name);\n  } else {\n    return prim_getOwnPropertyDescriptor(subject, name);\n  }\n};\n\n// patch Object.defineProperty to directly call\n// the Validator.prototype.defineProperty trap\n// This is to circumvent two issues with the built-in\n// trap mechanism:\n// 1) the current tracemonkey implementation of proxies\n// auto-completes 'desc', which is not correct. 'desc' should be\n// normalized, but not completed. Consider:\n// Object.defineProperty(proxy, 'foo', {enumerable:false})\n// This trap will receive desc =\n//  {value:undefined,writable:false,enumerable:false,configurable:false}\n// This will also set all other attributes to their default value,\n// which is unexpected and different from [[DefineOwnProperty]].\n// Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n// 2) the current spidermonkey implementation does not\n// throw an exception when this trap returns 'false', but instead silently\n// ignores the operation (this is regardless of strict-mode)\n// 2a) v8 does throw an exception for this case, but includes the rather\n//     unhelpful error message:\n// 'Proxy handler #<Object> returned false from 'defineProperty' trap'\nObject.defineProperty = function(subject, name, desc) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    var normalizedDesc = normalizePropertyDescriptor(desc);\n    var success = vhandler.defineProperty(name, normalizedDesc);\n    if (success === false) {\n      throw new TypeError(\"can't redefine property '\"+name+\"'\");\n    }\n    return subject;\n  } else {\n    return prim_defineProperty(subject, name, desc);\n  }\n};\n\nObject.defineProperties = function(subject, descs) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    var names = Object.keys(descs);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      var normalizedDesc = normalizePropertyDescriptor(descs[name]);\n      var success = vhandler.defineProperty(name, normalizedDesc);\n      if (success === false) {\n        throw new TypeError(\"can't redefine property '\"+name+\"'\");\n      }\n    }\n    return subject;\n  } else {\n    return prim_defineProperties(subject, descs);\n  }\n};\n\nObject.keys = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    var ownKeys = vHandler.ownKeys();\n    var result = [];\n    for (var i = 0; i < ownKeys.length; i++) {\n      var k = String(ownKeys[i]);\n      var desc = Object.getOwnPropertyDescriptor(subject, k);\n      if (desc !== undefined && desc.enumerable === true) {\n        result.push(k);\n      }\n    }\n    return result;\n  } else {\n    return prim_keys(subject);\n  }\n}\n\nObject.getOwnPropertyNames = Object_getOwnPropertyNames = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.ownKeys();\n  } else {\n    return prim_getOwnPropertyNames(subject);\n  }\n}\n\n// fixes issue #71 (Calling Object.getOwnPropertySymbols() on a Proxy\n// throws an error)\nif (prim_getOwnPropertySymbols !== undefined) {\n  Object.getOwnPropertySymbols = function(subject) {\n    var vHandler = directProxies.get(subject);\n    if (vHandler !== undefined) {\n      // as this shim does not support symbols, a Proxy never advertises\n      // any symbol-valued own properties\n      return [];\n    } else {\n      return prim_getOwnPropertySymbols(subject);\n    }\n  };\n}\n\n// fixes issue #72 ('Illegal access' error when using Object.assign)\n// Object.assign polyfill based on a polyfill posted on MDN: \n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\\\n//  Global_Objects/Object/assign\n// Note that this polyfill does not support Symbols, but this Proxy Shim\n// does not support Symbols anyway.\nif (prim_assign !== undefined) {\n  Object.assign = function (target) {\n    \n    // check if any argument is a proxy object\n    var noProxies = true;\n    for (var i = 0; i < arguments.length; i++) {\n      var vHandler = directProxies.get(arguments[i]);\n      if (vHandler !== undefined) {\n        noProxies = false;\n        break;\n      }\n    }\n    if (noProxies) {\n      // not a single argument is a proxy, perform built-in algorithm\n      return prim_assign.apply(Object, arguments);\n    }\n    \n    // there is at least one proxy argument, use the polyfill\n    \n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n}\n\n// returns whether an argument is a reference to an object,\n// which is legal as a WeakMap key.\nfunction isObject(arg) {\n  var type = typeof arg;\n  return (type === 'object' && arg !== null) || (type === 'function');\n};\n\n// a wrapper for WeakMap.get which returns the undefined value\n// for keys that are not objects (in which case the underlying\n// WeakMap would have thrown a TypeError).\nfunction safeWeakMapGet(map, key) {\n  return isObject(key) ? map.get(key) : undefined;\n};\n\n// returns a new function of zero arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a zero-argument method\n// that uses its |this|-binding.\nfunction makeUnwrapping0ArgMethod(primitive) {\n  return function builtin() {\n    var vHandler = safeWeakMapGet(directProxies, this);\n    if (vHandler !== undefined) {\n      return builtin.call(vHandler.target);\n    } else {\n      return primitive.call(this);\n    }\n  }\n};\n\n// returns a new function of 1 arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a 1-argument method\n// that uses its |this|-binding.\nfunction makeUnwrapping1ArgMethod(primitive) {\n  return function builtin(arg) {\n    var vHandler = safeWeakMapGet(directProxies, this);\n    if (vHandler !== undefined) {\n      return builtin.call(vHandler.target, arg);\n    } else {\n      return primitive.call(this, arg);\n    }\n  }\n};\n\nObject.prototype.valueOf =\n  makeUnwrapping0ArgMethod(Object.prototype.valueOf);\nObject.prototype.toString =\n  makeUnwrapping0ArgMethod(Object.prototype.toString);\nFunction.prototype.toString =\n  makeUnwrapping0ArgMethod(Function.prototype.toString);\nDate.prototype.toString =\n  makeUnwrapping0ArgMethod(Date.prototype.toString);\n\nObject.prototype.isPrototypeOf = function builtin(arg) {\n  // bugfix thanks to Bill Mark:\n  // built-in isPrototypeOf does not unwrap proxies used\n  // as arguments. So, we implement the builtin ourselves,\n  // based on the ECMAScript 6 spec. Our encoding will\n  // make sure that if a proxy is used as an argument,\n  // its getPrototypeOf trap will be called.\n  while (true) {\n    var vHandler2 = safeWeakMapGet(directProxies, arg);\n    if (vHandler2 !== undefined) {\n      arg = vHandler2.getPrototypeOf();\n      if (arg === null) {\n        return false;\n      } else if (sameValue(arg, this)) {\n        return true;\n      }\n    } else {\n      return prim_isPrototypeOf.call(this, arg);\n    }\n  }\n};\n\nArray.isArray = function(subject) {\n  var vHandler = safeWeakMapGet(directProxies, subject);\n  if (vHandler !== undefined) {\n    return Array.isArray(vHandler.target);\n  } else {\n    return prim_isArray(subject);\n  }\n};\n\nfunction isProxyArray(arg) {\n  var vHandler = safeWeakMapGet(directProxies, arg);\n  if (vHandler !== undefined) {\n    return Array.isArray(vHandler.target);\n  }\n  return false;\n}\n\n// Array.prototype.concat internally tests whether one of its\n// arguments is an Array, by checking whether [[Class]] == \"Array\"\n// As such, it will fail to recognize proxies-for-arrays as arrays.\n// We patch Array.prototype.concat so that it \"unwraps\" proxies-for-arrays\n// by making a copy. This will trigger the exact same sequence of\n// traps on the proxy-for-array as if we would not have unwrapped it.\n// See <https://github.com/tvcutsem/harmony-reflect/issues/19> for more.\nArray.prototype.concat = function(/*...args*/) {\n  var length;\n  for (var i = 0; i < arguments.length; i++) {\n    if (isProxyArray(arguments[i])) {\n      length = arguments[i].length;\n      arguments[i] = Array.prototype.slice.call(arguments[i], 0, length);\n    }\n  }\n  return prim_concat.apply(this, arguments);\n};\n\n// setPrototypeOf support on platforms that support __proto__\n\nvar prim_setPrototypeOf = Object.setPrototypeOf;\n\n// patch and extract original __proto__ setter\nvar __proto__setter = (function() {\n  var protoDesc = prim_getOwnPropertyDescriptor(Object.prototype,'__proto__');\n  if (protoDesc === undefined ||\n      typeof protoDesc.set !== \"function\") {\n    return function() {\n      throw new TypeError(\"setPrototypeOf not supported on this platform\");\n    }\n  }\n\n  // see if we can actually mutate a prototype with the generic setter\n  // (e.g. Chrome v28 doesn't allow setting __proto__ via the generic setter)\n  try {\n    protoDesc.set.call({},{});\n  } catch (e) {\n    return function() {\n      throw new TypeError(\"setPrototypeOf not supported on this platform\");\n    }\n  }\n\n  prim_defineProperty(Object.prototype, '__proto__', {\n    set: function(newProto) {\n      return Object.setPrototypeOf(this, Object(newProto));\n    }\n  });\n\n  return protoDesc.set;\n}());\n\nObject.setPrototypeOf = function(target, newProto) {\n  var handler = directProxies.get(target);\n  if (handler !== undefined) {\n    if (handler.setPrototypeOf(newProto)) {\n      return target;\n    } else {\n      throw new TypeError(\"proxy rejected prototype mutation\");\n    }\n  } else {\n    if (!Object_isExtensible(target)) {\n      throw new TypeError(\"can't set prototype on non-extensible object: \" +\n                          target);\n    }\n    if (prim_setPrototypeOf)\n      return prim_setPrototypeOf(target, newProto);\n\n    if (Object(newProto) !== newProto || newProto === null) {\n      throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                         newProto);\n      // throw new TypeError(\"prototype must be an object or null\")\n    }\n    __proto__setter.call(target, newProto);\n    return target;\n  }\n}\n\nObject.prototype.hasOwnProperty = function(name) {\n  var handler = safeWeakMapGet(directProxies, this);\n  if (handler !== undefined) {\n    var desc = handler.getOwnPropertyDescriptor(name);\n    return desc !== undefined;\n  } else {\n    return prim_hasOwnProperty.call(this, name);\n  }\n}\n\n// ============= Reflection module =============\n// see http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n\nvar Reflect = {\n  getOwnPropertyDescriptor: function(target, name) {\n    return Object.getOwnPropertyDescriptor(target, name);\n  },\n  defineProperty: function(target, name, desc) {\n\n    // if target is a proxy, invoke its \"defineProperty\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.defineProperty(target, name, desc);\n    }\n\n    // Implementation transliterated from [[DefineOwnProperty]]\n    // see ES5.1 section 8.12.9\n    // this is the _exact same algorithm_ as the isCompatibleDescriptor\n    // algorithm defined above, except that at every place it\n    // returns true, this algorithm actually does define the property.\n    var current = Object.getOwnPropertyDescriptor(target, name);\n    var extensible = Object.isExtensible(target);\n    if (current === undefined && extensible === false) {\n      return false;\n    }\n    if (current === undefined && extensible === true) {\n      Object.defineProperty(target, name, desc); // should never fail\n      return true;\n    }\n    if (isEmptyDescriptor(desc)) {\n      return true;\n    }\n    if (isEquivalentDescriptor(current, desc)) {\n      return true;\n    }\n    if (current.configurable === false) {\n      if (desc.configurable === true) {\n        return false;\n      }\n      if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n        return false;\n      }\n    }\n    if (isGenericDescriptor(desc)) {\n      // no further validation necessary\n    } else if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        return false;\n      }\n    } else if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        if (current.writable === false && desc.writable === true) {\n          return false;\n        }\n        if (current.writable === false) {\n          if ('value' in desc && !sameValue(desc.value, current.value)) {\n            return false;\n          }\n        }\n      }\n    } else if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n      if (current.configurable === false) {\n        if ('set' in desc && !sameValue(desc.set, current.set)) {\n          return false;\n        }\n        if ('get' in desc && !sameValue(desc.get, current.get)) {\n          return false;\n        }\n      }\n    }\n    Object.defineProperty(target, name, desc); // should never fail\n    return true;\n  },\n  deleteProperty: function(target, name) {\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.delete(name);\n    }\n    \n    var desc = Object.getOwnPropertyDescriptor(target, name);\n    if (desc === undefined) {\n      return true;\n    }\n    if (desc.configurable === true) {\n      delete target[name];\n      return true;\n    }\n    return false;    \n  },\n  getPrototypeOf: function(target) {\n    return Object.getPrototypeOf(target);\n  },\n  setPrototypeOf: function(target, newProto) {\n    \n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.setPrototypeOf(newProto);\n    }\n    \n    if (Object(newProto) !== newProto || newProto === null) {\n      throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                         newProto);\n    }\n    \n    if (!Object_isExtensible(target)) {\n      return false;\n    }\n    \n    var current = Object.getPrototypeOf(target);\n    if (sameValue(current, newProto)) {\n      return true;\n    }\n    \n    if (prim_setPrototypeOf) {\n      try {\n        prim_setPrototypeOf(target, newProto);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    __proto__setter.call(target, newProto);\n    return true;\n  },\n  preventExtensions: function(target) {\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.preventExtensions();\n    }\n    prim_preventExtensions(target);\n    return true;\n  },\n  isExtensible: function(target) {\n    return Object.isExtensible(target);\n  },\n  has: function(target, name) {\n    return name in target;\n  },\n  get: function(target, name, receiver) {\n    receiver = receiver || target;\n\n    // if target is a proxy, invoke its \"get\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.get(receiver, name);\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(target, name);\n    if (desc === undefined) {\n      var proto = Object.getPrototypeOf(target);\n      if (proto === null) {\n        return undefined;\n      }\n      return Reflect.get(proto, name, receiver);\n    }\n    if (isDataDescriptor(desc)) {\n      return desc.value;\n    }\n    var getter = desc.get;\n    if (getter === undefined) {\n      return undefined;\n    }\n    return desc.get.call(receiver);\n  },\n  // Reflect.set implementation based on latest version of [[SetP]] at\n  // http://wiki.ecmascript.org/doku.php?id=harmony:proto_climbing_refactoring\n  set: function(target, name, value, receiver) {\n    receiver = receiver || target;\n\n    // if target is a proxy, invoke its \"set\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.set(receiver, name, value);\n    }\n\n    // first, check whether target has a non-writable property\n    // shadowing name on receiver\n    var ownDesc = Object.getOwnPropertyDescriptor(target, name);\n\n    if (ownDesc === undefined) {\n      // name is not defined in target, search target's prototype\n      var proto = Object.getPrototypeOf(target);\n\n      if (proto !== null) {\n        // continue the search in target's prototype\n        return Reflect.set(proto, name, value, receiver);\n      }\n\n      // Rev16 change. Cf. https://bugs.ecmascript.org/show_bug.cgi?id=1549\n      // target was the last prototype, now we know that 'name' is not shadowed\n      // by an existing (accessor or data) property, so we can add the property\n      // to the initial receiver object\n      // (this branch will intentionally fall through to the code below)\n      ownDesc =\n        { value: undefined,\n          writable: true,\n          enumerable: true,\n          configurable: true };\n    }\n\n    // we now know that ownDesc !== undefined\n    if (isAccessorDescriptor(ownDesc)) {\n      var setter = ownDesc.set;\n      if (setter === undefined) return false;\n      setter.call(receiver, value); // assumes Function.prototype.call\n      return true;\n    }\n    // otherwise, isDataDescriptor(ownDesc) must be true\n    if (ownDesc.writable === false) return false;\n    // we found an existing writable data property on the prototype chain.\n    // Now update or add the data property on the receiver, depending on\n    // whether the receiver already defines the property or not.\n    var existingDesc = Object.getOwnPropertyDescriptor(receiver, name);\n    if (existingDesc !== undefined) {\n      var updateDesc =\n        { value: value,\n          // FIXME: it should not be necessary to describe the following\n          // attributes. Added to circumvent a bug in tracemonkey:\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n          writable:     existingDesc.writable,\n          enumerable:   existingDesc.enumerable,\n          configurable: existingDesc.configurable };\n      Object.defineProperty(receiver, name, updateDesc);\n      return true;\n    } else {\n      if (!Object.isExtensible(receiver)) return false;\n      var newDesc =\n        { value: value,\n          writable: true,\n          enumerable: true,\n          configurable: true };\n      Object.defineProperty(receiver, name, newDesc);\n      return true;\n    }\n  },\n  /*invoke: function(target, name, args, receiver) {\n    receiver = receiver || target;\n\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.invoke(receiver, name, args);\n    }\n\n    var fun = Reflect.get(target, name, receiver);\n    return Function.prototype.apply.call(fun, receiver, args);\n  },*/\n  enumerate: function(target) {\n    var handler = directProxies.get(target);\n    var result;\n    if (handler !== undefined) {\n      // handler.enumerate should return an iterator directly, but the\n      // iterator gets converted to an array for backward-compat reasons,\n      // so we must re-iterate over the array\n      result = handler.enumerate(handler.target);\n    } else {\n      result = [];\n      for (var name in target) { result.push(name); };      \n    }\n    var l = +result.length;\n    var idx = 0;\n    return {\n      next: function() {\n        if (idx === l) return { done: true };\n        return { done: false, value: result[idx++] };\n      }\n    };\n  },\n  // imperfect ownKeys implementation: in ES6, should also include\n  // symbol-keyed properties.\n  ownKeys: function(target) {\n    return Object_getOwnPropertyNames(target);\n  },\n  apply: function(target, receiver, args) {\n    // target.apply(receiver, args)\n    return Function.prototype.apply.call(target, receiver, args);\n  },\n  construct: function(target, args, newTarget) {\n    // return new target(...args);\n\n    // if target is a proxy, invoke its \"construct\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.construct(handler.target, args, newTarget);\n    }\n    \n    if (typeof target !== \"function\") {\n      throw new TypeError(\"target is not a function: \" + target);\n    }\n    if (newTarget === undefined || newTarget === target) {\n      // If newTarget is undefined, then newTarget is set to `target` and\n      // `Reflect.construct(target, ...args)` becomes equivalent to\n      // `new target(...args)`\n      // if `target` is an ES2015 Class constructor, it must be called using\n      // the `new` operator. Hence we use the new operator on a bound function\n      // to trigger the [[Construct]] internal method. This technique will work \n      // for both plain constructor functions and ES2015 classes\n      return new (Function.prototype.bind.apply(target, [null].concat(args)));\n    } else {\n      if (typeof newTarget !== \"function\") {\n        throw new TypeError(\"newTarget is not a function: \" + target);\n      }\n      // if newTarget is a *different* constructor function, we need to\n      // emulate [[Construct]] by falling back to [[Call]] with a hand-crafted\n      // new instance inheriting from newTarget.prototype\n      // Unfortunately this won't work if target is an ES2015 Constructor\n      // function, whose [[Call]] method throws an error (it must be invoked\n      // using the `new` operator)\n      var proto = newTarget.prototype;\n      var instance = (Object(proto) === proto) ? Object.create(proto) : {};\n      var result = Function.prototype.apply.call(target, instance, args);\n      return Object(result) === result ? result : instance;\n    }\n  }\n};\n\n// feature-test whether the Reflect global exists\nif (global.Reflect !== undefined) {\n  // Reflect exists, add/override the shimmed methods\n  Object.getOwnPropertyNames(Reflect).forEach(function (key) {\n    global.Reflect[key] = Reflect[key];\n  });\n} else {\n  // Reflect doesn't exist, define it as the shimmed Reflect object\n  global.Reflect = Reflect;\n}\n\n// feature-test whether the Proxy global exists, with\n// the harmony-era Proxy.create API\nif (typeof Proxy !== \"undefined\" &&\n    typeof Proxy.create !== \"undefined\") {\n\n  var primCreate = Proxy.create,\n      primCreateFunction = Proxy.createFunction;\n\n  var revokedHandler = primCreate({\n    get: function() { throw new TypeError(\"proxy is revoked\"); }\n  });\n\n  global.Proxy = function(target, handler) {\n    // check that target is an Object\n    if (Object(target) !== target) {\n      throw new TypeError(\"Proxy target must be an Object, given \"+target);\n    }\n    // check that handler is an Object\n    if (Object(handler) !== handler) {\n      throw new TypeError(\"Proxy handler must be an Object, given \"+handler);\n    }\n\n    var vHandler = new Validator(target, handler);\n    var proxy;\n    if (typeof target === \"function\") {\n      proxy = primCreateFunction(vHandler,\n        // call trap\n        function() {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.apply(target, this, args);\n        },\n        // construct trap\n        function() {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.construct(target, args);\n        });\n    } else {\n      proxy = primCreate(vHandler, Object.getPrototypeOf(target));\n    }\n    directProxies.set(proxy, vHandler);\n    return proxy;\n  };\n\n  global.Proxy.revocable = function(target, handler) {\n    var proxy = new Proxy(target, handler);\n    var revoke = function() {\n      var vHandler = directProxies.get(proxy);\n      if (vHandler !== null) {\n        vHandler.target  = null;\n        vHandler.handler = revokedHandler;\n      }\n      return undefined;\n    };\n    return {proxy: proxy, revoke: revoke};\n  }\n  \n  // add the old Proxy.create and Proxy.createFunction methods\n  // so old code that still depends on the harmony-era Proxy object\n  // is not broken. Also ensures that multiple versions of this\n  // library should load fine\n  global.Proxy.create = primCreate;\n  global.Proxy.createFunction = primCreateFunction;\n\n} else {\n  // Proxy global not defined, or old API not available\n  if (typeof Proxy === \"undefined\") {\n    // Proxy global not defined, add a Proxy function stub\n    global.Proxy = function(_target, _handler) {\n      throw new Error(\"proxies not supported on this platform. On v8/node/iojs, make sure to pass the --harmony_proxies flag\");\n    };\n  }\n  // Proxy global defined but old API not available\n  // presumably Proxy global already supports new API, leave untouched\n}\n\n// for node.js modules, export every property in the Reflect object\n// as part of the module interface\nif (typeof exports !== 'undefined') {\n  Object.keys(Reflect).forEach(function (key) {\n    exports[key] = Reflect[key];\n  });\n}\n\n// function-as-module pattern\n}(typeof exports !== 'undefined' ? global : this));"],"mappings":"AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEC;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACD;AACC;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA,WAASA,MAAT,EAAgB;EAAE;EACnB,aADiB,CAGjB;EAEA;EACA;EACA;EAEA;EAEA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EAEA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EAEA;EAEA;EAEA;EAEA;EACA;EACA;;EACA,IAAI,OAAOC,OAAP,KAAmB,WAAvB,EAAoC;IAClCD,MAAM,CAACC,OAAP,GAAiB,YAAU,CAAE,CAA7B;;IACAD,MAAM,CAACC,OAAP,CAAeC,SAAf,GAA2B;MACzBC,GAAG,EAAE,UAASC,CAAT,EAAY;QAAE,OAAOC,SAAP;MAAmB,CADb;MAEzBC,GAAG,EAAE,UAASF,CAAT,EAAWG,CAAX,EAAc;QAAE,MAAM,IAAIC,KAAJ,CAAU,uBAAV,CAAN;MAA2C;IAFvC,CAA3B;EAID,CAxGgB,CA0GjB;;;EAEA,SAASC,mBAAT,CAA6BC,IAA7B,EAAmC;IACjC,OAAO,qDAAqDC,IAArD,CAA0DD,I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"},"metadata":{},"sourceType":"script"}