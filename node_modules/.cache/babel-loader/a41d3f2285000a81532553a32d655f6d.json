{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'no-unnecessary-boolean-literal-compare',\n  meta: {\n    docs: {\n      description: 'Disallow unnecessary equality comparisons against boolean literals',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    fixable: 'code',\n    messages: {\n      direct: 'This expression unnecessarily compares a boolean value to a boolean instead of using it directly.',\n      negated: 'This expression unnecessarily compares a boolean value to a boolean instead of negating it.',\n      comparingNullableToTrueDirect: 'This expression unnecessarily compares a nullable boolean value to true instead of using it directly.',\n      comparingNullableToTrueNegated: 'This expression unnecessarily compares a nullable boolean value to true instead of negating it.',\n      comparingNullableToFalse: 'This expression unnecessarily compares a nullable boolean value to false instead of using the ?? operator to provide a default.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowComparingNullableBooleansToTrue: {\n          description: 'Whether to allow comparisons between nullable boolean variables and `true`.',\n          type: 'boolean'\n        },\n        allowComparingNullableBooleansToFalse: {\n          description: 'Whether to allow comparisons between nullable boolean variables and `false`.',\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    type: 'suggestion'\n  },\n  defaultOptions: [{\n    allowComparingNullableBooleansToTrue: true,\n    allowComparingNullableBooleansToFalse: true\n  }],\n\n  create(context, _ref) {\n    let [options] = _ref;\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n\n    function getBooleanComparison(node) {\n      const comparison = deconstructComparison(node);\n\n      if (!comparison) {\n        return undefined;\n      }\n\n      const expressionType = checker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(comparison.expression));\n\n      if (isBooleanType(expressionType)) {\n        return Object.assign(Object.assign({}, comparison), {\n          expressionIsNullableBoolean: false\n        });\n      }\n\n      if (isNullableBoolean(expressionType)) {\n        return Object.assign(Object.assign({}, comparison), {\n          expressionIsNullableBoolean: true\n        });\n      }\n\n      return undefined;\n    }\n\n    function isBooleanType(expressionType) {\n      return tsutils.isTypeFlagSet(expressionType, ts.TypeFlags.Boolean | ts.TypeFlags.BooleanLiteral);\n    }\n    /**\n     * checks if the expressionType is a union that\n     *   1) contains at least one nullish type (null or undefined)\n     *   2) contains at least once boolean type (true or false or boolean)\n     *   3) does not contain any types besides nullish and boolean types\n     */\n\n\n    function isNullableBoolean(expressionType) {\n      if (!expressionType.isUnion()) {\n        return false;\n      }\n\n      const {\n        types\n      } = expressionType;\n      const nonNullishTypes = types.filter(type => !tsutils.isTypeFlagSet(type, ts.TypeFlags.Undefined | ts.TypeFlags.Null));\n      const hasNonNullishType = nonNullishTypes.length > 0;\n\n      if (!hasNonNullishType) {\n        return false;\n      }\n\n      const hasNullableType = nonNullishTypes.length < types.length;\n\n      if (!hasNullableType) {\n        return false;\n      }\n\n      const allNonNullishTypesAreBoolean = nonNullishTypes.every(isBooleanType);\n\n      if (!allNonNullishTypesAreBoolean) {\n        return false;\n      }\n\n      return true;\n    }\n\n    function deconstructComparison(node) {\n      const comparisonType = getEqualsKind(node.operator);\n\n      if (!comparisonType) {\n        return undefined;\n      }\n\n      for (const [against, expression] of [[node.right, node.left], [node.left, node.right]]) {\n        if (against.type !== utils_1.AST_NODE_TYPES.Literal || typeof against.value !== 'boolean') {\n          continue;\n        }\n\n        const {\n          value: literalBooleanInComparison\n        } = against;\n        const negated = !comparisonType.isPositive;\n        return {\n          literalBooleanInComparison,\n          forTruthy: literalBooleanInComparison ? !negated : negated,\n          expression,\n          negated,\n          range: expression.range[0] < against.range[0] ? [expression.range[1], against.range[1]] : [against.range[0], expression.range[0]]\n        };\n      }\n\n      return undefined;\n    }\n\n    function nodeIsUnaryNegation(node) {\n      return node.type === utils_1.AST_NODE_TYPES.UnaryExpression && node.prefix && node.operator === '!';\n    }\n\n    return {\n      BinaryExpression(node) {\n        const comparison = getBooleanComparison(node);\n\n        if (comparison === undefined) {\n          return;\n        }\n\n        if (comparison.expressionIsNullableBoolean) {\n          if (comparison.literalBooleanInComparison && options.allowComparingNullableBooleansToTrue) {\n            return;\n          }\n\n          if (!comparison.literalBooleanInComparison && options.allowComparingNullableBooleansToFalse) {\n            return;\n          }\n        }\n\n        context.report({\n          fix: function* (fixer) {\n            yield fixer.removeRange(comparison.range); // if the expression `exp` isn't nullable, or we're comparing to `true`,\n            // we can just replace the entire comparison with `exp` or `!exp`\n\n            if (!comparison.expressionIsNullableBoolean || comparison.literalBooleanInComparison) {\n              if (!comparison.forTruthy) {\n                yield fixer.insertTextBefore(node, '!');\n              }\n\n              return;\n            } // if we're here, then the expression is a nullable boolean and we're\n            // comparing to a literal `false`\n            // if we're doing `== false` or `=== false`, then we need to negate the expression\n\n\n            if (!comparison.negated) {\n              const {\n                parent\n              } = node; // if the parent is a negation, we can instead just get rid of the parent's negation.\n              // i.e. instead of resulting in `!(!(exp))`, we can just result in `exp`\n\n              if (parent != null && nodeIsUnaryNegation(parent)) {\n                // remove from the beginning of the parent to the beginning of this node\n                yield fixer.removeRange([parent.range[0], node.range[0]]); // remove from the end of the node to the end of the parent\n\n                yield fixer.removeRange([node.range[1], parent.range[1]]);\n              } else {\n                yield fixer.insertTextBefore(node, '!');\n              }\n            } // provide the default `true`\n\n\n            yield fixer.insertTextBefore(node, '(');\n            yield fixer.insertTextAfter(node, ' ?? true)');\n          },\n          messageId: comparison.expressionIsNullableBoolean ? comparison.literalBooleanInComparison ? comparison.negated ? 'comparingNullableToTrueNegated' : 'comparingNullableToTrueDirect' : 'comparingNullableToFalse' : comparison.negated ? 'negated' : 'direct',\n          node\n        });\n      }\n\n    };\n  }\n\n});\n\nfunction getEqualsKind(operator) {\n  switch (operator) {\n    case '==':\n      return {\n        isPositive: true,\n        isStrict: false\n      };\n\n    case '===':\n      return {\n        isPositive: true,\n        isStrict: true\n      };\n\n    case '!=':\n      return {\n        isPositive: false,\n        isStrict: false\n      };\n\n    case '!==':\n      return {\n        isPositive: false,\n        isStrict: true\n      };\n\n    default:\n      return undefined;\n  }\n}","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","docs","description","recommended","requiresTypeChecking","fixable","messages","direct","negated","comparingNullableToTrueDirect","comparingNullableToTrueNegated","comparingNullableToFalse","schema","type","properties","allowComparingNullableBooleansToTrue","allowComparingNullableBooleansToFalse","additionalProperties","defaultOptions","create","context","options","parserServices","getParserServices","checker","program","getTypeChecker","getBooleanComparison","node","comparison","deconstructComparison","undefined","expressionType","getTypeAtLocation","esTreeNodeToTSNodeMap","get","expression","isBooleanType","expressionIsNullableBoolean","isNullableBoolean","tsutils","isTypeFlagSet","ts","TypeFlags","Boolean","BooleanLiteral","isUnion","types","nonNullishTypes","filter","Undefined","Null","hasNonNullishType","length","hasNullableType","allNonNullishTypesAreBoolean","every","comparisonType","getEqualsKind","operator","against","right","left","utils_1","Literal","value","literalBooleanInComparison","isPositive","forTruthy","range","nodeIsUnaryNegation","UnaryExpression","prefix","BinaryExpression","report","fix","fixer","removeRange","insertTextBefore","parent","insertTextAfter","messageId","isStrict"],"sources":["../../src/rules/no-unnecessary-boolean-literal-compare.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}