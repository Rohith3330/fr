{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"splitAtTopLevelOnly\", {\n  enumerable: true,\n  get: () => splitAtTopLevelOnly\n});\n\nconst _regex = /*#__PURE__*/_interopRequireWildcard(require(\"../lib/regex\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction* splitAtTopLevelOnly(input, separator) {\n  let SPECIALS = new RegExp(`[(){}\\\\[\\\\]${_regex.escape(separator)}]`, \"g\");\n  let depth = 0;\n  let lastIndex = 0;\n  let found = false;\n  let separatorIndex = 0;\n  let separatorStart = 0;\n  let separatorLength = separator.length; // Find all paren-like things & character\n  // And only split on commas if they're top-level\n\n  for (let match of input.matchAll(SPECIALS)) {\n    let matchesSeparator = match[0] === separator[separatorIndex];\n    let atEndOfSeparator = separatorIndex === separatorLength - 1;\n    let matchesFullSeparator = matchesSeparator && atEndOfSeparator;\n    if (match[0] === \"(\") depth++;\n    if (match[0] === \")\") depth--;\n    if (match[0] === \"[\") depth++;\n    if (match[0] === \"]\") depth--;\n    if (match[0] === \"{\") depth++;\n    if (match[0] === \"}\") depth--;\n\n    if (matchesSeparator && depth === 0) {\n      if (separatorStart === 0) {\n        separatorStart = match.index;\n      }\n\n      separatorIndex++;\n    }\n\n    if (matchesFullSeparator && depth === 0) {\n      found = true;\n      yield input.substring(lastIndex, separatorStart);\n      lastIndex = separatorStart + separatorLength;\n    }\n\n    if (separatorIndex === separatorLength) {\n      separatorIndex = 0;\n      separatorStart = 0;\n    }\n  } // Provide the last segment of the string if available\n  // Otherwise the whole string since no `char`s were found\n  // This mirrors the behavior of string.split()\n\n\n  if (found) {\n    yield input.substring(lastIndex);\n  } else {\n    yield input;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","splitAtTopLevelOnly","_regex","_interopRequireWildcard","require","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","input","separator","SPECIALS","RegExp","escape","depth","lastIndex","found","separatorIndex","separatorStart","separatorLength","length","match","matchAll","matchesSeparator","atEndOfSeparator","matchesFullSeparator","index","substring"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"splitAtTopLevelOnly\", {\n    enumerable: true,\n    get: ()=>splitAtTopLevelOnly\n});\nconst _regex = /*#__PURE__*/ _interopRequireWildcard(require(\"../lib/regex\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction* splitAtTopLevelOnly(input, separator) {\n    let SPECIALS = new RegExp(`[(){}\\\\[\\\\]${_regex.escape(separator)}]`, \"g\");\n    let depth = 0;\n    let lastIndex = 0;\n    let found = false;\n    let separatorIndex = 0;\n    let separatorStart = 0;\n    let separatorLength = separator.length;\n    // Find all paren-like things & character\n    // And only split on commas if they're top-level\n    for (let match of input.matchAll(SPECIALS)){\n        let matchesSeparator = match[0] === separator[separatorIndex];\n        let atEndOfSeparator = separatorIndex === separatorLength - 1;\n        let matchesFullSeparator = matchesSeparator && atEndOfSeparator;\n        if (match[0] === \"(\") depth++;\n        if (match[0] === \")\") depth--;\n        if (match[0] === \"[\") depth++;\n        if (match[0] === \"]\") depth--;\n        if (match[0] === \"{\") depth++;\n        if (match[0] === \"}\") depth--;\n        if (matchesSeparator && depth === 0) {\n            if (separatorStart === 0) {\n                separatorStart = match.index;\n            }\n            separatorIndex++;\n        }\n        if (matchesFullSeparator && depth === 0) {\n            found = true;\n            yield input.substring(lastIndex, separatorStart);\n            lastIndex = separatorStart + separatorLength;\n        }\n        if (separatorIndex === separatorLength) {\n            separatorIndex = 0;\n            separatorStart = 0;\n        }\n    }\n    // Provide the last segment of the string if available\n    // Otherwise the whole string since no `char`s were found\n    // This mirrors the behavior of string.split()\n    if (found) {\n        yield input.substring(lastIndex);\n    } else {\n        yield input;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}