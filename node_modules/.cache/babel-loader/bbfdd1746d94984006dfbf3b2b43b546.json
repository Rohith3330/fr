{"ast":null,"code":"'use strict';\n\nvar _staticRequire = require('../core/staticRequire');\n\nvar _staticRequire2 = _interopRequireDefault(_staticRequire);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar log = (0, _debug2['default'])('eslint-plugin-import:rules:newline-after-import'); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * @fileoverview Rule to enforce new line after import not followed by another import.\n * @author Radek Benkel\n */\n\nfunction containsNodeOrEqual(outerNode, innerNode) {\n  return outerNode.range[0] <= innerNode.range[0] && outerNode.range[1] >= innerNode.range[1];\n}\n\nfunction getScopeBody(scope) {\n  if (scope.block.type === 'SwitchStatement') {\n    log('SwitchStatement scopes not supported');\n    return null;\n  }\n\n  var body = scope.block.body;\n\n  if (body && body.type === 'BlockStatement') {\n    return body.body;\n  }\n\n  return body;\n}\n\nfunction findNodeIndexInScopeBody(body, nodeToFind) {\n  return body.findIndex(function (node) {\n    return containsNodeOrEqual(node, nodeToFind);\n  });\n}\n\nfunction getLineDifference(node, nextNode) {\n  return nextNode.loc.start.line - node.loc.end.line;\n}\n\nfunction isClassWithDecorator(node) {\n  return node.type === 'ClassDeclaration' && node.decorators && node.decorators.length;\n}\n\nfunction isExportDefaultClass(node) {\n  return node.type === 'ExportDefaultDeclaration' && node.declaration.type === 'ClassDeclaration';\n}\n\nfunction isExportNameClass(node) {\n  return node.type === 'ExportNamedDeclaration' && node.declaration && node.declaration.type === 'ClassDeclaration';\n}\n\nmodule.exports = {\n  meta: {\n    type: 'layout',\n    docs: {\n      url: (0, _docsUrl2['default'])('newline-after-import')\n    },\n    fixable: 'whitespace',\n    schema: [{\n      'type': 'object',\n      'properties': {\n        'count': {\n          'type': 'integer',\n          'minimum': 1\n        }\n      },\n      'additionalProperties': false\n    }]\n  },\n  create: function () {\n    function create(context) {\n      var level = 0;\n      var requireCalls = [];\n\n      function checkForNewLine(node, nextNode, type) {\n        if (isExportDefaultClass(nextNode) || isExportNameClass(nextNode)) {\n          var classNode = nextNode.declaration;\n\n          if (isClassWithDecorator(classNode)) {\n            nextNode = classNode.decorators[0];\n          }\n        } else if (isClassWithDecorator(nextNode)) {\n          nextNode = nextNode.decorators[0];\n        }\n\n        var options = context.options[0] || {\n          count: 1\n        };\n        var lineDifference = getLineDifference(node, nextNode);\n        var EXPECTED_LINE_DIFFERENCE = options.count + 1;\n\n        if (lineDifference < EXPECTED_LINE_DIFFERENCE) {\n          var column = node.loc.start.column;\n\n          if (node.loc.start.line !== node.loc.end.line) {\n            column = 0;\n          }\n\n          context.report({\n            loc: {\n              line: node.loc.end.line,\n              column: column\n            },\n            message: 'Expected ' + String(options.count) + ' empty line' + (options.count > 1 ? 's' : '') + ' after ' + String(type) + ' statement not followed by another ' + String(type) + '.',\n            fix: function () {\n              function fix(fixer) {\n                return fixer.insertTextAfter(node, '\\n'.repeat(EXPECTED_LINE_DIFFERENCE - lineDifference));\n              }\n\n              return fix;\n            }()\n          });\n        }\n      }\n\n      function incrementLevel() {\n        level++;\n      }\n\n      function decrementLevel() {\n        level--;\n      }\n\n      function checkImport(node) {\n        var parent = node.parent;\n        var nodePosition = parent.body.indexOf(node);\n        var nextNode = parent.body[nodePosition + 1]; // skip \"export import\"s\n\n        if (node.type === 'TSImportEqualsDeclaration' && node.isExport) {\n          return;\n        }\n\n        if (nextNode && nextNode.type !== 'ImportDeclaration' && (nextNode.type !== 'TSImportEqualsDeclaration' || nextNode.isExport)) {\n          checkForNewLine(node, nextNode, 'import');\n        }\n      }\n\n      return {\n        ImportDeclaration: checkImport,\n        TSImportEqualsDeclaration: checkImport,\n        CallExpression: function () {\n          function CallExpression(node) {\n            if ((0, _staticRequire2['default'])(node) && level === 0) {\n              requireCalls.push(node);\n            }\n          }\n\n          return CallExpression;\n        }(),\n        'Program:exit': function () {\n          function ProgramExit() {\n            log('exit processing for', context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename());\n            var scopeBody = getScopeBody(context.getScope());\n            log('got scope:', scopeBody);\n            requireCalls.forEach(function (node, index) {\n              var nodePosition = findNodeIndexInScopeBody(scopeBody, node);\n              log('node position in scope:', nodePosition);\n              var statementWithRequireCall = scopeBody[nodePosition];\n              var nextStatement = scopeBody[nodePosition + 1];\n              var nextRequireCall = requireCalls[index + 1];\n\n              if (nextRequireCall && containsNodeOrEqual(statementWithRequireCall, nextRequireCall)) {\n                return;\n              }\n\n              if (nextStatement && (!nextRequireCall || !containsNodeOrEqual(nextStatement, nextRequireCall))) {\n                checkForNewLine(statementWithRequireCall, nextStatement, 'require');\n              }\n            });\n          }\n\n          return ProgramExit;\n        }(),\n        FunctionDeclaration: incrementLevel,\n        FunctionExpression: incrementLevel,\n        ArrowFunctionExpression: incrementLevel,\n        BlockStatement: incrementLevel,\n        ObjectExpression: incrementLevel,\n        Decorator: incrementLevel,\n        'FunctionDeclaration:exit': decrementLevel,\n        'FunctionExpression:exit': decrementLevel,\n        'ArrowFunctionExpression:exit': decrementLevel,\n        'BlockStatement:exit': decrementLevel,\n        'ObjectExpression:exit': decrementLevel,\n        'Decorator:exit': decrementLevel\n      };\n    }\n\n    return create;\n  }()\n};","map":{"version":3,"mappings":"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","names":["log","containsNodeOrEqual","outerNode","innerNode","range","getScopeBody","scope","block","type","body","findNodeIndexInScopeBody","nodeToFind","findIndex","node","getLineDifference","nextNode","loc","start","line","end","isClassWithDecorator","decorators","length","isExportDefaultClass","declaration","isExportNameClass","module","exports","meta","docs","url","fixable","schema","create","context","level","requireCalls","checkForNewLine","classNode","options","count","lineDifference","EXPECTED_LINE_DIFFERENCE","column","report","message","fix","fixer","insertTextAfter","repeat","incrementLevel","decrementLevel","checkImport","parent","nodePosition","indexOf","isExport","ImportDeclaration","TSImportEqualsDeclaration","CallExpression","push","getPhysicalFilename","getFilename","scopeBody","getScope","forEach","index","statementWithRequireCall","nextStatement","nextRequireCall","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","BlockStatement","ObjectExpression","Decorator"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\newline-after-import.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce new line after import not followed by another import.\n * @author Radek Benkel\n */\n\nimport isStaticRequire from '../core/staticRequire';\nimport docsUrl from '../docsUrl';\n\nimport debug from 'debug';\nconst log = debug('eslint-plugin-import:rules:newline-after-import');\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nfunction containsNodeOrEqual(outerNode, innerNode) {\n  return outerNode.range[0] <= innerNode.range[0] && outerNode.range[1] >= innerNode.range[1];\n}\n\nfunction getScopeBody(scope) {\n  if (scope.block.type === 'SwitchStatement') {\n    log('SwitchStatement scopes not supported');\n    return null;\n  }\n\n  const { body } = scope.block;\n  if (body && body.type === 'BlockStatement') {\n    return body.body;\n  }\n\n  return body;\n}\n\nfunction findNodeIndexInScopeBody(body, nodeToFind) {\n  return body.findIndex((node) => containsNodeOrEqual(node, nodeToFind));\n}\n\nfunction getLineDifference(node, nextNode) {\n  return nextNode.loc.start.line - node.loc.end.line;\n}\n\nfunction isClassWithDecorator(node) {\n  return node.type === 'ClassDeclaration' && node.decorators && node.decorators.length;\n}\n\nfunction isExportDefaultClass(node) {\n  return node.type === 'ExportDefaultDeclaration' && node.declaration.type === 'ClassDeclaration';\n}\n\nfunction isExportNameClass(node) {\n\n  return node.type === 'ExportNamedDeclaration' && node.declaration && node.declaration.type === 'ClassDeclaration';\n}\n\nmodule.exports = {\n  meta: {\n    type: 'layout',\n    docs: {\n      url: docsUrl('newline-after-import'),\n    },\n    fixable: 'whitespace',\n    schema: [\n      {\n        'type': 'object',\n        'properties': {\n          'count': {\n            'type': 'integer',\n            'minimum': 1,\n          },\n        },\n        'additionalProperties': false,\n      },\n    ],\n  },\n  create(context) {\n    let level = 0;\n    const requireCalls = [];\n\n    function checkForNewLine(node, nextNode, type) {\n      if (isExportDefaultClass(nextNode) || isExportNameClass(nextNode)) {\n        const classNode = nextNode.declaration;\n\n        if (isClassWithDecorator(classNode)) {\n          nextNode = classNode.decorators[0];\n        }\n      } else if (isClassWithDecorator(nextNode)) {\n        nextNode = nextNode.decorators[0];\n      }\n\n      const options = context.options[0] || { count: 1 };\n      const lineDifference = getLineDifference(node, nextNode);\n      const EXPECTED_LINE_DIFFERENCE = options.count + 1;\n\n      if (lineDifference < EXPECTED_LINE_DIFFERENCE) {\n        let column = node.loc.start.column;\n\n        if (node.loc.start.line !== node.loc.end.line) {\n          column = 0;\n        }\n\n        context.report({\n          loc: {\n            line: node.loc.end.line,\n            column,\n          },\n          message: `Expected ${options.count} empty line${options.count > 1 ? 's' : ''} \\\nafter ${type} statement not followed by another ${type}.`,\n          fix: fixer => fixer.insertTextAfter(\n            node,\n            '\\n'.repeat(EXPECTED_LINE_DIFFERENCE - lineDifference),\n          ),\n        });\n      }\n    }\n\n    function incrementLevel() {\n      level++;\n    }\n    function decrementLevel() {\n      level--;\n    }\n\n    function checkImport(node) {\n      const { parent } = node;\n      const nodePosition = parent.body.indexOf(node);\n      const nextNode = parent.body[nodePosition + 1];\n\n      // skip \"export import\"s\n      if (node.type === 'TSImportEqualsDeclaration' && node.isExport) {\n        return;\n      }\n\n      if (nextNode && nextNode.type !== 'ImportDeclaration' && (nextNode.type !== 'TSImportEqualsDeclaration' || nextNode.isExport)) {\n        checkForNewLine(node, nextNode, 'import');\n      }\n    }\n\n    return {\n      ImportDeclaration: checkImport,\n      TSImportEqualsDeclaration: checkImport,\n      CallExpression(node) {\n        if (isStaticRequire(node) && level === 0) {\n          requireCalls.push(node);\n        }\n      },\n      'Program:exit': function () {\n        log('exit processing for', context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename());\n        const scopeBody = getScopeBody(context.getScope());\n        log('got scope:', scopeBody);\n\n        requireCalls.forEach(function (node, index) {\n          const nodePosition = findNodeIndexInScopeBody(scopeBody, node);\n          log('node position in scope:', nodePosition);\n\n          const statementWithRequireCall = scopeBody[nodePosition];\n          const nextStatement = scopeBody[nodePosition + 1];\n          const nextRequireCall = requireCalls[index + 1];\n\n          if (nextRequireCall && containsNodeOrEqual(statementWithRequireCall, nextRequireCall)) {\n            return;\n          }\n\n          if (nextStatement &&\n             (!nextRequireCall || !containsNodeOrEqual(nextStatement, nextRequireCall))) {\n\n            checkForNewLine(statementWithRequireCall, nextStatement, 'require');\n          }\n        });\n      },\n      FunctionDeclaration: incrementLevel,\n      FunctionExpression: incrementLevel,\n      ArrowFunctionExpression: incrementLevel,\n      BlockStatement: incrementLevel,\n      ObjectExpression: incrementLevel,\n      Decorator: incrementLevel,\n      'FunctionDeclaration:exit': decrementLevel,\n      'FunctionExpression:exit': decrementLevel,\n      'ArrowFunctionExpression:exit': decrementLevel,\n      'BlockStatement:exit': decrementLevel,\n      'ObjectExpression:exit': decrementLevel,\n      'Decorator:exit': decrementLevel,\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"script"}