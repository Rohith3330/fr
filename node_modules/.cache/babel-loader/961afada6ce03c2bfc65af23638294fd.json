{"ast":null,"code":"exports.quote = function (xs) {\n  return xs.map(function (s) {\n    if (s && typeof s === 'object') {\n      return s.op.replace(/(.)/g, '\\\\$1');\n    } else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n      return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n    } else if (/[\"'\\s]/.test(s)) {\n      return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n    } else {\n      return String(s).replace(/([A-Za-z]:)?([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '$1\\\\$2');\n    }\n  }).join(' ');\n}; // '<(' is process substitution operator and\n// can be parsed the same as control operator\n\n\nvar CONTROL = '(?:' + ['\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '>>', '>\\\\&', '[&;()|<>]'].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar TOKEN = '';\n\nfor (var i = 0; i < 4; i++) {\n  TOKEN += (Math.pow(16, 8) * Math.random()).toString(16);\n}\n\nexports.parse = function (s, env, opts) {\n  var mapped = parse(s, env, opts);\n  if (typeof env !== 'function') return mapped;\n  return mapped.reduce(function (acc, s) {\n    if (typeof s === 'object') return acc.concat(s);\n    var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n    if (xs.length === 1) return acc.concat(xs[0]);\n    return acc.concat(xs.filter(Boolean).map(function (x) {\n      if (RegExp('^' + TOKEN).test(x)) {\n        return JSON.parse(x.split(TOKEN)[1]);\n      } else return x;\n    }));\n  }, []);\n};\n\nfunction parse(s, env, opts) {\n  var chunker = new RegExp(['(' + CONTROL + ')', // control chars\n  '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'].join('|'), 'g');\n  var match = s.match(chunker).filter(Boolean);\n  var commented = false;\n  if (!match) return [];\n  if (!env) env = {};\n  if (!opts) opts = {};\n  return match.map(function (s, j) {\n    if (commented) {\n      return;\n    }\n\n    if (RegExp('^' + CONTROL + '$').test(s)) {\n      return {\n        op: s\n      };\n    } // Hand-written scanner/parser for Bash quoting rules:\n    //\n    //  1. inside single quotes, all characters are printed literally.\n    //  2. inside double quotes, all characters are printed literally\n    //     except variables prefixed by '$' and backslashes followed by\n    //     either a double quote or another backslash.\n    //  3. outside of any quotes, backslashes are treated as escape\n    //     characters and not printed (unless they are themselves escaped)\n    //  4. quote context can switch mid-token if there is no whitespace\n    //     between the two quote contexts (e.g. all'one'\"token\" parses as\n    //     \"allonetoken\")\n\n\n    var SQ = \"'\";\n    var DQ = '\"';\n    var DS = '$';\n    var BS = opts.escape || '\\\\';\n    var quote = false;\n    var esc = false;\n    var out = '';\n    var isGlob = false;\n\n    for (var i = 0, len = s.length; i < len; i++) {\n      var c = s.charAt(i);\n      isGlob = isGlob || !quote && (c === '*' || c === '?');\n\n      if (esc) {\n        out += c;\n        esc = false;\n      } else if (quote) {\n        if (c === quote) {\n          quote = false;\n        } else if (quote == SQ) {\n          out += c;\n        } else {\n          // Double quote\n          if (c === BS) {\n            i += 1;\n            c = s.charAt(i);\n\n            if (c === DQ || c === BS || c === DS) {\n              out += c;\n            } else {\n              out += BS + c;\n            }\n          } else if (c === DS) {\n            out += parseEnvVar();\n          } else {\n            out += c;\n          }\n        }\n      } else if (c === DQ || c === SQ) {\n        quote = c;\n      } else if (RegExp('^' + CONTROL + '$').test(c)) {\n        return {\n          op: s\n        };\n      } else if (RegExp('^#$').test(c)) {\n        commented = true;\n\n        if (out.length) {\n          return [out, {\n            comment: s.slice(i + 1) + match.slice(j + 1).join(' ')\n          }];\n        }\n\n        return [{\n          comment: s.slice(i + 1) + match.slice(j + 1).join(' ')\n        }];\n      } else if (c === BS) {\n        esc = true;\n      } else if (c === DS) {\n        out += parseEnvVar();\n      } else out += c;\n    }\n\n    if (isGlob) return {\n      op: 'glob',\n      pattern: out\n    };\n    return out;\n\n    function parseEnvVar() {\n      i += 1;\n      var varend, varname; //debugger\n\n      if (s.charAt(i) === '{') {\n        i += 1;\n\n        if (s.charAt(i) === '}') {\n          throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n        }\n\n        varend = s.indexOf('}', i);\n\n        if (varend < 0) {\n          throw new Error(\"Bad substitution: \" + s.substr(i));\n        }\n\n        varname = s.substr(i, varend - i);\n        i = varend;\n      } else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n        varname = s.charAt(i);\n        i += 1;\n      } else {\n        varend = s.substr(i).match(/[^\\w\\d_]/);\n\n        if (!varend) {\n          varname = s.substr(i);\n          i = s.length;\n        } else {\n          varname = s.substr(i, varend.index);\n          i += varend.index - 1;\n        }\n      }\n\n      return getVar(null, '', varname);\n    }\n  }) // finalize parsed aruments\n  .reduce(function (prev, arg) {\n    if (arg === undefined) {\n      return prev;\n    }\n\n    return prev.concat(arg);\n  }, []);\n\n  function getVar(_, pre, key) {\n    var r = typeof env === 'function' ? env(key) : env[key];\n    if (r === undefined && key != '') r = '';else if (r === undefined) r = '$';\n\n    if (typeof r === 'object') {\n      return pre + TOKEN + JSON.stringify(r) + TOKEN;\n    } else return pre + r;\n  }\n}","map":{"version":3,"names":["exports","quote","xs","map","s","op","replace","test","String","join","CONTROL","META","BAREWORD","SINGLE_QUOTE","DOUBLE_QUOTE","TOKEN","i","Math","pow","random","toString","parse","env","opts","mapped","reduce","acc","concat","split","RegExp","length","filter","Boolean","x","JSON","chunker","match","commented","j","SQ","DQ","DS","BS","escape","esc","out","isGlob","len","c","charAt","parseEnvVar","comment","slice","pattern","varend","varname","Error","substr","indexOf","index","getVar","prev","arg","undefined","_","pre","key","r","stringify"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/shell-quote/index.js"],"sourcesContent":["exports.quote = function (xs) {\n    return xs.map(function (s) {\n        if (s && typeof s === 'object') {\n            return s.op.replace(/(.)/g, '\\\\$1');\n        }\n        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n        }\n        else if (/[\"'\\s]/.test(s)) {\n            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n        }\n        else {\n            return String(s).replace(/([A-Za-z]:)?([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '$1\\\\$2');\n        }\n    }).join(' ');\n};\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '>>', '>\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\n}\n\nexports.parse = function (s, env, opts) {\n    var mapped = parse(s, env, opts);\n    if (typeof env !== 'function') return mapped;\n    return mapped.reduce(function (acc, s) {\n        if (typeof s === 'object') return acc.concat(s);\n        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n        if (xs.length === 1) return acc.concat(xs[0]);\n        return acc.concat(xs.filter(Boolean).map(function (x) {\n            if (RegExp('^' + TOKEN).test(x)) {\n                return JSON.parse(x.split(TOKEN)[1]);\n            }\n            else return x;\n        }));\n    }, []);\n};\n\nfunction parse (s, env, opts) {\n    var chunker = new RegExp([\n        '(' + CONTROL + ')', // control chars\n        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n    ].join('|'), 'g');\n    var match = s.match(chunker).filter(Boolean);\n    var commented = false;\n\n    if (!match) return [];\n    if (!env) env = {};\n    if (!opts) opts = {};\n    return match.map(function (s, j) {\n        if (commented) {\n            return;\n        }\n        if (RegExp('^' + CONTROL + '$').test(s)) {\n            return { op: s };\n        }\n\n        // Hand-written scanner/parser for Bash quoting rules:\n        //\n        //  1. inside single quotes, all characters are printed literally.\n        //  2. inside double quotes, all characters are printed literally\n        //     except variables prefixed by '$' and backslashes followed by\n        //     either a double quote or another backslash.\n        //  3. outside of any quotes, backslashes are treated as escape\n        //     characters and not printed (unless they are themselves escaped)\n        //  4. quote context can switch mid-token if there is no whitespace\n        //     between the two quote contexts (e.g. all'one'\"token\" parses as\n        //     \"allonetoken\")\n        var SQ = \"'\";\n        var DQ = '\"';\n        var DS = '$';\n        var BS = opts.escape || '\\\\';\n        var quote = false;\n        var esc = false;\n        var out = '';\n        var isGlob = false;\n\n        for (var i = 0, len = s.length; i < len; i++) {\n            var c = s.charAt(i);\n            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\n            if (esc) {\n                out += c;\n                esc = false;\n            }\n            else if (quote) {\n                if (c === quote) {\n                    quote = false;\n                }\n                else if (quote == SQ) {\n                    out += c;\n                }\n                else { // Double quote\n                    if (c === BS) {\n                        i += 1;\n                        c = s.charAt(i);\n                        if (c === DQ || c === BS || c === DS) {\n                            out += c;\n                        } else {\n                            out += BS + c;\n                        }\n                    }\n                    else if (c === DS) {\n                        out += parseEnvVar();\n                    }\n                    else {\n                        out += c;\n                    }\n                }\n            }\n            else if (c === DQ || c === SQ) {\n                quote = c;\n            }\n            else if (RegExp('^' + CONTROL + '$').test(c)) {\n                return { op: s };\n            }\n            else if (RegExp('^#$').test(c)) {\n                commented = true;\n                if (out.length){\n                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n                }\n                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n            }\n            else if (c === BS) {\n                esc = true;\n            }\n            else if (c === DS) {\n                out += parseEnvVar();\n            }\n            else out += c;\n        }\n\n        if (isGlob) return {op: 'glob', pattern: out};\n\n        return out;\n\n        function parseEnvVar() {\n            i += 1;\n            var varend, varname;\n            //debugger\n            if (s.charAt(i) === '{') {\n                i += 1;\n                if (s.charAt(i) === '}') {\n                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n                }\n                varend = s.indexOf('}', i);\n                if (varend < 0) {\n                    throw new Error(\"Bad substitution: \" + s.substr(i));\n                }\n                varname = s.substr(i, varend - i);\n                i = varend;\n            }\n            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n                varname = s.charAt(i);\n                i += 1;\n            }\n            else {\n                varend = s.substr(i).match(/[^\\w\\d_]/);\n                if (!varend) {\n                    varname = s.substr(i);\n                    i = s.length;\n                } else {\n                    varname = s.substr(i, varend.index);\n                    i += varend.index - 1;\n                }\n            }\n            return getVar(null, '', varname);\n        }\n    })\n    // finalize parsed aruments\n    .reduce(function(prev, arg){\n        if (arg === undefined){\n            return prev;\n        }\n        return prev.concat(arg);\n    },[]);\n\n    function getVar (_, pre, key) {\n        var r = typeof env === 'function' ? env(key) : env[key];\n        if (r === undefined && key != '')\n            r = '';\n        else if (r === undefined)\n            r = '$';\n\n        if (typeof r === 'object') {\n            return pre + TOKEN + JSON.stringify(r) + TOKEN;\n        }\n        else return pre + r;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}