{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _t = require(\"@babel/types\");\n\nvar _t2 = _t;\nconst {\n  react\n} = _t;\nconst {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator\n} = _t2;\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","map":{"version":3,"mappings":"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","names":["react","cloneNode","jsxExpressionContainer","variableDeclaration","variableDeclarator","referenceVisitor","ReferencedIdentifier","path","state","isJSXIdentifier","isCompatTag","node","name","parentPath","isJSXMemberExpression","scope","isFunction","isArrowFunctionExpression","parent","breakOnScopePaths","push","binding","getBinding","violation","constantViolations","mutableBinding","stop","bindings","PathHoister","constructor","scopes","attachAfter","isCompatibleScope","key","Object","keys","bindingIdentifierEquals","identifier","getCompatibleScopes","indexOf","getAttachmentPath","_getAttachmentPath","targetScope","isProgram","hasOwnBinding","kind","parentKey","bindingParentPath","getAttachmentParentForPath","violationPath","pop","hasOwnParamBindings","bodies","get","i","length","_blockHoist","getNextScopeAttachmentParent","Array","isArray","container","isStatement","constant","run","traverse","attachTo","getFunctionParent","uid","generateUidIdentifier","declarator","insertFn","attached","isVariableDeclarator","isJSXElement","children","replaceWith"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\path\\lib\\hoister.ts"],"sourcesContent":["import { react } from \"@babel/types\";\nimport {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type Scope from \"../../scope\";\nimport type NodePath from \"../index\";\nimport type Binding from \"../../scope/binding\";\nimport type { Visitor } from \"../../types\";\n\nconst referenceVisitor: Visitor<PathHoister> = {\n  // This visitor looks for bindings to establish a topmost scope for hoisting.\n  ReferencedIdentifier(path, state) {\n    // Don't hoist regular JSX identifiers ('div', 'span', etc).\n    // We do have to consider member expressions for hoisting (e.g. `this.component`)\n    if (\n      path.isJSXIdentifier() &&\n      react.isCompatTag(path.node.name) &&\n      !path.parentPath.isJSXMemberExpression()\n    ) {\n      return;\n    }\n\n    // If the identifier refers to `this`, we need to break on the closest non-arrow scope.\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n      do {\n        if (\n          scope.path.isFunction() &&\n          !scope.path.isArrowFunctionExpression()\n        ) {\n          break;\n        }\n      } while ((scope = scope.parent));\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    // direct references that we need to track to hoist this to the highest scope we can\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    // we can handle reassignments only if they happen in the same scope as the declaration\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    // this binding isn't accessible from the parent scope so we can safely ignore it\n    // eg. it's in a closure etc\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n\n    state.bindings[path.node.name] = binding;\n  },\n};\n\nexport default class PathHoister<T extends t.Node = t.Node> {\n  breakOnScopePaths: NodePath[];\n  bindings: { [k: string]: Binding };\n  mutableBinding: boolean;\n  private scopes: Scope[];\n  scope: Scope;\n  private path: NodePath<T>;\n  private attachAfter: boolean;\n\n  constructor(path: NodePath<T>, scope: Scope) {\n    // Storage for scopes we can't hoist above.\n    this.breakOnScopePaths = [];\n    // Storage for bindings that may affect what path we can hoist to.\n    this.bindings = {};\n    // \"true\" if the current path contains a reference to a binding whose\n    // value can change and thus can't be safely hoisted.\n    this.mutableBinding = false;\n    // Storage for eligible scopes.\n    this.scopes = [];\n    // Our original scope and path.\n    this.scope = scope;\n    this.path = path;\n    // By default, we attach as far up as we can; but if we're trying\n    // to avoid referencing a binding, we may have to go after.\n    this.attachAfter = false;\n  }\n\n  // A scope is compatible if all required bindings are reachable.\n  isCompatibleScope(scope: Scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Look through all scopes and push compatible ones.\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      // deopt: These scopes are set in the visitor on const violations\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while ((scope = scope.parent));\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n    if (!path) return;\n\n    let targetScope = path.scope;\n\n    // don't allow paths that have their own lexical environments to pollute\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    // avoid hoisting to a scope that contains bindings that are executed after our attachment path\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        // check binding is a direct child of this paths scope\n        if (!targetScope.hasOwnBinding(name)) continue;\n\n        const binding = this.bindings[name];\n\n        // allow parameter references and expressions in params (like destructuring rest)\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        // For each binding, get its attachment parent. This gives us an idea of where we might\n        // introduce conflicts.\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        // If the binding's attachment appears at or after our attachment point, then we move after it.\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          // We also move past any constant violations.\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n\n    const scope = scopes.pop();\n    // deopt: no compatible scopes\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        // deopt: should ignore this scope since it's ourselves\n        if (this.scope === scope) return;\n\n        // needs to be attached to the body\n        const bodies = scope.path.get(\"body\").get(\"body\") as NodePath[];\n        for (let i = 0; i < bodies.length; i++) {\n          // Don't attach to something that's going to get hoisted,\n          // like a default parameter\n          // @ts-expect-error todo(flow->ts): avoid mutating the node, introducing new fields\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n        // deopt: If here, no attachment path found\n      } else {\n        // doesn't need to be be attached to this scope\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  // Find an attachment for this path.\n  getAttachmentParentForPath(path: NodePath) {\n    do {\n      if (\n        // Beginning of the scope\n        !path.parentPath ||\n        // Has siblings and is a statement\n        (Array.isArray(path.container) && path.isStatement())\n      ) {\n        return path;\n      }\n    } while ((path = path.parentPath));\n  }\n\n  // Returns true if a scope has param bindings.\n  hasOwnParamBindings(scope: Scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n\n      const binding = this.bindings[name];\n      // Ensure constant; without it we could place behind a reassignment\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n\n    if (this.mutableBinding) return;\n\n    this.getCompatibleScopes();\n\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n\n    // don't bother hoisting to the same function as this will cause multiple branches to be\n    // evaluated more than once leading to a bad optimisation\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n\n    // generate declaration and insert it to our point\n    let uid: t.Identifier | t.JSXExpressionContainer =\n      attachTo.scope.generateUidIdentifier(\"ref\");\n\n    // @ts-expect-error todo(flow->ts): more specific type for this.path\n    const declarator = variableDeclarator(uid, this.path.node);\n\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([\n      attachTo.isVariableDeclarator()\n        ? declarator\n        : variableDeclaration(\"var\", [declarator]),\n    ]);\n\n    const parent = this.path.parentPath;\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      // turning the `span` in `<div><span /></div>` to an expression so we need to wrap it with\n      // an expression container\n      uid = jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(cloneNode(uid));\n\n    return attachTo.isVariableDeclarator()\n      ? attached.get(\"init\")\n      : attached.get(\"declarations.0.init\");\n  }\n}\n"]},"metadata":{},"sourceType":"script"}