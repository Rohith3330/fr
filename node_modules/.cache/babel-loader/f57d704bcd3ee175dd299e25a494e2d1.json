{"ast":null,"code":"/**\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\n * @author Milos Djermanovic\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  findVariable\n} = require(\"eslint-utils\");\n\nconst {\n  RegExpValidator,\n  visitRegExpAST,\n  RegExpParser\n} = require(\"regexpp\");\n\nconst {\n  canTokensBeAdjacent\n} = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst REGEXPP_LATEST_ECMA_VERSION = 2022;\n/**\n * Determines whether the given node is a string literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a string literal.\n */\n\nfunction isStringLiteral(node) {\n  return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n/**\n * Determines whether the given node is a regex literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a regex literal.\n */\n\n\nfunction isRegexLiteral(node) {\n  return node.type === \"Literal\" && Object.prototype.hasOwnProperty.call(node, \"regex\");\n}\n/**\n * Determines whether the given node is a template literal without expressions.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a template literal without expressions.\n */\n\n\nfunction isStaticTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\nconst validPrecedingTokens = new Set([\"(\", \";\", \"[\", \",\", \"=\", \"+\", \"*\", \"-\", \"?\", \"~\", \"%\", \"**\", \"!\", \"typeof\", \"instanceof\", \"&&\", \"||\", \"??\", \"return\", \"...\", \"delete\", \"void\", \"in\", \"<\", \">\", \"<=\", \">=\", \"==\", \"===\", \"!=\", \"!==\", \"<<\", \">>\", \">>>\", \"&\", \"|\", \"^\", \":\", \"{\", \"=>\", \"*=\", \"<<=\", \">>=\", \">>>=\", \"^=\", \"|=\", \"&=\", \"??=\", \"||=\", \"&&=\", \"**=\", \"+=\", \"-=\", \"/=\", \"%=\", \"/\", \"do\", \"break\", \"continue\", \"debugger\", \"case\", \"throw\"]); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow use of the `RegExp` constructor in favor of regular expression literals\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-regex-literals\"\n    },\n    hasSuggestions: true,\n    schema: [{\n      type: \"object\",\n      properties: {\n        disallowRedundantWrapping: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\",\n      replaceWithLiteral: \"Replace with an equivalent regular expression literal.\",\n      unexpectedRedundantRegExp: \"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.\",\n      unexpectedRedundantRegExpWithFlags: \"Use regular expression literal with flags instead of the 'RegExp' constructor.\"\n    }\n  },\n\n  create(context) {\n    const [{\n      disallowRedundantWrapping = false\n    } = {}] = context.options;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Determines whether the given identifier node is a reference to a global variable.\n     * @param {ASTNode} node `Identifier` node to check.\n     * @returns {boolean} True if the identifier is a reference to a global variable.\n     */\n\n    function isGlobalReference(node) {\n      const scope = context.getScope();\n      const variable = findVariable(scope, node);\n      return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n    }\n    /**\n     * Determines whether the given node is a String.raw`` tagged template expression\n     * with a static template literal.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node is String.raw`` with a static template.\n     */\n\n\n    function isStringRawTaggedStaticTemplateLiteral(node) {\n      return node.type === \"TaggedTemplateExpression\" && astUtils.isSpecificMemberAccess(node.tag, \"String\", \"raw\") && isGlobalReference(astUtils.skipChainExpression(node.tag).object) && isStaticTemplateLiteral(node.quasi);\n    }\n    /**\n     * Gets the value of a string\n     * @param {ASTNode} node The node to get the string of.\n     * @returns {string|null} The value of the node.\n     */\n\n\n    function getStringValue(node) {\n      if (isStringLiteral(node)) {\n        return node.value;\n      }\n\n      if (isStaticTemplateLiteral(node)) {\n        return node.quasis[0].value.cooked;\n      }\n\n      if (isStringRawTaggedStaticTemplateLiteral(node)) {\n        return node.quasi.quasis[0].value.raw;\n      }\n\n      return null;\n    }\n    /**\n     * Determines whether the given node is considered to be a static string by the logic of this rule.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node is a static string.\n     */\n\n\n    function isStaticString(node) {\n      return isStringLiteral(node) || isStaticTemplateLiteral(node) || isStringRawTaggedStaticTemplateLiteral(node);\n    }\n    /**\n     * Determines whether the relevant arguments of the given are all static string literals.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if all arguments are static strings.\n     */\n\n\n    function hasOnlyStaticStringArguments(node) {\n      const args = node.arguments;\n\n      if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Determines whether the arguments of the given node indicate that a regex literal is unnecessarily wrapped.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node already contains a regex literal argument.\n     */\n\n\n    function isUnnecessarilyWrappedRegexLiteral(node) {\n      const args = node.arguments;\n\n      if (args.length === 1 && isRegexLiteral(args[0])) {\n        return true;\n      }\n\n      if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Returns a ecmaVersion compatible for regexpp.\n     * @param {any} ecmaVersion The ecmaVersion to convert.\n     * @returns {import(\"regexpp/ecma-versions\").EcmaVersion} The resulting ecmaVersion compatible for regexpp.\n     */\n\n\n    function getRegexppEcmaVersion(ecmaVersion) {\n      if (typeof ecmaVersion !== \"number\" || ecmaVersion <= 5) {\n        return 5;\n      }\n\n      return Math.min(ecmaVersion + 2009, REGEXPP_LATEST_ECMA_VERSION);\n    }\n    /**\n     * Makes a character escaped or else returns null.\n     * @param {string} character The character to escape.\n     * @returns {string} The resulting escaped character.\n     */\n\n\n    function resolveEscapes(character) {\n      switch (character) {\n        case \"\\n\":\n        case \"\\\\\\n\":\n          return \"\\\\n\";\n\n        case \"\\r\":\n        case \"\\\\\\r\":\n          return \"\\\\r\";\n\n        case \"\\t\":\n        case \"\\\\\\t\":\n          return \"\\\\t\";\n\n        case \"\\v\":\n        case \"\\\\\\v\":\n          return \"\\\\v\";\n\n        case \"\\f\":\n        case \"\\\\\\f\":\n          return \"\\\\f\";\n\n        case \"/\":\n          return \"\\\\/\";\n\n        default:\n          return null;\n      }\n    }\n\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        const traceMap = {\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        };\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(node)) {\n            if (node.arguments.length === 2) {\n              context.report({\n                node,\n                messageId: \"unexpectedRedundantRegExpWithFlags\"\n              });\n            } else {\n              context.report({\n                node,\n                messageId: \"unexpectedRedundantRegExp\"\n              });\n            }\n          } else if (hasOnlyStaticStringArguments(node)) {\n            let regexContent = getStringValue(node.arguments[0]);\n            let noFix = false;\n            let flags;\n\n            if (node.arguments[1]) {\n              flags = getStringValue(node.arguments[1]);\n            }\n\n            const regexppEcmaVersion = getRegexppEcmaVersion(context.parserOptions.ecmaVersion);\n            const RegExpValidatorInstance = new RegExpValidator({\n              ecmaVersion: regexppEcmaVersion\n            });\n\n            try {\n              RegExpValidatorInstance.validatePattern(regexContent, 0, regexContent.length, flags ? flags.includes(\"u\") : false);\n\n              if (flags) {\n                RegExpValidatorInstance.validateFlags(flags);\n              }\n            } catch {\n              noFix = true;\n            }\n\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            if (tokenBefore && !validPrecedingTokens.has(tokenBefore.value)) {\n              noFix = true;\n            }\n\n            if (!/^[-a-zA-Z0-9\\\\[\\](){} \\t\\r\\n\\v\\f!@#$%^&*+^_=/~`.><?,'\"|:;]*$/u.test(regexContent)) {\n              noFix = true;\n            }\n\n            if (sourceCode.getCommentsInside(node).length > 0) {\n              noFix = true;\n            }\n\n            if (regexContent && !noFix) {\n              let charIncrease = 0;\n              const ast = new RegExpParser({\n                ecmaVersion: regexppEcmaVersion\n              }).parsePattern(regexContent, 0, regexContent.length, flags ? flags.includes(\"u\") : false);\n              visitRegExpAST(ast, {\n                onCharacterEnter(characterNode) {\n                  const escaped = resolveEscapes(characterNode.raw);\n\n                  if (escaped) {\n                    regexContent = regexContent.slice(0, characterNode.start + charIncrease) + escaped + regexContent.slice(characterNode.end + charIncrease);\n\n                    if (characterNode.raw.length === 1) {\n                      charIncrease += 1;\n                    }\n                  }\n                }\n\n              });\n            }\n\n            const newRegExpValue = `/${regexContent || \"(?:)\"}/${flags || \"\"}`;\n            context.report({\n              node,\n              messageId: \"unexpectedRegExp\",\n              suggest: noFix ? [] : [{\n                messageId: \"replaceWithLiteral\",\n\n                fix(fixer) {\n                  const tokenAfter = sourceCode.getTokenAfter(node);\n                  return fixer.replaceText(node, (tokenBefore && !canTokensBeAdjacent(tokenBefore, newRegExpValue) && tokenBefore.range[1] === node.range[0] ? \" \" : \"\") + newRegExpValue + (tokenAfter && !canTokensBeAdjacent(newRegExpValue, tokenAfter) && node.range[1] === tokenAfter.range[0] ? \" \" : \"\"));\n                }\n\n              }]\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","CALL","CONSTRUCT","ReferenceTracker","findVariable","RegExpValidator","visitRegExpAST","RegExpParser","canTokensBeAdjacent","REGEXPP_LATEST_ECMA_VERSION","isStringLiteral","node","type","value","isRegexLiteral","Object","prototype","hasOwnProperty","call","isStaticTemplateLiteral","expressions","length","validPrecedingTokens","Set","module","exports","meta","docs","description","recommended","url","hasSuggestions","schema","properties","disallowRedundantWrapping","default","additionalProperties","messages","unexpectedRegExp","replaceWithLiteral","unexpectedRedundantRegExp","unexpectedRedundantRegExpWithFlags","create","context","options","sourceCode","getSourceCode","isGlobalReference","scope","getScope","variable","defs","isStringRawTaggedStaticTemplateLiteral","isSpecificMemberAccess","tag","skipChainExpression","object","quasi","getStringValue","quasis","cooked","raw","isStaticString","hasOnlyStaticStringArguments","args","arguments","every","isUnnecessarilyWrappedRegexLiteral","getRegexppEcmaVersion","ecmaVersion","Math","min","resolveEscapes","character","Program","tracker","traceMap","RegExp","iterateGlobalReferences","report","messageId","regexContent","noFix","flags","regexppEcmaVersion","parserOptions","RegExpValidatorInstance","validatePattern","includes","validateFlags","tokenBefore","getTokenBefore","has","test","getCommentsInside","charIncrease","ast","parsePattern","onCharacterEnter","characterNode","escaped","slice","start","end","newRegExpValue","suggest","fix","fixer","tokenAfter","getTokenAfter","replaceText","range"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/prefer-regex-literals.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { CALL, CONSTRUCT, ReferenceTracker, findVariable } = require(\"eslint-utils\");\nconst { RegExpValidator, visitRegExpAST, RegExpParser } = require(\"regexpp\");\nconst { canTokensBeAdjacent } = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst REGEXPP_LATEST_ECMA_VERSION = 2022;\n\n/**\n * Determines whether the given node is a string literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a string literal.\n */\nfunction isStringLiteral(node) {\n    return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\n/**\n * Determines whether the given node is a regex literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a regex literal.\n */\nfunction isRegexLiteral(node) {\n    return node.type === \"Literal\" && Object.prototype.hasOwnProperty.call(node, \"regex\");\n}\n\n/**\n * Determines whether the given node is a template literal without expressions.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a template literal without expressions.\n */\nfunction isStaticTemplateLiteral(node) {\n    return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\nconst validPrecedingTokens = new Set([\n    \"(\",\n    \";\",\n    \"[\",\n    \",\",\n    \"=\",\n    \"+\",\n    \"*\",\n    \"-\",\n    \"?\",\n    \"~\",\n    \"%\",\n    \"**\",\n    \"!\",\n    \"typeof\",\n    \"instanceof\",\n    \"&&\",\n    \"||\",\n    \"??\",\n    \"return\",\n    \"...\",\n    \"delete\",\n    \"void\",\n    \"in\",\n    \"<\",\n    \">\",\n    \"<=\",\n    \">=\",\n    \"==\",\n    \"===\",\n    \"!=\",\n    \"!==\",\n    \"<<\",\n    \">>\",\n    \">>>\",\n    \"&\",\n    \"|\",\n    \"^\",\n    \":\",\n    \"{\",\n    \"=>\",\n    \"*=\",\n    \"<<=\",\n    \">>=\",\n    \">>>=\",\n    \"^=\",\n    \"|=\",\n    \"&=\",\n    \"??=\",\n    \"||=\",\n    \"&&=\",\n    \"**=\",\n    \"+=\",\n    \"-=\",\n    \"/=\",\n    \"%=\",\n    \"/\",\n    \"do\",\n    \"break\",\n    \"continue\",\n    \"debugger\",\n    \"case\",\n    \"throw\"\n]);\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow use of the `RegExp` constructor in favor of regular expression literals\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-regex-literals\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    disallowRedundantWrapping: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\",\n            replaceWithLiteral: \"Replace with an equivalent regular expression literal.\",\n            unexpectedRedundantRegExp: \"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.\",\n            unexpectedRedundantRegExpWithFlags: \"Use regular expression literal with flags instead of the 'RegExp' constructor.\"\n        }\n    },\n\n    create(context) {\n        const [{ disallowRedundantWrapping = false } = {}] = context.options;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether the given identifier node is a reference to a global variable.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} True if the identifier is a reference to a global variable.\n         */\n        function isGlobalReference(node) {\n            const scope = context.getScope();\n            const variable = findVariable(scope, node);\n\n            return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n        }\n\n        /**\n         * Determines whether the given node is a String.raw`` tagged template expression\n         * with a static template literal.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is String.raw`` with a static template.\n         */\n        function isStringRawTaggedStaticTemplateLiteral(node) {\n            return node.type === \"TaggedTemplateExpression\" &&\n                astUtils.isSpecificMemberAccess(node.tag, \"String\", \"raw\") &&\n                isGlobalReference(astUtils.skipChainExpression(node.tag).object) &&\n                isStaticTemplateLiteral(node.quasi);\n        }\n\n        /**\n         * Gets the value of a string\n         * @param {ASTNode} node The node to get the string of.\n         * @returns {string|null} The value of the node.\n         */\n        function getStringValue(node) {\n            if (isStringLiteral(node)) {\n                return node.value;\n            }\n\n            if (isStaticTemplateLiteral(node)) {\n                return node.quasis[0].value.cooked;\n            }\n\n            if (isStringRawTaggedStaticTemplateLiteral(node)) {\n                return node.quasi.quasis[0].value.raw;\n            }\n\n            return null;\n        }\n\n        /**\n         * Determines whether the given node is considered to be a static string by the logic of this rule.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is a static string.\n         */\n        function isStaticString(node) {\n            return isStringLiteral(node) ||\n                isStaticTemplateLiteral(node) ||\n                isStringRawTaggedStaticTemplateLiteral(node);\n        }\n\n        /**\n         * Determines whether the relevant arguments of the given are all static string literals.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if all arguments are static strings.\n         */\n        function hasOnlyStaticStringArguments(node) {\n            const args = node.arguments;\n\n            if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines whether the arguments of the given node indicate that a regex literal is unnecessarily wrapped.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node already contains a regex literal argument.\n         */\n        function isUnnecessarilyWrappedRegexLiteral(node) {\n            const args = node.arguments;\n\n            if (args.length === 1 && isRegexLiteral(args[0])) {\n                return true;\n            }\n\n            if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Returns a ecmaVersion compatible for regexpp.\n         * @param {any} ecmaVersion The ecmaVersion to convert.\n         * @returns {import(\"regexpp/ecma-versions\").EcmaVersion} The resulting ecmaVersion compatible for regexpp.\n         */\n        function getRegexppEcmaVersion(ecmaVersion) {\n            if (typeof ecmaVersion !== \"number\" || ecmaVersion <= 5) {\n                return 5;\n            }\n            return Math.min(ecmaVersion + 2009, REGEXPP_LATEST_ECMA_VERSION);\n        }\n\n        /**\n         * Makes a character escaped or else returns null.\n         * @param {string} character The character to escape.\n         * @returns {string} The resulting escaped character.\n         */\n        function resolveEscapes(character) {\n            switch (character) {\n                case \"\\n\":\n                case \"\\\\\\n\":\n                    return \"\\\\n\";\n\n                case \"\\r\":\n                case \"\\\\\\r\":\n                    return \"\\\\r\";\n\n                case \"\\t\":\n                case \"\\\\\\t\":\n                    return \"\\\\t\";\n\n                case \"\\v\":\n                case \"\\\\\\v\":\n                    return \"\\\\v\";\n\n                case \"\\f\":\n                case \"\\\\\\f\":\n                    return \"\\\\f\";\n\n                case \"/\":\n                    return \"\\\\/\";\n\n                default:\n                    return null;\n            }\n        }\n\n        return {\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const traceMap = {\n                    RegExp: {\n                        [CALL]: true,\n                        [CONSTRUCT]: true\n                    }\n                };\n\n                for (const { node } of tracker.iterateGlobalReferences(traceMap)) {\n                    if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(node)) {\n                        if (node.arguments.length === 2) {\n                            context.report({ node, messageId: \"unexpectedRedundantRegExpWithFlags\" });\n                        } else {\n                            context.report({ node, messageId: \"unexpectedRedundantRegExp\" });\n                        }\n                    } else if (hasOnlyStaticStringArguments(node)) {\n                        let regexContent = getStringValue(node.arguments[0]);\n                        let noFix = false;\n                        let flags;\n\n                        if (node.arguments[1]) {\n                            flags = getStringValue(node.arguments[1]);\n                        }\n\n                        const regexppEcmaVersion = getRegexppEcmaVersion(context.parserOptions.ecmaVersion);\n                        const RegExpValidatorInstance = new RegExpValidator({ ecmaVersion: regexppEcmaVersion });\n\n                        try {\n                            RegExpValidatorInstance.validatePattern(regexContent, 0, regexContent.length, flags ? flags.includes(\"u\") : false);\n                            if (flags) {\n                                RegExpValidatorInstance.validateFlags(flags);\n                            }\n                        } catch {\n                            noFix = true;\n                        }\n\n                        const tokenBefore = sourceCode.getTokenBefore(node);\n\n                        if (tokenBefore && !validPrecedingTokens.has(tokenBefore.value)) {\n                            noFix = true;\n                        }\n\n                        if (!/^[-a-zA-Z0-9\\\\[\\](){} \\t\\r\\n\\v\\f!@#$%^&*+^_=/~`.><?,'\"|:;]*$/u.test(regexContent)) {\n                            noFix = true;\n                        }\n\n                        if (sourceCode.getCommentsInside(node).length > 0) {\n                            noFix = true;\n                        }\n\n                        if (regexContent && !noFix) {\n                            let charIncrease = 0;\n\n                            const ast = new RegExpParser({ ecmaVersion: regexppEcmaVersion }).parsePattern(regexContent, 0, regexContent.length, flags ? flags.includes(\"u\") : false);\n\n                            visitRegExpAST(ast, {\n                                onCharacterEnter(characterNode) {\n                                    const escaped = resolveEscapes(characterNode.raw);\n\n                                    if (escaped) {\n                                        regexContent =\n                                            regexContent.slice(0, characterNode.start + charIncrease) +\n                                            escaped +\n                                            regexContent.slice(characterNode.end + charIncrease);\n\n                                        if (characterNode.raw.length === 1) {\n                                            charIncrease += 1;\n                                        }\n                                    }\n                                }\n                            });\n                        }\n\n                        const newRegExpValue = `/${regexContent || \"(?:)\"}/${flags || \"\"}`;\n\n                        context.report({\n                            node,\n                            messageId: \"unexpectedRegExp\",\n                            suggest: noFix ? [] : [{\n                                messageId: \"replaceWithLiteral\",\n                                fix(fixer) {\n                                    const tokenAfter = sourceCode.getTokenAfter(node);\n\n                                    return fixer.replaceText(\n                                        node,\n                                        (tokenBefore && !canTokensBeAdjacent(tokenBefore, newRegExpValue) && tokenBefore.range[1] === node.range[0] ? \" \" : \"\") +\n                                            newRegExpValue +\n                                            (tokenAfter && !canTokensBeAdjacent(newRegExpValue, tokenAfter) && node.range[1] === tokenAfter.range[0] ? \" \" : \"\")\n                                    );\n                                }\n                            }]\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}