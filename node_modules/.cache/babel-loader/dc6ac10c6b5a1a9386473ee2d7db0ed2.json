{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst util = __importStar(require(\"../util\"));\n\nconst util_1 = require(\"../util\");\n\nexports.default = util.createRule({\n  name: 'no-unsafe-member-access',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow member access on a value with type `any`',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    messages: {\n      unsafeMemberExpression: 'Unsafe member access {{property}} on an `any` value.',\n      unsafeThisMemberExpression: ['Unsafe member access {{property}} on an `any` value. `this` is typed as `any`.', 'You can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.'].join('\\n'),\n      unsafeComputedMemberAccess: 'Computed name {{property}} resolves to an any value.'\n    },\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const {\n      program,\n      esTreeNodeToTSNodeMap\n    } = util.getParserServices(context);\n    const checker = program.getTypeChecker();\n    const compilerOptions = program.getCompilerOptions();\n    const isNoImplicitThis = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'noImplicitThis');\n    const sourceCode = context.getSourceCode();\n    const stateCache = new Map();\n\n    function checkMemberExpression(node) {\n      const cachedState = stateCache.get(node);\n\n      if (cachedState) {\n        return cachedState;\n      }\n\n      if (node.object.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n        const objectState = checkMemberExpression(node.object);\n\n        if (objectState === 1\n        /* State.Unsafe */\n        ) {\n          // if the object is unsafe, we know this will be unsafe as well\n          // we don't need to report, as we have already reported on the inner member expr\n          stateCache.set(node, objectState);\n          return objectState;\n        }\n      }\n\n      const tsNode = esTreeNodeToTSNodeMap.get(node.object);\n      const type = checker.getTypeAtLocation(tsNode);\n      const state = util.isTypeAnyType(type) ? 1\n      /* State.Unsafe */\n      : 2\n      /* State.Safe */\n      ;\n      stateCache.set(node, state);\n\n      if (state === 1\n      /* State.Unsafe */\n      ) {\n        const propertyName = sourceCode.getText(node.property);\n        let messageId = 'unsafeMemberExpression';\n\n        if (!isNoImplicitThis) {\n          // `this.foo` or `this.foo[bar]`\n          const thisExpression = (0, util_1.getThisExpression)(node);\n\n          if (thisExpression && util.isTypeAnyType(util.getConstrainedTypeAtLocation(checker, esTreeNodeToTSNodeMap.get(thisExpression)))) {\n            messageId = 'unsafeThisMemberExpression';\n          }\n        }\n\n        context.report({\n          node,\n          messageId,\n          data: {\n            property: node.computed ? `[${propertyName}]` : `.${propertyName}`\n          }\n        });\n      }\n\n      return state;\n    }\n\n    return {\n      // ignore MemberExpression if it's parent is TSClassImplements or TSInterfaceHeritage\n      ':not(TSClassImplements, TSInterfaceHeritage) > MemberExpression': checkMemberExpression,\n\n      'MemberExpression[computed = true] > *.property'(node) {\n        if ( // x[1]\n        node.type === utils_1.AST_NODE_TYPES.Literal || // x[1++] x[++x] etc\n        // FUN FACT - **all** update expressions return type number, regardless of the argument's type,\n        // because JS engines return NaN if there the argument is not a number.\n        node.type === utils_1.AST_NODE_TYPES.UpdateExpression) {\n          // perf optimizations - literals can obviously never be `any`\n          return;\n        }\n\n        const tsNode = esTreeNodeToTSNodeMap.get(node);\n        const type = checker.getTypeAtLocation(tsNode);\n\n        if (util.isTypeAnyType(type)) {\n          const propertyName = sourceCode.getText(node);\n          context.report({\n            node,\n            messageId: 'unsafeComputedMemberAccess',\n            data: {\n              property: `[${propertyName}]`\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","messages","unsafeMemberExpression","unsafeThisMemberExpression","join","unsafeComputedMemberAccess","schema","defaultOptions","create","context","program","esTreeNodeToTSNodeMap","getParserServices","checker","getTypeChecker","compilerOptions","getCompilerOptions","isNoImplicitThis","tsutils","isStrictCompilerOptionEnabled","sourceCode","getSourceCode","stateCache","Map","checkMemberExpression","node","cachedState","get","object","utils_1","MemberExpression","objectState","set","tsNode","getTypeAtLocation","state","isTypeAnyType","propertyName","getText","property","messageId","thisExpression","getConstrainedTypeAtLocation","report","data","computed","Literal","UpdateExpression"],"sources":["../../src/rules/no-unsafe-member-access.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}