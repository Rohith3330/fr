{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Converter = exports.convertError = void 0; // There's lots of funny stuff due to the typing of ts.Node\n\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access */\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst getModifiers_1 = require(\"./getModifiers\");\n\nconst node_utils_1 = require(\"./node-utils\");\n\nconst ts_estree_1 = require(\"./ts-estree\");\n\nconst version_check_1 = require(\"./version-check\");\n\nconst SyntaxKind = ts.SyntaxKind;\n/**\n * Extends and formats a given error object\n * @param error the error object\n * @returns converted error object\n */\n\nfunction convertError(error) {\n  return (0, node_utils_1.createError)(error.file, error.start, 'message' in error && error.message || error.messageText);\n}\n\nexports.convertError = convertError;\n\nclass Converter {\n  /**\n   * Converts a TypeScript node into an ESTree node\n   * @param ast the full TypeScript AST\n   * @param options additional options for the conversion\n   * @returns the converted ESTreeNode\n   */\n  constructor(ast, options) {\n    this.esTreeNodeToTSNodeMap = new WeakMap();\n    this.tsNodeToESTreeNodeMap = new WeakMap();\n    this.allowPattern = false;\n    this.inTypeMode = false;\n    this.ast = ast;\n    this.options = Object.assign({}, options);\n  }\n\n  getASTMaps() {\n    return {\n      esTreeNodeToTSNodeMap: this.esTreeNodeToTSNodeMap,\n      tsNodeToESTreeNodeMap: this.tsNodeToESTreeNodeMap\n    };\n  }\n\n  convertProgram() {\n    return this.converter(this.ast);\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * @param node the child ts.Node\n   * @param parent parentNode\n   * @param inTypeMode flag to determine if we are in typeMode\n   * @param allowPattern flag to determine if patterns are allowed\n   * @returns the converted ESTree node\n   */\n\n\n  converter(node, parent, inTypeMode, allowPattern) {\n    /**\n     * Exit early for null and undefined\n     */\n    if (!node) {\n      return null;\n    }\n\n    const typeMode = this.inTypeMode;\n    const pattern = this.allowPattern;\n\n    if (inTypeMode !== undefined) {\n      this.inTypeMode = inTypeMode;\n    }\n\n    if (allowPattern !== undefined) {\n      this.allowPattern = allowPattern;\n    }\n\n    const result = this.convertNode(node, parent !== null && parent !== void 0 ? parent : node.parent);\n    this.registerTSNodeInNodeMap(node, result);\n    this.inTypeMode = typeMode;\n    this.allowPattern = pattern;\n    return result;\n  }\n  /**\n   * Fixes the exports of the given ts.Node\n   * @param node the ts.Node\n   * @param result result\n   * @returns the ESTreeNode with fixed exports\n   */\n\n\n  fixExports(node, result) {\n    // check for exports\n    const modifiers = (0, getModifiers_1.getModifiers)(node);\n\n    if ((modifiers === null || modifiers === void 0 ? void 0 : modifiers[0].kind) === SyntaxKind.ExportKeyword) {\n      /**\n       * Make sure that original node is registered instead of export\n       */\n      this.registerTSNodeInNodeMap(node, result);\n      const exportKeyword = modifiers[0];\n      const nextModifier = modifiers[1];\n      const declarationIsDefault = nextModifier && nextModifier.kind === SyntaxKind.DefaultKeyword;\n      const varToken = declarationIsDefault ? (0, node_utils_1.findNextToken)(nextModifier, this.ast, this.ast) : (0, node_utils_1.findNextToken)(exportKeyword, this.ast, this.ast);\n      result.range[0] = varToken.getStart(this.ast);\n      result.loc = (0, node_utils_1.getLocFor)(result.range[0], result.range[1], this.ast);\n\n      if (declarationIsDefault) {\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,\n          declaration: result,\n          range: [exportKeyword.getStart(this.ast), result.range[1]],\n          exportKind: 'value'\n        });\n      } else {\n        const isType = result.type === ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration || result.type === ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration;\n        const isDeclare = 'declare' in result && result.declare === true;\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,\n          // @ts-expect-error - TODO, narrow the types here\n          declaration: result,\n          specifiers: [],\n          source: null,\n          exportKind: isType || isDeclare ? 'type' : 'value',\n          range: [exportKeyword.getStart(this.ast), result.range[1]],\n          assertions: []\n        });\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Register specific TypeScript node into map with first ESTree node provided\n   */\n\n\n  registerTSNodeInNodeMap(node, result) {\n    if (result && this.options.shouldPreserveNodeMaps) {\n      if (!this.tsNodeToESTreeNodeMap.has(node)) {\n        this.tsNodeToESTreeNodeMap.set(node, result);\n      }\n    }\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * @param child the child ts.Node\n   * @param parent parentNode\n   * @returns the converted ESTree node\n   */\n\n\n  convertPattern(child, parent) {\n    return this.converter(child, parent, this.inTypeMode, true);\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * @param child the child ts.Node\n   * @param parent parentNode\n   * @returns the converted ESTree node\n   */\n\n\n  convertChild(child, parent) {\n    return this.converter(child, parent, this.inTypeMode, false);\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * @param child the child ts.Node\n   * @param parent parentNode\n   * @returns the converted ESTree node\n   */\n\n\n  convertType(child, parent) {\n    return this.converter(child, parent, true, false);\n  }\n\n  createNode(node, data) {\n    const result = data;\n\n    if (!result.range) {\n      result.range = (0, node_utils_1.getRange)( // this is completely valid, but TS hates it\n      node, this.ast);\n    }\n\n    if (!result.loc) {\n      result.loc = (0, node_utils_1.getLocFor)(result.range[0], result.range[1], this.ast);\n    }\n\n    if (result && this.options.shouldPreserveNodeMaps) {\n      this.esTreeNodeToTSNodeMap.set(result, node);\n    }\n\n    return result;\n  }\n\n  convertBindingNameWithTypeAnnotation(name, tsType, parent) {\n    const id = this.convertPattern(name);\n\n    if (tsType) {\n      id.typeAnnotation = this.convertTypeAnnotation(tsType, parent);\n      this.fixParentLocation(id, id.typeAnnotation.range);\n    }\n\n    return id;\n  }\n  /**\n   * Converts a child into a type annotation. This creates an intermediary\n   * TypeAnnotation node to match what Flow does.\n   * @param child The TypeScript AST node to convert.\n   * @param parent parentNode\n   * @returns The type annotation node.\n   */\n\n\n  convertTypeAnnotation(child, parent) {\n    // in FunctionType and ConstructorType typeAnnotation has 2 characters `=>` and in other places is just colon\n    const offset = (parent === null || parent === void 0 ? void 0 : parent.kind) === SyntaxKind.FunctionType || (parent === null || parent === void 0 ? void 0 : parent.kind) === SyntaxKind.ConstructorType ? 2 : 1;\n    const annotationStartCol = child.getFullStart() - offset;\n    const loc = (0, node_utils_1.getLocFor)(annotationStartCol, child.end, this.ast);\n    return {\n      type: ts_estree_1.AST_NODE_TYPES.TSTypeAnnotation,\n      loc,\n      range: [annotationStartCol, child.end],\n      typeAnnotation: this.convertType(child)\n    };\n  }\n  /**\n   * Coverts body Nodes and add a directive field to StringLiterals\n   * @param nodes of ts.Node\n   * @param parent parentNode\n   * @returns Array of body statements\n   */\n\n\n  convertBodyExpressions(nodes, parent) {\n    let allowDirectives = (0, node_utils_1.canContainDirective)(parent);\n    return nodes.map(statement => {\n      const child = this.convertChild(statement);\n\n      if (allowDirectives) {\n        if ((child === null || child === void 0 ? void 0 : child.expression) && ts.isExpressionStatement(statement) && ts.isStringLiteral(statement.expression)) {\n          const raw = child.expression.raw;\n          child.directive = raw.slice(1, -1);\n          return child; // child can be null, but it's filtered below\n        } else {\n          allowDirectives = false;\n        }\n      }\n\n      return child; // child can be null, but it's filtered below\n    }) // filter out unknown nodes for now\n    .filter(statement => statement);\n  }\n  /**\n   * Converts a ts.Node's typeArguments to TSTypeParameterInstantiation node\n   * @param typeArguments ts.NodeArray typeArguments\n   * @param node parent used to create this node\n   * @returns TypeParameterInstantiation node\n   */\n\n\n  convertTypeArgumentsToTypeParameters(typeArguments, node) {\n    const greaterThanToken = (0, node_utils_1.findNextToken)(typeArguments, this.ast, this.ast);\n    return this.createNode(node, {\n      type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterInstantiation,\n      range: [typeArguments.pos - 1, greaterThanToken.end],\n      params: typeArguments.map(typeArgument => this.convertType(typeArgument))\n    });\n  }\n  /**\n   * Converts a ts.Node's typeParameters to TSTypeParameterDeclaration node\n   * @param typeParameters ts.Node typeParameters\n   * @returns TypeParameterDeclaration node\n   */\n\n\n  convertTSTypeParametersToTypeParametersDeclaration(typeParameters) {\n    const greaterThanToken = (0, node_utils_1.findNextToken)(typeParameters, this.ast, this.ast);\n    return {\n      type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterDeclaration,\n      range: [typeParameters.pos - 1, greaterThanToken.end],\n      loc: (0, node_utils_1.getLocFor)(typeParameters.pos - 1, greaterThanToken.end, this.ast),\n      params: typeParameters.map(typeParameter => this.convertType(typeParameter))\n    };\n  }\n  /**\n   * Converts an array of ts.Node parameters into an array of ESTreeNode params\n   * @param parameters An array of ts.Node params to be converted\n   * @returns an array of converted ESTreeNode params\n   */\n\n\n  convertParameters(parameters) {\n    if (!(parameters === null || parameters === void 0 ? void 0 : parameters.length)) {\n      return [];\n    }\n\n    return parameters.map(param => {\n      const convertedParam = this.convertChild(param);\n      const decorators = (0, getModifiers_1.getDecorators)(param);\n\n      if (decorators === null || decorators === void 0 ? void 0 : decorators.length) {\n        convertedParam.decorators = decorators.map(el => this.convertChild(el));\n      }\n\n      return convertedParam;\n    });\n  }\n\n  convertChainExpression(node, tsNode) {\n    const {\n      child,\n      isOptional\n    } = (() => {\n      if (node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {\n        return {\n          child: node.object,\n          isOptional: node.optional\n        };\n      }\n\n      if (node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {\n        return {\n          child: node.callee,\n          isOptional: node.optional\n        };\n      }\n\n      return {\n        child: node.expression,\n        isOptional: false\n      };\n    })();\n\n    const isChildUnwrappable = (0, node_utils_1.isChildUnwrappableOptionalChain)(tsNode, child);\n\n    if (!isChildUnwrappable && !isOptional) {\n      return node;\n    }\n\n    if (isChildUnwrappable && (0, node_utils_1.isChainExpression)(child)) {\n      // unwrap the chain expression child\n      const newChild = child.expression;\n\n      if (node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {\n        node.object = newChild;\n      } else if (node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {\n        node.callee = newChild;\n      } else {\n        node.expression = newChild;\n      }\n    }\n\n    return this.createNode(tsNode, {\n      type: ts_estree_1.AST_NODE_TYPES.ChainExpression,\n      expression: node\n    });\n  }\n  /**\n   * For nodes that are copied directly from the TypeScript AST into\n   * ESTree mostly as-is. The only difference is the addition of a type\n   * property instead of a kind property. Recursively copies all children.\n   */\n\n\n  deeplyCopy(node) {\n    if (node.kind === ts.SyntaxKind.JSDocFunctionType) {\n      throw (0, node_utils_1.createError)(this.ast, node.pos, 'JSDoc types can only be used inside documentation comments.');\n    }\n\n    const customType = `TS${SyntaxKind[node.kind]}`;\n    /**\n     * If the \"errorOnUnknownASTType\" option is set to true, throw an error,\n     * otherwise fallback to just including the unknown type as-is.\n     */\n\n    if (this.options.errorOnUnknownASTType && !ts_estree_1.AST_NODE_TYPES[customType]) {\n      throw new Error(`Unknown AST_NODE_TYPE: \"${customType}\"`);\n    }\n\n    const result = this.createNode(node, {\n      type: customType\n    });\n\n    if ('type' in node) {\n      result.typeAnnotation = node.type && 'kind' in node.type && ts.isTypeNode(node.type) ? this.convertTypeAnnotation(node.type, node) : null;\n    }\n\n    if ('typeArguments' in node) {\n      result.typeParameters = node.typeArguments && 'pos' in node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : null;\n    }\n\n    if ('typeParameters' in node) {\n      result.typeParameters = node.typeParameters && 'pos' in node.typeParameters ? this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters) : null;\n    }\n\n    const decorators = (0, getModifiers_1.getDecorators)(node);\n\n    if (decorators === null || decorators === void 0 ? void 0 : decorators.length) {\n      result.decorators = decorators.map(el => this.convertChild(el));\n    } // keys we never want to clone from the base typescript node as they\n    // introduce garbage into our AST\n\n\n    const KEYS_TO_NOT_COPY = new Set(['_children', 'decorators', 'end', 'flags', 'illegalDecorators', 'heritageClauses', 'locals', 'localSymbol', 'jsDoc', 'kind', 'modifierFlagsCache', 'modifiers', 'nextContainer', 'parent', 'pos', 'symbol', 'transformFlags', 'type', 'typeArguments', 'typeParameters']);\n    Object.entries(node).filter(_ref => {\n      let [key] = _ref;\n      return !KEYS_TO_NOT_COPY.has(key);\n    }).forEach(_ref2 => {\n      let [key, value] = _ref2;\n\n      if (Array.isArray(value)) {\n        result[key] = value.map(el => this.convertChild(el));\n      } else if (value && typeof value === 'object' && value.kind) {\n        // need to check node[key].kind to ensure we don't try to convert a symbol\n        result[key] = this.convertChild(value);\n      } else {\n        result[key] = value;\n      }\n    });\n    return result;\n  }\n\n  convertJSXIdentifier(node) {\n    const result = this.createNode(node, {\n      type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n      name: node.getText()\n    });\n    this.registerTSNodeInNodeMap(node, result);\n    return result;\n  }\n\n  convertJSXNamespaceOrIdentifier(node) {\n    const text = node.getText();\n    const colonIndex = text.indexOf(':'); // this is intentional we can ignore conversion if `:` is in first character\n\n    if (colonIndex > 0) {\n      const range = (0, node_utils_1.getRange)(node, this.ast);\n      const result = this.createNode(node, {\n        type: ts_estree_1.AST_NODE_TYPES.JSXNamespacedName,\n        namespace: this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n          name: text.slice(0, colonIndex),\n          range: [range[0], range[0] + colonIndex]\n        }),\n        name: this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n          name: text.slice(colonIndex + 1),\n          range: [range[0] + colonIndex + 1, range[1]]\n        }),\n        range\n      });\n      this.registerTSNodeInNodeMap(node, result);\n      return result;\n    }\n\n    return this.convertJSXIdentifier(node);\n  }\n  /**\n   * Converts a TypeScript JSX node.tagName into an ESTree node.name\n   * @param node the tagName object from a JSX ts.Node\n   * @param parent\n   * @returns the converted ESTree name object\n   */\n\n\n  convertJSXTagName(node, parent) {\n    let result;\n\n    switch (node.kind) {\n      case SyntaxKind.PropertyAccessExpression:\n        if (node.name.kind === SyntaxKind.PrivateIdentifier) {\n          // This is one of the few times where TS explicitly errors, and doesn't even gracefully handle the syntax.\n          // So we shouldn't ever get into this state to begin with.\n          throw new Error('Non-private identifier expected.');\n        }\n\n        result = this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXMemberExpression,\n          object: this.convertJSXTagName(node.expression, parent),\n          property: this.convertJSXIdentifier(node.name)\n        });\n        break;\n\n      case SyntaxKind.ThisKeyword:\n      case SyntaxKind.Identifier:\n      default:\n        return this.convertJSXNamespaceOrIdentifier(node);\n    }\n\n    this.registerTSNodeInNodeMap(node, result);\n    return result;\n  }\n\n  convertMethodSignature(node) {\n    const result = this.createNode(node, {\n      type: ts_estree_1.AST_NODE_TYPES.TSMethodSignature,\n      computed: (0, node_utils_1.isComputedProperty)(node.name),\n      key: this.convertChild(node.name),\n      params: this.convertParameters(node.parameters),\n      kind: (() => {\n        switch (node.kind) {\n          case SyntaxKind.GetAccessor:\n            return 'get';\n\n          case SyntaxKind.SetAccessor:\n            return 'set';\n\n          case SyntaxKind.MethodSignature:\n            return 'method';\n        }\n      })()\n    });\n\n    if ((0, node_utils_1.isOptional)(node)) {\n      result.optional = true;\n    }\n\n    if (node.type) {\n      result.returnType = this.convertTypeAnnotation(node.type, node);\n    }\n\n    if ((0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node)) {\n      result.readonly = true;\n    }\n\n    if (node.typeParameters) {\n      result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n    }\n\n    const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n\n    if (accessibility) {\n      result.accessibility = accessibility;\n    }\n\n    if ((0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)) {\n      result.export = true;\n    }\n\n    if ((0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node)) {\n      result.static = true;\n    }\n\n    return result;\n  }\n\n  convertAssertClasue(node) {\n    return node === undefined ? [] : node.elements.map(element => this.convertChild(element));\n  }\n  /**\n   * Applies the given TS modifiers to the given result object.\n   *\n   * This method adds not standardized `modifiers` property in nodes\n   *\n   * @param result\n   * @param modifiers original ts.Nodes from the node.modifiers array\n   * @returns the current result object will be mutated\n   */\n\n\n  applyModifiersToResult(result, modifiers) {\n    if (!modifiers) {\n      return;\n    }\n\n    const remainingModifiers = [];\n    /**\n     * Some modifiers are explicitly handled by applying them as\n     * boolean values on the result node. As well as adding them\n     * to the result, we remove them from the array, so that they\n     * are not handled twice.\n     */\n\n    for (const modifier of modifiers) {\n      switch (modifier.kind) {\n        /**\n         * Ignore ExportKeyword and DefaultKeyword, they are handled\n         * via the fixExports utility function\n         */\n        case SyntaxKind.ExportKeyword:\n        case SyntaxKind.DefaultKeyword:\n          break;\n\n        case SyntaxKind.ConstKeyword:\n          result.const = true;\n          break;\n\n        case SyntaxKind.DeclareKeyword:\n          result.declare = true;\n          break;\n\n        default:\n          remainingModifiers.push(this.convertChild(modifier));\n          break;\n      }\n    }\n    /**\n     * If there are still valid modifiers available which have\n     * not been explicitly handled above, we just convert and\n     * add the modifiers array to the result node.\n     */\n\n\n    if (remainingModifiers.length > 0) {\n      result.modifiers = remainingModifiers;\n    }\n  }\n  /**\n   * Uses the provided range location to adjust the location data of the given Node\n   * @param result The node that will have its location data mutated\n   * @param childRange The child node range used to expand location\n   */\n\n\n  fixParentLocation(result, childRange) {\n    if (childRange[0] < result.range[0]) {\n      result.range[0] = childRange[0];\n      result.loc.start = (0, node_utils_1.getLineAndCharacterFor)(result.range[0], this.ast);\n    }\n\n    if (childRange[1] > result.range[1]) {\n      result.range[1] = childRange[1];\n      result.loc.end = (0, node_utils_1.getLineAndCharacterFor)(result.range[1], this.ast);\n    }\n  }\n\n  assertModuleSpecifier(node, allowNull) {\n    var _a;\n\n    if (!allowNull && node.moduleSpecifier == null) {\n      throw (0, node_utils_1.createError)(this.ast, node.pos, 'Module specifier must be a string literal.');\n    }\n\n    if (node.moduleSpecifier && ((_a = node.moduleSpecifier) === null || _a === void 0 ? void 0 : _a.kind) !== SyntaxKind.StringLiteral) {\n      throw (0, node_utils_1.createError)(this.ast, node.moduleSpecifier.pos, 'Module specifier must be a string literal.');\n    }\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * The core of the conversion logic:\n   * Identify and convert each relevant TypeScript SyntaxKind\n   * @param node the child ts.Node\n   * @param parent parentNode\n   * @returns the converted ESTree node\n   */\n\n\n  convertNode(node, parent) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n    switch (node.kind) {\n      case SyntaxKind.SourceFile:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Program,\n            body: this.convertBodyExpressions(node.statements, node),\n            sourceType: node.externalModuleIndicator ? 'module' : 'script',\n            range: [node.getStart(this.ast), node.endOfFileToken.end]\n          });\n        }\n\n      case SyntaxKind.Block:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.BlockStatement,\n            body: this.convertBodyExpressions(node.statements, node)\n          });\n        }\n\n      case SyntaxKind.Identifier:\n        {\n          if ((0, node_utils_1.isThisInTypeQuery)(node)) {\n            // special case for `typeof this.foo` - TS emits an Identifier for `this`\n            // but we want to treat it as a ThisExpression for consistency\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ThisExpression\n            });\n          }\n\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Identifier,\n            name: node.text\n          });\n        }\n\n      case SyntaxKind.PrivateIdentifier:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.PrivateIdentifier,\n            // typescript includes the `#` in the text\n            name: node.text.slice(1)\n          });\n        }\n\n      case SyntaxKind.WithStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.WithStatement,\n          object: this.convertChild(node.expression),\n          body: this.convertChild(node.statement)\n        });\n      // Control Flow\n\n      case SyntaxKind.ReturnStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ReturnStatement,\n          argument: this.convertChild(node.expression)\n        });\n\n      case SyntaxKind.LabeledStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.LabeledStatement,\n          label: this.convertChild(node.label),\n          body: this.convertChild(node.statement)\n        });\n\n      case SyntaxKind.ContinueStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ContinueStatement,\n          label: this.convertChild(node.label)\n        });\n\n      case SyntaxKind.BreakStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.BreakStatement,\n          label: this.convertChild(node.label)\n        });\n      // Choice\n\n      case SyntaxKind.IfStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.IfStatement,\n          test: this.convertChild(node.expression),\n          consequent: this.convertChild(node.thenStatement),\n          alternate: this.convertChild(node.elseStatement)\n        });\n\n      case SyntaxKind.SwitchStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.SwitchStatement,\n          discriminant: this.convertChild(node.expression),\n          cases: node.caseBlock.clauses.map(el => this.convertChild(el))\n        });\n\n      case SyntaxKind.CaseClause:\n      case SyntaxKind.DefaultClause:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.SwitchCase,\n          // expression is present in case only\n          test: node.kind === SyntaxKind.CaseClause ? this.convertChild(node.expression) : null,\n          consequent: node.statements.map(el => this.convertChild(el))\n        });\n      // Exceptions\n\n      case SyntaxKind.ThrowStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ThrowStatement,\n          argument: this.convertChild(node.expression)\n        });\n\n      case SyntaxKind.TryStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TryStatement,\n          block: this.convertChild(node.tryBlock),\n          handler: this.convertChild(node.catchClause),\n          finalizer: this.convertChild(node.finallyBlock)\n        });\n\n      case SyntaxKind.CatchClause:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.CatchClause,\n          param: node.variableDeclaration ? this.convertBindingNameWithTypeAnnotation(node.variableDeclaration.name, node.variableDeclaration.type) : null,\n          body: this.convertChild(node.block)\n        });\n      // Loops\n\n      case SyntaxKind.WhileStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.WhileStatement,\n          test: this.convertChild(node.expression),\n          body: this.convertChild(node.statement)\n        });\n\n      /**\n       * Unlike other parsers, TypeScript calls a \"DoWhileStatement\"\n       * a \"DoStatement\"\n       */\n\n      case SyntaxKind.DoStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.DoWhileStatement,\n          test: this.convertChild(node.expression),\n          body: this.convertChild(node.statement)\n        });\n\n      case SyntaxKind.ForStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ForStatement,\n          init: this.convertChild(node.initializer),\n          test: this.convertChild(node.condition),\n          update: this.convertChild(node.incrementor),\n          body: this.convertChild(node.statement)\n        });\n\n      case SyntaxKind.ForInStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ForInStatement,\n          left: this.convertPattern(node.initializer),\n          right: this.convertChild(node.expression),\n          body: this.convertChild(node.statement)\n        });\n\n      case SyntaxKind.ForOfStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ForOfStatement,\n          left: this.convertPattern(node.initializer),\n          right: this.convertChild(node.expression),\n          body: this.convertChild(node.statement),\n          await: Boolean(node.awaitModifier && node.awaitModifier.kind === SyntaxKind.AwaitKeyword)\n        });\n      // Declarations\n\n      case SyntaxKind.FunctionDeclaration:\n        {\n          const isDeclare = (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node);\n          const result = this.createNode(node, {\n            type: isDeclare || !node.body ? ts_estree_1.AST_NODE_TYPES.TSDeclareFunction : ts_estree_1.AST_NODE_TYPES.FunctionDeclaration,\n            id: this.convertChild(node.name),\n            generator: !!node.asteriskToken,\n            expression: false,\n            async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n            params: this.convertParameters(node.parameters),\n            body: this.convertChild(node.body) || undefined\n          }); // Process returnType\n\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          } // Process typeParameters\n\n\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n\n          if (isDeclare) {\n            result.declare = true;\n          } // check for exports\n\n\n          return this.fixExports(node, result);\n        }\n\n      case SyntaxKind.VariableDeclaration:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.VariableDeclarator,\n            id: this.convertBindingNameWithTypeAnnotation(node.name, node.type, node),\n            init: this.convertChild(node.initializer)\n          });\n\n          if (node.exclamationToken) {\n            result.definite = true;\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.VariableStatement:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,\n            declarations: node.declarationList.declarations.map(el => this.convertChild(el)),\n            kind: (0, node_utils_1.getDeclarationKind)(node.declarationList)\n          });\n          /**\n           * Semantically, decorators are not allowed on variable declarations,\n           * Pre 4.8 TS would include them in the AST, so we did as well.\n           * However as of 4.8 TS no longer includes it (as it is, well, invalid).\n           *\n           * So for consistency across versions, we no longer include it either.\n           */\n\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {\n            result.declare = true;\n          } // check for exports\n\n\n          return this.fixExports(node, result);\n        }\n      // mostly for for-of, for-in\n\n      case SyntaxKind.VariableDeclarationList:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,\n          declarations: node.declarations.map(el => this.convertChild(el)),\n          kind: (0, node_utils_1.getDeclarationKind)(node)\n        });\n      // Expressions\n\n      case SyntaxKind.ExpressionStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ExpressionStatement,\n          expression: this.convertChild(node.expression)\n        });\n\n      case SyntaxKind.ThisKeyword:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ThisExpression\n        });\n\n      case SyntaxKind.ArrayLiteralExpression:\n        {\n          // TypeScript uses ArrayLiteralExpression in destructuring assignment, too\n          if (this.allowPattern) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,\n              elements: node.elements.map(el => this.convertPattern(el))\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ArrayExpression,\n              elements: node.elements.map(el => this.convertChild(el))\n            });\n          }\n        }\n\n      case SyntaxKind.ObjectLiteralExpression:\n        {\n          // TypeScript uses ObjectLiteralExpression in destructuring assignment, too\n          if (this.allowPattern) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,\n              properties: node.properties.map(el => this.convertPattern(el))\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ObjectExpression,\n              properties: node.properties.map(el => this.convertChild(el))\n            });\n          }\n        }\n\n      case SyntaxKind.PropertyAssignment:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.Property,\n          key: this.convertChild(node.name),\n          value: this.converter(node.initializer, node, this.inTypeMode, this.allowPattern),\n          computed: (0, node_utils_1.isComputedProperty)(node.name),\n          method: false,\n          shorthand: false,\n          kind: 'init'\n        });\n\n      case SyntaxKind.ShorthandPropertyAssignment:\n        {\n          if (node.objectAssignmentInitializer) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.Property,\n              key: this.convertChild(node.name),\n              value: this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                left: this.convertPattern(node.name),\n                right: this.convertChild(node.objectAssignmentInitializer)\n              }),\n              computed: false,\n              method: false,\n              shorthand: true,\n              kind: 'init'\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.Property,\n              key: this.convertChild(node.name),\n              value: this.convertChild(node.name),\n              computed: false,\n              method: false,\n              shorthand: true,\n              kind: 'init'\n            });\n          }\n        }\n\n      case SyntaxKind.ComputedPropertyName:\n        return this.convertChild(node.expression);\n\n      case SyntaxKind.PropertyDeclaration:\n        {\n          const isAbstract = (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node);\n          const result = this.createNode(node, {\n            type: isAbstract ? ts_estree_1.AST_NODE_TYPES.TSAbstractPropertyDefinition : ts_estree_1.AST_NODE_TYPES.PropertyDefinition,\n            key: this.convertChild(node.name),\n            value: isAbstract ? null : this.convertChild(node.initializer),\n            computed: (0, node_utils_1.isComputedProperty)(node.name),\n            static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),\n            readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || undefined,\n            declare: (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),\n            override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node)\n          });\n\n          if (node.type) {\n            result.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n          }\n\n          const decorators = (0, getModifiers_1.getDecorators)(node);\n\n          if (decorators) {\n            result.decorators = decorators.map(el => this.convertChild(el));\n          }\n\n          const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n\n          if (accessibility) {\n            result.accessibility = accessibility;\n          }\n\n          if ((node.name.kind === SyntaxKind.Identifier || node.name.kind === SyntaxKind.ComputedPropertyName || node.name.kind === SyntaxKind.PrivateIdentifier) && node.questionToken) {\n            result.optional = true;\n          }\n\n          if (node.exclamationToken) {\n            result.definite = true;\n          }\n\n          if (result.key.type === ts_estree_1.AST_NODE_TYPES.Literal && node.questionToken) {\n            result.optional = true;\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.GetAccessor:\n      case SyntaxKind.SetAccessor:\n        {\n          if (node.parent.kind === SyntaxKind.InterfaceDeclaration || node.parent.kind === SyntaxKind.TypeLiteral) {\n            return this.convertMethodSignature(node);\n          }\n        }\n      // otherwise, it is a non-type accessor - intentional fallthrough\n\n      case SyntaxKind.MethodDeclaration:\n        {\n          const method = this.createNode(node, {\n            type: !node.body ? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression : ts_estree_1.AST_NODE_TYPES.FunctionExpression,\n            id: null,\n            generator: !!node.asteriskToken,\n            expression: false,\n            async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n            body: this.convertChild(node.body),\n            range: [node.parameters.pos - 1, node.end],\n            params: []\n          });\n\n          if (node.type) {\n            method.returnType = this.convertTypeAnnotation(node.type, node);\n          } // Process typeParameters\n\n\n          if (node.typeParameters) {\n            method.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n            this.fixParentLocation(method, method.typeParameters.range);\n          }\n\n          let result;\n\n          if (parent.kind === SyntaxKind.ObjectLiteralExpression) {\n            method.params = node.parameters.map(el => this.convertChild(el));\n            result = this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.Property,\n              key: this.convertChild(node.name),\n              value: method,\n              computed: (0, node_utils_1.isComputedProperty)(node.name),\n              method: node.kind === SyntaxKind.MethodDeclaration,\n              shorthand: false,\n              kind: 'init'\n            });\n          } else {\n            // class\n\n            /**\n             * Unlike in object literal methods, class method params can have decorators\n             */\n            method.params = this.convertParameters(node.parameters);\n            /**\n             * TypeScript class methods can be defined as \"abstract\"\n             */\n\n            const methodDefinitionType = (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node) ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition : ts_estree_1.AST_NODE_TYPES.MethodDefinition;\n            result = this.createNode(node, {\n              type: methodDefinitionType,\n              key: this.convertChild(node.name),\n              value: method,\n              computed: (0, node_utils_1.isComputedProperty)(node.name),\n              static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),\n              kind: 'method',\n              override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node)\n            });\n            const decorators = (0, getModifiers_1.getDecorators)(node);\n\n            if (decorators) {\n              result.decorators = decorators.map(el => this.convertChild(el));\n            }\n\n            const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n\n            if (accessibility) {\n              result.accessibility = accessibility;\n            }\n          }\n\n          if (node.questionToken) {\n            result.optional = true;\n          }\n\n          if (node.kind === SyntaxKind.GetAccessor) {\n            result.kind = 'get';\n          } else if (node.kind === SyntaxKind.SetAccessor) {\n            result.kind = 'set';\n          } else if (!result.static && node.name.kind === SyntaxKind.StringLiteral && node.name.text === 'constructor' && result.type !== ts_estree_1.AST_NODE_TYPES.Property) {\n            result.kind = 'constructor';\n          }\n\n          return result;\n        }\n      // TypeScript uses this even for static methods named \"constructor\"\n\n      case SyntaxKind.Constructor:\n        {\n          const lastModifier = (0, node_utils_1.getLastModifier)(node);\n          const constructorToken = lastModifier && (0, node_utils_1.findNextToken)(lastModifier, node, this.ast) || node.getFirstToken();\n          const constructor = this.createNode(node, {\n            type: !node.body ? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression : ts_estree_1.AST_NODE_TYPES.FunctionExpression,\n            id: null,\n            params: this.convertParameters(node.parameters),\n            generator: false,\n            expression: false,\n            async: false,\n            body: this.convertChild(node.body),\n            range: [node.parameters.pos - 1, node.end]\n          }); // Process typeParameters\n\n          if (node.typeParameters) {\n            constructor.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n            this.fixParentLocation(constructor, constructor.typeParameters.range);\n          } // Process returnType\n\n\n          if (node.type) {\n            constructor.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n\n          const constructorKey = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Identifier,\n            name: 'constructor',\n            range: [constructorToken.getStart(this.ast), constructorToken.end]\n          });\n          const isStatic = (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node);\n          const result = this.createNode(node, {\n            type: (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node) ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition : ts_estree_1.AST_NODE_TYPES.MethodDefinition,\n            key: constructorKey,\n            value: constructor,\n            computed: false,\n            static: isStatic,\n            kind: isStatic ? 'method' : 'constructor',\n            override: false\n          });\n          const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n\n          if (accessibility) {\n            result.accessibility = accessibility;\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.FunctionExpression:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.FunctionExpression,\n            id: this.convertChild(node.name),\n            generator: !!node.asteriskToken,\n            params: this.convertParameters(node.parameters),\n            body: this.convertChild(node.body),\n            async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n            expression: false\n          }); // Process returnType\n\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          } // Process typeParameters\n\n\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.SuperKeyword:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.Super\n        });\n\n      case SyntaxKind.ArrayBindingPattern:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,\n          elements: node.elements.map(el => this.convertPattern(el))\n        });\n      // occurs with missing array elements like [,]\n\n      case SyntaxKind.OmittedExpression:\n        return null;\n\n      case SyntaxKind.ObjectBindingPattern:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,\n          properties: node.elements.map(el => this.convertPattern(el))\n        });\n\n      case SyntaxKind.BindingElement:\n        {\n          if (parent.kind === SyntaxKind.ArrayBindingPattern) {\n            const arrayItem = this.convertChild(node.name, parent);\n\n            if (node.initializer) {\n              return this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                left: arrayItem,\n                right: this.convertChild(node.initializer)\n              });\n            } else if (node.dotDotDotToken) {\n              return this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.RestElement,\n                argument: arrayItem\n              });\n            } else {\n              return arrayItem;\n            }\n          } else {\n            let result;\n\n            if (node.dotDotDotToken) {\n              result = this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.RestElement,\n                argument: this.convertChild((_a = node.propertyName) !== null && _a !== void 0 ? _a : node.name)\n              });\n            } else {\n              result = this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.Property,\n                key: this.convertChild((_b = node.propertyName) !== null && _b !== void 0 ? _b : node.name),\n                value: this.convertChild(node.name),\n                computed: Boolean(node.propertyName && node.propertyName.kind === SyntaxKind.ComputedPropertyName),\n                method: false,\n                shorthand: !node.propertyName,\n                kind: 'init'\n              });\n            }\n\n            if (node.initializer) {\n              result.value = this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                left: this.convertChild(node.name),\n                right: this.convertChild(node.initializer),\n                range: [node.name.getStart(this.ast), node.initializer.end]\n              });\n            }\n\n            return result;\n          }\n        }\n\n      case SyntaxKind.ArrowFunction:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ArrowFunctionExpression,\n            generator: false,\n            id: null,\n            params: this.convertParameters(node.parameters),\n            body: this.convertChild(node.body),\n            async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n            expression: node.body.kind !== SyntaxKind.Block\n          }); // Process returnType\n\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          } // Process typeParameters\n\n\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.YieldExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.YieldExpression,\n          delegate: !!node.asteriskToken,\n          argument: this.convertChild(node.expression)\n        });\n\n      case SyntaxKind.AwaitExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.AwaitExpression,\n          argument: this.convertChild(node.expression)\n        });\n      // Template Literals\n\n      case SyntaxKind.NoSubstitutionTemplateLiteral:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,\n          quasis: [this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TemplateElement,\n            value: {\n              raw: this.ast.text.slice(node.getStart(this.ast) + 1, node.end - 1),\n              cooked: node.text\n            },\n            tail: true\n          })],\n          expressions: []\n        });\n\n      case SyntaxKind.TemplateExpression:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,\n            quasis: [this.convertChild(node.head)],\n            expressions: []\n          });\n          node.templateSpans.forEach(templateSpan => {\n            result.expressions.push(this.convertChild(templateSpan.expression));\n            result.quasis.push(this.convertChild(templateSpan.literal));\n          });\n          return result;\n        }\n\n      case SyntaxKind.TaggedTemplateExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TaggedTemplateExpression,\n          typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined,\n          tag: this.convertChild(node.tag),\n          quasi: this.convertChild(node.template)\n        });\n\n      case SyntaxKind.TemplateHead:\n      case SyntaxKind.TemplateMiddle:\n      case SyntaxKind.TemplateTail:\n        {\n          const tail = node.kind === SyntaxKind.TemplateTail;\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TemplateElement,\n            value: {\n              raw: this.ast.text.slice(node.getStart(this.ast) + 1, node.end - (tail ? 1 : 2)),\n              cooked: node.text\n            },\n            tail\n          });\n        }\n      // Patterns\n\n      case SyntaxKind.SpreadAssignment:\n      case SyntaxKind.SpreadElement:\n        {\n          if (this.allowPattern) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.RestElement,\n              argument: this.convertPattern(node.expression)\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.SpreadElement,\n              argument: this.convertChild(node.expression)\n            });\n          }\n        }\n\n      case SyntaxKind.Parameter:\n        {\n          let parameter;\n          let result;\n\n          if (node.dotDotDotToken) {\n            parameter = result = this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.RestElement,\n              argument: this.convertChild(node.name)\n            });\n          } else if (node.initializer) {\n            parameter = this.convertChild(node.name);\n            result = this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n              left: parameter,\n              right: this.convertChild(node.initializer)\n            });\n            const modifiers = (0, getModifiers_1.getModifiers)(node);\n\n            if (modifiers) {\n              // AssignmentPattern should not contain modifiers in range\n              result.range[0] = parameter.range[0];\n              result.loc = (0, node_utils_1.getLocFor)(result.range[0], result.range[1], this.ast);\n            }\n          } else {\n            parameter = result = this.convertChild(node.name, parent);\n          }\n\n          if (node.type) {\n            parameter.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n            this.fixParentLocation(parameter, parameter.typeAnnotation.range);\n          }\n\n          if (node.questionToken) {\n            if (node.questionToken.end > parameter.range[1]) {\n              parameter.range[1] = node.questionToken.end;\n              parameter.loc.end = (0, node_utils_1.getLineAndCharacterFor)(parameter.range[1], this.ast);\n            }\n\n            parameter.optional = true;\n          }\n\n          const modifiers = (0, getModifiers_1.getModifiers)(node);\n\n          if (modifiers) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSParameterProperty,\n              accessibility: (_c = (0, node_utils_1.getTSNodeAccessibility)(node)) !== null && _c !== void 0 ? _c : undefined,\n              readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || undefined,\n              static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node) || undefined,\n              export: (0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node) || undefined,\n              override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node) || undefined,\n              parameter: result\n            });\n          }\n\n          return result;\n        }\n      // Classes\n\n      case SyntaxKind.ClassDeclaration:\n      case SyntaxKind.ClassExpression:\n        {\n          const heritageClauses = (_d = node.heritageClauses) !== null && _d !== void 0 ? _d : [];\n          const classNodeType = node.kind === SyntaxKind.ClassDeclaration ? ts_estree_1.AST_NODE_TYPES.ClassDeclaration : ts_estree_1.AST_NODE_TYPES.ClassExpression;\n          const superClass = heritageClauses.find(clause => clause.token === SyntaxKind.ExtendsKeyword);\n          const implementsClause = heritageClauses.find(clause => clause.token === SyntaxKind.ImplementsKeyword);\n          const result = this.createNode(node, {\n            type: classNodeType,\n            id: this.convertChild(node.name),\n            body: this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ClassBody,\n              body: [],\n              range: [node.members.pos - 1, node.end]\n            }),\n            superClass: (superClass === null || superClass === void 0 ? void 0 : superClass.types[0]) ? this.convertChild(superClass.types[0].expression) : null\n          });\n\n          if (superClass) {\n            if (superClass.types.length > 1) {\n              throw (0, node_utils_1.createError)(this.ast, superClass.types[1].pos, 'Classes can only extend a single class.');\n            }\n\n            if ((_e = superClass.types[0]) === null || _e === void 0 ? void 0 : _e.typeArguments) {\n              result.superTypeParameters = this.convertTypeArgumentsToTypeParameters(superClass.types[0].typeArguments, superClass.types[0]);\n            }\n          }\n\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n\n          if (implementsClause) {\n            result.implements = implementsClause.types.map(el => this.convertChild(el));\n          }\n          /**\n           * TypeScript class declarations can be defined as \"abstract\"\n           */\n\n\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)) {\n            result.abstract = true;\n          }\n\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {\n            result.declare = true;\n          }\n\n          const decorators = (0, getModifiers_1.getDecorators)(node);\n\n          if (decorators) {\n            result.decorators = decorators.map(el => this.convertChild(el));\n          }\n\n          const filteredMembers = node.members.filter(node_utils_1.isESTreeClassMember);\n\n          if (filteredMembers.length) {\n            result.body.body = filteredMembers.map(el => this.convertChild(el));\n          } // check for exports\n\n\n          return this.fixExports(node, result);\n        }\n      // Modules\n\n      case SyntaxKind.ModuleBlock:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TSModuleBlock,\n          body: this.convertBodyExpressions(node.statements, node)\n        });\n\n      case SyntaxKind.ImportDeclaration:\n        {\n          this.assertModuleSpecifier(node, false);\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ImportDeclaration,\n            source: this.convertChild(node.moduleSpecifier),\n            specifiers: [],\n            importKind: 'value',\n            assertions: this.convertAssertClasue(node.assertClause)\n          });\n\n          if (node.importClause) {\n            if (node.importClause.isTypeOnly) {\n              result.importKind = 'type';\n            }\n\n            if (node.importClause.name) {\n              result.specifiers.push(this.convertChild(node.importClause));\n            }\n\n            if (node.importClause.namedBindings) {\n              switch (node.importClause.namedBindings.kind) {\n                case SyntaxKind.NamespaceImport:\n                  result.specifiers.push(this.convertChild(node.importClause.namedBindings));\n                  break;\n\n                case SyntaxKind.NamedImports:\n                  result.specifiers = result.specifiers.concat(node.importClause.namedBindings.elements.map(el => this.convertChild(el)));\n                  break;\n              }\n            }\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.NamespaceImport:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ImportNamespaceSpecifier,\n          local: this.convertChild(node.name)\n        });\n\n      case SyntaxKind.ImportSpecifier:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ImportSpecifier,\n          local: this.convertChild(node.name),\n          imported: this.convertChild((_f = node.propertyName) !== null && _f !== void 0 ? _f : node.name),\n          importKind: node.isTypeOnly ? 'type' : 'value'\n        });\n\n      case SyntaxKind.ImportClause:\n        {\n          const local = this.convertChild(node.name);\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ImportDefaultSpecifier,\n            local,\n            range: local.range\n          });\n        }\n\n      case SyntaxKind.ExportDeclaration:\n        {\n          if (((_g = node.exportClause) === null || _g === void 0 ? void 0 : _g.kind) === SyntaxKind.NamedExports) {\n            this.assertModuleSpecifier(node, true);\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,\n              source: this.convertChild(node.moduleSpecifier),\n              specifiers: node.exportClause.elements.map(el => this.convertChild(el)),\n              exportKind: node.isTypeOnly ? 'type' : 'value',\n              declaration: null,\n              assertions: this.convertAssertClasue(node.assertClause)\n            });\n          } else {\n            this.assertModuleSpecifier(node, false);\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ExportAllDeclaration,\n              source: this.convertChild(node.moduleSpecifier),\n              exportKind: node.isTypeOnly ? 'type' : 'value',\n              exported: // note - for compat with 3.7.x, where node.exportClause is always undefined and\n              //        SyntaxKind.NamespaceExport does not exist yet (i.e. is undefined), this\n              //        cannot be shortened to an optional chain, or else you end up with\n              //        undefined === undefined, and the true path will hard error at runtime\n              node.exportClause && node.exportClause.kind === SyntaxKind.NamespaceExport ? this.convertChild(node.exportClause.name) : null,\n              assertions: this.convertAssertClasue(node.assertClause)\n            });\n          }\n        }\n\n      case SyntaxKind.ExportSpecifier:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ExportSpecifier,\n          local: this.convertChild((_h = node.propertyName) !== null && _h !== void 0 ? _h : node.name),\n          exported: this.convertChild(node.name),\n          exportKind: node.isTypeOnly ? 'type' : 'value'\n        });\n\n      case SyntaxKind.ExportAssignment:\n        if (node.isExportEquals) {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSExportAssignment,\n            expression: this.convertChild(node.expression)\n          });\n        } else {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,\n            declaration: this.convertChild(node.expression),\n            exportKind: 'value'\n          });\n        }\n\n      // Unary Operations\n\n      case SyntaxKind.PrefixUnaryExpression:\n      case SyntaxKind.PostfixUnaryExpression:\n        {\n          const operator = (0, node_utils_1.getTextForTokenKind)(node.operator);\n          /**\n           * ESTree uses UpdateExpression for ++/--\n           */\n\n          if (operator === '++' || operator === '--') {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.UpdateExpression,\n              operator,\n              prefix: node.kind === SyntaxKind.PrefixUnaryExpression,\n              argument: this.convertChild(node.operand)\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n              operator,\n              prefix: node.kind === SyntaxKind.PrefixUnaryExpression,\n              argument: this.convertChild(node.operand)\n            });\n          }\n        }\n\n      case SyntaxKind.DeleteExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n          operator: 'delete',\n          prefix: true,\n          argument: this.convertChild(node.expression)\n        });\n\n      case SyntaxKind.VoidExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n          operator: 'void',\n          prefix: true,\n          argument: this.convertChild(node.expression)\n        });\n\n      case SyntaxKind.TypeOfExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n          operator: 'typeof',\n          prefix: true,\n          argument: this.convertChild(node.expression)\n        });\n\n      case SyntaxKind.TypeOperator:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TSTypeOperator,\n          operator: (0, node_utils_1.getTextForTokenKind)(node.operator),\n          typeAnnotation: this.convertChild(node.type)\n        });\n      // Binary Operations\n\n      case SyntaxKind.BinaryExpression:\n        {\n          // TypeScript uses BinaryExpression for sequences as well\n          if ((0, node_utils_1.isComma)(node.operatorToken)) {\n            const result = this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.SequenceExpression,\n              expressions: []\n            });\n            const left = this.convertChild(node.left);\n\n            if (left.type === ts_estree_1.AST_NODE_TYPES.SequenceExpression && node.left.kind !== SyntaxKind.ParenthesizedExpression) {\n              result.expressions = result.expressions.concat(left.expressions);\n            } else {\n              result.expressions.push(left);\n            }\n\n            result.expressions.push(this.convertChild(node.right));\n            return result;\n          } else {\n            const type = (0, node_utils_1.getBinaryExpressionType)(node.operatorToken);\n\n            if (this.allowPattern && type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression) {\n              return this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                left: this.convertPattern(node.left, node),\n                right: this.convertChild(node.right)\n              });\n            }\n\n            return this.createNode(node, {\n              type,\n              operator: (0, node_utils_1.getTextForTokenKind)(node.operatorToken.kind),\n              left: this.converter(node.left, node, this.inTypeMode, type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression),\n              right: this.convertChild(node.right)\n            });\n          }\n        }\n\n      case SyntaxKind.PropertyAccessExpression:\n        {\n          const object = this.convertChild(node.expression);\n          const property = this.convertChild(node.name);\n          const computed = false;\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.MemberExpression,\n            object,\n            property,\n            computed,\n            optional: node.questionDotToken !== undefined\n          });\n          return this.convertChainExpression(result, node);\n        }\n\n      case SyntaxKind.ElementAccessExpression:\n        {\n          const object = this.convertChild(node.expression);\n          const property = this.convertChild(node.argumentExpression);\n          const computed = true;\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.MemberExpression,\n            object,\n            property,\n            computed,\n            optional: node.questionDotToken !== undefined\n          });\n          return this.convertChainExpression(result, node);\n        }\n\n      case SyntaxKind.CallExpression:\n        {\n          if (node.expression.kind === SyntaxKind.ImportKeyword) {\n            if (node.arguments.length !== 1 && node.arguments.length !== 2) {\n              throw (0, node_utils_1.createError)(this.ast, node.arguments.pos, 'Dynamic import requires exactly one or two arguments.');\n            }\n\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ImportExpression,\n              source: this.convertChild(node.arguments[0]),\n              attributes: node.arguments[1] ? this.convertChild(node.arguments[1]) : null\n            });\n          }\n\n          const callee = this.convertChild(node.expression);\n          const args = node.arguments.map(el => this.convertChild(el));\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.CallExpression,\n            callee,\n            arguments: args,\n            optional: node.questionDotToken !== undefined\n          });\n\n          if (node.typeArguments) {\n            result.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);\n          }\n\n          return this.convertChainExpression(result, node);\n        }\n\n      case SyntaxKind.NewExpression:\n        {\n          // NOTE - NewExpression cannot have an optional chain in it\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.NewExpression,\n            callee: this.convertChild(node.expression),\n            arguments: node.arguments ? node.arguments.map(el => this.convertChild(el)) : []\n          });\n\n          if (node.typeArguments) {\n            result.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.ConditionalExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ConditionalExpression,\n          test: this.convertChild(node.condition),\n          consequent: this.convertChild(node.whenTrue),\n          alternate: this.convertChild(node.whenFalse)\n        });\n\n      case SyntaxKind.MetaProperty:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.MetaProperty,\n            meta: this.createNode( // TODO: do we really want to convert it to Token?\n            node.getFirstToken(), {\n              type: ts_estree_1.AST_NODE_TYPES.Identifier,\n              name: (0, node_utils_1.getTextForTokenKind)(node.keywordToken)\n            }),\n            property: this.convertChild(node.name)\n          });\n        }\n\n      case SyntaxKind.Decorator:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Decorator,\n            expression: this.convertChild(node.expression)\n          });\n        }\n      // Literals\n\n      case SyntaxKind.StringLiteral:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            value: parent.kind === SyntaxKind.JsxAttribute ? (0, node_utils_1.unescapeStringLiteralText)(node.text) : node.text,\n            raw: node.getText()\n          });\n        }\n\n      case SyntaxKind.NumericLiteral:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            value: Number(node.text),\n            raw: node.getText()\n          });\n        }\n\n      case SyntaxKind.BigIntLiteral:\n        {\n          const range = (0, node_utils_1.getRange)(node, this.ast);\n          const rawValue = this.ast.text.slice(range[0], range[1]);\n          const bigint = rawValue // remove suffix `n`\n          .slice(0, -1) // `BigInt` doesn't accept numeric separator\n          // and `bigint` property should not include numeric separator\n          .replace(/_/g, '');\n          const value = typeof BigInt !== 'undefined' ? BigInt(bigint) : null;\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            raw: rawValue,\n            value: value,\n            bigint: value === null ? bigint : String(value),\n            range\n          });\n        }\n\n      case SyntaxKind.RegularExpressionLiteral:\n        {\n          const pattern = node.text.slice(1, node.text.lastIndexOf('/'));\n          const flags = node.text.slice(node.text.lastIndexOf('/') + 1);\n          let regex = null;\n\n          try {\n            regex = new RegExp(pattern, flags);\n          } catch (exception) {\n            regex = null;\n          }\n\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            value: regex,\n            raw: node.text,\n            regex: {\n              pattern,\n              flags\n            }\n          });\n        }\n\n      case SyntaxKind.TrueKeyword:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.Literal,\n          value: true,\n          raw: 'true'\n        });\n\n      case SyntaxKind.FalseKeyword:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.Literal,\n          value: false,\n          raw: 'false'\n        });\n\n      case SyntaxKind.NullKeyword:\n        {\n          if (!version_check_1.typescriptVersionIsAtLeast['4.0'] && this.inTypeMode) {\n            // 4.0 started nesting null types inside a LiteralType node, but we still need to support pre-4.0\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword\n            });\n          }\n\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            value: null,\n            raw: 'null'\n          });\n        }\n\n      case SyntaxKind.EmptyStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.EmptyStatement\n        });\n\n      case SyntaxKind.DebuggerStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.DebuggerStatement\n        });\n      // JSX\n\n      case SyntaxKind.JsxElement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXElement,\n          openingElement: this.convertChild(node.openingElement),\n          closingElement: this.convertChild(node.closingElement),\n          children: node.children.map(el => this.convertChild(el))\n        });\n\n      case SyntaxKind.JsxFragment:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXFragment,\n          openingFragment: this.convertChild(node.openingFragment),\n          closingFragment: this.convertChild(node.closingFragment),\n          children: node.children.map(el => this.convertChild(el))\n        });\n\n      case SyntaxKind.JsxSelfClosingElement:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.JSXElement,\n\n            /**\n             * Convert SyntaxKind.JsxSelfClosingElement to SyntaxKind.JsxOpeningElement,\n             * TypeScript does not seem to have the idea of openingElement when tag is self-closing\n             */\n            openingElement: this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,\n              typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined,\n              selfClosing: true,\n              name: this.convertJSXTagName(node.tagName, node),\n              attributes: node.attributes.properties.map(el => this.convertChild(el)),\n              range: (0, node_utils_1.getRange)(node, this.ast)\n            }),\n            closingElement: null,\n            children: []\n          });\n        }\n\n      case SyntaxKind.JsxOpeningElement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,\n          typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined,\n          selfClosing: false,\n          name: this.convertJSXTagName(node.tagName, node),\n          attributes: node.attributes.properties.map(el => this.convertChild(el))\n        });\n\n      case SyntaxKind.JsxClosingElement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXClosingElement,\n          name: this.convertJSXTagName(node.tagName, node)\n        });\n\n      case SyntaxKind.JsxOpeningFragment:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXOpeningFragment\n        });\n\n      case SyntaxKind.JsxClosingFragment:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXClosingFragment\n        });\n\n      case SyntaxKind.JsxExpression:\n        {\n          const expression = node.expression ? this.convertChild(node.expression) : this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.JSXEmptyExpression,\n            range: [node.getStart(this.ast) + 1, node.getEnd() - 1]\n          });\n\n          if (node.dotDotDotToken) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.JSXSpreadChild,\n              expression\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.JSXExpressionContainer,\n              expression\n            });\n          }\n        }\n\n      case SyntaxKind.JsxAttribute:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.JSXAttribute,\n            name: this.convertJSXNamespaceOrIdentifier(node.name),\n            value: this.convertChild(node.initializer)\n          });\n        }\n\n      case SyntaxKind.JsxText:\n        {\n          const start = node.getFullStart();\n          const end = node.getEnd();\n          const text = this.ast.text.slice(start, end);\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.JSXText,\n            value: (0, node_utils_1.unescapeStringLiteralText)(text),\n            raw: text,\n            range: [start, end]\n          });\n        }\n\n      case SyntaxKind.JsxSpreadAttribute:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXSpreadAttribute,\n          argument: this.convertChild(node.expression)\n        });\n\n      case SyntaxKind.QualifiedName:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSQualifiedName,\n            left: this.convertChild(node.left),\n            right: this.convertChild(node.right)\n          });\n        }\n      // TypeScript specific\n\n      case SyntaxKind.TypeReference:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeReference,\n            typeName: this.convertType(node.typeName),\n            typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined\n          });\n        }\n\n      case SyntaxKind.TypeParameter:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeParameter,\n            name: this.convertType(node.name),\n            constraint: node.constraint ? this.convertType(node.constraint) : undefined,\n            default: node.default ? this.convertType(node.default) : undefined,\n            in: (0, node_utils_1.hasModifier)(SyntaxKind.InKeyword, node),\n            out: (0, node_utils_1.hasModifier)(SyntaxKind.OutKeyword, node)\n          });\n        }\n\n      case SyntaxKind.ThisType:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TSThisType\n        });\n\n      case SyntaxKind.AnyKeyword:\n      case SyntaxKind.BigIntKeyword:\n      case SyntaxKind.BooleanKeyword:\n      case SyntaxKind.NeverKeyword:\n      case SyntaxKind.NumberKeyword:\n      case SyntaxKind.ObjectKeyword:\n      case SyntaxKind.StringKeyword:\n      case SyntaxKind.SymbolKeyword:\n      case SyntaxKind.UnknownKeyword:\n      case SyntaxKind.VoidKeyword:\n      case SyntaxKind.UndefinedKeyword:\n      case SyntaxKind.IntrinsicKeyword:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES[`TS${SyntaxKind[node.kind]}`]\n          });\n        }\n\n      case SyntaxKind.NonNullExpression:\n        {\n          const nnExpr = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSNonNullExpression,\n            expression: this.convertChild(node.expression)\n          });\n          return this.convertChainExpression(nnExpr, node);\n        }\n\n      case SyntaxKind.TypeLiteral:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeLiteral,\n            members: node.members.map(el => this.convertChild(el))\n          });\n        }\n\n      case SyntaxKind.ArrayType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSArrayType,\n            elementType: this.convertType(node.elementType)\n          });\n        }\n\n      case SyntaxKind.IndexedAccessType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSIndexedAccessType,\n            objectType: this.convertType(node.objectType),\n            indexType: this.convertType(node.indexType)\n          });\n        }\n\n      case SyntaxKind.ConditionalType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSConditionalType,\n            checkType: this.convertType(node.checkType),\n            extendsType: this.convertType(node.extendsType),\n            trueType: this.convertType(node.trueType),\n            falseType: this.convertType(node.falseType)\n          });\n        }\n\n      case SyntaxKind.TypeQuery:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeQuery,\n            exprName: this.convertType(node.exprName),\n            typeParameters: node.typeArguments && this.convertTypeArgumentsToTypeParameters(node.typeArguments, node)\n          });\n        }\n\n      case SyntaxKind.MappedType:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSMappedType,\n            typeParameter: this.convertType(node.typeParameter),\n            nameType: (_j = this.convertType(node.nameType)) !== null && _j !== void 0 ? _j : null\n          });\n\n          if (node.readonlyToken) {\n            if (node.readonlyToken.kind === SyntaxKind.ReadonlyKeyword) {\n              result.readonly = true;\n            } else {\n              result.readonly = (0, node_utils_1.getTextForTokenKind)(node.readonlyToken.kind);\n            }\n          }\n\n          if (node.questionToken) {\n            if (node.questionToken.kind === SyntaxKind.QuestionToken) {\n              result.optional = true;\n            } else {\n              result.optional = (0, node_utils_1.getTextForTokenKind)(node.questionToken.kind);\n            }\n          }\n\n          if (node.type) {\n            result.typeAnnotation = this.convertType(node.type);\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.ParenthesizedExpression:\n        return this.convertChild(node.expression, parent);\n\n      case SyntaxKind.TypeAliasDeclaration:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration,\n            id: this.convertChild(node.name),\n            typeAnnotation: this.convertType(node.type)\n          });\n\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {\n            result.declare = true;\n          } // Process typeParameters\n\n\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          } // check for exports\n\n\n          return this.fixExports(node, result);\n        }\n\n      case SyntaxKind.MethodSignature:\n        {\n          return this.convertMethodSignature(node);\n        }\n\n      case SyntaxKind.PropertySignature:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSPropertySignature,\n            optional: (0, node_utils_1.isOptional)(node) || undefined,\n            computed: (0, node_utils_1.isComputedProperty)(node.name),\n            key: this.convertChild(node.name),\n            typeAnnotation: node.type ? this.convertTypeAnnotation(node.type, node) : undefined,\n            initializer: this.convertChild( // eslint-disable-next-line deprecation/deprecation -- TODO breaking change remove this from the AST\n            node.initializer) || undefined,\n            readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || undefined,\n            static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node) || undefined,\n            export: (0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node) || undefined\n          });\n          const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n\n          if (accessibility) {\n            result.accessibility = accessibility;\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.IndexSignature:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSIndexSignature,\n            parameters: node.parameters.map(el => this.convertChild(el))\n          });\n\n          if (node.type) {\n            result.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n          }\n\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node)) {\n            result.readonly = true;\n          }\n\n          const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n\n          if (accessibility) {\n            result.accessibility = accessibility;\n          }\n\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)) {\n            result.export = true;\n          }\n\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node)) {\n            result.static = true;\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.ConstructorType:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSConstructorType,\n            params: this.convertParameters(node.parameters),\n            abstract: (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)\n          });\n\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.FunctionType:\n      case SyntaxKind.ConstructSignature:\n      case SyntaxKind.CallSignature:\n        {\n          const type = node.kind === SyntaxKind.ConstructSignature ? ts_estree_1.AST_NODE_TYPES.TSConstructSignatureDeclaration : node.kind === SyntaxKind.CallSignature ? ts_estree_1.AST_NODE_TYPES.TSCallSignatureDeclaration : ts_estree_1.AST_NODE_TYPES.TSFunctionType;\n          const result = this.createNode(node, {\n            type: type,\n            params: this.convertParameters(node.parameters)\n          });\n\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.ExpressionWithTypeArguments:\n        {\n          const parentKind = parent.kind;\n          const type = parentKind === SyntaxKind.InterfaceDeclaration ? ts_estree_1.AST_NODE_TYPES.TSInterfaceHeritage : parentKind === SyntaxKind.HeritageClause ? ts_estree_1.AST_NODE_TYPES.TSClassImplements : ts_estree_1.AST_NODE_TYPES.TSInstantiationExpression;\n          const result = this.createNode(node, {\n            type,\n            expression: this.convertChild(node.expression)\n          });\n\n          if (node.typeArguments) {\n            result.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.InterfaceDeclaration:\n        {\n          const interfaceHeritageClauses = (_k = node.heritageClauses) !== null && _k !== void 0 ? _k : [];\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration,\n            body: this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSInterfaceBody,\n              body: node.members.map(member => this.convertChild(member)),\n              range: [node.members.pos - 1, node.end]\n            }),\n            id: this.convertChild(node.name)\n          });\n\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n\n          if (interfaceHeritageClauses.length > 0) {\n            const interfaceExtends = [];\n            const interfaceImplements = [];\n\n            for (const heritageClause of interfaceHeritageClauses) {\n              if (heritageClause.token === SyntaxKind.ExtendsKeyword) {\n                for (const n of heritageClause.types) {\n                  interfaceExtends.push(this.convertChild(n, node));\n                }\n              } else {\n                for (const n of heritageClause.types) {\n                  interfaceImplements.push(this.convertChild(n, node));\n                }\n              }\n            }\n\n            if (interfaceExtends.length) {\n              result.extends = interfaceExtends;\n            }\n\n            if (interfaceImplements.length) {\n              result.implements = interfaceImplements;\n            }\n          }\n\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)) {\n            result.abstract = true;\n          }\n\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {\n            result.declare = true;\n          } // check for exports\n\n\n          return this.fixExports(node, result);\n        }\n\n      case SyntaxKind.TypePredicate:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypePredicate,\n            asserts: node.assertsModifier !== undefined,\n            parameterName: this.convertChild(node.parameterName),\n            typeAnnotation: null\n          });\n          /**\n           * Specific fix for type-guard location data\n           */\n\n          if (node.type) {\n            result.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n            result.typeAnnotation.loc = result.typeAnnotation.typeAnnotation.loc;\n            result.typeAnnotation.range = result.typeAnnotation.typeAnnotation.range;\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.ImportType:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TSImportType,\n          isTypeOf: !!node.isTypeOf,\n          parameter: this.convertChild(node.argument),\n          qualifier: this.convertChild(node.qualifier),\n          typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : null\n        });\n\n      case SyntaxKind.EnumDeclaration:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSEnumDeclaration,\n            id: this.convertChild(node.name),\n            members: node.members.map(el => this.convertChild(el))\n          }); // apply modifiers first...\n\n          this.applyModifiersToResult(result, (0, getModifiers_1.getModifiers)(node)); // ...then check for exports\n\n          return this.fixExports(node, result);\n        }\n\n      case SyntaxKind.EnumMember:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSEnumMember,\n            id: this.convertChild(node.name)\n          });\n\n          if (node.initializer) {\n            result.initializer = this.convertChild(node.initializer);\n          }\n\n          if (node.name.kind === ts.SyntaxKind.ComputedPropertyName) {\n            result.computed = true;\n          }\n\n          return result;\n        }\n\n      case SyntaxKind.ModuleDeclaration:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration,\n            id: this.convertChild(node.name)\n          });\n\n          if (node.body) {\n            result.body = this.convertChild(node.body);\n          } // apply modifiers first...\n\n\n          this.applyModifiersToResult(result, (0, getModifiers_1.getModifiers)(node));\n\n          if (node.flags & ts.NodeFlags.GlobalAugmentation) {\n            result.global = true;\n          } // ...then check for exports\n\n\n          return this.fixExports(node, result);\n        }\n      // TypeScript specific types\n\n      case SyntaxKind.ParenthesizedType:\n        {\n          return this.convertType(node.type);\n        }\n\n      case SyntaxKind.UnionType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSUnionType,\n            types: node.types.map(el => this.convertType(el))\n          });\n        }\n\n      case SyntaxKind.IntersectionType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSIntersectionType,\n            types: node.types.map(el => this.convertType(el))\n          });\n        }\n\n      case SyntaxKind.AsExpression:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSAsExpression,\n            expression: this.convertChild(node.expression),\n            typeAnnotation: this.convertType(node.type)\n          });\n        }\n\n      case SyntaxKind.InferType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSInferType,\n            typeParameter: this.convertType(node.typeParameter)\n          });\n        }\n\n      case SyntaxKind.LiteralType:\n        {\n          if (version_check_1.typescriptVersionIsAtLeast['4.0'] && node.literal.kind === SyntaxKind.NullKeyword) {\n            // 4.0 started nesting null types inside a LiteralType node\n            // but our AST is designed around the old way of null being a keyword\n            return this.createNode(node.literal, {\n              type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSLiteralType,\n              literal: this.convertType(node.literal)\n            });\n          }\n        }\n\n      case SyntaxKind.TypeAssertionExpression:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeAssertion,\n            typeAnnotation: this.convertType(node.type),\n            expression: this.convertChild(node.expression)\n          });\n        }\n\n      case SyntaxKind.ImportEqualsDeclaration:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSImportEqualsDeclaration,\n            id: this.convertChild(node.name),\n            moduleReference: this.convertChild(node.moduleReference),\n            importKind: node.isTypeOnly ? 'type' : 'value',\n            isExport: (0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)\n          });\n        }\n\n      case SyntaxKind.ExternalModuleReference:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSExternalModuleReference,\n            expression: this.convertChild(node.expression)\n          });\n        }\n\n      case SyntaxKind.NamespaceExportDeclaration:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSNamespaceExportDeclaration,\n            id: this.convertChild(node.name)\n          });\n        }\n\n      case SyntaxKind.AbstractKeyword:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSAbstractKeyword\n          });\n        }\n      // Tuple\n\n      case SyntaxKind.TupleType:\n        {\n          // In TS 4.0, the `elementTypes` property was changed to `elements`.\n          // To support both at compile time, we cast to access the newer version\n          // if the former does not exist.\n          const elementTypes = 'elementTypes' in node ? node.elementTypes.map(el => this.convertType(el)) : node.elements.map(el => this.convertType(el));\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTupleType,\n            elementTypes\n          });\n        }\n\n      case SyntaxKind.NamedTupleMember:\n        {\n          const member = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSNamedTupleMember,\n            elementType: this.convertType(node.type, node),\n            label: this.convertChild(node.name, node),\n            optional: node.questionToken != null\n          });\n\n          if (node.dotDotDotToken) {\n            // adjust the start to account for the \"...\"\n            member.range[0] = member.label.range[0];\n            member.loc.start = member.label.loc.start;\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSRestType,\n              typeAnnotation: member\n            });\n          }\n\n          return member;\n        }\n\n      case SyntaxKind.OptionalType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSOptionalType,\n            typeAnnotation: this.convertType(node.type)\n          });\n        }\n\n      case SyntaxKind.RestType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSRestType,\n            typeAnnotation: this.convertType(node.type)\n          });\n        }\n      // Template Literal Types\n\n      case SyntaxKind.TemplateLiteralType:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTemplateLiteralType,\n            quasis: [this.convertChild(node.head)],\n            types: []\n          });\n          node.templateSpans.forEach(templateSpan => {\n            result.types.push(this.convertChild(templateSpan.type));\n            result.quasis.push(this.convertChild(templateSpan.literal));\n          });\n          return result;\n        }\n\n      case SyntaxKind.ClassStaticBlockDeclaration:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.StaticBlock,\n            body: this.convertBodyExpressions(node.body.statements, node)\n          });\n        }\n\n      case SyntaxKind.AssertEntry:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ImportAttribute,\n            key: this.convertChild(node.name),\n            value: this.convertChild(node.value)\n          });\n        }\n\n      default:\n        return this.deeplyCopy(node);\n    }\n  }\n\n}\n\nexports.Converter = Converter;","map":{"version":3,"mappings":"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","names":["SyntaxKind","ts","convertError","error","file","start","message","messageText","exports","Converter","constructor","ast","options","WeakMap","Object","getASTMaps","esTreeNodeToTSNodeMap","tsNodeToESTreeNodeMap","convertProgram","converter","node","parent","inTypeMode","allowPattern","typeMode","pattern","undefined","result","convertNode","registerTSNodeInNodeMap","fixExports","modifiers","kind","ExportKeyword","exportKeyword","nextModifier","declarationIsDefault","DefaultKeyword","varToken","range","getStart","loc","createNode","type","ts_estree_1","ExportDefaultDeclaration","declaration","exportKind","isType","TSInterfaceDeclaration","TSTypeAliasDeclaration","isDeclare","declare","ExportNamedDeclaration","specifiers","source","assertions","shouldPreserveNodeMaps","has","set","convertPattern","child","convertChild","convertType","data","convertBindingNameWithTypeAnnotation","name","tsType","id","typeAnnotation","convertTypeAnnotation","fixParentLocation","offset","FunctionType","ConstructorType","annotationStartCol","getFullStart","end","TSTypeAnnotation","convertBodyExpressions","nodes","allowDirectives","map","statement","expression","isExpressionStatement","isStringLiteral","raw","directive","slice","filter","convertTypeArgumentsToTypeParameters","typeArguments","greaterThanToken","TSTypeParameterInstantiation","pos","params","typeArgument","convertTSTypeParametersToTypeParametersDeclaration","typeParameters","TSTypeParameterDeclaration","typeParameter","convertParameters","parameters","length","param","convertedParam","decorators","el","convertChainExpression","tsNode","isOptional","MemberExpression","object","optional","CallExpression","callee","isChildUnwrappable","newChild","ChainExpression","deeplyCopy","JSDocFunctionType","customType","errorOnUnknownASTType","Error","isTypeNode","KEYS_TO_NOT_COPY","Set","entries","key","forEach","value","Array","isArray","convertJSXIdentifier","JSXIdentifier","getText","convertJSXNamespaceOrIdentifier","text","colonIndex","indexOf","JSXNamespacedName","namespace","convertJSXTagName","PropertyAccessExpression","PrivateIdentifier","JSXMemberExpression","property","ThisKeyword","Identifier","convertMethodSignature","TSMethodSignature","computed","GetAccessor","SetAccessor","MethodSignature","returnType","ReadonlyKeyword","readonly","accessibility","export","StaticKeyword","static","convertAssertClasue","elements","element","applyModifiersToResult","remainingModifiers","modifier","ConstKeyword","const","DeclareKeyword","push","childRange","assertModuleSpecifier","allowNull","moduleSpecifier","_a","StringLiteral","SourceFile","Program","body","statements","sourceType","externalModuleIndicator","endOfFileToken","Block","BlockStatement","ThisExpression","WithStatement","ReturnStatement","argument","LabeledStatement","label","ContinueStatement","BreakStatement","IfStatement","test","consequent","thenStatement","alternate","elseStatement","SwitchStatement","discriminant","cases","caseBlock","clauses","CaseClause","DefaultClause","SwitchCase","ThrowStatement","TryStatement","block","tryBlock","handler","catchClause","finalizer","finallyBlock","CatchClause","variableDeclaration","WhileStatement","DoStatement","DoWhileStatement","ForStatement","init","initializer","condition","update","incrementor","ForInStatement","left","right","ForOfStatement","await","Boolean","awaitModifier","AwaitKeyword","FunctionDeclaration","TSDeclareFunction","generator","asteriskToken","async","AsyncKeyword","VariableDeclaration","VariableDeclarator","exclamationToken","definite","VariableStatement","declarations","declarationList","VariableDeclarationList","ExpressionStatement","ArrayLiteralExpression","ArrayPattern","ArrayExpression","ObjectLiteralExpression","ObjectPattern","properties","ObjectExpression","PropertyAssignment","Property","method","shorthand","ShorthandPropertyAssignment","objectAssignmentInitializer","AssignmentPattern","ComputedPropertyName","PropertyDeclaration","isAbstract","AbstractKeyword","TSAbstractPropertyDefinition","PropertyDefinition","override","OverrideKeyword","questionToken","Literal","InterfaceDeclaration","TypeLiteral","MethodDeclaration","TSEmptyBodyFunctionExpression","FunctionExpression","methodDefinitionType","TSAbstractMethodDefinition","MethodDefinition","Constructor","lastModifier","constructorToken","getFirstToken","constructorKey","isStatic","SuperKeyword","Super","ArrayBindingPattern","OmittedExpression","ObjectBindingPattern","BindingElement","arrayItem","dotDotDotToken","RestElement","propertyName","_b","ArrowFunction","ArrowFunctionExpression","YieldExpression","delegate","AwaitExpression","NoSubstitutionTemplateLiteral","TemplateLiteral","quasis","TemplateElement","cooked","tail","expressions","TemplateExpression","head","templateSpans","templateSpan","literal","TaggedTemplateExpression","tag","quasi","template","TemplateHead","TemplateMiddle","TemplateTail","SpreadAssignment","SpreadElement","Parameter","parameter","TSParameterProperty","_c","ClassDeclaration","ClassExpression","heritageClauses","_d","classNodeType","superClass","find","clause","token","ExtendsKeyword","implementsClause","ImplementsKeyword","ClassBody","members","types","_e","superTypeParameters","implements","abstract","filteredMembers","node_utils_1","ModuleBlock","TSModuleBlock","ImportDeclaration","importKind","assertClause","importClause","isTypeOnly","namedBindings","NamespaceImport","NamedImports","concat","ImportNamespaceSpecifier","local","ImportSpecifier","imported","_f","ImportClause","ImportDefaultSpecifier","ExportDeclaration","exportClause","_g","NamedExports","ExportAllDeclaration","exported","NamespaceExport","ExportSpecifier","_h","ExportAssignment","isExportEquals","TSExportAssignment","PrefixUnaryExpression","PostfixUnaryExpression","operator","UpdateExpression","prefix","operand","UnaryExpression","DeleteExpression","VoidExpression","TypeOfExpression","TypeOperator","TSTypeOperator","BinaryExpression","operatorToken","SequenceExpression","ParenthesizedExpression","AssignmentExpression","questionDotToken","ElementAccessExpression","argumentExpression","ImportKeyword","arguments","ImportExpression","attributes","args","NewExpression","ConditionalExpression","whenTrue","whenFalse","MetaProperty","meta","keywordToken","Decorator","JsxAttribute","NumericLiteral","Number","BigIntLiteral","rawValue","bigint","replace","BigInt","String","RegularExpressionLiteral","lastIndexOf","flags","regex","RegExp","exception","TrueKeyword","FalseKeyword","NullKeyword","version_check_1","TSNullKeyword","EmptyStatement","DebuggerStatement","JsxElement","JSXElement","openingElement","closingElement","children","JsxFragment","JSXFragment","openingFragment","closingFragment","JsxSelfClosingElement","JSXOpeningElement","selfClosing","tagName","JsxOpeningElement","JsxClosingElement","JSXClosingElement","JsxOpeningFragment","JSXOpeningFragment","JsxClosingFragment","JSXClosingFragment","JsxExpression","JSXEmptyExpression","getEnd","JSXSpreadChild","JSXExpressionContainer","JSXAttribute","JsxText","JSXText","JsxSpreadAttribute","JSXSpreadAttribute","QualifiedName","TSQualifiedName","TypeReference","TSTypeReference","typeName","TypeParameter","TSTypeParameter","constraint","default","in","InKeyword","out","OutKeyword","ThisType","TSThisType","AnyKeyword","BigIntKeyword","BooleanKeyword","NeverKeyword","NumberKeyword","ObjectKeyword","StringKeyword","SymbolKeyword","UnknownKeyword","VoidKeyword","UndefinedKeyword","IntrinsicKeyword","NonNullExpression","nnExpr","TSNonNullExpression","TSTypeLiteral","ArrayType","TSArrayType","elementType","IndexedAccessType","TSIndexedAccessType","objectType","indexType","ConditionalType","TSConditionalType","checkType","extendsType","trueType","falseType","TypeQuery","TSTypeQuery","exprName","MappedType","TSMappedType","nameType","_j","readonlyToken","QuestionToken","TypeAliasDeclaration","PropertySignature","TSPropertySignature","IndexSignature","TSIndexSignature","TSConstructorType","ConstructSignature","CallSignature","TSConstructSignatureDeclaration","TSCallSignatureDeclaration","TSFunctionType","ExpressionWithTypeArguments","parentKind","TSInterfaceHeritage","HeritageClause","TSClassImplements","TSInstantiationExpression","interfaceHeritageClauses","_k","TSInterfaceBody","member","interfaceExtends","interfaceImplements","heritageClause","n","extends","TypePredicate","TSTypePredicate","asserts","assertsModifier","parameterName","ImportType","TSImportType","isTypeOf","qualifier","EnumDeclaration","TSEnumDeclaration","EnumMember","TSEnumMember","ModuleDeclaration","TSModuleDeclaration","NodeFlags","GlobalAugmentation","global","ParenthesizedType","UnionType","TSUnionType","IntersectionType","TSIntersectionType","AsExpression","TSAsExpression","InferType","TSInferType","LiteralType","TSLiteralType","TypeAssertionExpression","TSTypeAssertion","ImportEqualsDeclaration","TSImportEqualsDeclaration","moduleReference","isExport","ExternalModuleReference","TSExternalModuleReference","NamespaceExportDeclaration","TSNamespaceExportDeclaration","TSAbstractKeyword","TupleType","elementTypes","TSTupleType","NamedTupleMember","TSNamedTupleMember","TSRestType","OptionalType","TSOptionalType","RestType","TemplateLiteralType","TSTemplateLiteralType","ClassStaticBlockDeclaration","StaticBlock","AssertEntry","ImportAttribute"],"sources":["../src/convert.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}