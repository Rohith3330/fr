{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validatePluginObject = validatePluginObject;\n\nvar _optionAssertions = require(\"./option-assertions\");\n\nvar VALIDATORS = {\n  name: _optionAssertions.assertString,\n  manipulateOptions: _optionAssertions.assertFunction,\n  pre: _optionAssertions.assertFunction,\n  post: _optionAssertions.assertFunction,\n  inherits: _optionAssertions.assertFunction,\n  visitor: assertVisitorMap,\n  parserOverride: _optionAssertions.assertFunction,\n  generatorOverride: _optionAssertions.assertFunction\n};\n\nfunction assertVisitorMap(loc, value) {\n  var obj = (0, _optionAssertions.assertObject)(loc, value);\n\n  if (obj) {\n    Object.keys(obj).forEach(function (prop) {\n      return assertVisitorHandler(prop, obj[prop]);\n    });\n\n    if (obj.enter || obj.exit) {\n      throw new Error(\"\".concat((0, _optionAssertions.msg)(loc), \" cannot contain catch-all \\\"enter\\\" or \\\"exit\\\" handlers. Please target individual nodes.\"));\n    }\n  }\n\n  return obj;\n}\n\nfunction assertVisitorHandler(key, value) {\n  if (value && typeof value === \"object\") {\n    Object.keys(value).forEach(function (handler) {\n      if (handler !== \"enter\" && handler !== \"exit\") {\n        throw new Error(\".visitor[\\\"\".concat(key, \"\\\"] may only have .enter and/or .exit handlers.\"));\n      }\n    });\n  } else if (typeof value !== \"function\") {\n    throw new Error(\".visitor[\\\"\".concat(key, \"\\\"] must be a function\"));\n  }\n\n  return value;\n}\n\nfunction validatePluginObject(obj) {\n  var rootPath = {\n    type: \"root\",\n    source: \"plugin\"\n  };\n  Object.keys(obj).forEach(function (key) {\n    var validator = VALIDATORS[key];\n\n    if (validator) {\n      var optLoc = {\n        type: \"option\",\n        name: key,\n        parent: rootPath\n      };\n      validator(optLoc, obj[key]);\n    } else {\n      var invalidPluginPropertyError = new Error(\".\".concat(key, \" is not a valid Plugin property\"));\n      invalidPluginPropertyError.code = \"BABEL_UNKNOWN_PLUGIN_PROPERTY\";\n      throw invalidPluginPropertyError;\n    }\n  });\n  return obj;\n}\n\n0 && 0;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAqBA,IAAMA,UAAwB,GAAG;EAC/BC,IAAI,EAAEC,8BADyB;EAE/BC,iBAAiB,EAAEC,gCAFY;EAK/BC,GAAG,EAAED,gCAL0B;EAM/BE,IAAI,EAAEF,gCANyB;EAO/BG,QAAQ,EAAEH,gCAPqB;EAQ/BI,OAAO,EAAEC,gBARsB;EAU/BC,cAAc,EAAEN,gCAVe;EAW/BO,iBAAiB,EAAEP;AAXY,CAAjC;;AAgBA,SAASK,gBAAT,CAA0BG,GAA1B,EAA2CC,KAA3C,EAAoE;EAClE,IAAMC,GAAG,GAAG,oCAAaF,GAAb,EAAkBC,KAAlB,CAAZ;;EACA,IAAIC,GAAJ,EAAS;IACPC,MAAM,CAACC,IAAPD,CAAYD,GAAZC,EAAiBE,OAAjBF,CAAyBG,cAAI;MAAA,OAAIC,oBAAoB,CAACD,IAAD,EAAOJ,GAAG,CAACI,IAAD,CAAV,CAAxB;IAAA,CAA7BH;;IAEA,IAAID,GAAG,CAACM,KAAJN,IAAaA,GAAG,CAACO,IAArB,EAA2B;MACzB,MAAM,IAAIC,KAAJ,WACD,2BACDV,GADC,CADC,+FAAN;IAKD;EACF;;EACD,OAAOE,GAAP;AACD;;AAED,SAASK,oBAAT,CACEI,GADF,EAEEV,KAFF,EAGyB;EACvB,IAAIA,KAAK,IAAI,OAAOA,KAAP,KAAiB,QAA9B,EAAwC;IACtCE,MAAM,CAACC,IAAPD,CAAYF,KAAZE,EAAmBE,OAAnBF,CAA4BS,iBAAD,EAAqB;MAC9C,IAAIA,OAAO,KAAK,OAAZA,IAAuBA,OAAO,KAAK,MAAvC,EAA+C;QAC7C,MAAM,IAAIF,KAAJ,sBACSC,GADT,qDAAN;MAGD;IALH;EADF,OAQO,IAAI,OAAOV,KAAP,KAAiB,UAArB,EAAiC;IACtC,MAAM,IAAIS,KAAJ,sBAAuBC,GAAvB,4BAAN;EACD;;EAED,OAAOV,KAAP;AACD;;AAuBM,SAASY,oBAAT,CAA8BX,GAA9B,EAEU;EACf,IAAMY,QAAkB,GAAG;IACzBC,IAAI,EAAE,MADmB;IAEzBC,MAAM,EAAE;EAFiB,CAA3B;EAIAb,MAAM,CAACC,IAAPD,CAAYD,GAAZC,EAAiBE,OAAjBF,CAA0BQ,aAAD,EAAiB;IACxC,IAAMM,SAAS,GAAG7B,UAAU,CAACuB,GAAD,CAA5B;;IAEA,IAAIM,SAAJ,EAAe;MACb,IAAMC,MAAkB,GAAG;QACzBH,IAAI,EAAE,QADmB;QAEzB1B,IAAI,EAAEsB,GAFmB;QAGzBQ,MAAM,EAAEL;MAHiB,CAA3B;MAKAG,SAAS,CAACC,MAAD,EAAShB,GAAG,CAACS,GAAD,CAAZ,CAATM;IANF,OAOO;MACL,IAAMG,0BAA0B,GAAG,IAAIV,KAAJ,YAC7BC,GAD6B,qCAAnC;MAIAS,0BAA0B,CAACC,IAA3BD,GAAkC,+BAAlCA;MACA,MAAMA,0BAAN;IACD;EAjBH;EAoBA,OAAOlB,GAAP;AACD","names":["VALIDATORS","name","assertString","manipulateOptions","assertFunction","pre","post","inherits","visitor","assertVisitorMap","parserOverride","generatorOverride","loc","value","obj","Object","keys","forEach","prop","assertVisitorHandler","enter","exit","Error","key","handler","validatePluginObject","rootPath","type","source","validator","optLoc","parent","invalidPluginPropertyError","code"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\validation\\plugins.ts"],"sourcesContent":["import {\n  assertString,\n  assertFunction,\n  assertObject,\n  msg,\n} from \"./option-assertions\";\n\nimport type {\n  ValidatorSet,\n  Validator,\n  OptionPath,\n  RootPath,\n} from \"./option-assertions\";\nimport type { ParserOptions } from \"@babel/parser\";\nimport type { Visitor } from \"@babel/traverse\";\nimport type { ValidatedOptions } from \"./options\";\nimport type { File, PluginPass } from \"../../index\";\n\n// Note: The casts here are just meant to be static assertions to make sure\n// that the assertion functions actually assert that the value's type matches\n// the declared types.\nconst VALIDATORS: ValidatorSet = {\n  name: assertString as Validator<PluginObject[\"name\"]>,\n  manipulateOptions: assertFunction as Validator<\n    PluginObject[\"manipulateOptions\"]\n  >,\n  pre: assertFunction as Validator<PluginObject[\"pre\"]>,\n  post: assertFunction as Validator<PluginObject[\"post\"]>,\n  inherits: assertFunction as Validator<PluginObject[\"inherits\"]>,\n  visitor: assertVisitorMap as Validator<PluginObject[\"visitor\"]>,\n\n  parserOverride: assertFunction as Validator<PluginObject[\"parserOverride\"]>,\n  generatorOverride: assertFunction as Validator<\n    PluginObject[\"generatorOverride\"]\n  >,\n};\n\nfunction assertVisitorMap(loc: OptionPath, value: unknown): Visitor {\n  const obj = assertObject(loc, value);\n  if (obj) {\n    Object.keys(obj).forEach(prop => assertVisitorHandler(prop, obj[prop]));\n\n    if (obj.enter || obj.exit) {\n      throw new Error(\n        `${msg(\n          loc,\n        )} cannot contain catch-all \"enter\" or \"exit\" handlers. Please target individual nodes.`,\n      );\n    }\n  }\n  return obj as Visitor;\n}\n\nfunction assertVisitorHandler(\n  key: string,\n  value: unknown,\n): VisitorHandler | void {\n  if (value && typeof value === \"object\") {\n    Object.keys(value).forEach((handler: string) => {\n      if (handler !== \"enter\" && handler !== \"exit\") {\n        throw new Error(\n          `.visitor[\"${key}\"] may only have .enter and/or .exit handlers.`,\n        );\n      }\n    });\n  } else if (typeof value !== \"function\") {\n    throw new Error(`.visitor[\"${key}\"] must be a function`);\n  }\n\n  return value as any;\n}\n\ntype VisitorHandler =\n  | Function\n  | {\n      enter?: Function;\n      exit?: Function;\n    };\n\nexport type PluginObject<S extends PluginPass = PluginPass> = {\n  name?: string;\n  manipulateOptions?: (\n    options: ValidatedOptions,\n    parserOpts: ParserOptions,\n  ) => void;\n  pre?: (this: S, file: File) => void;\n  post?: (this: S, file: File) => void;\n  inherits?: Function;\n  visitor?: Visitor<S>;\n  parserOverride?: Function;\n  generatorOverride?: Function;\n};\n\nexport function validatePluginObject(obj: {\n  [key: string]: unknown;\n}): PluginObject {\n  const rootPath: RootPath = {\n    type: \"root\",\n    source: \"plugin\",\n  };\n  Object.keys(obj).forEach((key: string) => {\n    const validator = VALIDATORS[key];\n\n    if (validator) {\n      const optLoc: OptionPath = {\n        type: \"option\",\n        name: key,\n        parent: rootPath,\n      };\n      validator(optLoc, obj[key]);\n    } else {\n      const invalidPluginPropertyError = new Error(\n        `.${key} is not a valid Plugin property`,\n      );\n      // @ts-expect-error todo(flow->ts) consider additing BabelConfigError with code field\n      invalidPluginPropertyError.code = \"BABEL_UNKNOWN_PLUGIN_PROPERTY\";\n      throw invalidPluginPropertyError;\n    }\n  });\n\n  return obj as any;\n}\n"]},"metadata":{},"sourceType":"script"}