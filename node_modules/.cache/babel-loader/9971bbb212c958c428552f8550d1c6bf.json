{"ast":null,"code":"var constants = require('../tokenizer/const');\n\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\n\nvar utils = require('../tokenizer/utils');\n\nvar cmpStr = utils.cmpStr;\nvar EOF = TYPE.EOF;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar OFFSET_MASK = 0x00FFFFFF;\nvar TYPE_SHIFT = 24;\n\nvar TokenStream = function () {\n  this.offsetAndType = null;\n  this.balance = null;\n  this.reset();\n};\n\nTokenStream.prototype = {\n  reset: function () {\n    this.eof = false;\n    this.tokenIndex = -1;\n    this.tokenType = 0;\n    this.tokenStart = this.firstCharOffset;\n    this.tokenEnd = this.firstCharOffset;\n  },\n  lookupType: function (offset) {\n    offset += this.tokenIndex;\n\n    if (offset < this.tokenCount) {\n      return this.offsetAndType[offset] >> TYPE_SHIFT;\n    }\n\n    return EOF;\n  },\n  lookupOffset: function (offset) {\n    offset += this.tokenIndex;\n\n    if (offset < this.tokenCount) {\n      return this.offsetAndType[offset - 1] & OFFSET_MASK;\n    }\n\n    return this.source.length;\n  },\n  lookupValue: function (offset, referenceStr) {\n    offset += this.tokenIndex;\n\n    if (offset < this.tokenCount) {\n      return cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);\n    }\n\n    return false;\n  },\n  getTokenStart: function (tokenIndex) {\n    if (tokenIndex === this.tokenIndex) {\n      return this.tokenStart;\n    }\n\n    if (tokenIndex > 0) {\n      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n    }\n\n    return this.firstCharOffset;\n  },\n  // TODO: -> skipUntilBalanced\n  getRawLength: function (startToken, mode) {\n    var cursor = startToken;\n    var balanceEnd;\n    var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;\n    var type;\n\n    loop: for (; cursor < this.tokenCount; cursor++) {\n      balanceEnd = this.balance[cursor]; // stop scanning on balance edge that points to offset before start token\n\n      if (balanceEnd < startToken) {\n        break loop;\n      }\n\n      type = this.offsetAndType[cursor] >> TYPE_SHIFT; // check token is stop type\n\n      switch (mode(type, this.source, offset)) {\n        case 1:\n          break loop;\n\n        case 2:\n          cursor++;\n          break loop;\n\n        default:\n          // fast forward to the end of balanced block\n          if (this.balance[balanceEnd] === cursor) {\n            cursor = balanceEnd;\n          }\n\n          offset = this.offsetAndType[cursor] & OFFSET_MASK;\n      }\n    }\n\n    return cursor - this.tokenIndex;\n  },\n  isBalanceEdge: function (pos) {\n    return this.balance[this.tokenIndex] < pos;\n  },\n  isDelim: function (code, offset) {\n    if (offset) {\n      return this.lookupType(offset) === TYPE.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;\n    }\n\n    return this.tokenType === TYPE.Delim && this.source.charCodeAt(this.tokenStart) === code;\n  },\n  getTokenValue: function () {\n    return this.source.substring(this.tokenStart, this.tokenEnd);\n  },\n  getTokenLength: function () {\n    return this.tokenEnd - this.tokenStart;\n  },\n  substrToCursor: function (start) {\n    return this.source.substring(start, this.tokenStart);\n  },\n  skipWS: function () {\n    for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {\n      if (this.offsetAndType[i] >> TYPE_SHIFT !== WHITESPACE) {\n        break;\n      }\n    }\n\n    if (skipTokenCount > 0) {\n      this.skip(skipTokenCount);\n    }\n  },\n  skipSC: function () {\n    while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {\n      this.next();\n    }\n  },\n  skip: function (tokenCount) {\n    var next = this.tokenIndex + tokenCount;\n\n    if (next < this.tokenCount) {\n      this.tokenIndex = next;\n      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n      next = this.offsetAndType[next];\n      this.tokenType = next >> TYPE_SHIFT;\n      this.tokenEnd = next & OFFSET_MASK;\n    } else {\n      this.tokenIndex = this.tokenCount;\n      this.next();\n    }\n  },\n  next: function () {\n    var next = this.tokenIndex + 1;\n\n    if (next < this.tokenCount) {\n      this.tokenIndex = next;\n      this.tokenStart = this.tokenEnd;\n      next = this.offsetAndType[next];\n      this.tokenType = next >> TYPE_SHIFT;\n      this.tokenEnd = next & OFFSET_MASK;\n    } else {\n      this.tokenIndex = this.tokenCount;\n      this.eof = true;\n      this.tokenType = EOF;\n      this.tokenStart = this.tokenEnd = this.source.length;\n    }\n  },\n\n  forEachToken(fn) {\n    for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {\n      var start = offset;\n      var item = this.offsetAndType[i];\n      var end = item & OFFSET_MASK;\n      var type = item >> TYPE_SHIFT;\n      offset = end;\n      fn(type, start, end, i);\n    }\n  },\n\n  dump() {\n    var tokens = new Array(this.tokenCount);\n    this.forEachToken((type, start, end, index) => {\n      tokens[index] = {\n        idx: index,\n        type: NAME[type],\n        chunk: this.source.substring(start, end),\n        balance: this.balance[index]\n      };\n    });\n    return tokens;\n  }\n\n};\nmodule.exports = TokenStream;","map":{"version":3,"names":["constants","require","TYPE","NAME","utils","cmpStr","EOF","WHITESPACE","WhiteSpace","COMMENT","Comment","OFFSET_MASK","TYPE_SHIFT","TokenStream","offsetAndType","balance","reset","prototype","eof","tokenIndex","tokenType","tokenStart","firstCharOffset","tokenEnd","lookupType","offset","tokenCount","lookupOffset","source","length","lookupValue","referenceStr","getTokenStart","getRawLength","startToken","mode","cursor","balanceEnd","Math","max","type","loop","isBalanceEdge","pos","isDelim","code","Delim","charCodeAt","getTokenValue","substring","getTokenLength","substrToCursor","start","skipWS","i","skipTokenCount","skip","skipSC","next","forEachToken","fn","item","end","dump","tokens","Array","index","idx","chunk","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/csso/node_modules/css-tree/lib/common/TokenStream.js"],"sourcesContent":["var constants = require('../tokenizer/const');\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\n\nvar utils = require('../tokenizer/utils');\nvar cmpStr = utils.cmpStr;\n\nvar EOF = TYPE.EOF;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\n\nvar OFFSET_MASK = 0x00FFFFFF;\nvar TYPE_SHIFT = 24;\n\nvar TokenStream = function() {\n    this.offsetAndType = null;\n    this.balance = null;\n\n    this.reset();\n};\n\nTokenStream.prototype = {\n    reset: function() {\n        this.eof = false;\n        this.tokenIndex = -1;\n        this.tokenType = 0;\n        this.tokenStart = this.firstCharOffset;\n        this.tokenEnd = this.firstCharOffset;\n    },\n\n    lookupType: function(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset] >> TYPE_SHIFT;\n        }\n\n        return EOF;\n    },\n    lookupOffset: function(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset - 1] & OFFSET_MASK;\n        }\n\n        return this.source.length;\n    },\n    lookupValue: function(offset, referenceStr) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return cmpStr(\n                this.source,\n                this.offsetAndType[offset - 1] & OFFSET_MASK,\n                this.offsetAndType[offset] & OFFSET_MASK,\n                referenceStr\n            );\n        }\n\n        return false;\n    },\n    getTokenStart: function(tokenIndex) {\n        if (tokenIndex === this.tokenIndex) {\n            return this.tokenStart;\n        }\n\n        if (tokenIndex > 0) {\n            return tokenIndex < this.tokenCount\n                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK\n                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n        }\n\n        return this.firstCharOffset;\n    },\n\n    // TODO: -> skipUntilBalanced\n    getRawLength: function(startToken, mode) {\n        var cursor = startToken;\n        var balanceEnd;\n        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;\n        var type;\n\n        loop:\n        for (; cursor < this.tokenCount; cursor++) {\n            balanceEnd = this.balance[cursor];\n\n            // stop scanning on balance edge that points to offset before start token\n            if (balanceEnd < startToken) {\n                break loop;\n            }\n\n            type = this.offsetAndType[cursor] >> TYPE_SHIFT;\n\n            // check token is stop type\n            switch (mode(type, this.source, offset)) {\n                case 1:\n                    break loop;\n\n                case 2:\n                    cursor++;\n                    break loop;\n\n                default:\n                    // fast forward to the end of balanced block\n                    if (this.balance[balanceEnd] === cursor) {\n                        cursor = balanceEnd;\n                    }\n\n                    offset = this.offsetAndType[cursor] & OFFSET_MASK;\n            }\n        }\n\n        return cursor - this.tokenIndex;\n    },\n    isBalanceEdge: function(pos) {\n        return this.balance[this.tokenIndex] < pos;\n    },\n    isDelim: function(code, offset) {\n        if (offset) {\n            return (\n                this.lookupType(offset) === TYPE.Delim &&\n                this.source.charCodeAt(this.lookupOffset(offset)) === code\n            );\n        }\n\n        return (\n            this.tokenType === TYPE.Delim &&\n            this.source.charCodeAt(this.tokenStart) === code\n        );\n    },\n\n    getTokenValue: function() {\n        return this.source.substring(this.tokenStart, this.tokenEnd);\n    },\n    getTokenLength: function() {\n        return this.tokenEnd - this.tokenStart;\n    },\n    substrToCursor: function(start) {\n        return this.source.substring(start, this.tokenStart);\n    },\n\n    skipWS: function() {\n        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {\n            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {\n                break;\n            }\n        }\n\n        if (skipTokenCount > 0) {\n            this.skip(skipTokenCount);\n        }\n    },\n    skipSC: function() {\n        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {\n            this.next();\n        }\n    },\n    skip: function(tokenCount) {\n        var next = this.tokenIndex + tokenCount;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.tokenIndex = this.tokenCount;\n            this.next();\n        }\n    },\n    next: function() {\n        var next = this.tokenIndex + 1;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.tokenEnd;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.tokenIndex = this.tokenCount;\n            this.eof = true;\n            this.tokenType = EOF;\n            this.tokenStart = this.tokenEnd = this.source.length;\n        }\n    },\n\n    forEachToken(fn) {\n        for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {\n            var start = offset;\n            var item = this.offsetAndType[i];\n            var end = item & OFFSET_MASK;\n            var type = item >> TYPE_SHIFT;\n\n            offset = end;\n\n            fn(type, start, end, i);\n        }\n    },\n\n    dump() {\n        var tokens = new Array(this.tokenCount);\n\n        this.forEachToken((type, start, end, index) => {\n            tokens[index] = {\n                idx: index,\n                type: NAME[type],\n                chunk: this.source.substring(start, end),\n                balance: this.balance[index]\n            };\n        });\n\n        return tokens;\n    }\n};\n\nmodule.exports = TokenStream;\n"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,OAAO,CAAC,oBAAD,CAAvB;;AACA,IAAIC,IAAI,GAAGF,SAAS,CAACE,IAArB;AACA,IAAIC,IAAI,GAAGH,SAAS,CAACG,IAArB;;AAEA,IAAIC,KAAK,GAAGH,OAAO,CAAC,oBAAD,CAAnB;;AACA,IAAII,MAAM,GAAGD,KAAK,CAACC,MAAnB;AAEA,IAAIC,GAAG,GAAGJ,IAAI,CAACI,GAAf;AACA,IAAIC,UAAU,GAAGL,IAAI,CAACM,UAAtB;AACA,IAAIC,OAAO,GAAGP,IAAI,CAACQ,OAAnB;AAEA,IAAIC,WAAW,GAAG,UAAlB;AACA,IAAIC,UAAU,GAAG,EAAjB;;AAEA,IAAIC,WAAW,GAAG,YAAW;EACzB,KAAKC,aAAL,GAAqB,IAArB;EACA,KAAKC,OAAL,GAAe,IAAf;EAEA,KAAKC,KAAL;AACH,CALD;;AAOAH,WAAW,CAACI,SAAZ,GAAwB;EACpBD,KAAK,EAAE,YAAW;IACd,KAAKE,GAAL,GAAW,KAAX;IACA,KAAKC,UAAL,GAAkB,CAAC,CAAnB;IACA,KAAKC,SAAL,GAAiB,CAAjB;IACA,KAAKC,UAAL,GAAkB,KAAKC,eAAvB;IACA,KAAKC,QAAL,GAAgB,KAAKD,eAArB;EACH,CAPmB;EASpBE,UAAU,EAAE,UAASC,MAAT,EAAiB;IACzBA,MAAM,IAAI,KAAKN,UAAf;;IAEA,IAAIM,MAAM,GAAG,KAAKC,UAAlB,EAA8B;MAC1B,OAAO,KAAKZ,aAAL,CAAmBW,MAAnB,KAA8Bb,UAArC;IACH;;IAED,OAAON,GAAP;EACH,CAjBmB;EAkBpBqB,YAAY,EAAE,UAASF,MAAT,EAAiB;IAC3BA,MAAM,IAAI,KAAKN,UAAf;;IAEA,IAAIM,MAAM,GAAG,KAAKC,UAAlB,EAA8B;MAC1B,OAAO,KAAKZ,aAAL,CAAmBW,MAAM,GAAG,CAA5B,IAAiCd,WAAxC;IACH;;IAED,OAAO,KAAKiB,MAAL,CAAYC,MAAnB;EACH,CA1BmB;EA2BpBC,WAAW,EAAE,UAASL,MAAT,EAAiBM,YAAjB,EAA+B;IACxCN,MAAM,IAAI,KAAKN,UAAf;;IAEA,IAAIM,MAAM,GAAG,KAAKC,UAAlB,EAA8B;MAC1B,OAAOrB,MAAM,CACT,KAAKuB,MADI,EAET,KAAKd,aAAL,CAAmBW,MAAM,GAAG,CAA5B,IAAiCd,WAFxB,EAGT,KAAKG,aAAL,CAAmBW,MAAnB,IAA6Bd,WAHpB,EAIToB,YAJS,CAAb;IAMH;;IAED,OAAO,KAAP;EACH,CAxCmB;EAyCpBC,aAAa,EAAE,UAASb,UAAT,EAAqB;IAChC,IAAIA,UAAU,KAAK,KAAKA,UAAxB,EAAoC;MAChC,OAAO,KAAKE,UAAZ;IACH;;IAED,IAAIF,UAAU,GAAG,CAAjB,EAAoB;MAChB,OAAOA,UAAU,GAAG,KAAKO,UAAlB,GACD,KAAKZ,aAAL,CAAmBK,UAAU,GAAG,CAAhC,IAAqCR,WADpC,GAED,KAAKG,aAAL,CAAmB,KAAKY,UAAxB,IAAsCf,WAF5C;IAGH;;IAED,OAAO,KAAKW,eAAZ;EACH,CArDmB;EAuDpB;EACAW,YAAY,EAAE,UAASC,UAAT,EAAqBC,IAArB,EAA2B;IACrC,IAAIC,MAAM,GAAGF,UAAb;IACA,IAAIG,UAAJ;IACA,IAAIZ,MAAM,GAAG,KAAKX,aAAL,CAAmBwB,IAAI,CAACC,GAAL,CAASH,MAAM,GAAG,CAAlB,EAAqB,CAArB,CAAnB,IAA8CzB,WAA3D;IACA,IAAI6B,IAAJ;;IAEAC,IAAI,EACJ,OAAOL,MAAM,GAAG,KAAKV,UAArB,EAAiCU,MAAM,EAAvC,EAA2C;MACvCC,UAAU,GAAG,KAAKtB,OAAL,CAAaqB,MAAb,CAAb,CADuC,CAGvC;;MACA,IAAIC,UAAU,GAAGH,UAAjB,EAA6B;QACzB,MAAMO,IAAN;MACH;;MAEDD,IAAI,GAAG,KAAK1B,aAAL,CAAmBsB,MAAnB,KAA8BxB,UAArC,CARuC,CAUvC;;MACA,QAAQuB,IAAI,CAACK,IAAD,EAAO,KAAKZ,MAAZ,EAAoBH,MAApB,CAAZ;QACI,KAAK,CAAL;UACI,MAAMgB,IAAN;;QAEJ,KAAK,CAAL;UACIL,MAAM;UACN,MAAMK,IAAN;;QAEJ;UACI;UACA,IAAI,KAAK1B,OAAL,CAAasB,UAAb,MAA6BD,MAAjC,EAAyC;YACrCA,MAAM,GAAGC,UAAT;UACH;;UAEDZ,MAAM,GAAG,KAAKX,aAAL,CAAmBsB,MAAnB,IAA6BzB,WAAtC;MAdR;IAgBH;;IAED,OAAOyB,MAAM,GAAG,KAAKjB,UAArB;EACH,CA7FmB;EA8FpBuB,aAAa,EAAE,UAASC,GAAT,EAAc;IACzB,OAAO,KAAK5B,OAAL,CAAa,KAAKI,UAAlB,IAAgCwB,GAAvC;EACH,CAhGmB;EAiGpBC,OAAO,EAAE,UAASC,IAAT,EAAepB,MAAf,EAAuB;IAC5B,IAAIA,MAAJ,EAAY;MACR,OACI,KAAKD,UAAL,CAAgBC,MAAhB,MAA4BvB,IAAI,CAAC4C,KAAjC,IACA,KAAKlB,MAAL,CAAYmB,UAAZ,CAAuB,KAAKpB,YAAL,CAAkBF,MAAlB,CAAvB,MAAsDoB,IAF1D;IAIH;;IAED,OACI,KAAKzB,SAAL,KAAmBlB,IAAI,CAAC4C,KAAxB,IACA,KAAKlB,MAAL,CAAYmB,UAAZ,CAAuB,KAAK1B,UAA5B,MAA4CwB,IAFhD;EAIH,CA7GmB;EA+GpBG,aAAa,EAAE,YAAW;IACtB,OAAO,KAAKpB,MAAL,CAAYqB,SAAZ,CAAsB,KAAK5B,UAA3B,EAAuC,KAAKE,QAA5C,CAAP;EACH,CAjHmB;EAkHpB2B,cAAc,EAAE,YAAW;IACvB,OAAO,KAAK3B,QAAL,GAAgB,KAAKF,UAA5B;EACH,CApHmB;EAqHpB8B,cAAc,EAAE,UAASC,KAAT,EAAgB;IAC5B,OAAO,KAAKxB,MAAL,CAAYqB,SAAZ,CAAsBG,KAAtB,EAA6B,KAAK/B,UAAlC,CAAP;EACH,CAvHmB;EAyHpBgC,MAAM,EAAE,YAAW;IACf,KAAK,IAAIC,CAAC,GAAG,KAAKnC,UAAb,EAAyBoC,cAAc,GAAG,CAA/C,EAAkDD,CAAC,GAAG,KAAK5B,UAA3D,EAAuE4B,CAAC,IAAIC,cAAc,EAA1F,EAA8F;MAC1F,IAAK,KAAKzC,aAAL,CAAmBwC,CAAnB,KAAyB1C,UAA1B,KAA0CL,UAA9C,EAA0D;QACtD;MACH;IACJ;;IAED,IAAIgD,cAAc,GAAG,CAArB,EAAwB;MACpB,KAAKC,IAAL,CAAUD,cAAV;IACH;EACJ,CAnImB;EAoIpBE,MAAM,EAAE,YAAW;IACf,OAAO,KAAKrC,SAAL,KAAmBb,UAAnB,IAAiC,KAAKa,SAAL,KAAmBX,OAA3D,EAAoE;MAChE,KAAKiD,IAAL;IACH;EACJ,CAxImB;EAyIpBF,IAAI,EAAE,UAAS9B,UAAT,EAAqB;IACvB,IAAIgC,IAAI,GAAG,KAAKvC,UAAL,GAAkBO,UAA7B;;IAEA,IAAIgC,IAAI,GAAG,KAAKhC,UAAhB,EAA4B;MACxB,KAAKP,UAAL,GAAkBuC,IAAlB;MACA,KAAKrC,UAAL,GAAkB,KAAKP,aAAL,CAAmB4C,IAAI,GAAG,CAA1B,IAA+B/C,WAAjD;MACA+C,IAAI,GAAG,KAAK5C,aAAL,CAAmB4C,IAAnB,CAAP;MACA,KAAKtC,SAAL,GAAiBsC,IAAI,IAAI9C,UAAzB;MACA,KAAKW,QAAL,GAAgBmC,IAAI,GAAG/C,WAAvB;IACH,CAND,MAMO;MACH,KAAKQ,UAAL,GAAkB,KAAKO,UAAvB;MACA,KAAKgC,IAAL;IACH;EACJ,CAtJmB;EAuJpBA,IAAI,EAAE,YAAW;IACb,IAAIA,IAAI,GAAG,KAAKvC,UAAL,GAAkB,CAA7B;;IAEA,IAAIuC,IAAI,GAAG,KAAKhC,UAAhB,EAA4B;MACxB,KAAKP,UAAL,GAAkBuC,IAAlB;MACA,KAAKrC,UAAL,GAAkB,KAAKE,QAAvB;MACAmC,IAAI,GAAG,KAAK5C,aAAL,CAAmB4C,IAAnB,CAAP;MACA,KAAKtC,SAAL,GAAiBsC,IAAI,IAAI9C,UAAzB;MACA,KAAKW,QAAL,GAAgBmC,IAAI,GAAG/C,WAAvB;IACH,CAND,MAMO;MACH,KAAKQ,UAAL,GAAkB,KAAKO,UAAvB;MACA,KAAKR,GAAL,GAAW,IAAX;MACA,KAAKE,SAAL,GAAiBd,GAAjB;MACA,KAAKe,UAAL,GAAkB,KAAKE,QAAL,GAAgB,KAAKK,MAAL,CAAYC,MAA9C;IACH;EACJ,CAtKmB;;EAwKpB8B,YAAY,CAACC,EAAD,EAAK;IACb,KAAK,IAAIN,CAAC,GAAG,CAAR,EAAW7B,MAAM,GAAG,KAAKH,eAA9B,EAA+CgC,CAAC,GAAG,KAAK5B,UAAxD,EAAoE4B,CAAC,EAArE,EAAyE;MACrE,IAAIF,KAAK,GAAG3B,MAAZ;MACA,IAAIoC,IAAI,GAAG,KAAK/C,aAAL,CAAmBwC,CAAnB,CAAX;MACA,IAAIQ,GAAG,GAAGD,IAAI,GAAGlD,WAAjB;MACA,IAAI6B,IAAI,GAAGqB,IAAI,IAAIjD,UAAnB;MAEAa,MAAM,GAAGqC,GAAT;MAEAF,EAAE,CAACpB,IAAD,EAAOY,KAAP,EAAcU,GAAd,EAAmBR,CAAnB,CAAF;IACH;EACJ,CAnLmB;;EAqLpBS,IAAI,GAAG;IACH,IAAIC,MAAM,GAAG,IAAIC,KAAJ,CAAU,KAAKvC,UAAf,CAAb;IAEA,KAAKiC,YAAL,CAAkB,CAACnB,IAAD,EAAOY,KAAP,EAAcU,GAAd,EAAmBI,KAAnB,KAA6B;MAC3CF,MAAM,CAACE,KAAD,CAAN,GAAgB;QACZC,GAAG,EAAED,KADO;QAEZ1B,IAAI,EAAErC,IAAI,CAACqC,IAAD,CAFE;QAGZ4B,KAAK,EAAE,KAAKxC,MAAL,CAAYqB,SAAZ,CAAsBG,KAAtB,EAA6BU,GAA7B,CAHK;QAIZ/C,OAAO,EAAE,KAAKA,OAAL,CAAamD,KAAb;MAJG,CAAhB;IAMH,CAPD;IASA,OAAOF,MAAP;EACH;;AAlMmB,CAAxB;AAqMAK,MAAM,CAACC,OAAP,GAAiBzD,WAAjB"},"metadata":{},"sourceType":"script"}