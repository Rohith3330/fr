{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBound = require('call-bind/callBound');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar DeletePropertyOrThrow = require('./DeletePropertyOrThrow');\n\nvar Get = require('./Get');\n\nvar HasProperty = require('./HasProperty');\n\nvar IsIntegralNumber = require('./IsIntegralNumber');\n\nvar Set = require('./Set');\n\nvar ToString = require('./ToString');\n\nvar Type = require('./Type');\n\nvar isAbstractClosure = require('../helpers/isAbstractClosure');\n\nvar $push = callBound('Array.prototype.push');\nvar $sort = callBound('Array.prototype.sort'); // https://ecma-international.org/ecma-262/13.0/#sec-sortindexedproperties\n\nmodule.exports = function SortIndexedProperties(obj, len, SortCompare) {\n  if (Type(obj) !== 'Object') {\n    throw new $TypeError('Assertion failed: Type(obj) is not Object');\n  }\n\n  if (!IsIntegralNumber(len) || len < 0) {\n    throw new $TypeError('Assertion failed: `len` must be an integer >= 0');\n  }\n\n  if (!isAbstractClosure(SortCompare) || SortCompare.length !== 2) {\n    throw new $TypeError('Assertion failed: `SortCompare` must be an abstract closure taking 2 arguments');\n  }\n\n  var items = []; // step 1\n\n  var k = 0; // step 2\n\n  while (k < len) {\n    // step 3\n    var Pk = ToString(k);\n    var kPresent = HasProperty(obj, Pk);\n\n    if (kPresent) {\n      var kValue = Get(obj, Pk);\n      $push(items, kValue);\n    }\n\n    k += 1;\n  }\n\n  var itemCount = items.length; // step 4\n\n  $sort(items, SortCompare); // step 5\n\n  var j = 0; // step 6\n\n  while (j < itemCount) {\n    // step 7\n    Set(obj, ToString(j), items[j], true);\n    j += 1;\n  }\n\n  while (j < len) {\n    // step 8\n    DeletePropertyOrThrow(obj, ToString(j));\n    j += 1;\n  }\n\n  return obj; // step 9\n};","map":{"version":3,"names":["GetIntrinsic","require","callBound","$TypeError","DeletePropertyOrThrow","Get","HasProperty","IsIntegralNumber","Set","ToString","Type","isAbstractClosure","$push","$sort","module","exports","SortIndexedProperties","obj","len","SortCompare","length","items","k","Pk","kPresent","kValue","itemCount","j"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/es-abstract/2022/SortIndexedProperties.js"],"sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bind/callBound');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar DeletePropertyOrThrow = require('./DeletePropertyOrThrow');\nvar Get = require('./Get');\nvar HasProperty = require('./HasProperty');\nvar IsIntegralNumber = require('./IsIntegralNumber');\nvar Set = require('./Set');\nvar ToString = require('./ToString');\nvar Type = require('./Type');\n\nvar isAbstractClosure = require('../helpers/isAbstractClosure');\n\nvar $push = callBound('Array.prototype.push');\nvar $sort = callBound('Array.prototype.sort');\n\n// https://ecma-international.org/ecma-262/13.0/#sec-sortindexedproperties\n\nmodule.exports = function SortIndexedProperties(obj, len, SortCompare) {\n\tif (Type(obj) !== 'Object') {\n\t\tthrow new $TypeError('Assertion failed: Type(obj) is not Object');\n\t}\n\tif (!IsIntegralNumber(len) || len < 0) {\n\t\tthrow new $TypeError('Assertion failed: `len` must be an integer >= 0');\n\t}\n\tif (!isAbstractClosure(SortCompare) || SortCompare.length !== 2) {\n\t\tthrow new $TypeError('Assertion failed: `SortCompare` must be an abstract closure taking 2 arguments');\n\t}\n\n\tvar items = []; // step 1\n\n\tvar k = 0; // step 2\n\n\twhile (k < len) { // step 3\n\t\tvar Pk = ToString(k);\n\t\tvar kPresent = HasProperty(obj, Pk);\n\t\tif (kPresent) {\n\t\t\tvar kValue = Get(obj, Pk);\n\t\t\t$push(items, kValue);\n\t\t}\n\t\tk += 1;\n\t}\n\n\tvar itemCount = items.length; // step 4\n\n\t$sort(items, SortCompare); // step 5\n\n\tvar j = 0; // step 6\n\n\twhile (j < itemCount) { // step 7\n\t\tSet(obj, ToString(j), items[j], true);\n\t\tj += 1;\n\t}\n\n\twhile (j < len) { // step 8\n\t\tDeletePropertyOrThrow(obj, ToString(j));\n\t\tj += 1;\n\t}\n\treturn obj; // step 9\n};\n"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AACA,IAAIC,SAAS,GAAGD,OAAO,CAAC,qBAAD,CAAvB;;AAEA,IAAIE,UAAU,GAAGH,YAAY,CAAC,aAAD,CAA7B;;AAEA,IAAII,qBAAqB,GAAGH,OAAO,CAAC,yBAAD,CAAnC;;AACA,IAAII,GAAG,GAAGJ,OAAO,CAAC,OAAD,CAAjB;;AACA,IAAIK,WAAW,GAAGL,OAAO,CAAC,eAAD,CAAzB;;AACA,IAAIM,gBAAgB,GAAGN,OAAO,CAAC,oBAAD,CAA9B;;AACA,IAAIO,GAAG,GAAGP,OAAO,CAAC,OAAD,CAAjB;;AACA,IAAIQ,QAAQ,GAAGR,OAAO,CAAC,YAAD,CAAtB;;AACA,IAAIS,IAAI,GAAGT,OAAO,CAAC,QAAD,CAAlB;;AAEA,IAAIU,iBAAiB,GAAGV,OAAO,CAAC,8BAAD,CAA/B;;AAEA,IAAIW,KAAK,GAAGV,SAAS,CAAC,sBAAD,CAArB;AACA,IAAIW,KAAK,GAAGX,SAAS,CAAC,sBAAD,CAArB,C,CAEA;;AAEAY,MAAM,CAACC,OAAP,GAAiB,SAASC,qBAAT,CAA+BC,GAA/B,EAAoCC,GAApC,EAAyCC,WAAzC,EAAsD;EACtE,IAAIT,IAAI,CAACO,GAAD,CAAJ,KAAc,QAAlB,EAA4B;IAC3B,MAAM,IAAId,UAAJ,CAAe,2CAAf,CAAN;EACA;;EACD,IAAI,CAACI,gBAAgB,CAACW,GAAD,CAAjB,IAA0BA,GAAG,GAAG,CAApC,EAAuC;IACtC,MAAM,IAAIf,UAAJ,CAAe,iDAAf,CAAN;EACA;;EACD,IAAI,CAACQ,iBAAiB,CAACQ,WAAD,CAAlB,IAAmCA,WAAW,CAACC,MAAZ,KAAuB,CAA9D,EAAiE;IAChE,MAAM,IAAIjB,UAAJ,CAAe,gFAAf,CAAN;EACA;;EAED,IAAIkB,KAAK,GAAG,EAAZ,CAXsE,CAWtD;;EAEhB,IAAIC,CAAC,GAAG,CAAR,CAbsE,CAa3D;;EAEX,OAAOA,CAAC,GAAGJ,GAAX,EAAgB;IAAE;IACjB,IAAIK,EAAE,GAAGd,QAAQ,CAACa,CAAD,CAAjB;IACA,IAAIE,QAAQ,GAAGlB,WAAW,CAACW,GAAD,EAAMM,EAAN,CAA1B;;IACA,IAAIC,QAAJ,EAAc;MACb,IAAIC,MAAM,GAAGpB,GAAG,CAACY,GAAD,EAAMM,EAAN,CAAhB;MACAX,KAAK,CAACS,KAAD,EAAQI,MAAR,CAAL;IACA;;IACDH,CAAC,IAAI,CAAL;EACA;;EAED,IAAII,SAAS,GAAGL,KAAK,CAACD,MAAtB,CAzBsE,CAyBxC;;EAE9BP,KAAK,CAACQ,KAAD,EAAQF,WAAR,CAAL,CA3BsE,CA2B3C;;EAE3B,IAAIQ,CAAC,GAAG,CAAR,CA7BsE,CA6B3D;;EAEX,OAAOA,CAAC,GAAGD,SAAX,EAAsB;IAAE;IACvBlB,GAAG,CAACS,GAAD,EAAMR,QAAQ,CAACkB,CAAD,CAAd,EAAmBN,KAAK,CAACM,CAAD,CAAxB,EAA6B,IAA7B,CAAH;IACAA,CAAC,IAAI,CAAL;EACA;;EAED,OAAOA,CAAC,GAAGT,GAAX,EAAgB;IAAE;IACjBd,qBAAqB,CAACa,GAAD,EAAMR,QAAQ,CAACkB,CAAD,CAAd,CAArB;IACAA,CAAC,IAAI,CAAL;EACA;;EACD,OAAOV,GAAP,CAxCsE,CAwC1D;AACZ,CAzCD"},"metadata":{},"sourceType":"script"}