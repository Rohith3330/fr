{"ast":null,"code":"/**\n * @fileoverview Rule to disallow negating the left operand of relational operators\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given operator is `in` or `instanceof`\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is `in` or `instanceof`\n */\n\n\nfunction isInOrInstanceOfOperator(op) {\n  return op === \"in\" || op === \"instanceof\";\n}\n/**\n * Checks whether the given operator is an ordering relational operator or not.\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is an ordering relational operator.\n */\n\n\nfunction isOrderingRelationalOperator(op) {\n  return op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\";\n}\n/**\n * Checks whether the given node is a logical negation expression or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a logical negation expression.\n */\n\n\nfunction isNegation(node) {\n  return node.type === \"UnaryExpression\" && node.operator === \"!\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow negating the left operand of relational operators\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unsafe-negation\"\n    },\n    hasSuggestions: true,\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForOrderingRelations: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: null,\n    messages: {\n      unexpected: \"Unexpected negating the left operand of '{{operator}}' operator.\",\n      suggestNegatedExpression: \"Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.\",\n      suggestParenthesisedNegation: \"Wrap negation in '()' to make the intention explicit. This preserves the current behavior.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0] || {};\n    const enforceForOrderingRelations = options.enforceForOrderingRelations === true;\n    return {\n      BinaryExpression(node) {\n        const operator = node.operator;\n        const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);\n\n        if ((isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) && isNegation(node.left) && !astUtils.isParenthesised(sourceCode, node.left)) {\n          context.report({\n            node,\n            loc: node.left.loc,\n            messageId: \"unexpected\",\n            data: {\n              operator\n            },\n            suggest: [{\n              messageId: \"suggestNegatedExpression\",\n              data: {\n                operator\n              },\n\n              fix(fixer) {\n                const negationToken = sourceCode.getFirstToken(node.left);\n                const fixRange = [negationToken.range[1], node.range[1]];\n                const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\n                return fixer.replaceTextRange(fixRange, `(${text})`);\n              }\n\n            }, {\n              messageId: \"suggestParenthesisedNegation\",\n\n              fix(fixer) {\n                return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);\n              }\n\n            }]\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","isInOrInstanceOfOperator","op","isOrderingRelationalOperator","isNegation","node","type","operator","module","exports","meta","docs","description","recommended","url","hasSuggestions","schema","properties","enforceForOrderingRelations","default","additionalProperties","fixable","messages","unexpected","suggestNegatedExpression","suggestParenthesisedNegation","create","context","sourceCode","getSourceCode","options","BinaryExpression","orderingRelationRuleApplies","left","isParenthesised","report","loc","messageId","data","suggest","fix","fixer","negationToken","getFirstToken","fixRange","range","text","slice","replaceTextRange","replaceText","getText"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/no-unsafe-negation.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow negating the left operand of relational operators\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given operator is `in` or `instanceof`\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is `in` or `instanceof`\n */\nfunction isInOrInstanceOfOperator(op) {\n    return op === \"in\" || op === \"instanceof\";\n}\n\n/**\n * Checks whether the given operator is an ordering relational operator or not.\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is an ordering relational operator.\n */\nfunction isOrderingRelationalOperator(op) {\n    return op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\";\n}\n\n/**\n * Checks whether the given node is a logical negation expression or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a logical negation expression.\n */\nfunction isNegation(node) {\n    return node.type === \"UnaryExpression\" && node.operator === \"!\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow negating the left operand of relational operators\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unsafe-negation\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    enforceForOrderingRelations: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: null,\n\n        messages: {\n            unexpected: \"Unexpected negating the left operand of '{{operator}}' operator.\",\n            suggestNegatedExpression: \"Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.\",\n            suggestParenthesisedNegation: \"Wrap negation in '()' to make the intention explicit. This preserves the current behavior.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0] || {};\n        const enforceForOrderingRelations = options.enforceForOrderingRelations === true;\n\n        return {\n            BinaryExpression(node) {\n                const operator = node.operator;\n                const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);\n\n                if (\n                    (isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) &&\n                    isNegation(node.left) &&\n                    !astUtils.isParenthesised(sourceCode, node.left)\n                ) {\n                    context.report({\n                        node,\n                        loc: node.left.loc,\n                        messageId: \"unexpected\",\n                        data: { operator },\n                        suggest: [\n                            {\n                                messageId: \"suggestNegatedExpression\",\n                                data: { operator },\n                                fix(fixer) {\n                                    const negationToken = sourceCode.getFirstToken(node.left);\n                                    const fixRange = [negationToken.range[1], node.range[1]];\n                                    const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\n\n                                    return fixer.replaceTextRange(fixRange, `(${text})`);\n                                }\n                            },\n                            {\n                                messageId: \"suggestParenthesisedNegation\",\n                                fix(fixer) {\n                                    return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);\n                                }\n                            }\n                        ]\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}