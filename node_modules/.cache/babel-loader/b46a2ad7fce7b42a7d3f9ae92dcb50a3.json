{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxFlow = require(\"@babel/plugin-syntax-flow\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const FLOW_DIRECTIVE = /(@flow(\\s+(strict(-local)?|weak))?|@noflow)/;\n  let skipStrip = false;\n  const {\n    requireDirective = false\n  } = opts;\n  {\n    var {\n      allowDeclareFields = false\n    } = opts;\n  }\n  return {\n    name: \"transform-flow-strip-types\",\n    inherits: _pluginSyntaxFlow.default,\n    visitor: {\n      Program(path, _ref) {\n        let {\n          file: {\n            ast: {\n              comments\n            }\n          }\n        } = _ref;\n        skipStrip = false;\n        let directiveFound = false;\n\n        if (comments) {\n          for (const comment of comments) {\n            if (FLOW_DIRECTIVE.test(comment.value)) {\n              directiveFound = true;\n              comment.value = comment.value.replace(FLOW_DIRECTIVE, \"\");\n\n              if (!comment.value.replace(/\\*/g, \"\").trim()) {\n                comment.ignore = true;\n              }\n            }\n          }\n        }\n\n        if (!directiveFound && requireDirective) {\n          skipStrip = true;\n        }\n      },\n\n      ImportDeclaration(path) {\n        if (skipStrip) return;\n        if (!path.node.specifiers.length) return;\n        let typeCount = 0;\n        path.node.specifiers.forEach(_ref2 => {\n          let {\n            importKind\n          } = _ref2;\n\n          if (importKind === \"type\" || importKind === \"typeof\") {\n            typeCount++;\n          }\n        });\n\n        if (typeCount === path.node.specifiers.length) {\n          path.remove();\n        }\n      },\n\n      Flow(path) {\n        if (skipStrip) {\n          throw path.buildCodeFrameError(\"A @flow directive is required when using Flow annotations with \" + \"the `requireDirective` option.\");\n        }\n\n        path.remove();\n      },\n\n      ClassPrivateProperty(path) {\n        if (skipStrip) return;\n        path.node.typeAnnotation = null;\n      },\n\n      Class(path) {\n        if (skipStrip) return;\n        path.node.implements = null;\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassProperty()) {\n            const {\n              node\n            } = child;\n            {\n              if (!allowDeclareFields && node.declare) {\n                throw child.buildCodeFrameError(`The 'declare' modifier is only allowed when the ` + `'allowDeclareFields' option of ` + `@babel/plugin-transform-flow-strip-types or ` + `@babel/preset-flow is enabled.`);\n              }\n            }\n\n            if (node.declare) {\n              child.remove();\n            } else {\n              {\n                if (!allowDeclareFields && !node.value && !node.decorators) {\n                  child.remove();\n                  return;\n                }\n              }\n              node.variance = null;\n              node.typeAnnotation = null;\n            }\n          }\n        });\n      },\n\n      AssignmentPattern(_ref3) {\n        let {\n          node\n        } = _ref3;\n        if (skipStrip) return;\n\n        if (node.left.optional) {\n          node.left.optional = false;\n        }\n      },\n\n      Function(_ref4) {\n        let {\n          node\n        } = _ref4;\n        if (skipStrip) return;\n\n        if (node.params.length > 0 && node.params[0].type === \"Identifier\" && node.params[0].name === \"this\") {\n          node.params.shift();\n        }\n\n        for (let i = 0; i < node.params.length; i++) {\n          let param = node.params[i];\n\n          if (param.type === \"AssignmentPattern\") {\n            param = param.left;\n          }\n\n          if (param.optional) {\n            param.optional = false;\n          }\n        }\n\n        if (!_core.types.isMethod(node)) {\n          node.predicate = null;\n        }\n      },\n\n      TypeCastExpression(path) {\n        if (skipStrip) return;\n        let {\n          node\n        } = path;\n\n        do {\n          node = node.expression;\n        } while (_core.types.isTypeCastExpression(node));\n\n        path.replaceWith(node);\n      },\n\n      CallExpression(_ref5) {\n        let {\n          node\n        } = _ref5;\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n\n      OptionalCallExpression(_ref6) {\n        let {\n          node\n        } = _ref6;\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n\n      NewExpression(_ref7) {\n        let {\n          node\n        } = _ref7;\n        if (skipStrip) return;\n        node.typeArguments = null;\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["api","opts","assertVersion","FLOW_DIRECTIVE","skipStrip","requireDirective","allowDeclareFields","name","inherits","syntaxFlow","visitor","Program","path","file","ast","comments","directiveFound","comment","test","value","replace","trim","ignore","ImportDeclaration","node","specifiers","length","typeCount","forEach","importKind","remove","Flow","buildCodeFrameError","ClassPrivateProperty","typeAnnotation","Class","implements","get","child","isClassProperty","declare","decorators","variance","AssignmentPattern","left","optional","Function","params","type","shift","i","param","t","isMethod","predicate","TypeCastExpression","expression","isTypeCastExpression","replaceWith","CallExpression","typeArguments","OptionalCallExpression","NewExpression"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-transform-flow-strip-types\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxFlow from \"@babel/plugin-syntax-flow\";\nimport { types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport interface Options {\n  requireDirective?: boolean;\n  allowDeclareFields?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(7);\n\n  const FLOW_DIRECTIVE = /(@flow(\\s+(strict(-local)?|weak))?|@noflow)/;\n\n  let skipStrip = false;\n\n  const { requireDirective = false } = opts;\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // eslint-disable-next-line no-var\n    var { allowDeclareFields = false } = opts;\n  }\n\n  return {\n    name: \"transform-flow-strip-types\",\n    inherits: syntaxFlow,\n\n    visitor: {\n      Program(\n        path,\n        {\n          file: {\n            ast: { comments },\n          },\n        },\n      ) {\n        skipStrip = false;\n        let directiveFound = false;\n\n        if (comments) {\n          for (const comment of comments) {\n            if (FLOW_DIRECTIVE.test(comment.value)) {\n              directiveFound = true;\n\n              // remove flow directive\n              comment.value = comment.value.replace(FLOW_DIRECTIVE, \"\");\n\n              // remove the comment completely if it only consists of whitespace and/or stars\n              if (!comment.value.replace(/\\*/g, \"\").trim()) {\n                comment.ignore = true;\n              }\n            }\n          }\n        }\n\n        if (!directiveFound && requireDirective) {\n          skipStrip = true;\n        }\n      },\n      ImportDeclaration(path) {\n        if (skipStrip) return;\n        if (!path.node.specifiers.length) return;\n\n        let typeCount = 0;\n\n        // @ts-expect-error importKind is only in importSpecifier\n        path.node.specifiers.forEach(({ importKind }) => {\n          if (importKind === \"type\" || importKind === \"typeof\") {\n            typeCount++;\n          }\n        });\n\n        if (typeCount === path.node.specifiers.length) {\n          path.remove();\n        }\n      },\n\n      Flow(\n        path: NodePath<\n          t.Flow | t.ImportDeclaration | t.ExportDeclaration | t.ImportSpecifier\n        >,\n      ) {\n        if (skipStrip) {\n          throw path.buildCodeFrameError(\n            \"A @flow directive is required when using Flow annotations with \" +\n              \"the `requireDirective` option.\",\n          );\n        }\n\n        path.remove();\n      },\n\n      ClassPrivateProperty(path) {\n        if (skipStrip) return;\n        path.node.typeAnnotation = null;\n      },\n\n      Class(path) {\n        if (skipStrip) return;\n        path.node.implements = null;\n\n        // We do this here instead of in a `ClassProperty` visitor because the class transform\n        // would transform the class before we reached the class property.\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassProperty()) {\n            const { node } = child;\n\n            if (!process.env.BABEL_8_BREAKING) {\n              if (!allowDeclareFields && node.declare) {\n                throw child.buildCodeFrameError(\n                  `The 'declare' modifier is only allowed when the ` +\n                    `'allowDeclareFields' option of ` +\n                    `@babel/plugin-transform-flow-strip-types or ` +\n                    `@babel/preset-flow is enabled.`,\n                );\n              }\n            }\n\n            if (node.declare) {\n              child.remove();\n            } else {\n              if (!process.env.BABEL_8_BREAKING) {\n                if (!allowDeclareFields && !node.value && !node.decorators) {\n                  child.remove();\n                  return;\n                }\n              }\n\n              node.variance = null;\n              node.typeAnnotation = null;\n            }\n          }\n        });\n      },\n\n      AssignmentPattern({ node }) {\n        if (skipStrip) return;\n        // @ts-expect-error optional is not in ObjectPattern\n        if (node.left.optional) {\n          // @ts-expect-error optional is not in ObjectPattern\n          node.left.optional = false;\n        }\n      },\n\n      Function({ node }) {\n        if (skipStrip) return;\n        if (\n          node.params.length > 0 &&\n          node.params[0].type === \"Identifier\" &&\n          node.params[0].name === \"this\"\n        ) {\n          node.params.shift();\n        }\n        for (let i = 0; i < node.params.length; i++) {\n          let param = node.params[i];\n          if (param.type === \"AssignmentPattern\") {\n            // @ts-expect-error: refine AST types, the left of an assignment pattern as a binding\n            // must not be a MemberExpression\n            param = param.left;\n          }\n          // @ts-expect-error optional is not in ObjectPattern\n          if (param.optional) {\n            // @ts-expect-error optional is not in ObjectPattern\n            param.optional = false;\n          }\n        }\n\n        if (!t.isMethod(node)) {\n          node.predicate = null;\n        }\n      },\n\n      TypeCastExpression(path) {\n        if (skipStrip) return;\n        let { node } = path;\n        do {\n          // @ts-expect-error node is a search pointer\n          node = node.expression;\n        } while (t.isTypeCastExpression(node));\n        path.replaceWith(node);\n      },\n\n      CallExpression({ node }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n\n      OptionalCallExpression({ node }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n\n      NewExpression({ node }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n    },\n  };\n});\n"]},"metadata":{},"sourceType":"script"}