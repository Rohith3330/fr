{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'no-throw-literal',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow throwing literals as exceptions',\n      recommended: 'strict',\n      extendsBaseRule: true,\n      requiresTypeChecking: true\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowThrowingAny: {\n          type: 'boolean'\n        },\n        allowThrowingUnknown: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      object: 'Expected an error object to be thrown.',\n      undef: 'Do not throw undefined.'\n    }\n  },\n  defaultOptions: [{\n    allowThrowingAny: true,\n    allowThrowingUnknown: true\n  }],\n\n  create(context, _ref) {\n    let [options] = _ref;\n    const parserServices = util.getParserServices(context);\n    const program = parserServices.program;\n    const checker = program.getTypeChecker();\n\n    function isErrorLike(type) {\n      var _a;\n\n      if (type.isIntersection()) {\n        return type.types.some(isErrorLike);\n      }\n\n      if (type.isUnion()) {\n        return type.types.every(isErrorLike);\n      }\n\n      const symbol = type.getSymbol();\n\n      if (!symbol) {\n        return false;\n      }\n\n      if (symbol.getName() === 'Error') {\n        const declarations = (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : [];\n\n        for (const declaration of declarations) {\n          const sourceFile = declaration.getSourceFile();\n\n          if (program.isSourceFileDefaultLibrary(sourceFile)) {\n            return true;\n          }\n        }\n      }\n\n      if (symbol.flags & (ts.SymbolFlags.Class | ts.SymbolFlags.Interface)) {\n        for (const baseType of checker.getBaseTypes(type)) {\n          if (isErrorLike(baseType)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    function checkThrowArgument(node) {\n      if (node.type === utils_1.AST_NODE_TYPES.AwaitExpression || node.type === utils_1.AST_NODE_TYPES.YieldExpression) {\n        return;\n      }\n\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      const type = checker.getTypeAtLocation(tsNode);\n\n      if (type.flags & ts.TypeFlags.Undefined) {\n        context.report({\n          node,\n          messageId: 'undef'\n        });\n        return;\n      }\n\n      if (options.allowThrowingAny && util.isTypeAnyType(type)) {\n        return;\n      }\n\n      if (options.allowThrowingUnknown && util.isTypeUnknownType(type)) {\n        return;\n      }\n\n      if (isErrorLike(type)) {\n        return;\n      }\n\n      context.report({\n        node,\n        messageId: 'object'\n      });\n    }\n\n    return {\n      ThrowStatement(node) {\n        if (node.argument) {\n          checkThrowArgument(node.argument);\n        }\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","extendsBaseRule","requiresTypeChecking","schema","properties","allowThrowingAny","allowThrowingUnknown","additionalProperties","messages","object","undef","defaultOptions","create","context","options","parserServices","getParserServices","program","checker","getTypeChecker","isErrorLike","isIntersection","types","some","isUnion","every","symbol","getSymbol","getName","declarations","getDeclarations","_a","declaration","sourceFile","getSourceFile","isSourceFileDefaultLibrary","flags","ts","SymbolFlags","Class","Interface","baseType","getBaseTypes","checkThrowArgument","node","utils_1","AwaitExpression","YieldExpression","tsNode","esTreeNodeToTSNodeMap","get","getTypeAtLocation","TypeFlags","Undefined","report","messageId","isTypeAnyType","isTypeUnknownType","ThrowStatement","argument"],"sources":["../../src/rules/no-throw-literal.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}