{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'consistent-type-assertions',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce consistent usage of type assertions',\n      recommended: 'strict'\n    },\n    messages: {\n      as: \"Use 'as {{cast}}' instead of '<{{cast}}>'.\",\n      'angle-bracket': \"Use '<{{cast}}>' instead of 'as {{cast}}'.\",\n      never: 'Do not use any type assertions.',\n      unexpectedObjectTypeAssertion: 'Always prefer const x: T = { ... }.'\n    },\n    schema: [{\n      oneOf: [{\n        type: 'object',\n        properties: {\n          assertionStyle: {\n            enum: ['never']\n          }\n        },\n        additionalProperties: false,\n        required: ['assertionStyle']\n      }, {\n        type: 'object',\n        properties: {\n          assertionStyle: {\n            enum: ['as', 'angle-bracket']\n          },\n          objectLiteralTypeAssertions: {\n            enum: ['allow', 'allow-as-parameter', 'never']\n          }\n        },\n        additionalProperties: false,\n        required: ['assertionStyle']\n      }]\n    }]\n  },\n  defaultOptions: [{\n    assertionStyle: 'as',\n    objectLiteralTypeAssertions: 'allow'\n  }],\n\n  create(context, _ref) {\n    let [options] = _ref;\n    const sourceCode = context.getSourceCode();\n\n    function isConst(node) {\n      if (node.type !== utils_1.AST_NODE_TYPES.TSTypeReference) {\n        return false;\n      }\n\n      return node.typeName.type === utils_1.AST_NODE_TYPES.Identifier && node.typeName.name === 'const';\n    }\n\n    function reportIncorrectAssertionType(node) {\n      const messageId = options.assertionStyle; // If this node is `as const`, then don't report an error.\n\n      if (isConst(node.typeAnnotation) && messageId === 'never') {\n        return;\n      }\n\n      context.report({\n        node,\n        messageId,\n        data: messageId !== 'never' ? {\n          cast: sourceCode.getText(node.typeAnnotation)\n        } : {}\n      });\n    }\n\n    function checkType(node) {\n      switch (node.type) {\n        case utils_1.AST_NODE_TYPES.TSAnyKeyword:\n        case utils_1.AST_NODE_TYPES.TSUnknownKeyword:\n          return false;\n\n        case utils_1.AST_NODE_TYPES.TSTypeReference:\n          return (// Ignore `as const` and `<const>`\n            !isConst(node) || // Allow qualified names which have dots between identifiers, `Foo.Bar`\n            node.typeName.type === utils_1.AST_NODE_TYPES.TSQualifiedName\n          );\n\n        default:\n          return true;\n      }\n    }\n\n    function checkExpression(node) {\n      if (options.assertionStyle === 'never' || options.objectLiteralTypeAssertions === 'allow' || node.expression.type !== utils_1.AST_NODE_TYPES.ObjectExpression) {\n        return;\n      }\n\n      if (options.objectLiteralTypeAssertions === 'allow-as-parameter' && node.parent && (node.parent.type === utils_1.AST_NODE_TYPES.NewExpression || node.parent.type === utils_1.AST_NODE_TYPES.CallExpression || node.parent.type === utils_1.AST_NODE_TYPES.ThrowStatement || node.parent.type === utils_1.AST_NODE_TYPES.AssignmentPattern || node.parent.type === utils_1.AST_NODE_TYPES.JSXExpressionContainer)) {\n        return;\n      }\n\n      if (checkType(node.typeAnnotation) && node.expression.type === utils_1.AST_NODE_TYPES.ObjectExpression) {\n        context.report({\n          node,\n          messageId: 'unexpectedObjectTypeAssertion'\n        });\n      }\n    }\n\n    return {\n      TSTypeAssertion(node) {\n        if (options.assertionStyle !== 'angle-bracket') {\n          reportIncorrectAssertionType(node);\n          return;\n        }\n\n        checkExpression(node);\n      },\n\n      TSAsExpression(node) {\n        if (options.assertionStyle !== 'as') {\n          reportIncorrectAssertionType(node);\n          return;\n        }\n\n        checkExpression(node);\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","messages","as","never","unexpectedObjectTypeAssertion","schema","oneOf","properties","assertionStyle","enum","additionalProperties","required","objectLiteralTypeAssertions","defaultOptions","create","context","options","sourceCode","getSourceCode","isConst","node","utils_1","TSTypeReference","typeName","Identifier","reportIncorrectAssertionType","messageId","typeAnnotation","report","data","cast","getText","checkType","TSAnyKeyword","TSUnknownKeyword","TSQualifiedName","checkExpression","expression","ObjectExpression","parent","NewExpression","CallExpression","ThrowStatement","AssignmentPattern","JSXExpressionContainer","TSTypeAssertion","TSAsExpression"],"sources":["../../src/rules/consistent-type-assertions.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}