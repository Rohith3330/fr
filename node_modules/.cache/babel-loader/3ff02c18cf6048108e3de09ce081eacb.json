{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)(api => {\n  api.assertVersion(7);\n  return {\n    name: \"transform-typeof-symbol\",\n    visitor: {\n      Scope(_ref) {\n        let {\n          scope\n        } = _ref;\n\n        if (!scope.getBinding(\"Symbol\")) {\n          return;\n        }\n\n        scope.rename(\"Symbol\");\n      },\n\n      UnaryExpression(path) {\n        const {\n          node,\n          parent\n        } = path;\n        if (node.operator !== \"typeof\") return;\n\n        if (path.parentPath.isBinaryExpression() && _core.types.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {\n          const opposite = path.getOpposite();\n\n          if (opposite.isStringLiteral() && opposite.node.value !== \"symbol\" && opposite.node.value !== \"object\") {\n            return;\n          }\n        }\n\n        let isUnderHelper = path.findParent(path => {\n          if (path.isFunction()) {\n            var _path$get;\n\n            return ((_path$get = path.get(\"body.directives.0\")) == null ? void 0 : _path$get.node.value.value) === \"@babel/helpers - typeof\";\n          }\n        });\n        if (isUnderHelper) return;\n        const helper = this.addHelper(\"typeof\");\n        isUnderHelper = path.findParent(path => {\n          return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;\n        });\n\n        if (isUnderHelper) {\n          return;\n        }\n\n        const call = _core.types.callExpression(helper, [node.argument]);\n\n        const arg = path.get(\"argument\");\n\n        if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {\n          const unary = _core.types.unaryExpression(\"typeof\", _core.types.cloneNode(node.argument));\n\n          path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression(\"===\", unary, _core.types.stringLiteral(\"undefined\")), _core.types.stringLiteral(\"undefined\"), call));\n        } else {\n          path.replaceWith(call);\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_core","_default","declare","api","assertVersion","name","visitor","Scope","scope","getBinding","rename","UnaryExpression","path","node","parent","operator","parentPath","isBinaryExpression","types","EQUALITY_BINARY_OPERATORS","indexOf","opposite","getOpposite","isStringLiteral","isUnderHelper","findParent","isFunction","_path$get","get","helper","addHelper","isVariableDeclarator","id","isFunctionDeclaration","call","callExpression","argument","arg","isIdentifier","hasBinding","unary","unaryExpression","cloneNode","replaceWith","conditionalExpression","binaryExpression","stringLiteral"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/plugin-transform-typeof-symbol/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)(api => {\n  api.assertVersion(7);\n  return {\n    name: \"transform-typeof-symbol\",\n    visitor: {\n      Scope({\n        scope\n      }) {\n        if (!scope.getBinding(\"Symbol\")) {\n          return;\n        }\n\n        scope.rename(\"Symbol\");\n      },\n\n      UnaryExpression(path) {\n        const {\n          node,\n          parent\n        } = path;\n        if (node.operator !== \"typeof\") return;\n\n        if (path.parentPath.isBinaryExpression() && _core.types.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {\n          const opposite = path.getOpposite();\n\n          if (opposite.isStringLiteral() && opposite.node.value !== \"symbol\" && opposite.node.value !== \"object\") {\n            return;\n          }\n        }\n\n        let isUnderHelper = path.findParent(path => {\n          if (path.isFunction()) {\n            var _path$get;\n\n            return ((_path$get = path.get(\"body.directives.0\")) == null ? void 0 : _path$get.node.value.value) === \"@babel/helpers - typeof\";\n          }\n        });\n        if (isUnderHelper) return;\n        const helper = this.addHelper(\"typeof\");\n        isUnderHelper = path.findParent(path => {\n          return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;\n        });\n\n        if (isUnderHelper) {\n          return;\n        }\n\n        const call = _core.types.callExpression(helper, [node.argument]);\n\n        const arg = path.get(\"argument\");\n\n        if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {\n          const unary = _core.types.unaryExpression(\"typeof\", _core.types.cloneNode(node.argument));\n\n          path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression(\"===\", unary, _core.types.stringLiteral(\"undefined\")), _core.types.stringLiteral(\"undefined\"), call));\n        } else {\n          path.replaceWith(call);\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}