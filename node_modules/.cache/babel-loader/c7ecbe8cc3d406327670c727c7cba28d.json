{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.exhaustiveTypeException = exports.getStrippedPath = exports.getPathsToTry = void 0;\n\nvar path = require(\"path\");\n\nvar path_1 = require(\"path\");\n\nvar filesystem_1 = require(\"./filesystem\");\n/**\n * Builds a list of all physical paths to try by:\n * 1. Check for file named exactly as request.\n * 2. Check for files named as request ending in any of the extensions.\n * 3. Check for file specified in package.json's main property.\n * 4. Check for files named as request ending in \"index\" with any of the extensions.\n */\n\n\nfunction getPathsToTry(extensions, absolutePathMappings, requestedModule) {\n  if (!absolutePathMappings || !requestedModule || requestedModule[0] === \".\") {\n    return undefined;\n  }\n\n  var pathsToTry = [];\n\n  for (var _i = 0, absolutePathMappings_1 = absolutePathMappings; _i < absolutePathMappings_1.length; _i++) {\n    var entry = absolutePathMappings_1[_i];\n    var starMatch = entry.pattern === requestedModule ? \"\" : matchStar(entry.pattern, requestedModule);\n\n    if (starMatch !== undefined) {\n      var _loop_1 = function (physicalPathPattern) {\n        var physicalPath = physicalPathPattern.replace(\"*\", starMatch);\n        pathsToTry.push({\n          type: \"file\",\n          path: physicalPath\n        });\n        pathsToTry.push.apply(pathsToTry, extensions.map(function (e) {\n          return {\n            type: \"extension\",\n            path: physicalPath + e\n          };\n        }));\n        pathsToTry.push({\n          type: \"package\",\n          path: path.join(physicalPath, \"/package.json\")\n        });\n        var indexPath = path.join(physicalPath, \"/index\");\n        pathsToTry.push.apply(pathsToTry, extensions.map(function (e) {\n          return {\n            type: \"index\",\n            path: indexPath + e\n          };\n        }));\n      };\n\n      for (var _a = 0, _b = entry.paths; _a < _b.length; _a++) {\n        var physicalPathPattern = _b[_a];\n\n        _loop_1(physicalPathPattern);\n      }\n    }\n  }\n\n  return pathsToTry.length === 0 ? undefined : pathsToTry;\n}\n\nexports.getPathsToTry = getPathsToTry; // Not sure why we don't just return the full found path?\n\nfunction getStrippedPath(tryPath) {\n  return tryPath.type === \"index\" ? (0, path_1.dirname)(tryPath.path) : tryPath.type === \"file\" ? tryPath.path : tryPath.type === \"extension\" ? (0, filesystem_1.removeExtension)(tryPath.path) : tryPath.type === \"package\" ? tryPath.path : exhaustiveTypeException(tryPath.type);\n}\n\nexports.getStrippedPath = getStrippedPath;\n\nfunction exhaustiveTypeException(check) {\n  throw new Error(\"Unknown type \".concat(check));\n}\n\nexports.exhaustiveTypeException = exhaustiveTypeException;\n/**\n * Matches pattern with a single star against search.\n * Star must match at least one character to be considered a match.\n * @param patttern for example \"foo*\"\n * @param search for example \"fooawesomebar\"\n * @returns the part of search that * matches, or undefined if no match.\n */\n\nfunction matchStar(pattern, search) {\n  if (search.length < pattern.length) {\n    return undefined;\n  }\n\n  if (pattern === \"*\") {\n    return search;\n  }\n\n  var star = pattern.indexOf(\"*\");\n\n  if (star === -1) {\n    return undefined;\n  }\n\n  var part1 = pattern.substring(0, star);\n  var part2 = pattern.substring(star + 1);\n\n  if (search.substr(0, star) !== part1) {\n    return undefined;\n  }\n\n  if (search.substr(search.length - part2.length) !== part2) {\n    return undefined;\n  }\n\n  return search.substr(star, search.length - part2.length);\n}","map":{"version":3,"mappings":"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","names":["getPathsToTry","extensions","absolutePathMappings","requestedModule","undefined","pathsToTry","_i","entry","starMatch","pattern","matchStar","physicalPathPattern","physicalPath","replace","push","type","path","apply","map","e","join","indexPath","paths","_a","length","exports","getStrippedPath","tryPath","exhaustiveTypeException","check","Error","search","star","indexOf","part1","substring","part2","substr"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\tsconfig-paths\\src\\try-path.ts"],"sourcesContent":["import * as path from \"path\";\nimport { MappingEntry } from \"./mapping-entry\";\nimport { dirname } from \"path\";\nimport { removeExtension } from \"./filesystem\";\n\nexport interface TryPath {\n  readonly type: \"file\" | \"extension\" | \"index\" | \"package\";\n  readonly path: string;\n}\n\n/**\n * Builds a list of all physical paths to try by:\n * 1. Check for file named exactly as request.\n * 2. Check for files named as request ending in any of the extensions.\n * 3. Check for file specified in package.json's main property.\n * 4. Check for files named as request ending in \"index\" with any of the extensions.\n */\nexport function getPathsToTry(\n  extensions: ReadonlyArray<string>,\n  absolutePathMappings: ReadonlyArray<MappingEntry>,\n  requestedModule: string\n): ReadonlyArray<TryPath> | undefined {\n  if (!absolutePathMappings || !requestedModule || requestedModule[0] === \".\") {\n    return undefined;\n  }\n\n  const pathsToTry: Array<TryPath> = [];\n  for (const entry of absolutePathMappings) {\n    const starMatch =\n      entry.pattern === requestedModule\n        ? \"\"\n        : matchStar(entry.pattern, requestedModule);\n    if (starMatch !== undefined) {\n      for (const physicalPathPattern of entry.paths) {\n        const physicalPath = physicalPathPattern.replace(\"*\", starMatch);\n        pathsToTry.push({ type: \"file\", path: physicalPath });\n        pathsToTry.push(\n          ...extensions.map(\n            (e) => ({ type: \"extension\", path: physicalPath + e } as TryPath)\n          )\n        );\n        pathsToTry.push({\n          type: \"package\",\n          path: path.join(physicalPath, \"/package.json\"),\n        });\n        const indexPath = path.join(physicalPath, \"/index\");\n        pathsToTry.push(\n          ...extensions.map(\n            (e) => ({ type: \"index\", path: indexPath + e } as TryPath)\n          )\n        );\n      }\n    }\n  }\n  return pathsToTry.length === 0 ? undefined : pathsToTry;\n}\n\n// Not sure why we don't just return the full found path?\nexport function getStrippedPath(tryPath: TryPath): string {\n  return tryPath.type === \"index\"\n    ? dirname(tryPath.path)\n    : tryPath.type === \"file\"\n    ? tryPath.path\n    : tryPath.type === \"extension\"\n    ? removeExtension(tryPath.path)\n    : tryPath.type === \"package\"\n    ? tryPath.path\n    : exhaustiveTypeException(tryPath.type);\n}\n\nexport function exhaustiveTypeException(check: never): never {\n  throw new Error(`Unknown type ${check}`);\n}\n\n/**\n * Matches pattern with a single star against search.\n * Star must match at least one character to be considered a match.\n * @param patttern for example \"foo*\"\n * @param search for example \"fooawesomebar\"\n * @returns the part of search that * matches, or undefined if no match.\n */\nfunction matchStar(pattern: string, search: string): string | undefined {\n  if (search.length < pattern.length) {\n    return undefined;\n  }\n  if (pattern === \"*\") {\n    return search;\n  }\n  const star = pattern.indexOf(\"*\");\n  if (star === -1) {\n    return undefined;\n  }\n  const part1 = pattern.substring(0, star);\n  const part2 = pattern.substring(star + 1);\n  if (search.substr(0, star) !== part1) {\n    return undefined;\n  }\n  if (search.substr(search.length - part2.length) !== part2) {\n    return undefined;\n  }\n  return search.substr(star, search.length - part2.length);\n}\n"]},"metadata":{},"sourceType":"script"}