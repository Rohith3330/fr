{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCachedDescriptors = createCachedDescriptors;\nexports.createDescriptor = createDescriptor;\nexports.createUncachedDescriptors = createUncachedDescriptors;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _functional = require(\"../gensync-utils/functional\");\n\nvar _files = require(\"./files\");\n\nvar _item = require(\"./item\");\n\nvar _caching = require(\"./caching\");\n\nvar _resolveTargets = require(\"./resolve-targets\");\n\nfunction isEqualDescriptor(a, b) {\n  return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && (a.file && a.file.request) === (b.file && b.file.request) && (a.file && a.file.resolved) === (b.file && b.file.resolved);\n}\n\nfunction* handlerOf(value) {\n  return value;\n}\n\nfunction optionsWithResolvedBrowserslistConfigFile(options, dirname) {\n  if (typeof options.browserslistConfigFile === \"string\") {\n    options.browserslistConfigFile = (0, _resolveTargets.resolveBrowserslistConfigFile)(options.browserslistConfigFile, dirname);\n  }\n\n  return options;\n}\n\nfunction createCachedDescriptors(dirname, options, alias) {\n  const {\n    plugins,\n    presets,\n    passPerPreset\n  } = options;\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n    plugins: plugins ? () => createCachedPluginDescriptors(plugins, dirname)(alias) : () => handlerOf([]),\n    presets: presets ? () => createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset) : () => handlerOf([])\n  };\n}\n\nfunction createUncachedDescriptors(dirname, options, alias) {\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n    plugins: (0, _functional.once)(() => createPluginDescriptors(options.plugins || [], dirname, alias)),\n    presets: (0, _functional.once)(() => createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset))\n  };\n}\n\nconst PRESET_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPresetDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {\n  const dirname = cache.using(dir => dir);\n  return (0, _caching.makeStrongCacheSync)(alias => (0, _caching.makeStrongCache)(function* (passPerPreset) {\n    const descriptors = yield* createPresetDescriptors(items, dirname, alias, passPerPreset);\n    return descriptors.map(desc => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc));\n  }));\n});\nconst PLUGIN_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPluginDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {\n  const dirname = cache.using(dir => dir);\n  return (0, _caching.makeStrongCache)(function* (alias) {\n    const descriptors = yield* createPluginDescriptors(items, dirname, alias);\n    return descriptors.map(desc => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc));\n  });\n});\nconst DEFAULT_OPTIONS = {};\n\nfunction loadCachedDescriptor(cache, desc) {\n  const {\n    value,\n    options = DEFAULT_OPTIONS\n  } = desc;\n  if (options === false) return desc;\n  let cacheByOptions = cache.get(value);\n\n  if (!cacheByOptions) {\n    cacheByOptions = new WeakMap();\n    cache.set(value, cacheByOptions);\n  }\n\n  let possibilities = cacheByOptions.get(options);\n\n  if (!possibilities) {\n    possibilities = [];\n    cacheByOptions.set(options, possibilities);\n  }\n\n  if (possibilities.indexOf(desc) === -1) {\n    const matches = possibilities.filter(possibility => isEqualDescriptor(possibility, desc));\n\n    if (matches.length > 0) {\n      return matches[0];\n    }\n\n    possibilities.push(desc);\n  }\n\n  return desc;\n}\n\nfunction* createPresetDescriptors(items, dirname, alias, passPerPreset) {\n  return yield* createDescriptors(\"preset\", items, dirname, alias, passPerPreset);\n}\n\nfunction* createPluginDescriptors(items, dirname, alias) {\n  return yield* createDescriptors(\"plugin\", items, dirname, alias);\n}\n\nfunction* createDescriptors(type, items, dirname, alias, ownPass) {\n  const descriptors = yield* _gensync().all(items.map((item, index) => createDescriptor(item, dirname, {\n    type,\n    alias: `${alias}$${index}`,\n    ownPass: !!ownPass\n  })));\n  assertNoDuplicates(descriptors);\n  return descriptors;\n}\n\nfunction* createDescriptor(pair, dirname, _ref) {\n  let {\n    type,\n    alias,\n    ownPass\n  } = _ref;\n  const desc = (0, _item.getItemDescriptor)(pair);\n\n  if (desc) {\n    return desc;\n  }\n\n  let name;\n  let options;\n  let value = pair;\n\n  if (Array.isArray(value)) {\n    if (value.length === 3) {\n      [value, options, name] = value;\n    } else {\n      [value, options] = value;\n    }\n  }\n\n  let file = undefined;\n  let filepath = null;\n\n  if (typeof value === \"string\") {\n    if (typeof type !== \"string\") {\n      throw new Error(\"To resolve a string-based item, the type of item must be given\");\n    }\n\n    const resolver = type === \"plugin\" ? _files.loadPlugin : _files.loadPreset;\n    const request = value;\n    ({\n      filepath,\n      value\n    } = yield* resolver(value, dirname));\n    file = {\n      request,\n      resolved: filepath\n    };\n  }\n\n  if (!value) {\n    throw new Error(`Unexpected falsy value: ${String(value)}`);\n  }\n\n  if (typeof value === \"object\" && value.__esModule) {\n    if (value.default) {\n      value = value.default;\n    } else {\n      throw new Error(\"Must export a default export when using ES6 modules.\");\n    }\n  }\n\n  if (typeof value !== \"object\" && typeof value !== \"function\") {\n    throw new Error(`Unsupported format: ${typeof value}. Expected an object or a function.`);\n  }\n\n  if (filepath !== null && typeof value === \"object\" && value) {\n    throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`);\n  }\n\n  return {\n    name,\n    alias: filepath || alias,\n    value,\n    options,\n    dirname,\n    ownPass,\n    file\n  };\n}\n\nfunction assertNoDuplicates(items) {\n  const map = new Map();\n\n  for (const item of items) {\n    if (typeof item.value !== \"function\") continue;\n    let nameMap = map.get(item.value);\n\n    if (!nameMap) {\n      nameMap = new Set();\n      map.set(item.value, nameMap);\n    }\n\n    if (nameMap.has(item.name)) {\n      const conflicts = items.filter(i => i.value === item.value);\n      throw new Error([`Duplicate plugin/preset detected.`, `If you'd like to use two separate instances of a plugin,`, `they need separate names, e.g.`, ``, `  plugins: [`, `    ['some-plugin', {}],`, `    ['some-plugin', {}, 'some unique name'],`, `  ]`, ``, `Duplicates detected are:`, `${JSON.stringify(conflicts, null, 2)}`].join(\"\\n\"));\n    }\n\n    nameMap.add(item.name);\n  }\n}\n\n0 && 0;","map":{"version":3,"mappings":";;;;;;;;;AAAA;EAAA;;EAAAA;IAAA;EAAA;;EAAA;AAAA;;AACA;;AAEA;;AAEA;;AAEA;;AAaA;;AA2BA,SAASC,iBAAT,CACEC,CADF,EAEEC,CAFF,EAGW;EACT,OACED,CAAC,CAACE,IAAFF,KAAWC,CAAC,CAACC,IAAbF,IACAA,CAAC,CAACG,KAAFH,KAAYC,CAAC,CAACE,KADdH,IAEAA,CAAC,CAACI,OAAFJ,KAAcC,CAAC,CAACG,OAFhBJ,IAGAA,CAAC,CAACK,OAAFL,KAAcC,CAAC,CAACI,OAHhBL,IAIAA,CAAC,CAACM,KAAFN,KAAYC,CAAC,CAACK,KAJdN,IAKAA,CAAC,CAACO,OAAFP,KAAcC,CAAC,CAACM,OALhBP,IAMA,CAACA,CAAC,CAACQ,IAAFR,IAAUA,CAAC,CAACQ,IAAFR,CAAOS,OAAlB,OAAgCR,CAAC,CAACO,IAAFP,IAAUA,CAAC,CAACO,IAAFP,CAAOQ,OAAjD,CANAT,IAOA,CAACA,CAAC,CAACQ,IAAFR,IAAUA,CAAC,CAACQ,IAAFR,CAAOU,QAAlB,OAAiCT,CAAC,CAACO,IAAFP,IAAUA,CAAC,CAACO,IAAFP,CAAOS,QAAlD,CARF;AAUD;;AASD,UAAUC,SAAV,CAAuBR,KAAvB,EAA6C;EAC3C,OAAOA,KAAP;AACD;;AAED,SAASS,yCAAT,CACER,OADF,EAEEC,OAFF,EAGoB;EAClB,IAAI,OAAOD,OAAO,CAACS,sBAAf,KAA0C,QAA9C,EAAwD;IACtDT,OAAO,CAACS,sBAART,GAAiC,mDAC/BA,OAAO,CAACS,sBADuB,EAE/BR,OAF+B,CAAjCD;EAID;;EACD,OAAOA,OAAP;AACD;;AAOM,SAASU,uBAAT,CACLT,OADK,EAELD,OAFK,EAGLE,KAHK,EAIkB;EACvB,MAAM;IAAES,OAAF;IAAWC,OAAX;IAAoBC;EAApB,IAAsCb,OAA5C;EACA,OAAO;IACLA,OAAO,EAAEQ,yCAAyC,CAACR,OAAD,EAAUC,OAAV,CAD7C;IAELU,OAAO,EAAEA,OAAO,GACZ,MAEEG,6BAA6B,CAACH,OAAD,EAAUV,OAAV,CAA7Ba,CAAgDZ,KAAhDY,CAHU,GAIZ,MAAMP,SAAS,CAAC,EAAD,CANd;IAOLK,OAAO,EAAEA,OAAO,GACZ,MAEEG,6BAA6B,CAACH,OAAD,EAAUX,OAAV,CAA7Bc,CAAgDb,KAAhDa,EACE,CAAC,CAACF,aADJE,CAHU,GAMZ,MAAMR,SAAS,CAAC,EAAD;EAbd,CAAP;AAeD;;AAMM,SAASS,yBAAT,CACLf,OADK,EAELD,OAFK,EAGLE,KAHK,EAIkB;EACvB,OAAO;IACLF,OAAO,EAAEQ,yCAAyC,CAACR,OAAD,EAAUC,OAAV,CAD7C;IAKLU,OAAO,EAAE,sBAAK,MACZM,uBAAuB,CAACjB,OAAO,CAACW,OAARX,IAAmB,EAApB,EAAwBC,OAAxB,EAAiCC,KAAjC,CADhB,CALJ;IAQLU,OAAO,EAAE,sBAAK,MACZM,uBAAuB,CACrBlB,OAAO,CAACY,OAARZ,IAAmB,EADE,EAErBC,OAFqB,EAGrBC,KAHqB,EAIrB,CAAC,CAACF,OAAO,CAACa,aAJW,CADhB;EARJ,CAAP;AAiBD;;AAED,MAAMM,uBAAuB,GAAG,IAAIC,OAAJ,EAAhC;AACA,MAAML,6BAA6B,GAAG,gCACpC,CAACM,KAAD,EAAoBC,KAApB,KAAyD;EACvD,MAAMrB,OAAO,GAAGqB,KAAK,CAACC,KAAND,CAAYE,GAAG,IAAIA,GAAnBF,CAAhB;EACA,OAAO,kCAAqBpB,KAAD,IACzB,8BAAgB,WACdW,aADc,EAEsB;IACpC,MAAMY,WAAW,GAAG,OAAOP,uBAAuB,CAChDG,KADgD,EAEhDpB,OAFgD,EAGhDC,KAHgD,EAIhDW,aAJgD,CAAlD;IAMA,OAAOY,WAAW,CAACC,GAAZD,CAILE,IAAI,IAAIC,oBAAoB,CAACT,uBAAD,EAA0BQ,IAA1B,CAJvBF,CAAP;EATF,EADK,CAAP;AAHkC,EAAtC;AAwBA,MAAMI,uBAAuB,GAAG,IAAIT,OAAJ,EAAhC;AACA,MAAMN,6BAA6B,GAAG,gCACpC,CAACO,KAAD,EAAoBC,KAApB,KAAyD;EACvD,MAAMrB,OAAO,GAAGqB,KAAK,CAACC,KAAND,CAAYE,GAAG,IAAIA,GAAnBF,CAAhB;EACA,OAAO,8BAAgB,WACrBpB,KADqB,EAEe;IACpC,MAAMuB,WAAW,GAAG,OAAOR,uBAAuB,CAACI,KAAD,EAAQpB,OAAR,EAAiBC,KAAjB,CAAlD;IACA,OAAOuB,WAAW,CAACC,GAAZD,CAILE,IAAI,IAAIC,oBAAoB,CAACC,uBAAD,EAA0BF,IAA1B,CAJvBF,CAAP;EAJK,EAAP;AAHkC,EAAtC;AAqBA,MAAMK,eAAe,GAAG,EAAxB;;AAOA,SAASF,oBAAT,CACEN,KADF,EAEEK,IAFF,EAGE;EACA,MAAM;IAAE5B,KAAF;IAASC,OAAO,GAAG8B;EAAnB,IAAuCH,IAA7C;EACA,IAAI3B,OAAO,KAAK,KAAhB,EAAuB,OAAO2B,IAAP;EAEvB,IAAII,cAAc,GAAGT,KAAK,CAACU,GAANV,CAAUvB,KAAVuB,CAArB;;EACA,IAAI,CAACS,cAAL,EAAqB;IACnBA,cAAc,GAAG,IAAIX,OAAJ,EAAjBW;IACAT,KAAK,CAACW,GAANX,CAAUvB,KAAVuB,EAAiBS,cAAjBT;EACD;;EAED,IAAIY,aAAa,GAAGH,cAAc,CAACC,GAAfD,CAAmB/B,OAAnB+B,CAApB;;EACA,IAAI,CAACG,aAAL,EAAoB;IAClBA,aAAa,GAAG,EAAhBA;IACAH,cAAc,CAACE,GAAfF,CAAmB/B,OAAnB+B,EAA4BG,aAA5BH;EACD;;EAED,IAAIG,aAAa,CAACC,OAAdD,CAAsBP,IAAtBO,MAAgC,CAAC,CAArC,EAAwC;IACtC,MAAME,OAAO,GAAGF,aAAa,CAACG,MAAdH,CAAqBI,WAAW,IAC9C3C,iBAAiB,CAAC2C,WAAD,EAAcX,IAAd,CADHO,CAAhB;;IAGA,IAAIE,OAAO,CAACG,MAARH,GAAiB,CAArB,EAAwB;MACtB,OAAOA,OAAO,CAAC,CAAD,CAAd;IACD;;IAEDF,aAAa,CAACM,IAAdN,CAAmBP,IAAnBO;EACD;;EAED,OAAOP,IAAP;AACD;;AAED,UAAUT,uBAAV,CACEG,KADF,EAEEpB,OAFF,EAGEC,KAHF,EAIEW,aAJF,EAKsC;EACpC,OAAO,OAAO4B,iBAAiB,CAC7B,QAD6B,EAE7BpB,KAF6B,EAG7BpB,OAH6B,EAI7BC,KAJ6B,EAK7BW,aAL6B,CAA/B;AAOD;;AAED,UAAUI,uBAAV,CACEI,KADF,EAEEpB,OAFF,EAGEC,KAHF,EAIsC;EACpC,OAAO,OAAOuC,iBAAiB,CAAC,QAAD,EAAWpB,KAAX,EAAkBpB,OAAlB,EAA2BC,KAA3B,CAA/B;AACD;;AAED,UAAUuC,iBAAV,CACEC,IADF,EAEErB,KAFF,EAGEpB,OAHF,EAIEC,KAJF,EAKEC,OALF,EAMsC;EACpC,MAAMsB,WAAW,GAAG,OAAOkB,WAAQC,GAARD,CACzBtB,KAAK,CAACK,GAANL,CAAU,CAACwB,IAAD,EAAOC,KAAP,KACRC,gBAAgB,CAACF,IAAD,EAAO5C,OAAP,EAAgB;IAC9ByC,IAD8B;IAE9BxC,KAAK,EAAG,GAAEA,KAAM,IAAG4C,KAAM,EAFK;IAG9B3C,OAAO,EAAE,CAAC,CAACA;EAHmB,CAAhB,CADlBkB,CADyBsB,CAA3B;EAUAK,kBAAkB,CAACvB,WAAD,CAAlBuB;EAEA,OAAOvB,WAAP;AACD;;AAKM,UAAUsB,gBAAV,CACLE,IADK,EAELhD,OAFK,QAYwB;EAAA,IAT7B;IACEyC,IADF;IAEExC,KAFF;IAGEC;EAHF,CAS6B;EAC7B,MAAMwB,IAAI,GAAG,6BAAkBsB,IAAlB,CAAb;;EACA,IAAItB,IAAJ,EAAU;IACR,OAAOA,IAAP;EACD;;EAED,IAAI7B,IAAJ;EACA,IAAIE,OAAJ;EAEA,IAAID,KAAU,GAAGkD,IAAjB;;EACA,IAAIC,KAAK,CAACC,OAAND,CAAcnD,KAAdmD,CAAJ,EAA0B;IACxB,IAAInD,KAAK,CAACwC,MAANxC,KAAiB,CAArB,EAAwB;MACtB,CAACA,KAAD,EAAQC,OAAR,EAAiBF,IAAjB,IAAyBC,KAAzB;IADF,OAEO;MACL,CAACA,KAAD,EAAQC,OAAR,IAAmBD,KAAnB;IACD;EACF;;EAED,IAAIK,IAAI,GAAGgD,SAAX;EACA,IAAIC,QAAQ,GAAG,IAAf;;EACA,IAAI,OAAOtD,KAAP,KAAiB,QAArB,EAA+B;IAC7B,IAAI,OAAO2C,IAAP,KAAgB,QAApB,EAA8B;MAC5B,MAAM,IAAIY,KAAJ,CACJ,gEADI,CAAN;IAGD;;IACD,MAAMC,QAAQ,GAAGb,IAAI,KAAK,QAATA,GAAoBc,iBAApBd,GAAiCe,iBAAlD;IACA,MAAMpD,OAAO,GAAGN,KAAhB;IAEA,CAAC;MAAEsD,QAAF;MAAYtD;IAAZ,IAAsB,OAAOwD,QAAQ,CAACxD,KAAD,EAAQE,OAAR,CAAtC;IAEAG,IAAI,GAAG;MACLC,OADK;MAELC,QAAQ,EAAE+C;IAFL,CAAPjD;EAID;;EAED,IAAI,CAACL,KAAL,EAAY;IACV,MAAM,IAAIuD,KAAJ,CAAW,2BAA0BI,MAAM,CAAC3D,KAAD,CAAQ,EAAnD,CAAN;EACD;;EAED,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAAC4D,UAAvC,EAAmD;IACjD,IAAI5D,KAAK,CAAC6D,OAAV,EAAmB;MACjB7D,KAAK,GAAGA,KAAK,CAAC6D,OAAd7D;IADF,OAEO;MACL,MAAM,IAAIuD,KAAJ,CAAU,sDAAV,CAAN;IACD;EACF;;EAED,IAAI,OAAOvD,KAAP,KAAiB,QAAjB,IAA6B,OAAOA,KAAP,KAAiB,UAAlD,EAA8D;IAC5D,MAAM,IAAIuD,KAAJ,CACH,uBAAsB,OAAOvD,KAAM,qCADhC,CAAN;EAGD;;EAED,IAAIsD,QAAQ,KAAK,IAAbA,IAAqB,OAAOtD,KAAP,KAAiB,QAAtCsD,IAAkDtD,KAAtD,EAA6D;IAI3D,MAAM,IAAIuD,KAAJ,CACH,6EAA4ED,QAAS,EADlF,CAAN;EAGD;;EAED,OAAO;IACLvD,IADK;IAELI,KAAK,EAAEmD,QAAQ,IAAInD,KAFd;IAGLH,KAHK;IAILC,OAJK;IAKLC,OALK;IAMLE,OANK;IAOLC;EAPK,CAAP;AASD;;AAED,SAAS4C,kBAAT,CAA4B3B,KAA5B,EAAoE;EAClE,MAAMK,GAAG,GAAG,IAAImC,GAAJ,EAAZ;;EAEA,KAAK,MAAMhB,IAAX,IAAmBxB,KAAnB,EAA0B;IACxB,IAAI,OAAOwB,IAAI,CAAC9C,KAAZ,KAAsB,UAA1B,EAAsC;IAEtC,IAAI+D,OAAO,GAAGpC,GAAG,CAACM,GAAJN,CAAQmB,IAAI,CAAC9C,KAAb2B,CAAd;;IACA,IAAI,CAACoC,OAAL,EAAc;MACZA,OAAO,GAAG,IAAIC,GAAJ,EAAVD;MACApC,GAAG,CAACO,GAAJP,CAAQmB,IAAI,CAAC9C,KAAb2B,EAAoBoC,OAApBpC;IACD;;IAED,IAAIoC,OAAO,CAACE,GAARF,CAAYjB,IAAI,CAAC/C,IAAjBgE,CAAJ,EAA4B;MAC1B,MAAMG,SAAS,GAAG5C,KAAK,CAACgB,MAANhB,CAAa6C,CAAC,IAAIA,CAAC,CAACnE,KAAFmE,KAAYrB,IAAI,CAAC9C,KAAnCsB,CAAlB;MACA,MAAM,IAAIiC,KAAJ,CACJ,CACG,mCADH,EAEG,0DAFH,EAGG,gCAHH,EAIG,EAJH,EAKG,cALH,EAMG,0BANH,EAOG,8CAPH,EAQG,KARH,EASG,EATH,EAUG,0BAVH,EAWG,GAAEa,IAAI,CAACC,SAALD,CAAeF,SAAfE,EAA0B,IAA1BA,EAAgC,CAAhCA,CAAmC,EAXxC,EAYEE,IAZF,CAYO,IAZP,CADI,CAAN;IAeD;;IAEDP,OAAO,CAACQ,GAARR,CAAYjB,IAAI,CAAC/C,IAAjBgE;EACD;AACF","names":["_gensync","isEqualDescriptor","a","b","name","value","options","dirname","alias","ownPass","file","request","resolved","handlerOf","optionsWithResolvedBrowserslistConfigFile","browserslistConfigFile","createCachedDescriptors","plugins","presets","passPerPreset","createCachedPluginDescriptors","createCachedPresetDescriptors","createUncachedDescriptors","createPluginDescriptors","createPresetDescriptors","PRESET_DESCRIPTOR_CACHE","WeakMap","items","cache","using","dir","descriptors","map","desc","loadCachedDescriptor","PLUGIN_DESCRIPTOR_CACHE","DEFAULT_OPTIONS","cacheByOptions","get","set","possibilities","indexOf","matches","filter","possibility","length","push","createDescriptors","type","gensync","all","item","index","createDescriptor","assertNoDuplicates","pair","Array","isArray","undefined","filepath","Error","resolver","loadPlugin","loadPreset","String","__esModule","default","Map","nameMap","Set","has","conflicts","i","JSON","stringify","join","add"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\config-descriptors.ts"],"sourcesContent":["import gensync, { type Handler } from \"gensync\";\nimport { once } from \"../gensync-utils/functional\";\n\nimport { loadPlugin, loadPreset } from \"./files\";\n\nimport { getItemDescriptor } from \"./item\";\n\nimport {\n  makeWeakCacheSync,\n  makeStrongCacheSync,\n  makeStrongCache,\n} from \"./caching\";\nimport type { CacheConfigurator } from \"./caching\";\n\nimport type {\n  ValidatedOptions,\n  PluginList,\n  PluginItem,\n} from \"./validation/options\";\n\nimport { resolveBrowserslistConfigFile } from \"./resolve-targets\";\n\n// Represents a config object and functions to lazily load the descriptors\n// for the plugins and presets so we don't load the plugins/presets unless\n// the options object actually ends up being applicable.\nexport type OptionsAndDescriptors = {\n  options: ValidatedOptions;\n  plugins: () => Handler<Array<UnloadedDescriptor>>;\n  presets: () => Handler<Array<UnloadedDescriptor>>;\n};\n\n// Represents a plugin or presets at a given location in a config object.\n// At this point these have been resolved to a specific object or function,\n// but have not yet been executed to call functions with options.\nexport type UnloadedDescriptor = {\n  name: string | undefined;\n  value: any | Function;\n  options: {} | undefined | false;\n  dirname: string;\n  alias: string;\n  ownPass?: boolean;\n  file?: {\n    request: string;\n    resolved: string;\n  };\n};\n\nfunction isEqualDescriptor(\n  a: UnloadedDescriptor,\n  b: UnloadedDescriptor,\n): boolean {\n  return (\n    a.name === b.name &&\n    a.value === b.value &&\n    a.options === b.options &&\n    a.dirname === b.dirname &&\n    a.alias === b.alias &&\n    a.ownPass === b.ownPass &&\n    (a.file && a.file.request) === (b.file && b.file.request) &&\n    (a.file && a.file.resolved) === (b.file && b.file.resolved)\n  );\n}\n\nexport type ValidatedFile = {\n  filepath: string;\n  dirname: string;\n  options: ValidatedOptions;\n};\n\n// eslint-disable-next-line require-yield\nfunction* handlerOf<T>(value: T): Handler<T> {\n  return value;\n}\n\nfunction optionsWithResolvedBrowserslistConfigFile(\n  options: ValidatedOptions,\n  dirname: string,\n): ValidatedOptions {\n  if (typeof options.browserslistConfigFile === \"string\") {\n    options.browserslistConfigFile = resolveBrowserslistConfigFile(\n      options.browserslistConfigFile,\n      dirname,\n    );\n  }\n  return options;\n}\n\n/**\n * Create a set of descriptors from a given options object, preserving\n * descriptor identity based on the identity of the plugin/preset arrays\n * themselves, and potentially on the identity of the plugins/presets + options.\n */\nexport function createCachedDescriptors(\n  dirname: string,\n  options: ValidatedOptions,\n  alias: string,\n): OptionsAndDescriptors {\n  const { plugins, presets, passPerPreset } = options;\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n    plugins: plugins\n      ? () =>\n          // @ts-expect-error todo(flow->ts) ts complains about incorrect arguments\n          createCachedPluginDescriptors(plugins, dirname)(alias)\n      : () => handlerOf([]),\n    presets: presets\n      ? () =>\n          // @ts-expect-error todo(flow->ts) ts complains about incorrect arguments\n          createCachedPresetDescriptors(presets, dirname)(alias)(\n            !!passPerPreset,\n          )\n      : () => handlerOf([]),\n  };\n}\n\n/**\n * Create a set of descriptors from a given options object, with consistent\n * identity for the descriptors, but not caching based on any specific identity.\n */\nexport function createUncachedDescriptors(\n  dirname: string,\n  options: ValidatedOptions,\n  alias: string,\n): OptionsAndDescriptors {\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n    // The returned result here is cached to represent a config object in\n    // memory, so we build and memoize the descriptors to ensure the same\n    // values are returned consistently.\n    plugins: once(() =>\n      createPluginDescriptors(options.plugins || [], dirname, alias),\n    ),\n    presets: once(() =>\n      createPresetDescriptors(\n        options.presets || [],\n        dirname,\n        alias,\n        !!options.passPerPreset,\n      ),\n    ),\n  };\n}\n\nconst PRESET_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPresetDescriptors = makeWeakCacheSync(\n  (items: PluginList, cache: CacheConfigurator<string>) => {\n    const dirname = cache.using(dir => dir);\n    return makeStrongCacheSync((alias: string) =>\n      makeStrongCache(function* (\n        passPerPreset: boolean,\n      ): Handler<Array<UnloadedDescriptor>> {\n        const descriptors = yield* createPresetDescriptors(\n          items,\n          dirname,\n          alias,\n          passPerPreset,\n        );\n        return descriptors.map(\n          // Items are cached using the overall preset array identity when\n          // possibly, but individual descriptors are also cached if a match\n          // can be found in the previously-used descriptor lists.\n          desc => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc),\n        );\n      }),\n    );\n  },\n);\n\nconst PLUGIN_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPluginDescriptors = makeWeakCacheSync(\n  (items: PluginList, cache: CacheConfigurator<string>) => {\n    const dirname = cache.using(dir => dir);\n    return makeStrongCache(function* (\n      alias: string,\n    ): Handler<Array<UnloadedDescriptor>> {\n      const descriptors = yield* createPluginDescriptors(items, dirname, alias);\n      return descriptors.map(\n        // Items are cached using the overall plugin array identity when\n        // possibly, but individual descriptors are also cached if a match\n        // can be found in the previously-used descriptor lists.\n        desc => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc),\n      );\n    });\n  },\n);\n\n/**\n * When no options object is given in a descriptor, this object is used\n * as a WeakMap key in order to have consistent identity.\n */\nconst DEFAULT_OPTIONS = {};\n\n/**\n * Given the cache and a descriptor, returns a matching descriptor from the\n * cache, or else returns the input descriptor and adds it to the cache for\n * next time.\n */\nfunction loadCachedDescriptor(\n  cache: WeakMap<{} | Function, WeakMap<{}, Array<UnloadedDescriptor>>>,\n  desc: UnloadedDescriptor,\n) {\n  const { value, options = DEFAULT_OPTIONS } = desc;\n  if (options === false) return desc;\n\n  let cacheByOptions = cache.get(value);\n  if (!cacheByOptions) {\n    cacheByOptions = new WeakMap();\n    cache.set(value, cacheByOptions);\n  }\n\n  let possibilities = cacheByOptions.get(options);\n  if (!possibilities) {\n    possibilities = [];\n    cacheByOptions.set(options, possibilities);\n  }\n\n  if (possibilities.indexOf(desc) === -1) {\n    const matches = possibilities.filter(possibility =>\n      isEqualDescriptor(possibility, desc),\n    );\n    if (matches.length > 0) {\n      return matches[0];\n    }\n\n    possibilities.push(desc);\n  }\n\n  return desc;\n}\n\nfunction* createPresetDescriptors(\n  items: PluginList,\n  dirname: string,\n  alias: string,\n  passPerPreset: boolean,\n): Handler<Array<UnloadedDescriptor>> {\n  return yield* createDescriptors(\n    \"preset\",\n    items,\n    dirname,\n    alias,\n    passPerPreset,\n  );\n}\n\nfunction* createPluginDescriptors(\n  items: PluginList,\n  dirname: string,\n  alias: string,\n): Handler<Array<UnloadedDescriptor>> {\n  return yield* createDescriptors(\"plugin\", items, dirname, alias);\n}\n\nfunction* createDescriptors(\n  type: \"plugin\" | \"preset\",\n  items: PluginList,\n  dirname: string,\n  alias: string,\n  ownPass?: boolean,\n): Handler<Array<UnloadedDescriptor>> {\n  const descriptors = yield* gensync.all(\n    items.map((item, index) =>\n      createDescriptor(item, dirname, {\n        type,\n        alias: `${alias}$${index}`,\n        ownPass: !!ownPass,\n      }),\n    ),\n  );\n\n  assertNoDuplicates(descriptors);\n\n  return descriptors;\n}\n\n/**\n * Given a plugin/preset item, resolve it into a standard format.\n */\nexport function* createDescriptor(\n  pair: PluginItem,\n  dirname: string,\n  {\n    type,\n    alias,\n    ownPass,\n  }: {\n    type?: \"plugin\" | \"preset\";\n    alias: string;\n    ownPass?: boolean;\n  },\n): Handler<UnloadedDescriptor> {\n  const desc = getItemDescriptor(pair);\n  if (desc) {\n    return desc;\n  }\n\n  let name;\n  let options;\n  // todo(flow->ts) better type annotation\n  let value: any = pair;\n  if (Array.isArray(value)) {\n    if (value.length === 3) {\n      [value, options, name] = value;\n    } else {\n      [value, options] = value;\n    }\n  }\n\n  let file = undefined;\n  let filepath = null;\n  if (typeof value === \"string\") {\n    if (typeof type !== \"string\") {\n      throw new Error(\n        \"To resolve a string-based item, the type of item must be given\",\n      );\n    }\n    const resolver = type === \"plugin\" ? loadPlugin : loadPreset;\n    const request = value;\n\n    ({ filepath, value } = yield* resolver(value, dirname));\n\n    file = {\n      request,\n      resolved: filepath,\n    };\n  }\n\n  if (!value) {\n    throw new Error(`Unexpected falsy value: ${String(value)}`);\n  }\n\n  if (typeof value === \"object\" && value.__esModule) {\n    if (value.default) {\n      value = value.default;\n    } else {\n      throw new Error(\"Must export a default export when using ES6 modules.\");\n    }\n  }\n\n  if (typeof value !== \"object\" && typeof value !== \"function\") {\n    throw new Error(\n      `Unsupported format: ${typeof value}. Expected an object or a function.`,\n    );\n  }\n\n  if (filepath !== null && typeof value === \"object\" && value) {\n    // We allow object values for plugins/presets nested directly within a\n    // config object, because it can be useful to define them in nested\n    // configuration contexts.\n    throw new Error(\n      `Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`,\n    );\n  }\n\n  return {\n    name,\n    alias: filepath || alias,\n    value,\n    options,\n    dirname,\n    ownPass,\n    file,\n  };\n}\n\nfunction assertNoDuplicates(items: Array<UnloadedDescriptor>): void {\n  const map = new Map();\n\n  for (const item of items) {\n    if (typeof item.value !== \"function\") continue;\n\n    let nameMap = map.get(item.value);\n    if (!nameMap) {\n      nameMap = new Set();\n      map.set(item.value, nameMap);\n    }\n\n    if (nameMap.has(item.name)) {\n      const conflicts = items.filter(i => i.value === item.value);\n      throw new Error(\n        [\n          `Duplicate plugin/preset detected.`,\n          `If you'd like to use two separate instances of a plugin,`,\n          `they need separate names, e.g.`,\n          ``,\n          `  plugins: [`,\n          `    ['some-plugin', {}],`,\n          `    ['some-plugin', {}, 'some unique name'],`,\n          `  ]`,\n          ``,\n          `Duplicates detected are:`,\n          `${JSON.stringify(conflicts, null, 2)}`,\n        ].join(\"\\n\"),\n      );\n    }\n\n    nameMap.add(item.name);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}