{"ast":null,"code":"/* eslint-env mocha */\n\n/* eslint no-template-curly-in-string: 0 */\nimport assert from 'assert';\nimport { extractProp, describeIfNotBabylon, changePlugins, setParserName } from '../helper';\nimport { getLiteralPropValue } from '../../src/getPropValue';\ndescribe('getLiteralPropValue', () => {\n  beforeEach(() => {\n    setParserName('babel');\n  });\n  it('should export a function', () => {\n    const expected = 'function';\n    const actual = typeof getLiteralPropValue;\n    assert.equal(actual, expected);\n  });\n  it('should return undefined when not provided with a JSXAttribute', () => {\n    const expected = undefined;\n    const actual = getLiteralPropValue(1);\n    assert.equal(actual, expected);\n  });\n  it('should not throw error when trying to get value from unknown node type', () => {\n    const prop = {\n      type: 'JSXAttribute',\n      value: {\n        type: 'JSXExpressionContainer'\n      }\n    };\n    let counter = 0; // eslint-disable-next-line no-console\n\n    const errorOrig = console.error; // eslint-disable-next-line no-console\n\n    console.error = () => {\n      counter += 1;\n    };\n\n    let value;\n    assert.doesNotThrow(() => {\n      value = getLiteralPropValue(prop);\n    }, Error);\n    assert.equal(null, value);\n    assert.equal(counter, 1); // eslint-disable-next-line no-console\n\n    console.error = errorOrig;\n  });\n  describe('Null', () => {\n    it('should return true when no value is given', () => {\n      const prop = extractProp('<div foo />');\n      const expected = true;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Literal', () => {\n    it('should return correct string if value is a string', () => {\n      const prop = extractProp('<div foo=\"bar\" />');\n      const expected = 'bar';\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return correct string if value is a string expression', () => {\n      const prop = extractProp('<div foo={\"bar\"} />');\n      const expected = 'bar';\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return correct integer if value is a integer expression', () => {\n      const prop = extractProp('<div foo={1} />');\n      const expected = 1;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should convert \"true\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"true\" />');\n      const expected = true;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should convert \"TrUE\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"TrUE\" />');\n      const expected = true;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should convert \"false\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"false\" />');\n      const expected = false;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should convert \"FaLsE\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"FaLsE\" />');\n      const expected = false;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return String null when value is null', () => {\n      const prop = extractProp('<div foo={null} />');\n      const expected = 'null';\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('JSXElement', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={<bar />} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Identifier', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={bar} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return undefined when identifier is literally `undefined`', () => {\n      const prop = extractProp('<div foo={undefined} />');\n      const expected = undefined;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describeIfNotBabylon('Chain Expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={abc?.def} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Template literal', () => {\n    it('should return template literal with vars wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={`bar ${baz}`} />');\n      const expected = 'bar {baz}';\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string \"undefined\" for expressions that evaluate to undefined', () => {\n      const prop = extractProp('<div foo={`bar ${undefined}`} />');\n      const expected = 'bar undefined';\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Tagged Template literal', () => {\n    it('should return template literal with vars wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={noop`bar ${baz}`} />');\n      const expected = 'bar {baz}';\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string \"undefined\" for expressions that evaluate to undefined', () => {\n      const prop = extractProp('<div foo={noop`bar ${undefined}`} />');\n      const expected = 'bar undefined';\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Arrow function expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={ () => { return \"bar\"; }} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Function expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={ function() { return \"bar\"; } } />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Logical expression', () => {\n    it('should return null for && operator', () => {\n      const prop = extractProp('<div foo={bar && baz} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return null for || operator', () => {\n      const prop = extractProp('<div foo={bar || baz} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Member expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={bar.baz} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Call expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={bar()} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Unary expression', () => {\n    it('should correctly evaluate an expression that prefixes with -', () => {\n      const prop = extractProp('<div foo={-bar} />'); // -\"bar\" => NaN\n\n      const expected = true;\n      const actual = Number.isNaN(getLiteralPropValue(prop));\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that prefixes with -', () => {\n      const prop = extractProp('<div foo={-42} />');\n      const expected = -42;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that prefixes with +', () => {\n      const prop = extractProp('<div foo={+bar} />'); // +\"bar\" => NaN\n\n      const expected = true;\n      const actual = Number.isNaN(getLiteralPropValue(prop));\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that prefixes with +', () => {\n      const prop = extractProp('<div foo={+42} />');\n      const expected = 42;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that prefixes with !', () => {\n      const prop = extractProp('<div foo={!bar} />');\n      const expected = false; // !\"bar\" === false\n\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that prefixes with ~', () => {\n      const prop = extractProp('<div foo={~bar} />');\n      const expected = -1; // ~\"bar\" === -1\n\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return true when evaluating `delete foo`', () => {\n      const prop = extractProp('<div foo={delete x} />');\n      const expected = true;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return undefined when evaluating `void foo`', () => {\n      const prop = extractProp('<div foo={void x} />');\n      const expected = undefined;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    }); // TODO: We should fix this to check to see if we can evaluate it.\n\n    it('should return undefined when evaluating `typeof foo`', () => {\n      const prop = extractProp('<div foo={typeof x} />');\n      const expected = undefined;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Update expression', () => {\n    it('should correctly evaluate an expression that prefixes with ++', () => {\n      const prop = extractProp('<div foo={++bar} />'); // ++\"bar\" => NaN\n\n      const expected = true;\n      const actual = Number.isNaN(getLiteralPropValue(prop));\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that prefixes with --', () => {\n      const prop = extractProp('<div foo={--bar} />'); // --\"bar\" => NaN\n\n      const expected = true;\n      const actual = Number.isNaN(getLiteralPropValue(prop));\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that suffixes with ++', () => {\n      const prop = extractProp('<div foo={bar++} />'); // \"bar\"++ => NaN\n\n      const expected = true;\n      const actual = Number.isNaN(getLiteralPropValue(prop));\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that suffixes with --', () => {\n      const prop = extractProp('<div foo={bar--} />'); // \"bar\"-- => NaN\n\n      const expected = true;\n      const actual = Number.isNaN(getLiteralPropValue(prop));\n      assert.equal(actual, expected);\n    });\n  });\n  describe('This expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={this} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Conditional expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={bar ? baz : bam} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Binary expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={1 == \"1\"} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Object expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={ { bar: \"baz\" } } />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n  });\n  describe('New expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={new Bar()} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n  });\n  describe('Array expression', () => {\n    it('should evaluate to correct representation of the the array in props', () => {\n      const prop = extractProp('<div foo={[\"bar\", 42, null]} />');\n      const expected = ['bar', 42];\n      const actual = getLiteralPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n  });\n  it('should return an empty array provided an empty array in props', () => {\n    const prop = extractProp('<div foo={[]} />');\n    const expected = [];\n    const actual = getLiteralPropValue(prop);\n    assert.deepEqual(actual, expected);\n  });\n  describe('Bind expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={::this.handleClick} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n  });\n  describeIfNotBabylon('Typescript', () => {\n    beforeEach(() => {\n      changePlugins(pls => [...pls, 'typescript']);\n    });\n    it('should return string representation of variable identifier wrapped in a Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={bar!} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of variable identifier wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar!)!} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of variable identifier wrapped in a Typescript type coercion', () => {\n      changePlugins(pls => [...pls, 'typescript']);\n      const prop = extractProp('<div foo={bar as any} />');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should work with a this.props value', () => {\n      const prop = extractProp('<a href={this.props.href!}>Download</a>');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n});","map":{"version":3,"names":["assert","extractProp","describeIfNotBabylon","changePlugins","setParserName","getLiteralPropValue","describe","beforeEach","it","expected","actual","equal","undefined","prop","type","value","counter","errorOrig","console","error","doesNotThrow","Error","Number","isNaN","deepEqual","pls"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jsx-ast-utils/__tests__/src/getPropLiteralValue-babelparser-test.js"],"sourcesContent":["/* eslint-env mocha */\n/* eslint no-template-curly-in-string: 0 */\nimport assert from 'assert';\nimport {\n  extractProp,\n  describeIfNotBabylon,\n  changePlugins,\n  setParserName,\n} from '../helper';\nimport { getLiteralPropValue } from '../../src/getPropValue';\n\ndescribe('getLiteralPropValue', () => {\n  beforeEach(() => {\n    setParserName('babel');\n  });\n  it('should export a function', () => {\n    const expected = 'function';\n    const actual = typeof getLiteralPropValue;\n\n    assert.equal(actual, expected);\n  });\n\n  it('should return undefined when not provided with a JSXAttribute', () => {\n    const expected = undefined;\n    const actual = getLiteralPropValue(1);\n\n    assert.equal(actual, expected);\n  });\n\n  it('should not throw error when trying to get value from unknown node type', () => {\n    const prop = {\n      type: 'JSXAttribute',\n      value: {\n        type: 'JSXExpressionContainer',\n      },\n    };\n    let counter = 0;\n    // eslint-disable-next-line no-console\n    const errorOrig = console.error;\n    // eslint-disable-next-line no-console\n    console.error = () => {\n      counter += 1;\n    };\n    let value;\n    assert.doesNotThrow(() => {\n      value = getLiteralPropValue(prop);\n    }, Error);\n\n    assert.equal(null, value);\n    assert.equal(counter, 1);\n    // eslint-disable-next-line no-console\n    console.error = errorOrig;\n  });\n\n  describe('Null', () => {\n    it('should return true when no value is given', () => {\n      const prop = extractProp('<div foo />');\n\n      const expected = true;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Literal', () => {\n    it('should return correct string if value is a string', () => {\n      const prop = extractProp('<div foo=\"bar\" />');\n\n      const expected = 'bar';\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return correct string if value is a string expression', () => {\n      const prop = extractProp('<div foo={\"bar\"} />');\n\n      const expected = 'bar';\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return correct integer if value is a integer expression', () => {\n      const prop = extractProp('<div foo={1} />');\n\n      const expected = 1;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should convert \"true\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"true\" />');\n\n      const expected = true;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should convert \"TrUE\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"TrUE\" />');\n\n      const expected = true;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should convert \"false\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"false\" />');\n\n      const expected = false;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should convert \"FaLsE\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"FaLsE\" />');\n\n      const expected = false;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return String null when value is null', () => {\n      const prop = extractProp('<div foo={null} />');\n\n      const expected = 'null';\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('JSXElement', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={<bar />} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Identifier', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={bar} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return undefined when identifier is literally `undefined`', () => {\n      const prop = extractProp('<div foo={undefined} />');\n\n      const expected = undefined;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describeIfNotBabylon('Chain Expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={abc?.def} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Template literal', () => {\n    it('should return template literal with vars wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={`bar ${baz}`} />');\n\n      const expected = 'bar {baz}';\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string \"undefined\" for expressions that evaluate to undefined', () => {\n      const prop = extractProp('<div foo={`bar ${undefined}`} />');\n\n      const expected = 'bar undefined';\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Tagged Template literal', () => {\n    it('should return template literal with vars wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={noop`bar ${baz}`} />');\n\n      const expected = 'bar {baz}';\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string \"undefined\" for expressions that evaluate to undefined', () => {\n      const prop = extractProp('<div foo={noop`bar ${undefined}`} />');\n\n      const expected = 'bar undefined';\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Arrow function expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={ () => { return \"bar\"; }} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Function expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={ function() { return \"bar\"; } } />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Logical expression', () => {\n    it('should return null for && operator', () => {\n      const prop = extractProp('<div foo={bar && baz} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return null for || operator', () => {\n      const prop = extractProp('<div foo={bar || baz} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Member expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={bar.baz} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Call expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={bar()} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Unary expression', () => {\n    it('should correctly evaluate an expression that prefixes with -', () => {\n      const prop = extractProp('<div foo={-bar} />');\n\n      // -\"bar\" => NaN\n      const expected = true;\n      const actual = Number.isNaN(getLiteralPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with -', () => {\n      const prop = extractProp('<div foo={-42} />');\n\n      const expected = -42;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with +', () => {\n      const prop = extractProp('<div foo={+bar} />');\n\n      // +\"bar\" => NaN\n      const expected = true;\n      const actual = Number.isNaN(getLiteralPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with +', () => {\n      const prop = extractProp('<div foo={+42} />');\n\n      const expected = 42;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with !', () => {\n      const prop = extractProp('<div foo={!bar} />');\n\n      const expected = false; // !\"bar\" === false\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with ~', () => {\n      const prop = extractProp('<div foo={~bar} />');\n\n      const expected = -1; // ~\"bar\" === -1\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return true when evaluating `delete foo`', () => {\n      const prop = extractProp('<div foo={delete x} />');\n\n      const expected = true;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return undefined when evaluating `void foo`', () => {\n      const prop = extractProp('<div foo={void x} />');\n\n      const expected = undefined;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    // TODO: We should fix this to check to see if we can evaluate it.\n    it('should return undefined when evaluating `typeof foo`', () => {\n      const prop = extractProp('<div foo={typeof x} />');\n\n      const expected = undefined;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Update expression', () => {\n    it('should correctly evaluate an expression that prefixes with ++', () => {\n      const prop = extractProp('<div foo={++bar} />');\n\n      // ++\"bar\" => NaN\n      const expected = true;\n      const actual = Number.isNaN(getLiteralPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with --', () => {\n      const prop = extractProp('<div foo={--bar} />');\n\n      // --\"bar\" => NaN\n      const expected = true;\n      const actual = Number.isNaN(getLiteralPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that suffixes with ++', () => {\n      const prop = extractProp('<div foo={bar++} />');\n\n      // \"bar\"++ => NaN\n      const expected = true;\n      const actual = Number.isNaN(getLiteralPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that suffixes with --', () => {\n      const prop = extractProp('<div foo={bar--} />');\n\n      // \"bar\"-- => NaN\n      const expected = true;\n      const actual = Number.isNaN(getLiteralPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('This expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={this} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Conditional expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={bar ? baz : bam} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Binary expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={1 == \"1\"} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Object expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={ { bar: \"baz\" } } />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  describe('New expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={new Bar()} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  describe('Array expression', () => {\n    it('should evaluate to correct representation of the the array in props', () => {\n      const prop = extractProp('<div foo={[\"bar\", 42, null]} />');\n\n      const expected = ['bar', 42];\n      const actual = getLiteralPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  it('should return an empty array provided an empty array in props', () => {\n    const prop = extractProp('<div foo={[]} />');\n\n    const expected = [];\n    const actual = getLiteralPropValue(prop);\n\n    assert.deepEqual(actual, expected);\n  });\n\n  describe('Bind expression', () => {\n    it('should return null', () => {\n      const prop = extractProp('<div foo={::this.handleClick} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  describeIfNotBabylon('Typescript', () => {\n    beforeEach(() => {\n      changePlugins((pls) => [...pls, 'typescript']);\n    });\n\n    it('should return string representation of variable identifier wrapped in a Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={bar!} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of variable identifier wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar!)!} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of variable identifier wrapped in a Typescript type coercion', () => {\n      changePlugins((pls) => [...pls, 'typescript']);\n      const prop = extractProp('<div foo={bar as any} />');\n\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should work with a this.props value', () => {\n      const prop = extractProp('<a href={this.props.href!}>Download</a>');\n      const expected = null;\n      const actual = getLiteralPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}