{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _isAnnotatedForRemoval = _interopRequireDefault(require(\"./isAnnotatedForRemoval\"));\n\nvar _isStatelessComponent = _interopRequireDefault(require(\"./isStatelessComponent\"));\n\nvar _remove = _interopRequireDefault(require(\"./remove\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction isPathReactClass(path, globalOptions) {\n  var node = path.node;\n  var matchers = globalOptions.classNameMatchers;\n\n  if (path.matchesPattern('React.Component') || path.matchesPattern('React.PureComponent')) {\n    return true;\n  }\n\n  if (node && (node.name === 'Component' || node.name === 'PureComponent')) {\n    return true;\n  }\n\n  if (node && matchers && matchers.test(node.name)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isReactClass(superClass, scope, globalOptions) {\n  if (!superClass.node) {\n    return false;\n  }\n\n  var answer = false;\n\n  if (isPathReactClass(superClass, globalOptions)) {\n    answer = true;\n  } else if (superClass.node.name) {\n    // Check for inheritance\n    var className = superClass.node.name;\n    var binding = scope.getBinding(className);\n\n    if (!binding) {\n      answer = false;\n    } else {\n      var bindingSuperClass = binding.path.get('superClass');\n\n      if (isPathReactClass(bindingSuperClass, globalOptions)) {\n        answer = true;\n      }\n    }\n  }\n\n  return answer;\n}\n\nfunction areSetsEqual(set1, set2) {\n  if (set1 === set2) {\n    return true;\n  }\n\n  if (set1.size !== set2.size) {\n    return false;\n  }\n\n  return !Array.from(set1).some(function (item) {\n    return !set2.has(item);\n  });\n}\n\nfunction memberExpressionRootIdentifier(path) {\n  // Traverse up to the parent before the topmost member expression, and then\n  // traverse back down to find the topmost identifier. It seems like there\n  // might be a better way to do this.\n  var parent = path.findParent(function (p) {\n    return !p.isMemberExpression();\n  });\n  var type = parent.node.type;\n  var memberExpression;\n\n  if (type === 'ObjectProperty') {\n    // The topmost MemberExpression's parent is an object property, so the\n    // topmost MemberExpression should be the value.\n    memberExpression = parent.get('value');\n  }\n\n  if (!memberExpression || memberExpression.type !== 'MemberExpression') {\n    // This case is currently unhandled by this plugin.\n    return null;\n  } // We have a topmost MemberExpression now, so we want to traverse down the\n  // left half untli we no longer see MemberExpressions. This node will give us\n  // our leftmost identifier.\n\n\n  while (memberExpression.node.object.type === 'MemberExpression') {\n    memberExpression = memberExpression.get('object');\n  }\n\n  return memberExpression.get('object');\n}\n\nfunction _default(api) {\n  var template = api.template,\n      types = api.types,\n      traverse = api.traverse;\n  var nestedIdentifiers = new Set();\n  var removedPaths = new WeakSet();\n  var collectNestedIdentifiers = {\n    Identifier: function Identifier(path) {\n      if (path.parent.type === 'MemberExpression') {\n        // foo.bar\n        var root = memberExpressionRootIdentifier(path);\n\n        if (root) {\n          nestedIdentifiers.add(root.node.name);\n        }\n\n        return;\n      }\n\n      if (path.parent.type === 'ObjectProperty' && (path.parent.key === path.node || path.parent.shorthand)) {\n        // { foo: 'bar' }\n        // { foo }\n        return;\n      }\n\n      nestedIdentifiers.add(path.node.name);\n    }\n  };\n  return {\n    visitor: {\n      Program: function Program(programPath, state) {\n        var ignoreFilenames;\n        var classNameMatchers;\n\n        if (state.opts.ignoreFilenames) {\n          ignoreFilenames = new RegExp(state.opts.ignoreFilenames.join('|'), 'i');\n        } else {\n          ignoreFilenames = undefined;\n        }\n\n        if (state.opts.classNameMatchers) {\n          classNameMatchers = new RegExp(state.opts.classNameMatchers.join('|'));\n        } else {\n          classNameMatchers = undefined;\n        }\n\n        var globalOptions = {\n          visitedKey: \"transform-react-remove-prop-types\".concat(Date.now()),\n          unsafeWrapTemplate: template(\"\\n              if (process.env.NODE_ENV !== \\\"production\\\") {\\n                NODE;\\n              }\\n            \", {\n            placeholderPattern: /^NODE$/\n          }),\n          wrapTemplate: function wrapTemplate(_ref) {\n            var LEFT = _ref.LEFT,\n                RIGHT = _ref.RIGHT;\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var _options$as = options.as,\n                as = _options$as === void 0 ? 'assignmentExpression' : _options$as;\n            var right = template.expression(\"\\n                process.env.NODE_ENV !== \\\"production\\\" ? RIGHT : {}\\n              \", {\n              placeholderPattern: /^(LEFT|RIGHT)$/\n            })({\n              RIGHT: RIGHT\n            });\n\n            switch (as) {\n              case 'variableDeclarator':\n                return types.variableDeclarator(LEFT, right);\n\n              case 'assignmentExpression':\n                return types.assignmentExpression('=', LEFT, right);\n\n              default:\n                throw new Error(\"unrecognized template type \".concat(as));\n            }\n          },\n          mode: state.opts.mode || 'remove',\n          ignoreFilenames: ignoreFilenames,\n          types: types,\n          removeImport: state.opts.removeImport || false,\n          libraries: (state.opts.additionalLibraries || []).concat('prop-types'),\n          classNameMatchers: classNameMatchers,\n          createReactClassName: state.opts.createReactClassName || 'createReactClass'\n        };\n\n        if (state.opts.plugins) {\n          var pluginsState = state;\n          var pluginsVisitors = state.opts.plugins.map(function (pluginOpts) {\n            var pluginName = typeof pluginOpts === 'string' ? pluginOpts : pluginOpts[0];\n\n            if (typeof pluginOpts !== 'string') {\n              pluginsState.opts = _objectSpread({}, pluginsState.opts, pluginOpts[1]);\n            }\n\n            var plugin = require(pluginName);\n\n            if (typeof plugin !== 'function') {\n              plugin = plugin.default;\n            }\n\n            return plugin(api).visitor;\n          });\n          traverse(programPath.parent, traverse.visitors.merge(pluginsVisitors), programPath.scope, pluginsState, programPath.parentPath);\n        } // On program start, do an explicit traversal up front for this plugin.\n\n\n        programPath.traverse({\n          ObjectProperty: {\n            exit: function exit(path) {\n              var node = path.node;\n\n              if (node.computed || node.key.name !== 'propTypes') {\n                return;\n              }\n\n              var parent = path.findParent(function (currentNode) {\n                if (currentNode.type !== 'CallExpression') {\n                  return false;\n                }\n\n                return currentNode.get('callee').node.name === globalOptions.createReactClassName || currentNode.get('callee').node.property && currentNode.get('callee').node.property.name === 'createClass';\n              });\n\n              if (parent) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'createClass'\n                });\n              }\n            }\n          },\n          // Here to support stage-1 transform-class-properties.\n          ClassProperty: function ClassProperty(path) {\n            var node = path.node,\n                scope = path.scope;\n\n            if (node.key.name === 'propTypes') {\n              var pathClassDeclaration = scope.path;\n\n              if (isReactClass(pathClassDeclaration.get('superClass'), scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'class static',\n                  pathClassDeclaration: pathClassDeclaration\n                });\n              }\n            }\n          },\n          AssignmentExpression: function AssignmentExpression(path) {\n            var node = path.node,\n                scope = path.scope;\n\n            if (node.left.computed || !node.left.property || node.left.property.name !== 'propTypes') {\n              return;\n            }\n\n            var forceRemoval = (0, _isAnnotatedForRemoval.default)(path.node.left);\n\n            if (forceRemoval) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              (0, _remove.default)(path, globalOptions, {\n                type: 'assign'\n              });\n              return;\n            }\n\n            var className = node.left.object.name;\n            var binding = scope.getBinding(className);\n\n            if (!binding) {\n              return;\n            }\n\n            if (binding.path.isClassDeclaration()) {\n              var superClass = binding.path.get('superClass');\n\n              if (isReactClass(superClass, scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'assign'\n                });\n              }\n            } else if ((0, _isStatelessComponent.default)(binding.path)) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              (0, _remove.default)(path, globalOptions, {\n                type: 'assign'\n              });\n            }\n          }\n        });\n        var skippedIdentifiers = 0;\n        var removeNewlyUnusedIdentifiers = {\n          VariableDeclarator: function VariableDeclarator(path) {\n            // Only consider the top level scope.\n            if (path.scope.block.type !== 'Program') {\n              return;\n            }\n\n            if (['ObjectPattern', 'ArrayPattern'].includes(path.node.id.type)) {\n              // Object or Array destructuring, so we will want to capture all\n              // the names created by the destructuring. This currently doesn't\n              // work, but would be good to improve. All of the names for\n              // ObjectPattern can be collected like:\n              //\n              //   path.node.id.properties.map(prop => prop.value.name);\n              return;\n            }\n\n            var name = path.node.id.name;\n\n            if (!nestedIdentifiers.has(name)) {\n              return;\n            }\n\n            var _path$scope$getBindin = path.scope.getBinding(name),\n                referencePaths = _path$scope$getBindin.referencePaths; // Count the number of referencePaths that are not in the\n            // removedPaths Set. We need to do this in order to support the wrap\n            // option, which doesn't actually remove the references.\n\n\n            var hasRemainingReferencePaths = referencePaths.some(function (referencePath) {\n              var found = referencePath.find(function (path2) {\n                return removedPaths.has(path2);\n              });\n              return !found;\n            });\n\n            if (hasRemainingReferencePaths) {\n              // There are still references to this identifier, so we need to\n              // skip over it for now.\n              skippedIdentifiers += 1;\n              return;\n            }\n\n            removedPaths.add(path);\n            nestedIdentifiers.delete(name);\n            path.get('init').traverse(collectNestedIdentifiers);\n            (0, _remove.default)(path, globalOptions, {\n              type: 'declarator'\n            });\n          }\n        };\n        var lastNestedIdentifiers = new Set();\n\n        while (!areSetsEqual(nestedIdentifiers, lastNestedIdentifiers) && nestedIdentifiers.size > 0 && skippedIdentifiers < nestedIdentifiers.size) {\n          lastNestedIdentifiers = new Set(nestedIdentifiers);\n          skippedIdentifiers = 0;\n          programPath.scope.crawl();\n          programPath.traverse(removeNewlyUnusedIdentifiers);\n        }\n\n        if (globalOptions.removeImport) {\n          if (globalOptions.mode === 'remove') {\n            programPath.scope.crawl();\n            programPath.traverse({\n              ImportDeclaration: function ImportDeclaration(path) {\n                var _path$node = path.node,\n                    source = _path$node.source,\n                    specifiers = _path$node.specifiers;\n                var found = globalOptions.libraries.some(function (library) {\n                  if (library instanceof RegExp) {\n                    return library.test(source.value);\n                  }\n\n                  return source.value === library;\n                });\n\n                if (!found) {\n                  return;\n                }\n\n                var haveUsedSpecifiers = specifiers.some(function (specifier) {\n                  var importedIdentifierName = specifier.local.name;\n\n                  var _path$scope$getBindin2 = path.scope.getBinding(importedIdentifierName),\n                      referencePaths = _path$scope$getBindin2.referencePaths;\n\n                  return referencePaths.length > 0;\n                });\n\n                if (!haveUsedSpecifiers) {\n                  path.remove();\n                }\n              }\n            });\n          } else {\n            throw new Error('transform-react-remove-prop-type: removeImport = true and mode != \"remove\" can not be used at the same time.');\n          }\n        }\n      }\n    }\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_default","_isAnnotatedForRemoval","_interopRequireDefault","require","_isStatelessComponent","_remove","obj","__esModule","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","configurable","writable","isPathReactClass","path","globalOptions","node","matchers","classNameMatchers","matchesPattern","name","test","isReactClass","superClass","scope","answer","className","binding","getBinding","bindingSuperClass","get","areSetsEqual","set1","set2","size","Array","from","some","item","has","memberExpressionRootIdentifier","parent","findParent","p","isMemberExpression","type","memberExpression","object","api","template","types","traverse","nestedIdentifiers","Set","removedPaths","WeakSet","collectNestedIdentifiers","Identifier","root","add","shorthand","visitor","Program","programPath","state","ignoreFilenames","opts","RegExp","join","undefined","visitedKey","Date","now","unsafeWrapTemplate","placeholderPattern","wrapTemplate","_ref","LEFT","RIGHT","options","_options$as","as","right","expression","variableDeclarator","assignmentExpression","Error","mode","removeImport","libraries","additionalLibraries","createReactClassName","plugins","pluginsState","pluginsVisitors","map","pluginOpts","pluginName","plugin","visitors","merge","parentPath","ObjectProperty","exit","computed","currentNode","property","ClassProperty","pathClassDeclaration","AssignmentExpression","left","forceRemoval","isClassDeclaration","skippedIdentifiers","removeNewlyUnusedIdentifiers","VariableDeclarator","block","includes","id","_path$scope$getBindin","referencePaths","hasRemainingReferencePaths","referencePath","found","find","path2","delete","lastNestedIdentifiers","crawl","ImportDeclaration","_path$node","specifiers","library","haveUsedSpecifiers","specifier","importedIdentifierName","local","_path$scope$getBindin2","remove"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/babel-plugin-transform-react-remove-prop-types/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _isAnnotatedForRemoval = _interopRequireDefault(require(\"./isAnnotatedForRemoval\"));\n\nvar _isStatelessComponent = _interopRequireDefault(require(\"./isStatelessComponent\"));\n\nvar _remove = _interopRequireDefault(require(\"./remove\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction isPathReactClass(path, globalOptions) {\n  var node = path.node;\n  var matchers = globalOptions.classNameMatchers;\n\n  if (path.matchesPattern('React.Component') || path.matchesPattern('React.PureComponent')) {\n    return true;\n  }\n\n  if (node && (node.name === 'Component' || node.name === 'PureComponent')) {\n    return true;\n  }\n\n  if (node && matchers && matchers.test(node.name)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isReactClass(superClass, scope, globalOptions) {\n  if (!superClass.node) {\n    return false;\n  }\n\n  var answer = false;\n\n  if (isPathReactClass(superClass, globalOptions)) {\n    answer = true;\n  } else if (superClass.node.name) {\n    // Check for inheritance\n    var className = superClass.node.name;\n    var binding = scope.getBinding(className);\n\n    if (!binding) {\n      answer = false;\n    } else {\n      var bindingSuperClass = binding.path.get('superClass');\n\n      if (isPathReactClass(bindingSuperClass, globalOptions)) {\n        answer = true;\n      }\n    }\n  }\n\n  return answer;\n}\n\nfunction areSetsEqual(set1, set2) {\n  if (set1 === set2) {\n    return true;\n  }\n\n  if (set1.size !== set2.size) {\n    return false;\n  }\n\n  return !Array.from(set1).some(function (item) {\n    return !set2.has(item);\n  });\n}\n\nfunction memberExpressionRootIdentifier(path) {\n  // Traverse up to the parent before the topmost member expression, and then\n  // traverse back down to find the topmost identifier. It seems like there\n  // might be a better way to do this.\n  var parent = path.findParent(function (p) {\n    return !p.isMemberExpression();\n  });\n  var type = parent.node.type;\n  var memberExpression;\n\n  if (type === 'ObjectProperty') {\n    // The topmost MemberExpression's parent is an object property, so the\n    // topmost MemberExpression should be the value.\n    memberExpression = parent.get('value');\n  }\n\n  if (!memberExpression || memberExpression.type !== 'MemberExpression') {\n    // This case is currently unhandled by this plugin.\n    return null;\n  } // We have a topmost MemberExpression now, so we want to traverse down the\n  // left half untli we no longer see MemberExpressions. This node will give us\n  // our leftmost identifier.\n\n\n  while (memberExpression.node.object.type === 'MemberExpression') {\n    memberExpression = memberExpression.get('object');\n  }\n\n  return memberExpression.get('object');\n}\n\nfunction _default(api) {\n  var template = api.template,\n      types = api.types,\n      traverse = api.traverse;\n  var nestedIdentifiers = new Set();\n  var removedPaths = new WeakSet();\n  var collectNestedIdentifiers = {\n    Identifier: function Identifier(path) {\n      if (path.parent.type === 'MemberExpression') {\n        // foo.bar\n        var root = memberExpressionRootIdentifier(path);\n\n        if (root) {\n          nestedIdentifiers.add(root.node.name);\n        }\n\n        return;\n      }\n\n      if (path.parent.type === 'ObjectProperty' && (path.parent.key === path.node || path.parent.shorthand)) {\n        // { foo: 'bar' }\n        // { foo }\n        return;\n      }\n\n      nestedIdentifiers.add(path.node.name);\n    }\n  };\n  return {\n    visitor: {\n      Program: function Program(programPath, state) {\n        var ignoreFilenames;\n        var classNameMatchers;\n\n        if (state.opts.ignoreFilenames) {\n          ignoreFilenames = new RegExp(state.opts.ignoreFilenames.join('|'), 'i');\n        } else {\n          ignoreFilenames = undefined;\n        }\n\n        if (state.opts.classNameMatchers) {\n          classNameMatchers = new RegExp(state.opts.classNameMatchers.join('|'));\n        } else {\n          classNameMatchers = undefined;\n        }\n\n        var globalOptions = {\n          visitedKey: \"transform-react-remove-prop-types\".concat(Date.now()),\n          unsafeWrapTemplate: template(\"\\n              if (process.env.NODE_ENV !== \\\"production\\\") {\\n                NODE;\\n              }\\n            \", {\n            placeholderPattern: /^NODE$/\n          }),\n          wrapTemplate: function wrapTemplate(_ref) {\n            var LEFT = _ref.LEFT,\n                RIGHT = _ref.RIGHT;\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var _options$as = options.as,\n                as = _options$as === void 0 ? 'assignmentExpression' : _options$as;\n            var right = template.expression(\"\\n                process.env.NODE_ENV !== \\\"production\\\" ? RIGHT : {}\\n              \", {\n              placeholderPattern: /^(LEFT|RIGHT)$/\n            })({\n              RIGHT: RIGHT\n            });\n\n            switch (as) {\n              case 'variableDeclarator':\n                return types.variableDeclarator(LEFT, right);\n\n              case 'assignmentExpression':\n                return types.assignmentExpression('=', LEFT, right);\n\n              default:\n                throw new Error(\"unrecognized template type \".concat(as));\n            }\n          },\n          mode: state.opts.mode || 'remove',\n          ignoreFilenames: ignoreFilenames,\n          types: types,\n          removeImport: state.opts.removeImport || false,\n          libraries: (state.opts.additionalLibraries || []).concat('prop-types'),\n          classNameMatchers: classNameMatchers,\n          createReactClassName: state.opts.createReactClassName || 'createReactClass'\n        };\n\n        if (state.opts.plugins) {\n          var pluginsState = state;\n          var pluginsVisitors = state.opts.plugins.map(function (pluginOpts) {\n            var pluginName = typeof pluginOpts === 'string' ? pluginOpts : pluginOpts[0];\n\n            if (typeof pluginOpts !== 'string') {\n              pluginsState.opts = _objectSpread({}, pluginsState.opts, pluginOpts[1]);\n            }\n\n            var plugin = require(pluginName);\n\n            if (typeof plugin !== 'function') {\n              plugin = plugin.default;\n            }\n\n            return plugin(api).visitor;\n          });\n          traverse(programPath.parent, traverse.visitors.merge(pluginsVisitors), programPath.scope, pluginsState, programPath.parentPath);\n        } // On program start, do an explicit traversal up front for this plugin.\n\n\n        programPath.traverse({\n          ObjectProperty: {\n            exit: function exit(path) {\n              var node = path.node;\n\n              if (node.computed || node.key.name !== 'propTypes') {\n                return;\n              }\n\n              var parent = path.findParent(function (currentNode) {\n                if (currentNode.type !== 'CallExpression') {\n                  return false;\n                }\n\n                return currentNode.get('callee').node.name === globalOptions.createReactClassName || currentNode.get('callee').node.property && currentNode.get('callee').node.property.name === 'createClass';\n              });\n\n              if (parent) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'createClass'\n                });\n              }\n            }\n          },\n          // Here to support stage-1 transform-class-properties.\n          ClassProperty: function ClassProperty(path) {\n            var node = path.node,\n                scope = path.scope;\n\n            if (node.key.name === 'propTypes') {\n              var pathClassDeclaration = scope.path;\n\n              if (isReactClass(pathClassDeclaration.get('superClass'), scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'class static',\n                  pathClassDeclaration: pathClassDeclaration\n                });\n              }\n            }\n          },\n          AssignmentExpression: function AssignmentExpression(path) {\n            var node = path.node,\n                scope = path.scope;\n\n            if (node.left.computed || !node.left.property || node.left.property.name !== 'propTypes') {\n              return;\n            }\n\n            var forceRemoval = (0, _isAnnotatedForRemoval.default)(path.node.left);\n\n            if (forceRemoval) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              (0, _remove.default)(path, globalOptions, {\n                type: 'assign'\n              });\n              return;\n            }\n\n            var className = node.left.object.name;\n            var binding = scope.getBinding(className);\n\n            if (!binding) {\n              return;\n            }\n\n            if (binding.path.isClassDeclaration()) {\n              var superClass = binding.path.get('superClass');\n\n              if (isReactClass(superClass, scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'assign'\n                });\n              }\n            } else if ((0, _isStatelessComponent.default)(binding.path)) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              (0, _remove.default)(path, globalOptions, {\n                type: 'assign'\n              });\n            }\n          }\n        });\n        var skippedIdentifiers = 0;\n        var removeNewlyUnusedIdentifiers = {\n          VariableDeclarator: function VariableDeclarator(path) {\n            // Only consider the top level scope.\n            if (path.scope.block.type !== 'Program') {\n              return;\n            }\n\n            if (['ObjectPattern', 'ArrayPattern'].includes(path.node.id.type)) {\n              // Object or Array destructuring, so we will want to capture all\n              // the names created by the destructuring. This currently doesn't\n              // work, but would be good to improve. All of the names for\n              // ObjectPattern can be collected like:\n              //\n              //   path.node.id.properties.map(prop => prop.value.name);\n              return;\n            }\n\n            var name = path.node.id.name;\n\n            if (!nestedIdentifiers.has(name)) {\n              return;\n            }\n\n            var _path$scope$getBindin = path.scope.getBinding(name),\n                referencePaths = _path$scope$getBindin.referencePaths; // Count the number of referencePaths that are not in the\n            // removedPaths Set. We need to do this in order to support the wrap\n            // option, which doesn't actually remove the references.\n\n\n            var hasRemainingReferencePaths = referencePaths.some(function (referencePath) {\n              var found = referencePath.find(function (path2) {\n                return removedPaths.has(path2);\n              });\n              return !found;\n            });\n\n            if (hasRemainingReferencePaths) {\n              // There are still references to this identifier, so we need to\n              // skip over it for now.\n              skippedIdentifiers += 1;\n              return;\n            }\n\n            removedPaths.add(path);\n            nestedIdentifiers.delete(name);\n            path.get('init').traverse(collectNestedIdentifiers);\n            (0, _remove.default)(path, globalOptions, {\n              type: 'declarator'\n            });\n          }\n        };\n        var lastNestedIdentifiers = new Set();\n\n        while (!areSetsEqual(nestedIdentifiers, lastNestedIdentifiers) && nestedIdentifiers.size > 0 && skippedIdentifiers < nestedIdentifiers.size) {\n          lastNestedIdentifiers = new Set(nestedIdentifiers);\n          skippedIdentifiers = 0;\n          programPath.scope.crawl();\n          programPath.traverse(removeNewlyUnusedIdentifiers);\n        }\n\n        if (globalOptions.removeImport) {\n          if (globalOptions.mode === 'remove') {\n            programPath.scope.crawl();\n            programPath.traverse({\n              ImportDeclaration: function ImportDeclaration(path) {\n                var _path$node = path.node,\n                    source = _path$node.source,\n                    specifiers = _path$node.specifiers;\n                var found = globalOptions.libraries.some(function (library) {\n                  if (library instanceof RegExp) {\n                    return library.test(source.value);\n                  }\n\n                  return source.value === library;\n                });\n\n                if (!found) {\n                  return;\n                }\n\n                var haveUsedSpecifiers = specifiers.some(function (specifier) {\n                  var importedIdentifierName = specifier.local.name;\n\n                  var _path$scope$getBindin2 = path.scope.getBinding(importedIdentifierName),\n                      referencePaths = _path$scope$getBindin2.referencePaths;\n\n                  return referencePaths.length > 0;\n                });\n\n                if (!haveUsedSpecifiers) {\n                  path.remove();\n                }\n              }\n            });\n          } else {\n            throw new Error('transform-react-remove-prop-type: removeImport = true and mode != \"remove\" can not be used at the same time.');\n          }\n        }\n      }\n    }\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}