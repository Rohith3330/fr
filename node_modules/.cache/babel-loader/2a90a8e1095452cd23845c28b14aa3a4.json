{"ast":null,"code":"/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nvar path = require('path'),\n    convert = require('convert-source-map');\n\nvar fileProtocol = require('../file-protocol');\n\nvar rework = requireOptionalPeerDependency('rework'),\n    visit = requireOptionalPeerDependency('rework-visit');\n/**\n * Process the given CSS content into reworked CSS content.\n *\n * @param {string} sourceFile The absolute path of the file being processed\n * @param {string} sourceContent CSS content without source-map\n * @param {{outputSourceMap: boolean, transformDeclaration:function, absSourceMap:object,\n *        sourceMapConsumer:object}} params Named parameters\n * @return {{content: string, map: object}} Reworked CSS and optional source-map\n */\n\nfunction process(sourceFile, sourceContent, params) {\n  // embed source-map in css\n  //  prepend file protocol to all sources to avoid problems with source map\n  var contentWithMap = sourceContent + (params.absSourceMap ? convert.fromObject(fileProtocol.prepend(params.absSourceMap)).toComment({\n    multiline: true\n  }) : ''); // need to prepend file protocol to source as well to avoid problems with source map\n\n  var reworked = rework(contentWithMap, {\n    source: fileProtocol.prepend(sourceFile)\n  }).use(reworkPlugin).toString({\n    sourcemap: params.outputSourceMap,\n    sourcemapAsObject: params.outputSourceMap\n  }); // complete with source-map\n\n  if (params.outputSourceMap) {\n    return {\n      content: reworked.code,\n      map: fileProtocol.remove(reworked.map)\n    };\n  } // complete without source-map\n  else {\n    return {\n      content: reworked,\n      map: null\n    };\n  }\n  /**\n   * Plugin for css rework that follows SASS transpilation.\n   *\n   * @param {object} stylesheet AST for the CSS output from SASS\n   */\n\n\n  function reworkPlugin(stylesheet) {\n    // visit each node (selector) in the stylesheet recursively using the official utility method\n    //  each node may have multiple declarations\n    visit(stylesheet, function visitor(declarations) {\n      if (declarations) {\n        declarations.forEach(eachDeclaration);\n      }\n    });\n    /**\n     * Process a declaration from the syntax tree.\n     * @param declaration\n     */\n\n    function eachDeclaration(declaration) {\n      var isValid = declaration.value && declaration.value.indexOf('url') >= 0;\n\n      if (isValid) {\n        declaration.value = params.transformDeclaration(declaration.value, getPathsAtChar);\n      }\n      /**\n       * Create a hash of base path strings.\n       *\n       * Position in the declaration is not supported since rework does not refine sourcemaps to this detail.\n       *\n       * @throws Error on invalid source map\n       * @returns {{selector:string, property:string}} Hash of base path strings\n       */\n\n\n      function getPathsAtChar() {\n        var posSelector = declaration.parent && declaration.parent.position.start,\n            posProperty = declaration.position.start;\n        var result = {\n          property: positionToOriginalDirectory(posProperty),\n          selector: positionToOriginalDirectory(posSelector)\n        };\n        var isValid = [result.property, result.selector].every(Boolean);\n\n        if (isValid) {\n          return result;\n        } else if (params.sourceMapConsumer) {\n          throw new Error('source-map information is not available at url() declaration');\n        } else {\n          throw new Error('a valid source-map is not present (ensure preceding loaders output a source-map)');\n        }\n      }\n    }\n  }\n  /**\n   * Given an apparent position find the directory of the original file.\n   *\n   * @param startPosApparent {{line: number, column: number}}\n   * @returns {false|string} Directory of original file or false on invalid\n   */\n\n\n  function positionToOriginalDirectory(startPosApparent) {\n    // reverse the original source-map to find the original source file before transpilation\n    var startPosOriginal = !!params.sourceMapConsumer && params.sourceMapConsumer.originalPositionFor(startPosApparent); // we require a valid directory for the specified file\n\n    var directory = !!startPosOriginal && !!startPosOriginal.source && fileProtocol.remove(path.dirname(startPosOriginal.source));\n    return directory;\n  }\n}\n\nmodule.exports = process;\n/**\n * Require the given filename but fail with an error that `requireOptionalPeerDependencies` must be installed.\n *\n * @param moduleName The module to require\n * @returns {*} The module\n * @throws Error when module is not found\n */\n\nfunction requireOptionalPeerDependency(moduleName) {\n  try {\n    return require(moduleName);\n  } catch (error) {\n    if (error.message === 'Cannot find module \\'' + moduleName + '\\'') {\n      throw new Error('to use the \"rework\" engine you must install the optionalPeerDependencies');\n    } else {\n      throw error;\n    }\n  }\n}","map":{"version":3,"names":["path","require","convert","fileProtocol","rework","requireOptionalPeerDependency","visit","process","sourceFile","sourceContent","params","contentWithMap","absSourceMap","fromObject","prepend","toComment","multiline","reworked","source","use","reworkPlugin","toString","sourcemap","outputSourceMap","sourcemapAsObject","content","code","map","remove","stylesheet","visitor","declarations","forEach","eachDeclaration","declaration","isValid","value","indexOf","transformDeclaration","getPathsAtChar","posSelector","parent","position","start","posProperty","result","property","positionToOriginalDirectory","selector","every","Boolean","sourceMapConsumer","Error","startPosApparent","startPosOriginal","originalPositionFor","directory","dirname","module","exports","moduleName","error","message"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/resolve-url-loader/lib/engine/rework.js"],"sourcesContent":["/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nvar path    = require('path'),\n    convert = require('convert-source-map');\n\nvar fileProtocol = require('../file-protocol');\n\nvar rework = requireOptionalPeerDependency('rework'),\n    visit  = requireOptionalPeerDependency('rework-visit');\n\n/**\n * Process the given CSS content into reworked CSS content.\n *\n * @param {string} sourceFile The absolute path of the file being processed\n * @param {string} sourceContent CSS content without source-map\n * @param {{outputSourceMap: boolean, transformDeclaration:function, absSourceMap:object,\n *        sourceMapConsumer:object}} params Named parameters\n * @return {{content: string, map: object}} Reworked CSS and optional source-map\n */\nfunction process(sourceFile, sourceContent, params) {\n\n  // embed source-map in css\n  //  prepend file protocol to all sources to avoid problems with source map\n  var contentWithMap = sourceContent + (\n    params.absSourceMap ?\n      convert.fromObject(fileProtocol.prepend(params.absSourceMap)).toComment({multiline: true}) :\n      ''\n  );\n\n  // need to prepend file protocol to source as well to avoid problems with source map\n  var reworked = rework(contentWithMap, {source: fileProtocol.prepend(sourceFile)})\n    .use(reworkPlugin)\n    .toString({\n      sourcemap        : params.outputSourceMap,\n      sourcemapAsObject: params.outputSourceMap\n    });\n\n  // complete with source-map\n  if (params.outputSourceMap) {\n    return {\n      content: reworked.code,\n      map    : fileProtocol.remove(reworked.map)\n    };\n  }\n  // complete without source-map\n  else {\n    return {\n      content: reworked,\n      map    : null\n    };\n  }\n\n  /**\n   * Plugin for css rework that follows SASS transpilation.\n   *\n   * @param {object} stylesheet AST for the CSS output from SASS\n   */\n  function reworkPlugin(stylesheet) {\n\n    // visit each node (selector) in the stylesheet recursively using the official utility method\n    //  each node may have multiple declarations\n    visit(stylesheet, function visitor(declarations) {\n      if (declarations) {\n        declarations.forEach(eachDeclaration);\n      }\n    });\n\n    /**\n     * Process a declaration from the syntax tree.\n     * @param declaration\n     */\n    function eachDeclaration(declaration) {\n      var isValid = declaration.value && (declaration.value.indexOf('url') >= 0);\n      if (isValid) {\n        declaration.value = params.transformDeclaration(declaration.value, getPathsAtChar);\n      }\n\n      /**\n       * Create a hash of base path strings.\n       *\n       * Position in the declaration is not supported since rework does not refine sourcemaps to this detail.\n       *\n       * @throws Error on invalid source map\n       * @returns {{selector:string, property:string}} Hash of base path strings\n       */\n      function getPathsAtChar() {\n        var posSelector = declaration.parent && declaration.parent.position.start,\n            posProperty = declaration.position.start;\n\n        var result = {\n          property: positionToOriginalDirectory(posProperty),\n          selector: positionToOriginalDirectory(posSelector)\n        };\n\n        var isValid = [result.property, result.selector].every(Boolean);\n        if (isValid) {\n          return result;\n        }\n        else if (params.sourceMapConsumer) {\n          throw new Error('source-map information is not available at url() declaration');\n        } else {\n          throw new Error('a valid source-map is not present (ensure preceding loaders output a source-map)');\n        }\n      }\n    }\n  }\n\n  /**\n   * Given an apparent position find the directory of the original file.\n   *\n   * @param startPosApparent {{line: number, column: number}}\n   * @returns {false|string} Directory of original file or false on invalid\n   */\n  function positionToOriginalDirectory(startPosApparent) {\n    // reverse the original source-map to find the original source file before transpilation\n    var startPosOriginal =\n      !!params.sourceMapConsumer &&\n      params.sourceMapConsumer.originalPositionFor(startPosApparent);\n\n    // we require a valid directory for the specified file\n    var directory =\n      !!startPosOriginal &&\n      !!startPosOriginal.source &&\n      fileProtocol.remove(path.dirname(startPosOriginal.source));\n\n    return directory;\n  }\n}\n\nmodule.exports = process;\n\n/**\n * Require the given filename but fail with an error that `requireOptionalPeerDependencies` must be installed.\n *\n * @param moduleName The module to require\n * @returns {*} The module\n * @throws Error when module is not found\n */\nfunction requireOptionalPeerDependency(moduleName) {\n  try {\n    return require(moduleName);\n  }\n  catch (error) {\n    if (error.message === 'Cannot find module \\'' + moduleName + '\\'') {\n      throw new Error('to use the \"rework\" engine you must install the optionalPeerDependencies');\n    }\n    else {\n      throw error;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}