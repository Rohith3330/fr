{"ast":null,"code":"/**\n * @fileoverview Rule to flag comparisons to the value NaN\n * @author James Allardice\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given node is a NaN `Identifier` node.\n * @param {ASTNode|null} node The node to check.\n * @returns {boolean} `true` if the node is 'NaN' identifier.\n */\n\n\nfunction isNaNIdentifier(node) {\n  return Boolean(node) && (astUtils.isSpecificId(node, \"NaN\") || astUtils.isSpecificMemberAccess(node, \"Number\", \"NaN\"));\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Require calls to `isNaN()` when checking for `NaN`\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/use-isnan\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForSwitchCase: {\n          type: \"boolean\",\n          default: true\n        },\n        enforceForIndexOf: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      comparisonWithNaN: \"Use the isNaN function to compare with NaN.\",\n      switchNaN: \"'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.\",\n      caseNaN: \"'case NaN' can never match. Use Number.isNaN before the switch.\",\n      indexOfNaN: \"Array prototype method '{{ methodName }}' cannot find NaN.\"\n    }\n  },\n\n  create(context) {\n    const enforceForSwitchCase = !context.options[0] || context.options[0].enforceForSwitchCase;\n    const enforceForIndexOf = context.options[0] && context.options[0].enforceForIndexOf;\n    /**\n     * Checks the given `BinaryExpression` node for `foo === NaN` and other comparisons.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n\n    function checkBinaryExpression(node) {\n      if (/^(?:[<>]|[!=]=)=?$/u.test(node.operator) && (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))) {\n        context.report({\n          node,\n          messageId: \"comparisonWithNaN\"\n        });\n      }\n    }\n    /**\n     * Checks the discriminant and all case clauses of the given `SwitchStatement` node for `switch(NaN)` and `case NaN:`\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n\n\n    function checkSwitchStatement(node) {\n      if (isNaNIdentifier(node.discriminant)) {\n        context.report({\n          node,\n          messageId: \"switchNaN\"\n        });\n      }\n\n      for (const switchCase of node.cases) {\n        if (isNaNIdentifier(switchCase.test)) {\n          context.report({\n            node: switchCase,\n            messageId: \"caseNaN\"\n          });\n        }\n      }\n    }\n    /**\n     * Checks the given `CallExpression` node for `.indexOf(NaN)` and `.lastIndexOf(NaN)`.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n\n\n    function checkCallExpression(node) {\n      const callee = astUtils.skipChainExpression(node.callee);\n\n      if (callee.type === \"MemberExpression\") {\n        const methodName = astUtils.getStaticPropertyName(callee);\n\n        if ((methodName === \"indexOf\" || methodName === \"lastIndexOf\") && node.arguments.length === 1 && isNaNIdentifier(node.arguments[0])) {\n          context.report({\n            node,\n            messageId: \"indexOfNaN\",\n            data: {\n              methodName\n            }\n          });\n        }\n      }\n    }\n\n    const listeners = {\n      BinaryExpression: checkBinaryExpression\n    };\n\n    if (enforceForSwitchCase) {\n      listeners.SwitchStatement = checkSwitchStatement;\n    }\n\n    if (enforceForIndexOf) {\n      listeners.CallExpression = checkCallExpression;\n    }\n\n    return listeners;\n  }\n\n};","map":{"version":3,"names":["astUtils","require","isNaNIdentifier","node","Boolean","isSpecificId","isSpecificMemberAccess","module","exports","meta","type","docs","description","recommended","url","schema","properties","enforceForSwitchCase","default","enforceForIndexOf","additionalProperties","messages","comparisonWithNaN","switchNaN","caseNaN","indexOfNaN","create","context","options","checkBinaryExpression","test","operator","left","right","report","messageId","checkSwitchStatement","discriminant","switchCase","cases","checkCallExpression","callee","skipChainExpression","methodName","getStaticPropertyName","arguments","length","data","listeners","BinaryExpression","SwitchStatement","CallExpression"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/use-isnan.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag comparisons to the value NaN\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given node is a NaN `Identifier` node.\n * @param {ASTNode|null} node The node to check.\n * @returns {boolean} `true` if the node is 'NaN' identifier.\n */\nfunction isNaNIdentifier(node) {\n    return Boolean(node) && (\n        astUtils.isSpecificId(node, \"NaN\") ||\n        astUtils.isSpecificMemberAccess(node, \"Number\", \"NaN\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Require calls to `isNaN()` when checking for `NaN`\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/use-isnan\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    enforceForSwitchCase: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    enforceForIndexOf: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            comparisonWithNaN: \"Use the isNaN function to compare with NaN.\",\n            switchNaN: \"'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.\",\n            caseNaN: \"'case NaN' can never match. Use Number.isNaN before the switch.\",\n            indexOfNaN: \"Array prototype method '{{ methodName }}' cannot find NaN.\"\n        }\n    },\n\n    create(context) {\n\n        const enforceForSwitchCase = !context.options[0] || context.options[0].enforceForSwitchCase;\n        const enforceForIndexOf = context.options[0] && context.options[0].enforceForIndexOf;\n\n        /**\n         * Checks the given `BinaryExpression` node for `foo === NaN` and other comparisons.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkBinaryExpression(node) {\n            if (\n                /^(?:[<>]|[!=]=)=?$/u.test(node.operator) &&\n                (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))\n            ) {\n                context.report({ node, messageId: \"comparisonWithNaN\" });\n            }\n        }\n\n        /**\n         * Checks the discriminant and all case clauses of the given `SwitchStatement` node for `switch(NaN)` and `case NaN:`\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkSwitchStatement(node) {\n            if (isNaNIdentifier(node.discriminant)) {\n                context.report({ node, messageId: \"switchNaN\" });\n            }\n\n            for (const switchCase of node.cases) {\n                if (isNaNIdentifier(switchCase.test)) {\n                    context.report({ node: switchCase, messageId: \"caseNaN\" });\n                }\n            }\n        }\n\n        /**\n         * Checks the given `CallExpression` node for `.indexOf(NaN)` and `.lastIndexOf(NaN)`.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkCallExpression(node) {\n            const callee = astUtils.skipChainExpression(node.callee);\n\n            if (callee.type === \"MemberExpression\") {\n                const methodName = astUtils.getStaticPropertyName(callee);\n\n                if (\n                    (methodName === \"indexOf\" || methodName === \"lastIndexOf\") &&\n                    node.arguments.length === 1 &&\n                    isNaNIdentifier(node.arguments[0])\n                ) {\n                    context.report({ node, messageId: \"indexOfNaN\", data: { methodName } });\n                }\n            }\n        }\n\n        const listeners = {\n            BinaryExpression: checkBinaryExpression\n        };\n\n        if (enforceForSwitchCase) {\n            listeners.SwitchStatement = checkSwitchStatement;\n        }\n\n        if (enforceForIndexOf) {\n            listeners.CallExpression = checkCallExpression;\n        }\n\n        return listeners;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}