{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst nullable_1 = require(\"./nullable\");\n\nconst error = {\n  message: \"must be equal to one of the allowed values\",\n  params: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return (0, codegen_1._)`{allowedValues: ${schemaCode}}`;\n  }\n};\nconst def = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  error,\n\n  code(cxt) {\n    (0, metadata_1.checkMetadata)(cxt);\n    const {\n      gen,\n      data,\n      schema,\n      schemaValue,\n      parentSchema,\n      it\n    } = cxt;\n    if (schema.length === 0) throw new Error(\"enum must have non-empty array\");\n    if (schema.length !== new Set(schema).size) throw new Error(\"enum items must be unique\");\n    let valid;\n    const isString = (0, codegen_1._)`typeof ${data} == \"string\"`;\n\n    if (schema.length >= it.opts.loopEnum) {\n      let cond;\n      [valid, cond] = (0, nullable_1.checkNullable)(cxt, isString);\n      gen.if(cond, loopEnum);\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n      valid = (0, codegen_1.and)(isString, (0, codegen_1.or)(...schema.map(value => (0, codegen_1._)`${data} === ${value}`)));\n      if (parentSchema.nullable) valid = (0, codegen_1.or)((0, codegen_1._)`${data} === null`, valid);\n    }\n\n    cxt.pass(valid);\n\n    function loopEnum() {\n      gen.forOf(\"v\", schemaValue, v => gen.if((0, codegen_1._)`${valid} = ${data} === ${v}`, () => gen.break()));\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":";;;;;;AAEA;;AACA;;AACA;;AAIA,MAAMA,KAAK,GAA2B;EACpCC,OAAO,EAAE,4CAD2B;EAEpCC,MAAM,EAAE;IAAA,IAAC;MAACC;IAAD,CAAD;IAAA,OAAkB,gBAAC,mBAAmBA,UAAU,GAAhD;EAAA;AAF4B,CAAtC;AAKA,MAAMC,GAAG,GAA0B;EACjCC,OAAO,EAAE,MADwB;EAEjCC,UAAU,EAAE,OAFqB;EAGjCN,KAHiC;;EAIjCO,IAAI,CAACC,GAAD,EAAgB;IAClB,8BAAcA,GAAd;IACA,MAAM;MAACC,GAAD;MAAMC,IAAN;MAAYC,MAAZ;MAAoBC,WAApB;MAAiCC,YAAjC;MAA+CC;IAA/C,IAAqDN,GAA3D;IACA,IAAIG,MAAM,CAACI,MAAP,KAAkB,CAAtB,EAAyB,MAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;IACzB,IAAIL,MAAM,CAACI,MAAP,KAAkB,IAAIE,GAAJ,CAAQN,MAAR,EAAgBO,IAAtC,EAA4C,MAAM,IAAIF,KAAJ,CAAU,2BAAV,CAAN;IAC5C,IAAIG,KAAJ;IACA,MAAMC,QAAQ,GAAG,gBAAC,UAAUV,IAAI,cAAhC;;IACA,IAAIC,MAAM,CAACI,MAAP,IAAiBD,EAAE,CAACO,IAAH,CAAQC,QAA7B,EAAuC;MACrC,IAAIC,IAAJ;MACC,CAACJ,KAAD,EAAQI,IAAR,IAAgB,8BAAcf,GAAd,EAAmBY,QAAnB,CAAhB;MACDX,GAAG,CAACe,EAAJ,CAAOD,IAAP,EAAaD,QAAb;IACD,CAJD,MAIO;MACL;MACA,IAAI,CAACG,KAAK,CAACC,OAAN,CAAcf,MAAd,CAAL,EAA4B,MAAM,IAAIK,KAAJ,CAAU,0BAAV,CAAN;MAC5BG,KAAK,GAAG,mBAAIC,QAAJ,EAAc,kBAAG,GAAGT,MAAM,CAACgB,GAAP,CAAYC,KAAD,IAAmB,gBAAC,GAAGlB,IAAI,QAAQkB,KAAK,EAAnD,CAAN,CAAd,CAAR;MACA,IAAIf,YAAY,CAACgB,QAAjB,EAA2BV,KAAK,GAAG,kBAAG,gBAAC,GAAGT,IAAI,WAAX,EAAwBS,KAAxB,CAAR;IAC5B;;IACDX,GAAG,CAACsB,IAAJ,CAASX,KAAT;;IAEA,SAASG,QAAT,GAAiB;MACfb,GAAG,CAACsB,KAAJ,CAAU,GAAV,EAAenB,WAAf,EAAqCoB,CAAD,IAClCvB,GAAG,CAACe,EAAJ,CAAO,gBAAC,GAAGL,KAAK,MAAMT,IAAI,QAAQsB,CAAC,EAAnC,EAAuC,MAAMvB,GAAG,CAACwB,KAAJ,EAA7C,CADF;IAGD;EACF;;AA5BgC,CAAnC;AA+BAC,kBAAe9B,GAAf","names":["error","message","params","schemaCode","def","keyword","schemaType","code","cxt","gen","data","schema","schemaValue","parentSchema","it","length","Error","Set","size","valid","isString","opts","loopEnum","cond","if","Array","isArray","map","value","nullable","pass","forOf","v","break","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\mini-css-extract-plugin\\node_modules\\ajv\\lib\\vocabularies\\jtd\\enum.ts"],"sourcesContent":["import type {CodeKeywordDefinition, KeywordErrorDefinition, ErrorObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, and, Code} from \"../../compile/codegen\"\nimport {checkMetadata} from \"./metadata\"\nimport {checkNullable} from \"./nullable\"\n\nexport type JTDEnumError = ErrorObject<\"enum\", {allowedValues: string[]}, string[]>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  error,\n  code(cxt: KeywordCxt) {\n    checkMetadata(cxt)\n    const {gen, data, schema, schemaValue, parentSchema, it} = cxt\n    if (schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    if (schema.length !== new Set(schema).size) throw new Error(\"enum items must be unique\")\n    let valid: Code\n    const isString = _`typeof ${data} == \"string\"`\n    if (schema.length >= it.opts.loopEnum) {\n      let cond: Code\n      ;[valid, cond] = checkNullable(cxt, isString)\n      gen.if(cond, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      valid = and(isString, or(...schema.map((value: string) => _`${data} === ${value}`)))\n      if (parentSchema.nullable) valid = or(_`${data} === null`, valid)\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.forOf(\"v\", schemaValue as Code, (v) =>\n        gen.if(_`${valid} = ${data} === ${v}`, () => gen.break())\n      )\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}