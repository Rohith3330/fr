{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst {\n  stringifyPathData\n} = require('../lib/path.js');\n\nconst {\n  detachNodeFromParent\n} = require('../lib/xast.js');\n\nexports.name = 'convertShapeToPath';\nexports.type = 'visitor';\nexports.active = true;\nexports.description = 'converts basic shapes to more compact path form';\nconst regNumber = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n/**\n * Converts basic shape to more compact path.\n * It also allows further optimizations like\n * combining paths with similar attributes.\n *\n * @see https://www.w3.org/TR/SVG11/shapes.html\n *\n * @author Lev Solntsev\n *\n * @type {import('../lib/types').Plugin<{\n *   convertArcs?: boolean,\n *   floatPrecision?: number\n * }>}\n */\n\nexports.fn = (root, params) => {\n  const {\n    convertArcs = false,\n    floatPrecision: precision\n  } = params;\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // convert rect to path\n        if (node.name === 'rect' && node.attributes.width != null && node.attributes.height != null && node.attributes.rx == null && node.attributes.ry == null) {\n          const x = Number(node.attributes.x || '0');\n          const y = Number(node.attributes.y || '0');\n          const width = Number(node.attributes.width);\n          const height = Number(node.attributes.height); // Values like '100%' compute to NaN, thus running after\n          // cleanupNumericValues when 'px' units has already been removed.\n          // TODO: Calculate sizes from % and non-px units if possible.\n\n          if (Number.isNaN(x - y + width - height)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n\n          const pathData = [{\n            command: 'M',\n            args: [x, y]\n          }, {\n            command: 'H',\n            args: [x + width]\n          }, {\n            command: 'V',\n            args: [y + height]\n          }, {\n            command: 'H',\n            args: [x]\n          }, {\n            command: 'z',\n            args: []\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.x;\n          delete node.attributes.y;\n          delete node.attributes.width;\n          delete node.attributes.height;\n        } // convert line to path\n\n\n        if (node.name === 'line') {\n          const x1 = Number(node.attributes.x1 || '0');\n          const y1 = Number(node.attributes.y1 || '0');\n          const x2 = Number(node.attributes.x2 || '0');\n          const y2 = Number(node.attributes.y2 || '0');\n          if (Number.isNaN(x1 - y1 + x2 - y2)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n\n          const pathData = [{\n            command: 'M',\n            args: [x1, y1]\n          }, {\n            command: 'L',\n            args: [x2, y2]\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.x1;\n          delete node.attributes.y1;\n          delete node.attributes.x2;\n          delete node.attributes.y2;\n        } // convert polyline and polygon to path\n\n\n        if ((node.name === 'polyline' || node.name === 'polygon') && node.attributes.points != null) {\n          const coords = (node.attributes.points.match(regNumber) || []).map(Number);\n\n          if (coords.length < 4) {\n            detachNodeFromParent(node, parentNode);\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n\n\n          const pathData = [];\n\n          for (let i = 0; i < coords.length; i += 2) {\n            pathData.push({\n              command: i === 0 ? 'M' : 'L',\n              args: coords.slice(i, i + 2)\n            });\n          }\n\n          if (node.name === 'polygon') {\n            pathData.push({\n              command: 'z',\n              args: []\n            });\n          }\n\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.points;\n        } //  optionally convert circle\n\n\n        if (node.name === 'circle' && convertArcs) {\n          const cx = Number(node.attributes.cx || '0');\n          const cy = Number(node.attributes.cy || '0');\n          const r = Number(node.attributes.r || '0');\n\n          if (Number.isNaN(cx - cy + r)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n\n\n          const pathData = [{\n            command: 'M',\n            args: [cx, cy - r]\n          }, {\n            command: 'A',\n            args: [r, r, 0, 1, 0, cx, cy + r]\n          }, {\n            command: 'A',\n            args: [r, r, 0, 1, 0, cx, cy - r]\n          }, {\n            command: 'z',\n            args: []\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.r;\n        } // optionally covert ellipse\n\n\n        if (node.name === 'ellipse' && convertArcs) {\n          const ecx = Number(node.attributes.cx || '0');\n          const ecy = Number(node.attributes.cy || '0');\n          const rx = Number(node.attributes.rx || '0');\n          const ry = Number(node.attributes.ry || '0');\n\n          if (Number.isNaN(ecx - ecy + rx - ry)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n\n\n          const pathData = [{\n            command: 'M',\n            args: [ecx, ecy - ry]\n          }, {\n            command: 'A',\n            args: [rx, ry, 0, 1, 0, ecx, ecy + ry]\n          }, {\n            command: 'A',\n            args: [rx, ry, 0, 1, 0, ecx, ecy - ry]\n          }, {\n            command: 'z',\n            args: []\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.rx;\n          delete node.attributes.ry;\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["stringifyPathData","require","detachNodeFromParent","exports","name","type","active","description","regNumber","fn","root","params","convertArcs","floatPrecision","precision","element","enter","node","parentNode","attributes","width","height","rx","ry","x","Number","y","isNaN","pathData","command","args","d","x1","y1","x2","y2","points","coords","match","map","length","i","push","slice","cx","cy","r","ecx","ecy"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/svgo/plugins/convertShapeToPath.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst { stringifyPathData } = require('../lib/path.js');\nconst { detachNodeFromParent } = require('../lib/xast.js');\n\nexports.name = 'convertShapeToPath';\nexports.type = 'visitor';\nexports.active = true;\nexports.description = 'converts basic shapes to more compact path form';\n\nconst regNumber = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * Converts basic shape to more compact path.\n * It also allows further optimizations like\n * combining paths with similar attributes.\n *\n * @see https://www.w3.org/TR/SVG11/shapes.html\n *\n * @author Lev Solntsev\n *\n * @type {import('../lib/types').Plugin<{\n *   convertArcs?: boolean,\n *   floatPrecision?: number\n * }>}\n */\nexports.fn = (root, params) => {\n  const { convertArcs = false, floatPrecision: precision } = params;\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // convert rect to path\n        if (\n          node.name === 'rect' &&\n          node.attributes.width != null &&\n          node.attributes.height != null &&\n          node.attributes.rx == null &&\n          node.attributes.ry == null\n        ) {\n          const x = Number(node.attributes.x || '0');\n          const y = Number(node.attributes.y || '0');\n          const width = Number(node.attributes.width);\n          const height = Number(node.attributes.height);\n          // Values like '100%' compute to NaN, thus running after\n          // cleanupNumericValues when 'px' units has already been removed.\n          // TODO: Calculate sizes from % and non-px units if possible.\n          if (Number.isNaN(x - y + width - height)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [x, y] },\n            { command: 'H', args: [x + width] },\n            { command: 'V', args: [y + height] },\n            { command: 'H', args: [x] },\n            { command: 'z', args: [] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.x;\n          delete node.attributes.y;\n          delete node.attributes.width;\n          delete node.attributes.height;\n        }\n\n        // convert line to path\n        if (node.name === 'line') {\n          const x1 = Number(node.attributes.x1 || '0');\n          const y1 = Number(node.attributes.y1 || '0');\n          const x2 = Number(node.attributes.x2 || '0');\n          const y2 = Number(node.attributes.y2 || '0');\n          if (Number.isNaN(x1 - y1 + x2 - y2)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [x1, y1] },\n            { command: 'L', args: [x2, y2] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.x1;\n          delete node.attributes.y1;\n          delete node.attributes.x2;\n          delete node.attributes.y2;\n        }\n\n        // convert polyline and polygon to path\n        if (\n          (node.name === 'polyline' || node.name === 'polygon') &&\n          node.attributes.points != null\n        ) {\n          const coords = (node.attributes.points.match(regNumber) || []).map(\n            Number\n          );\n          if (coords.length < 4) {\n            detachNodeFromParent(node, parentNode);\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [];\n          for (let i = 0; i < coords.length; i += 2) {\n            pathData.push({\n              command: i === 0 ? 'M' : 'L',\n              args: coords.slice(i, i + 2),\n            });\n          }\n          if (node.name === 'polygon') {\n            pathData.push({ command: 'z', args: [] });\n          }\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.points;\n        }\n\n        //  optionally convert circle\n        if (node.name === 'circle' && convertArcs) {\n          const cx = Number(node.attributes.cx || '0');\n          const cy = Number(node.attributes.cy || '0');\n          const r = Number(node.attributes.r || '0');\n          if (Number.isNaN(cx - cy + r)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [cx, cy - r] },\n            { command: 'A', args: [r, r, 0, 1, 0, cx, cy + r] },\n            { command: 'A', args: [r, r, 0, 1, 0, cx, cy - r] },\n            { command: 'z', args: [] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.r;\n        }\n\n        // optionally covert ellipse\n        if (node.name === 'ellipse' && convertArcs) {\n          const ecx = Number(node.attributes.cx || '0');\n          const ecy = Number(node.attributes.cy || '0');\n          const rx = Number(node.attributes.rx || '0');\n          const ry = Number(node.attributes.ry || '0');\n          if (Number.isNaN(ecx - ecy + rx - ry)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [ecx, ecy - ry] },\n            { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },\n            { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },\n            { command: 'z', args: [] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.rx;\n          delete node.attributes.ry;\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}