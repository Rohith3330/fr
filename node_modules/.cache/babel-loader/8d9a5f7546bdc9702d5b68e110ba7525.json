{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _toConsumableArray = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConfigPrinter = exports.ChainFormatter = void 0;\n\nfunction _gensync() {\n  var data = require(\"gensync\");\n\n  _gensync = function _gensync() {\n    return data;\n  };\n\n  return data;\n}\n\nvar ChainFormatter = {\n  Programmatic: 0,\n  Config: 1\n};\nexports.ChainFormatter = ChainFormatter;\nvar Formatter = {\n  title: function title(type, callerName, filepath) {\n    var title = \"\";\n\n    if (type === ChainFormatter.Programmatic) {\n      title = \"programmatic options\";\n\n      if (callerName) {\n        title += \" from \" + callerName;\n      }\n    } else {\n      title = \"config \" + filepath;\n    }\n\n    return title;\n  },\n  loc: function loc(index, envName) {\n    var loc = \"\";\n\n    if (index != null) {\n      loc += \".overrides[\".concat(index, \"]\");\n    }\n\n    if (envName != null) {\n      loc += \".env[\\\"\".concat(envName, \"\\\"]\");\n    }\n\n    return loc;\n  },\n  optionsAndDescriptors: /*#__PURE__*/_regeneratorRuntime().mark(function optionsAndDescriptors(opt) {\n    var content, pluginDescriptors, presetDescriptors;\n    return _regeneratorRuntime().wrap(function optionsAndDescriptors$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            content = Object.assign({}, opt.options);\n            delete content.overrides;\n            delete content.env;\n            _context.t0 = _toConsumableArray;\n            return _context.delegateYield(opt.plugins(), \"t1\", 5);\n\n          case 5:\n            _context.t2 = _context.t1;\n            pluginDescriptors = (0, _context.t0)(_context.t2);\n\n            if (pluginDescriptors.length) {\n              content.plugins = pluginDescriptors.map(function (d) {\n                return descriptorToConfig(d);\n              });\n            }\n\n            _context.t3 = _toConsumableArray;\n            return _context.delegateYield(opt.presets(), \"t4\", 10);\n\n          case 10:\n            _context.t5 = _context.t4;\n            presetDescriptors = (0, _context.t3)(_context.t5);\n\n            if (presetDescriptors.length) {\n              content.presets = _toConsumableArray(presetDescriptors).map(function (d) {\n                return descriptorToConfig(d);\n              });\n            }\n\n            return _context.abrupt(\"return\", JSON.stringify(content, undefined, 2));\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, optionsAndDescriptors);\n  })\n};\n\nfunction descriptorToConfig(d) {\n  var _d$file;\n\n  var name = (_d$file = d.file) == null ? void 0 : _d$file.request;\n\n  if (name == null) {\n    if (typeof d.value === \"object\") {\n      name = d.value;\n    } else if (typeof d.value === \"function\") {\n      name = \"[Function: \".concat(d.value.toString().slice(0, 50), \" ... ]\");\n    }\n  }\n\n  if (name == null) {\n    name = \"[Unknown]\";\n  }\n\n  if (d.options === undefined) {\n    return name;\n  } else if (d.name == null) {\n    return [name, d.options];\n  } else {\n    return [name, d.options, d.name];\n  }\n}\n\nvar ConfigPrinter = /*#__PURE__*/function () {\n  function ConfigPrinter() {\n    _classCallCheck(this, ConfigPrinter);\n\n    this._stack = [];\n  }\n\n  _createClass(ConfigPrinter, [{\n    key: \"configure\",\n    value: function configure(enabled, type, _ref) {\n      var _this = this;\n\n      var callerName = _ref.callerName,\n          filepath = _ref.filepath;\n      if (!enabled) return function () {};\n      return function (content, index, envName) {\n        _this._stack.push({\n          type: type,\n          callerName: callerName,\n          filepath: filepath,\n          content: content,\n          index: index,\n          envName: envName\n        });\n      };\n    }\n  }, {\n    key: \"output\",\n    value: /*#__PURE__*/_regeneratorRuntime().mark(function output() {\n      var configs;\n      return _regeneratorRuntime().wrap(function output$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(this._stack.length === 0)) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", \"\");\n\n            case 2:\n              return _context2.delegateYield(_gensync().all(this._stack.map(function (s) {\n                return ConfigPrinter.format(s);\n              })), \"t0\", 3);\n\n            case 3:\n              configs = _context2.t0;\n              return _context2.abrupt(\"return\", configs.join(\"\\n\\n\"));\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, output, this);\n    })\n  }], [{\n    key: \"format\",\n    value: /*#__PURE__*/_regeneratorRuntime().mark(function format(config) {\n      var title, loc, content;\n      return _regeneratorRuntime().wrap(function format$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              title = Formatter.title(config.type, config.callerName, config.filepath);\n              loc = Formatter.loc(config.index, config.envName);\n              if (loc) title += \" \".concat(loc);\n              return _context3.delegateYield(Formatter.optionsAndDescriptors(config.content), \"t0\", 4);\n\n            case 4:\n              content = _context3.t0;\n              return _context3.abrupt(\"return\", \"\".concat(title, \"\\n\").concat(content));\n\n            case 6:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, format);\n    })\n  }]);\n\n  return ConfigPrinter;\n}();\n\nexports.ConfigPrinter = ConfigPrinter;\n0 && 0;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;AAAA;EAAA;;EAAAA;IAAA;EAAA;;EAAA;AAAA;;AAUO,IAAMC,cAAc,GAAG;EAC5BC,YAAY,EAAE,CADc;EAE5BC,MAAM,EAAE;AAFoB,CAAvB;;AAcP,IAAMC,SAAS,GAAG;EAChBC,KADgB,iBAEdC,IAFc,EAGdC,UAHc,EAIdC,QAJc,EAKN;IACR,IAAIH,KAAK,GAAG,EAAZ;;IACA,IAAIC,IAAI,KAAKL,cAAc,CAACC,YAA5B,EAA0C;MACxCG,KAAK,GAAG,sBAARA;;MACA,IAAIE,UAAJ,EAAgB;QACdF,KAAK,IAAI,WAAWE,UAApBF;MACD;IAJH,OAKO;MACLA,KAAK,GAAG,YAAYG,QAApBH;IACD;;IACD,OAAOA,KAAP;EAfc;EAiBhBI,GAjBgB,eAiBZC,KAjBY,EAiBWC,OAjBX,EAiB4C;IAC1D,IAAIF,GAAG,GAAG,EAAV;;IACA,IAAIC,KAAK,IAAI,IAAb,EAAmB;MACjBD,GAAG,yBAAkBC,KAAlB,MAAHD;IACD;;IACD,IAAIE,OAAO,IAAI,IAAf,EAAqB;MACnBF,GAAG,qBAAaE,OAAb,QAAHF;IACD;;IACD,OAAOA,GAAP;EAzBc;EA4BfG,qBA5Be,yEA4BOC,GA5BP;IAAA;IAAA;MAAA;QAAA;UAAA;YA6BRC,OA7BQ,GA6BDC,kBAAQF,GAAG,CAACG,OAAZ,CA7BC;YA+Bd,OAAOF,OAAO,CAACG,SAAf;YACA,OAAOH,OAAO,CAACI,GAAf;YAhCc;YAkCiB,8BAAOL,GAAG,CAACM,OAAJN,EAAP;;UAlCjB;YAAA;YAkCRO,iBAlCQ;;YAmCd,IAAIA,iBAAiB,CAACC,MAAtB,EAA8B;cAC5BP,OAAO,CAACK,OAARL,GAAkBM,iBAAiB,CAACE,GAAlBF,CAAsBG,WAAC;gBAAA,OAAIC,kBAAkB,CAACD,CAAD,CAAtB;cAAA,CAAvBH,CAAlBN;YACD;;YArCa;YAsCiB,8BAAOD,GAAG,CAACY,OAAJZ,EAAP;;UAtCjB;YAAA;YAsCRa,iBAtCQ;;YAuCd,IAAIA,iBAAiB,CAACL,MAAtB,EAA8B;cAC5BP,OAAO,CAACW,OAARX,GAAkB,mBAAIY,iBAAJ,EAAuBJ,GAAvB,CAA2BC,WAAC;gBAAA,OAAIC,kBAAkB,CAACD,CAAD,CAAtB;cAAA,CAA5B,CAAlBT;YACD;;YAzCa,iCA0CPa,IAAI,CAACC,SAALD,CAAeb,OAAfa,EAAwBE,SAAxBF,EAAmC,CAAnCA,CA1CO;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;AAAA,CAAlB;;AA8CA,SAASH,kBAAT,CACED,CADF,EAEgC;EAAA;;EAC9B,IAAIO,IAAI,cAAGP,CAAC,CAACQ,IAAL,qBAAGC,QAAQC,OAAnB;;EACA,IAAIH,IAAI,IAAI,IAAZ,EAAkB;IAChB,IAAI,OAAOP,CAAC,CAACW,KAAT,KAAmB,QAAvB,EAAiC;MAC/BJ,IAAI,GAAGP,CAAC,CAACW,KAATJ;IADF,OAEO,IAAI,OAAOP,CAAC,CAACW,KAAT,KAAmB,UAAvB,EAAmC;MAIxCJ,IAAI,wBAAiBP,CAAC,CAACW,KAAFX,CAAQY,QAARZ,GAAmBa,KAAnBb,CAAyB,CAAzBA,EAA4B,EAA5BA,CAAjB,WAAJO;IACD;EACF;;EACD,IAAIA,IAAI,IAAI,IAAZ,EAAkB;IAChBA,IAAI,GAAG,WAAPA;EACD;;EACD,IAAIP,CAAC,CAACP,OAAFO,KAAcM,SAAlB,EAA6B;IAC3B,OAAOC,IAAP;EADF,OAEO,IAAIP,CAAC,CAACO,IAAFP,IAAU,IAAd,EAAoB;IACzB,OAAO,CAACO,IAAD,EAAOP,CAAC,CAACP,OAAT,CAAP;EADK,OAEA;IACL,OAAO,CAACc,IAAD,EAAOP,CAAC,CAACP,OAAT,EAAkBO,CAAC,CAACO,IAApB,CAAP;EACD;AACF;;IAEYO,a;EAAc;IAAA;;IAAA,KACzBC,MADyB,GACQ,EADR;EAAA;;;;WAEzBC,mBACEC,OADFD,EAEEjC,IAFFiC,QAUE;MAAA;;MAAA,IANEhC,UAMF,QANEA,UAMF;MAAA,IALEC,QAKF,QALEA,QAKF;MACA,IAAI,CAACgC,OAAL,EAAc,OAAO,YAAM,CAAb;MACd,OAAO,UACL1B,OADK,EAELJ,KAFK,EAGLC,OAHK,EAIF;QACH,MAAK2B,MAAL,CAAYG,IAAZ,CAAiB;UACfnC,IADe,EACfA,IADe;UAEfC,UAFe,EAEfA,UAFe;UAGfC,QAHe,EAGfA,QAHe;UAIfM,OAJe,EAIfA,OAJe;UAKfJ,KALe,EAKfA,KALe;UAMfC;QANe,CAAjB;MALF;IAcD;;;mDAaM;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA,MACD,KAAK2B,MAAL,CAAYjB,MAAZ,KAAuB,CADtB;gBAAA;gBAAA;cAAA;;cAAA,kCACgC,EADhC;;YAAA;cAEW,+BAAOqB,WAAQC,GAARD,CACrB,KAAKJ,MAAL,CAAYhB,GAAZ,CAAgBsB,WAAC;gBAAA,OAAIP,aAAa,CAACQ,MAAdR,CAAqBO,CAArBP,CAAJ;cAAA,CAAjB,CADqBK,CAAP;;YAFX;cAECI,OAFD;cAAA,kCAKEA,OAAO,CAACC,IAARD,CAAa,MAAbA,CALF;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,C;;;mDAZO,gBAACE,MAAD;MAAA;MAAA;QAAA;UAAA;YAAA;cACR3C,KADQ,GACAD,SAAS,CAACC,KAAVD,CACV4C,MAAM,CAAC1C,IADGF,EAEV4C,MAAM,CAACzC,UAFGH,EAGV4C,MAAM,CAACxC,QAHGJ,CADA;cAMNK,GANM,GAMAL,SAAS,CAACK,GAAVL,CAAc4C,MAAM,CAACtC,KAArBN,EAA4B4C,MAAM,CAACrC,OAAnCP,CANA;cAOZ,IAAIK,GAAJ,EAASJ,KAAK,eAAQI,GAAR,CAALJ;cACO,+BAAOD,SAAS,CAACQ,qBAAVR,CAAgC4C,MAAM,CAAClC,OAAvCV,CAAP;;YARJ;cAQNU,OARM;cAAA,4CASFT,KATE,eASQS,OATR;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,C","names":["_gensync","ChainFormatter","Programmatic","Config","Formatter","title","type","callerName","filepath","loc","index","envName","optionsAndDescriptors","opt","content","Object","options","overrides","env","plugins","pluginDescriptors","length","map","d","descriptorToConfig","presets","presetDescriptors","JSON","stringify","undefined","name","file","_d$file","request","value","toString","slice","ConfigPrinter","_stack","configure","enabled","push","gensync","all","s","format","configs","join","config"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\printer.ts"],"sourcesContent":["import gensync from \"gensync\";\n\nimport type { Handler } from \"gensync\";\n\nimport type {\n  OptionsAndDescriptors,\n  UnloadedDescriptor,\n} from \"./config-descriptors\";\n\n// todo: Use flow enums when @babel/transform-flow-types supports it\nexport const ChainFormatter = {\n  Programmatic: 0,\n  Config: 1,\n};\n\ntype PrintableConfig = {\n  content: OptionsAndDescriptors;\n  type: typeof ChainFormatter[keyof typeof ChainFormatter];\n  callerName: string | undefined | null;\n  filepath: string | undefined | null;\n  index: number | undefined | null;\n  envName: string | undefined | null;\n};\n\nconst Formatter = {\n  title(\n    type: typeof ChainFormatter[keyof typeof ChainFormatter],\n    callerName?: string | null,\n    filepath?: string | null,\n  ): string {\n    let title = \"\";\n    if (type === ChainFormatter.Programmatic) {\n      title = \"programmatic options\";\n      if (callerName) {\n        title += \" from \" + callerName;\n      }\n    } else {\n      title = \"config \" + filepath;\n    }\n    return title;\n  },\n  loc(index?: number | null, envName?: string | null): string {\n    let loc = \"\";\n    if (index != null) {\n      loc += `.overrides[${index}]`;\n    }\n    if (envName != null) {\n      loc += `.env[\"${envName}\"]`;\n    }\n    return loc;\n  },\n\n  *optionsAndDescriptors(opt: OptionsAndDescriptors) {\n    const content = { ...opt.options };\n    // overrides and env will be printed as separated config items\n    delete content.overrides;\n    delete content.env;\n    // resolve to descriptors\n    const pluginDescriptors = [...(yield* opt.plugins())];\n    if (pluginDescriptors.length) {\n      content.plugins = pluginDescriptors.map(d => descriptorToConfig(d));\n    }\n    const presetDescriptors = [...(yield* opt.presets())];\n    if (presetDescriptors.length) {\n      content.presets = [...presetDescriptors].map(d => descriptorToConfig(d));\n    }\n    return JSON.stringify(content, undefined, 2);\n  },\n};\n\nfunction descriptorToConfig(\n  d: UnloadedDescriptor,\n): string | {} | Array<unknown> {\n  let name = d.file?.request;\n  if (name == null) {\n    if (typeof d.value === \"object\") {\n      name = d.value;\n    } else if (typeof d.value === \"function\") {\n      // If the unloaded descriptor is a function, i.e. `plugins: [ require(\"my-plugin\") ]`,\n      // we print the first 50 characters of the function source code and hopefully we can see\n      // `name: 'my-plugin'` in the source\n      name = `[Function: ${d.value.toString().slice(0, 50)} ... ]`;\n    }\n  }\n  if (name == null) {\n    name = \"[Unknown]\";\n  }\n  if (d.options === undefined) {\n    return name;\n  } else if (d.name == null) {\n    return [name, d.options];\n  } else {\n    return [name, d.options, d.name];\n  }\n}\n\nexport class ConfigPrinter {\n  _stack: Array<PrintableConfig> = [];\n  configure(\n    enabled: boolean,\n    type: typeof ChainFormatter[keyof typeof ChainFormatter],\n    {\n      callerName,\n      filepath,\n    }: {\n      callerName?: string;\n      filepath?: string;\n    },\n  ) {\n    if (!enabled) return () => {};\n    return (\n      content: OptionsAndDescriptors,\n      index?: number | null,\n      envName?: string | null,\n    ) => {\n      this._stack.push({\n        type,\n        callerName,\n        filepath,\n        content,\n        index,\n        envName,\n      });\n    };\n  }\n  static *format(config: PrintableConfig): Handler<string> {\n    let title = Formatter.title(\n      config.type,\n      config.callerName,\n      config.filepath,\n    );\n    const loc = Formatter.loc(config.index, config.envName);\n    if (loc) title += ` ${loc}`;\n    const content = yield* Formatter.optionsAndDescriptors(config.content);\n    return `${title}\\n${content}`;\n  }\n\n  *output(): Handler<string> {\n    if (this._stack.length === 0) return \"\";\n    const configs = yield* gensync.all(\n      this._stack.map(s => ConfigPrinter.format(s)),\n    );\n    return configs.join(\"\\n\\n\");\n  }\n}\n"]},"metadata":{},"sourceType":"script"}