{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluate = evaluate;\nexports.evaluateTruthy = evaluateTruthy;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction isValidCallee(val) {\n  return VALID_CALLEES.includes(val);\n}\n\nfunction isInvalidMethod(val) {\n  return INVALID_METHODS.includes(val);\n}\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key;\n\n      if (prop.node.computed) {\n        key = keyPath.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (keyPath.isIdentifier()) {\n        key = keyPath.node.name;\n      } else {\n        key = keyPath.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n\n      case \"??\":\n        state.confident = leftConfident && (left != null || rightConfident);\n        if (!state.confident) return;\n        return left != null ? left : right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && isValidCallee(callee.node.name)) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && isValidCallee(object.node.name) && !isInvalidMethod(property.node.name)) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state) {\n  let raw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","map":{"version":3,"mappings":"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","names":["VALID_CALLEES","INVALID_METHODS","isValidCallee","val","includes","isInvalidMethod","evaluateTruthy","res","evaluate","confident","value","deopt","path","state","deoptPath","evaluateCached","node","seen","has","existing","get","resolved","item","set","_evaluate","isSequenceExpression","exprs","length","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","isTemplateLiteral","evaluateQuasis","quasis","isTaggedTemplateExpression","isMemberExpression","object","name","property","isIdentifier","scope","getBinding","quasi","isConditionalExpression","testResult","isExpressionWrapper","parentPath","isCallExpression","callee","isLiteral","type","isReferencedIdentifier","binding","constantViolations","start","end","hasValue","undefined","Infinity","NaN","resolve","isUnaryExpression","prefix","operator","argument","isFunction","isClass","arg","isArrayExpression","arr","elems","elem","elemValue","push","isObjectExpression","obj","props","prop","isObjectMethod","isSpreadElement","keyPath","key","computed","valuePath","isLogicalExpression","wasConfident","left","leftConfident","right","rightConfident","isBinaryExpression","context","func","global","args","map","apply","raw","str","i","cooked","expr","String","Map"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\path\\evaluation.ts"],"sourcesContent":["import type NodePath from \"./index\";\nimport type * as t from \"@babel/types\";\n\n// This file contains Babels metainterpreter that can evaluate static code.\n\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"] as const;\nconst INVALID_METHODS = [\"random\"] as const;\n\nfunction isValidCallee(val: string): val is typeof VALID_CALLEES[number] {\n  return VALID_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isInvalidMethod(val: string): val is typeof INVALID_METHODS[number] {\n  return INVALID_METHODS.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\n/**\n * Walk the input `node` and statically evaluate if it's truthy.\n *\n * Returning `true` when we're sure that the expression will evaluate to a\n * truthy value, `false` if we're sure that it will evaluate to a falsy\n * value and `undefined` if we aren't sure. Because of this please do not\n * rely on coercion when using this method and check with === if it's false.\n *\n * For example do:\n *\n *   if (t.evaluateTruthy(node) === false) falsyLogic();\n *\n * **AND NOT**\n *\n *   if (!t.evaluateTruthy(node)) falsyLogic();\n *\n */\n\nexport function evaluateTruthy(this: NodePath): boolean {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\ntype State = {\n  confident: boolean;\n  deoptPath: NodePath | null;\n  seen: Map<t.Node, Result>;\n};\n\ntype Result = {\n  resolved: boolean;\n  value?: any;\n};\n/**\n * Deopts the evaluation\n */\nfunction deopt(path: NodePath, state: State) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\n/**\n * We wrap the _evaluate method so we can track `seen` nodes, we push an item\n * to the map before we actually evaluate it so we can deopt on self recursive\n * nodes such as:\n *\n *   var g = a ? 1 : 2,\n *       a = g * this.foo\n */\nfunction evaluateCached(path: NodePath, state: State): any {\n  const { node } = path;\n  const { seen } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item: Result = { resolved: false };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n    return val;\n  }\n}\n\nfunction _evaluate(path: NodePath, state: State): any {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (\n    path.isStringLiteral() ||\n    path.isNumericLiteral() ||\n    path.isBooleanLiteral()\n  ) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (\n    path.isTaggedTemplateExpression() &&\n    path.get(\"tag\").isMemberExpression()\n  ) {\n    const object = path.get(\"tag.object\") as NodePath;\n    const {\n      // @ts-expect-error todo(flow->ts): possible bug, object is can be any expression and so name might be undefined\n      node: { name },\n    } = object;\n    const property = path.get(\"tag.property\") as NodePath;\n\n    if (\n      object.isIdentifier() &&\n      name === \"String\" &&\n      // todo(flow->ts): was changed from getBinding(name, true)\n      //  should this be hasBinding(name, true) as the binding is never used later?\n      !path.scope.getBinding(name) &&\n      property.isIdentifier() &&\n      property.node.name === \"raw\"\n    ) {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    // TypeCastExpression, ExpressionStatement etc\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  // \"foo\".length\n  if (\n    path.isMemberExpression() &&\n    !path.parentPath.isCallExpression({ callee: path.node })\n  ) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      // @ts-expect-error todo(flow->ts): instead of typeof - would it be better to check type of ast node?\n      const value = object.node.value;\n      const type = typeof value;\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding?.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({ prefix: true })) {\n    if (path.node.operator === \"void\") {\n      // we don't need to evaluate the argument to know what this will return\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n    if (\n      path.node.operator === \"typeof\" &&\n      (argument.isFunction() || argument.isClass())\n    ) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n      case \"+\":\n        return +arg;\n      case \"-\":\n        return -arg;\n      case \"~\":\n        return ~arg;\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems: Array<NodePath> = path.get(\"elements\");\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n      const keyPath = (prop as NodePath<t.ObjectProperty>).get(\"key\");\n      let key;\n      // @ts-expect-error todo(flow->ts): type refinement issues ObjectMethod and SpreadElement somehow not excluded\n      if (prop.node.computed) {\n        key = keyPath.evaluate();\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n        key = key.value;\n      } else if (keyPath.isIdentifier()) {\n        key = keyPath.node.name;\n      } else {\n        key = (\n          keyPath.node as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral\n        ).value;\n      }\n      const valuePath = (prop as NodePath<t.ObjectProperty>).get(\"value\");\n      let value = valuePath.evaluate();\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n      value = value.value;\n      // @ts-expect-error key is any type\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    // If we are confident that the left side of an && is false, or the left\n    // side of an || is true, we can be confident about the entire expression\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        // TODO consider having a \"truthy type\" that doesn't bail on\n        // left uncertainty but can still evaluate to truthy.\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n\n        return left || right;\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n\n        return left && right;\n      case \"??\":\n        state.confident = leftConfident && (left != null || rightConfident);\n        if (!state.confident) return;\n\n        return left ?? right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n      case \"+\":\n        return left + right;\n      case \"/\":\n        return left / right;\n      case \"*\":\n        return left * right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return left ** right;\n      case \"<\":\n        return left < right;\n      case \">\":\n        return left > right;\n      case \"<=\":\n        return left <= right;\n      case \">=\":\n        return left >= right;\n      case \"==\":\n        return left == right; // eslint-disable-line eqeqeq\n      case \"!=\":\n        return left != right;\n      case \"===\":\n        return left === right;\n      case \"!==\":\n        return left !== right;\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \"^\":\n        return left ^ right;\n      case \"<<\":\n        return left << right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    // Number(1);\n    if (\n      callee.isIdentifier() &&\n      !path.scope.getBinding(callee.node.name) &&\n      isValidCallee(callee.node.name)\n    ) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      // Math.min(1, 2)\n      if (\n        object.isIdentifier() &&\n        property.isIdentifier() &&\n        isValidCallee(object.node.name) &&\n        !isInvalidMethod(property.node.name)\n      ) {\n        context = global[object.node.name];\n        // @ts-expect-error property may not exist in context object\n        func = context[property.node.name];\n      }\n\n      // \"abc\".charCodeAt(4)\n      if (object.isLiteral() && property.isIdentifier()) {\n        // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type (StringLiteral and NumberLiteral)\n        const type = typeof object.node.value;\n        if (type === \"string\" || type === \"number\") {\n          // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(\n  path: NodePath<t.TaggedTemplateExpression | t.TemplateLiteral>,\n  quasis: Array<any>,\n  state: State,\n  raw = false,\n) {\n  let str = \"\";\n\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    // not confident, evaluated an expression we don't like\n    if (!state.confident) break;\n\n    // add on element\n    str += raw ? elem.value.raw : elem.value.cooked;\n\n    // add on interpolated expression if it's present\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\n/**\n * Walk the input `node` and statically evaluate it.\n *\n * Returns an object in the form `{ confident, value, deopt }`. `confident`\n * indicates whether or not we had to drop out of evaluating the expression\n * because of hitting an unknown node that we couldn't confidently find the\n * value of, in which case `deopt` is the path of said node.\n *\n * Example:\n *\n *   t.evaluate(parse(\"5 + 5\")) // { confident: true, value: 10 }\n *   t.evaluate(parse(\"!true\")) // { confident: true, value: false }\n *   t.evaluate(parse(\"foo + foo\")) // { confident: false, value: undefined, deopt: NodePath }\n *\n */\n\nexport function evaluate(this: NodePath): {\n  confident: boolean;\n  value: any;\n  deopt?: NodePath;\n} {\n  const state: State = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map(),\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}