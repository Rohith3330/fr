{"ast":null,"code":"'use strict';\n\nconst browserslist = require('browserslist');\n\nconst {\n  sameParent\n} = require('cssnano-utils');\n\nconst {\n  ensureCompatibility,\n  sameVendor,\n  noVendor\n} = require('./lib/ensureCompatibility');\n/**\n * @param {import('postcss').Declaration} a\n * @param {import('postcss').Declaration} b\n * @return {boolean}\n */\n\n\nfunction declarationIsEqual(a, b) {\n  return a.important === b.important && a.prop === b.prop && a.value === b.value;\n}\n/**\n * @param {import('postcss').Declaration[]} array\n * @param {import('postcss').Declaration} decl\n * @return {number}\n */\n\n\nfunction indexOfDeclaration(array, decl) {\n  return array.findIndex(d => declarationIsEqual(d, decl));\n}\n/**\n * Returns filtered array of matched or unmatched declarations\n * @param {import('postcss').Declaration[]} a\n * @param {import('postcss').Declaration[]} b\n * @param {boolean} [not=false]\n * @return {import('postcss').Declaration[]}\n */\n\n\nfunction intersect(a, b, not) {\n  return a.filter(c => {\n    const index = indexOfDeclaration(b, c) !== -1;\n    return not ? !index : index;\n  });\n}\n/**\n * @param {import('postcss').Declaration[]} a\n * @param {import('postcss').Declaration[]} b\n * @return {boolean}\n */\n\n\nfunction sameDeclarationsAndOrder(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return a.every((d, index) => declarationIsEqual(d, b[index]));\n}\n/**\n * @param {import('postcss').Rule} ruleA\n * @param {import('postcss').Rule} ruleB\n * @param {string[]=} browsers\n * @param {Map<string, boolean>=} compatibilityCache\n * @return {boolean}\n */\n\n\nfunction canMerge(ruleA, ruleB, browsers, compatibilityCache) {\n  const a = ruleA.selectors;\n  const b = ruleB.selectors;\n  const selectors = a.concat(b);\n\n  if (!ensureCompatibility(selectors, browsers, compatibilityCache)) {\n    return false;\n  }\n\n  const parent = sameParent(\n  /** @type {any} */\n  ruleA,\n  /** @type {any} */\n  ruleB);\n\n  if (parent && ruleA.parent && ruleA.parent.type === 'atrule' &&\n  /** @type {import('postcss').AtRule} */\n  ruleA.parent.name.includes('keyframes')) {\n    return false;\n  }\n\n  return parent && (selectors.every(noVendor) || sameVendor(a, b));\n}\n/**\n * @param {import('postcss').ChildNode} node\n * @return {node is import('postcss').Declaration}\n */\n\n\nfunction isDeclaration(node) {\n  return node.type === 'decl';\n}\n/**\n * @param {import('postcss').Rule} rule\n * @return {import('postcss').Declaration[]}\n */\n\n\nfunction getDecls(rule) {\n  return rule.nodes.filter(isDeclaration);\n}\n/** @type {(...rules: import('postcss').Rule[]) => string} */\n\n\nconst joinSelectors = function () {\n  for (var _len = arguments.length, rules = new Array(_len), _key = 0; _key < _len; _key++) {\n    rules[_key] = arguments[_key];\n  }\n\n  return rules.map(s => s.selector).join();\n};\n/**\n * @param {...import('postcss').Rule} rules\n * @return {number}\n */\n\n\nfunction ruleLength() {\n  for (var _len2 = arguments.length, rules = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    rules[_key2] = arguments[_key2];\n  }\n\n  return rules.map(r => r.nodes.length ? String(r) : '').join('').length;\n}\n/**\n * @param {string} prop\n * @return {{prefix: string?, base:string?, rest:string[]}}\n */\n\n\nfunction splitProp(prop) {\n  // Treat vendor prefixed properties as if they were unprefixed;\n  // moving them when combined with non-prefixed properties can\n  // cause issues. e.g. moving -webkit-background-clip when there\n  // is a background shorthand definition.\n  const parts = prop.split('-');\n\n  if (prop[0] !== '-') {\n    return {\n      prefix: '',\n      base: parts[0],\n      rest: parts.slice(1)\n    };\n  } // Don't split css variables\n\n\n  if (prop[1] === '-') {\n    return {\n      prefix: null,\n      base: null,\n      rest: [prop]\n    };\n  } // Found prefix\n\n\n  return {\n    prefix: parts[1],\n    base: parts[2],\n    rest: parts.slice(3)\n  };\n}\n/**\n * @param {string} propA\n * @param {string} propB\n */\n\n\nfunction isConflictingProp(propA, propB) {\n  if (propA === propB) {\n    // Same specificity\n    return true;\n  }\n\n  const a = splitProp(propA);\n  const b = splitProp(propB); // Don't resort css variables\n\n  if (!a.base && !b.base) {\n    return true;\n  } // Different base;\n\n\n  if (a.base !== b.base) {\n    return false;\n  } // Conflict if rest-count mismatches\n\n\n  if (a.rest.length !== b.rest.length) {\n    return true;\n  } // Conflict if rest parameters are equal (same but unprefixed)\n\n\n  return a.rest.every((s, index) => b.rest[index] === s);\n}\n/**\n * @param {import('postcss').Rule} first\n * @param {import('postcss').Rule} second\n * @return {boolean} merged\n */\n\n\nfunction mergeParents(first, second) {\n  // Null check for detached rules\n  if (!first.parent || !second.parent) {\n    return false;\n  } // Check if parents share node\n\n\n  if (first.parent === second.parent) {\n    return false;\n  } // sameParent() already called by canMerge()\n\n\n  second.remove();\n  first.parent.append(second);\n  return true;\n}\n/**\n * @param {import('postcss').Rule} first\n * @param {import('postcss').Rule} second\n * @return {import('postcss').Rule} mergedRule\n */\n\n\nfunction partialMerge(first, second) {\n  let intersection = intersect(getDecls(first), getDecls(second));\n\n  if (!intersection.length) {\n    return second;\n  }\n\n  let nextRule = second.next();\n\n  if (!nextRule) {\n    // Grab next cousin\n\n    /** @type {any} */\n    const parentSibling =\n    /** @type {import('postcss').Container<import('postcss').ChildNode>} */\n    second.parent.next();\n    nextRule = parentSibling && parentSibling.nodes && parentSibling.nodes[0];\n  }\n\n  if (nextRule && nextRule.type === 'rule' && canMerge(second, nextRule)) {\n    let nextIntersection = intersect(getDecls(second), getDecls(nextRule));\n\n    if (nextIntersection.length > intersection.length) {\n      mergeParents(second, nextRule);\n      first = second;\n      second = nextRule;\n      intersection = nextIntersection;\n    }\n  }\n\n  const firstDecls = getDecls(first); // Filter out intersections with later conflicts in First\n\n  intersection = intersection.filter((decl, intersectIndex) => {\n    const indexOfDecl = indexOfDeclaration(firstDecls, decl);\n    const nextConflictInFirst = firstDecls.slice(indexOfDecl + 1).filter(d => isConflictingProp(d.prop, decl.prop));\n\n    if (!nextConflictInFirst.length) {\n      return true;\n    }\n\n    const nextConflictInIntersection = intersection.slice(intersectIndex + 1).filter(d => isConflictingProp(d.prop, decl.prop));\n\n    if (!nextConflictInIntersection.length) {\n      return false;\n    }\n\n    if (nextConflictInFirst.length !== nextConflictInIntersection.length) {\n      return false;\n    }\n\n    return nextConflictInFirst.every((d, index) => declarationIsEqual(d, nextConflictInIntersection[index]));\n  }); // Filter out intersections with previous conflicts in Second\n\n  const secondDecls = getDecls(second);\n  intersection = intersection.filter(decl => {\n    const nextConflictIndex = secondDecls.findIndex(d => isConflictingProp(d.prop, decl.prop));\n\n    if (nextConflictIndex === -1) {\n      return false;\n    }\n\n    if (!declarationIsEqual(secondDecls[nextConflictIndex], decl)) {\n      return false;\n    }\n\n    if (decl.prop.toLowerCase() !== 'direction' && decl.prop.toLowerCase() !== 'unicode-bidi' && secondDecls.some(declaration => declaration.prop.toLowerCase() === 'all')) {\n      return false;\n    }\n\n    secondDecls.splice(nextConflictIndex, 1);\n    return true;\n  });\n\n  if (!intersection.length) {\n    // Nothing to merge\n    return second;\n  }\n\n  const receivingBlock = second.clone();\n  receivingBlock.selector = joinSelectors(first, second);\n  receivingBlock.nodes = [];\n  /** @type {import('postcss').Container<import('postcss').ChildNode>} */\n\n  second.parent.insertBefore(second, receivingBlock);\n  const firstClone = first.clone();\n  const secondClone = second.clone();\n  /**\n   * @param {function(import('postcss').Declaration):void} callback\n   * @this {import('postcss').Rule}\n   * @return {function(import('postcss').Declaration)}\n   */\n\n  function moveDecl(callback) {\n    return decl => {\n      if (indexOfDeclaration(intersection, decl) !== -1) {\n        callback.call(this, decl);\n      }\n    };\n  }\n\n  firstClone.walkDecls(moveDecl(decl => {\n    decl.remove();\n    receivingBlock.append(decl);\n  }));\n  secondClone.walkDecls(moveDecl(decl => decl.remove()));\n  const merged = ruleLength(firstClone, receivingBlock, secondClone);\n  const original = ruleLength(first, second);\n\n  if (merged < original) {\n    first.replaceWith(firstClone);\n    second.replaceWith(secondClone);\n    [firstClone, receivingBlock, secondClone].forEach(r => {\n      if (!r.nodes.length) {\n        r.remove();\n      }\n    });\n\n    if (!secondClone.parent) {\n      return receivingBlock;\n    }\n\n    return secondClone;\n  } else {\n    receivingBlock.remove();\n    return second;\n  }\n}\n/**\n * @param {string[]} browsers\n * @param {Map<string, boolean>} compatibilityCache\n * @return {function(import('postcss').Rule)}\n */\n\n\nfunction selectorMerger(browsers, compatibilityCache) {\n  /** @type {import('postcss').Rule | null} */\n  let cache = null;\n  return function (rule) {\n    // Prime the cache with the first rule, or alternately ensure that it is\n    // safe to merge both declarations before continuing\n    if (!cache || !canMerge(rule, cache, browsers, compatibilityCache)) {\n      cache = rule;\n      return;\n    } // Ensure that we don't deduplicate the same rule; this is sometimes\n    // caused by a partial merge\n\n\n    if (cache === rule) {\n      cache = rule;\n      return;\n    } // Parents merge: check if the rules have same parents, but not same parent nodes\n\n\n    mergeParents(cache, rule); // Merge when declarations are exactly equal\n    // e.g. h1 { color: red } h2 { color: red }\n\n    if (sameDeclarationsAndOrder(getDecls(rule), getDecls(cache))) {\n      rule.selector = joinSelectors(cache, rule);\n      cache.remove();\n      cache = rule;\n      return;\n    } // Merge when both selectors are exactly equal\n    // e.g. a { color: blue } a { font-weight: bold }\n\n\n    if (cache.selector === rule.selector) {\n      const cached = getDecls(cache);\n      rule.walk(node => {\n        if (node.type === 'decl' && indexOfDeclaration(cached, node) !== -1) {\n          node.remove();\n          return;\n        }\n        /** @type {import('postcss').Rule} */\n\n\n        cache.append(node);\n      });\n      rule.remove();\n      return;\n    } // Partial merge: check if the rule contains a subset of the last; if\n    // so create a joined selector with the subset, if smaller.\n\n\n    cache = partialMerge(cache, rule);\n  };\n}\n/**\n * @type {import('postcss').PluginCreator<void>}\n * @return {import('postcss').Plugin}\n */\n\n\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-merge-rules',\n\n    prepare(result) {\n      /** @type {typeof result.opts & browserslist.Options} */\n      const resultOpts = result.opts || {};\n      const browsers = browserslist(null, {\n        stats: resultOpts.stats,\n        path: __dirname,\n        env: resultOpts.env\n      });\n      const compatibilityCache = new Map();\n      return {\n        OnceExit(css) {\n          css.walkRules(selectorMerger(browsers, compatibilityCache));\n        }\n\n      };\n    }\n\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;","map":{"version":3,"names":["browserslist","require","sameParent","ensureCompatibility","sameVendor","noVendor","declarationIsEqual","a","b","important","prop","value","indexOfDeclaration","array","decl","findIndex","d","intersect","not","filter","c","index","sameDeclarationsAndOrder","length","every","canMerge","ruleA","ruleB","browsers","compatibilityCache","selectors","concat","parent","type","name","includes","isDeclaration","node","getDecls","rule","nodes","joinSelectors","rules","map","s","selector","join","ruleLength","r","String","splitProp","parts","split","prefix","base","rest","slice","isConflictingProp","propA","propB","mergeParents","first","second","remove","append","partialMerge","intersection","nextRule","next","parentSibling","nextIntersection","firstDecls","intersectIndex","indexOfDecl","nextConflictInFirst","nextConflictInIntersection","secondDecls","nextConflictIndex","toLowerCase","some","declaration","splice","receivingBlock","clone","insertBefore","firstClone","secondClone","moveDecl","callback","call","walkDecls","merged","original","replaceWith","forEach","selectorMerger","cache","cached","walk","pluginCreator","postcssPlugin","prepare","result","resultOpts","opts","stats","path","__dirname","env","Map","OnceExit","css","walkRules","postcss","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-merge-rules/src/index.js"],"sourcesContent":["'use strict';\nconst browserslist = require('browserslist');\nconst { sameParent } = require('cssnano-utils');\nconst {\n  ensureCompatibility,\n  sameVendor,\n  noVendor,\n} = require('./lib/ensureCompatibility');\n\n/**\n * @param {import('postcss').Declaration} a\n * @param {import('postcss').Declaration} b\n * @return {boolean}\n */\nfunction declarationIsEqual(a, b) {\n  return (\n    a.important === b.important && a.prop === b.prop && a.value === b.value\n  );\n}\n\n/**\n * @param {import('postcss').Declaration[]} array\n * @param {import('postcss').Declaration} decl\n * @return {number}\n */\nfunction indexOfDeclaration(array, decl) {\n  return array.findIndex((d) => declarationIsEqual(d, decl));\n}\n\n/**\n * Returns filtered array of matched or unmatched declarations\n * @param {import('postcss').Declaration[]} a\n * @param {import('postcss').Declaration[]} b\n * @param {boolean} [not=false]\n * @return {import('postcss').Declaration[]}\n */\nfunction intersect(a, b, not) {\n  return a.filter((c) => {\n    const index = indexOfDeclaration(b, c) !== -1;\n    return not ? !index : index;\n  });\n}\n\n/**\n * @param {import('postcss').Declaration[]} a\n * @param {import('postcss').Declaration[]} b\n * @return {boolean}\n */\nfunction sameDeclarationsAndOrder(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  return a.every((d, index) => declarationIsEqual(d, b[index]));\n}\n\n/**\n * @param {import('postcss').Rule} ruleA\n * @param {import('postcss').Rule} ruleB\n * @param {string[]=} browsers\n * @param {Map<string, boolean>=} compatibilityCache\n * @return {boolean}\n */\nfunction canMerge(ruleA, ruleB, browsers, compatibilityCache) {\n  const a = ruleA.selectors;\n  const b = ruleB.selectors;\n\n  const selectors = a.concat(b);\n\n  if (!ensureCompatibility(selectors, browsers, compatibilityCache)) {\n    return false;\n  }\n\n  const parent = sameParent(\n    /** @type {any} */ (ruleA),\n    /** @type {any} */ (ruleB)\n  );\n  if (\n    parent &&\n    ruleA.parent &&\n    ruleA.parent.type === 'atrule' &&\n    /** @type {import('postcss').AtRule} */ (ruleA.parent).name.includes(\n      'keyframes'\n    )\n  ) {\n    return false;\n  }\n  return parent && (selectors.every(noVendor) || sameVendor(a, b));\n}\n\n/**\n * @param {import('postcss').ChildNode} node\n * @return {node is import('postcss').Declaration}\n */\nfunction isDeclaration(node) {\n  return node.type === 'decl';\n}\n/**\n * @param {import('postcss').Rule} rule\n * @return {import('postcss').Declaration[]}\n */\nfunction getDecls(rule) {\n  return rule.nodes.filter(isDeclaration);\n}\n\n/** @type {(...rules: import('postcss').Rule[]) => string} */\nconst joinSelectors = (...rules) => rules.map((s) => s.selector).join();\n\n/**\n * @param {...import('postcss').Rule} rules\n * @return {number}\n */\nfunction ruleLength(...rules) {\n  return rules.map((r) => (r.nodes.length ? String(r) : '')).join('').length;\n}\n\n/**\n * @param {string} prop\n * @return {{prefix: string?, base:string?, rest:string[]}}\n */\nfunction splitProp(prop) {\n  // Treat vendor prefixed properties as if they were unprefixed;\n  // moving them when combined with non-prefixed properties can\n  // cause issues. e.g. moving -webkit-background-clip when there\n  // is a background shorthand definition.\n\n  const parts = prop.split('-');\n  if (prop[0] !== '-') {\n    return {\n      prefix: '',\n      base: parts[0],\n      rest: parts.slice(1),\n    };\n  }\n  // Don't split css variables\n  if (prop[1] === '-') {\n    return {\n      prefix: null,\n      base: null,\n      rest: [prop],\n    };\n  }\n  // Found prefix\n  return {\n    prefix: parts[1],\n    base: parts[2],\n    rest: parts.slice(3),\n  };\n}\n\n/**\n * @param {string} propA\n * @param {string} propB\n */\nfunction isConflictingProp(propA, propB) {\n  if (propA === propB) {\n    // Same specificity\n    return true;\n  }\n  const a = splitProp(propA);\n  const b = splitProp(propB);\n  // Don't resort css variables\n  if (!a.base && !b.base) {\n    return true;\n  }\n  // Different base;\n  if (a.base !== b.base) {\n    return false;\n  }\n  // Conflict if rest-count mismatches\n  if (a.rest.length !== b.rest.length) {\n    return true;\n  }\n\n  // Conflict if rest parameters are equal (same but unprefixed)\n  return a.rest.every((s, index) => b.rest[index] === s);\n}\n\n/**\n * @param {import('postcss').Rule} first\n * @param {import('postcss').Rule} second\n * @return {boolean} merged\n */\nfunction mergeParents(first, second) {\n  // Null check for detached rules\n  if (!first.parent || !second.parent) {\n    return false;\n  }\n\n  // Check if parents share node\n  if (first.parent === second.parent) {\n    return false;\n  }\n\n  // sameParent() already called by canMerge()\n\n  second.remove();\n  first.parent.append(second);\n  return true;\n}\n\n/**\n * @param {import('postcss').Rule} first\n * @param {import('postcss').Rule} second\n * @return {import('postcss').Rule} mergedRule\n */\nfunction partialMerge(first, second) {\n  let intersection = intersect(getDecls(first), getDecls(second));\n  if (!intersection.length) {\n    return second;\n  }\n  let nextRule = second.next();\n  if (!nextRule) {\n    // Grab next cousin\n    /** @type {any} */\n    const parentSibling =\n      /** @type {import('postcss').Container<import('postcss').ChildNode>} */ (\n        second.parent\n      ).next();\n    nextRule = parentSibling && parentSibling.nodes && parentSibling.nodes[0];\n  }\n  if (nextRule && nextRule.type === 'rule' && canMerge(second, nextRule)) {\n    let nextIntersection = intersect(getDecls(second), getDecls(nextRule));\n    if (nextIntersection.length > intersection.length) {\n      mergeParents(second, nextRule);\n      first = second;\n      second = nextRule;\n      intersection = nextIntersection;\n    }\n  }\n\n  const firstDecls = getDecls(first);\n\n  // Filter out intersections with later conflicts in First\n  intersection = intersection.filter((decl, intersectIndex) => {\n    const indexOfDecl = indexOfDeclaration(firstDecls, decl);\n    const nextConflictInFirst = firstDecls\n      .slice(indexOfDecl + 1)\n      .filter((d) => isConflictingProp(d.prop, decl.prop));\n    if (!nextConflictInFirst.length) {\n      return true;\n    }\n    const nextConflictInIntersection = intersection\n      .slice(intersectIndex + 1)\n      .filter((d) => isConflictingProp(d.prop, decl.prop));\n    if (!nextConflictInIntersection.length) {\n      return false;\n    }\n    if (nextConflictInFirst.length !== nextConflictInIntersection.length) {\n      return false;\n    }\n    return nextConflictInFirst.every((d, index) =>\n      declarationIsEqual(d, nextConflictInIntersection[index])\n    );\n  });\n\n  // Filter out intersections with previous conflicts in Second\n  const secondDecls = getDecls(second);\n  intersection = intersection.filter((decl) => {\n    const nextConflictIndex = secondDecls.findIndex((d) =>\n      isConflictingProp(d.prop, decl.prop)\n    );\n    if (nextConflictIndex === -1) {\n      return false;\n    }\n    if (!declarationIsEqual(secondDecls[nextConflictIndex], decl)) {\n      return false;\n    }\n    if (\n      decl.prop.toLowerCase() !== 'direction' &&\n      decl.prop.toLowerCase() !== 'unicode-bidi' &&\n      secondDecls.some(\n        (declaration) => declaration.prop.toLowerCase() === 'all'\n      )\n    ) {\n      return false;\n    }\n    secondDecls.splice(nextConflictIndex, 1);\n    return true;\n  });\n\n  if (!intersection.length) {\n    // Nothing to merge\n    return second;\n  }\n\n  const receivingBlock = second.clone();\n  receivingBlock.selector = joinSelectors(first, second);\n  receivingBlock.nodes = [];\n\n  /** @type {import('postcss').Container<import('postcss').ChildNode>} */ (\n    second.parent\n  ).insertBefore(second, receivingBlock);\n\n  const firstClone = first.clone();\n  const secondClone = second.clone();\n\n  /**\n   * @param {function(import('postcss').Declaration):void} callback\n   * @this {import('postcss').Rule}\n   * @return {function(import('postcss').Declaration)}\n   */\n  function moveDecl(callback) {\n    return (decl) => {\n      if (indexOfDeclaration(intersection, decl) !== -1) {\n        callback.call(this, decl);\n      }\n    };\n  }\n  firstClone.walkDecls(\n    moveDecl((decl) => {\n      decl.remove();\n      receivingBlock.append(decl);\n    })\n  );\n  secondClone.walkDecls(moveDecl((decl) => decl.remove()));\n  const merged = ruleLength(firstClone, receivingBlock, secondClone);\n  const original = ruleLength(first, second);\n  if (merged < original) {\n    first.replaceWith(firstClone);\n    second.replaceWith(secondClone);\n    [firstClone, receivingBlock, secondClone].forEach((r) => {\n      if (!r.nodes.length) {\n        r.remove();\n      }\n    });\n    if (!secondClone.parent) {\n      return receivingBlock;\n    }\n    return secondClone;\n  } else {\n    receivingBlock.remove();\n    return second;\n  }\n}\n\n/**\n * @param {string[]} browsers\n * @param {Map<string, boolean>} compatibilityCache\n * @return {function(import('postcss').Rule)}\n */\nfunction selectorMerger(browsers, compatibilityCache) {\n  /** @type {import('postcss').Rule | null} */\n  let cache = null;\n  return function (rule) {\n    // Prime the cache with the first rule, or alternately ensure that it is\n    // safe to merge both declarations before continuing\n    if (!cache || !canMerge(rule, cache, browsers, compatibilityCache)) {\n      cache = rule;\n      return;\n    }\n    // Ensure that we don't deduplicate the same rule; this is sometimes\n    // caused by a partial merge\n    if (cache === rule) {\n      cache = rule;\n      return;\n    }\n\n    // Parents merge: check if the rules have same parents, but not same parent nodes\n    mergeParents(cache, rule);\n\n    // Merge when declarations are exactly equal\n    // e.g. h1 { color: red } h2 { color: red }\n    if (sameDeclarationsAndOrder(getDecls(rule), getDecls(cache))) {\n      rule.selector = joinSelectors(cache, rule);\n      cache.remove();\n      cache = rule;\n      return;\n    }\n    // Merge when both selectors are exactly equal\n    // e.g. a { color: blue } a { font-weight: bold }\n    if (cache.selector === rule.selector) {\n      const cached = getDecls(cache);\n      rule.walk((node) => {\n        if (node.type === 'decl' && indexOfDeclaration(cached, node) !== -1) {\n          node.remove();\n          return;\n        }\n        /** @type {import('postcss').Rule} */ (cache).append(node);\n      });\n      rule.remove();\n      return;\n    }\n    // Partial merge: check if the rule contains a subset of the last; if\n    // so create a joined selector with the subset, if smaller.\n    cache = partialMerge(cache, rule);\n  };\n}\n/**\n * @type {import('postcss').PluginCreator<void>}\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-merge-rules',\n\n    prepare(result) {\n      /** @type {typeof result.opts & browserslist.Options} */\n      const resultOpts = result.opts || {};\n      const browsers = browserslist(null, {\n        stats: resultOpts.stats,\n        path: __dirname,\n        env: resultOpts.env,\n      });\n\n      const compatibilityCache = new Map();\n      return {\n        OnceExit(css) {\n          css.walkRules(selectorMerger(browsers, compatibilityCache));\n        },\n      };\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}