{"ast":null,"code":"// Generated by LiveScript 1.6.0\n(function () {\n  var VERSION,\n      ref$,\n      id,\n      map,\n      compact,\n      any,\n      groupBy,\n      partition,\n      chars,\n      isItNaN,\n      keys,\n      Obj,\n      camelize,\n      deepIs,\n      closestString,\n      nameToRaw,\n      dasherize,\n      naturalJoin,\n      generateHelp,\n      generateHelpForOption,\n      parsedTypeCheck,\n      parseType,\n      parseLevn,\n      camelizeKeys,\n      parseString,\n      main,\n      toString$ = {}.toString,\n      slice$ = [].slice,\n      arrayFrom$ = Array.from || function (x) {\n    return slice$.call(x);\n  };\n\n  VERSION = '0.9.1';\n  ref$ = require('prelude-ls'), id = ref$.id, map = ref$.map, compact = ref$.compact, any = ref$.any, groupBy = ref$.groupBy, partition = ref$.partition, chars = ref$.chars, isItNaN = ref$.isItNaN, keys = ref$.keys, Obj = ref$.Obj, camelize = ref$.camelize;\n  deepIs = require('deep-is');\n  ref$ = require('./util'), closestString = ref$.closestString, nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize, naturalJoin = ref$.naturalJoin;\n  ref$ = require('./help'), generateHelp = ref$.generateHelp, generateHelpForOption = ref$.generateHelpForOption;\n  ref$ = require('type-check'), parsedTypeCheck = ref$.parsedTypeCheck, parseType = ref$.parseType;\n  parseLevn = require('levn').parsedTypeParse;\n\n  camelizeKeys = function (obj) {\n    var key,\n        value,\n        resultObj$ = {};\n\n    for (key in obj) {\n      value = obj[key];\n      resultObj$[camelize(key)] = value;\n    }\n\n    return resultObj$;\n  };\n\n  parseString = function (string) {\n    var assignOpt, regex, replaceRegex, result;\n    assignOpt = '--?[a-zA-Z][-a-z-A-Z0-9]*=';\n    regex = RegExp('(?:' + assignOpt + ')?(?:\\'(?:\\\\\\\\\\'|[^\\'])+\\'|\"(?:\\\\\\\\\"|[^\"])+\")|[^\\'\"\\\\s]+', 'g');\n    replaceRegex = RegExp('^(' + assignOpt + ')?[\\'\"]([\\\\s\\\\S]*)[\\'\"]$');\n    result = map(function (it) {\n      return it.replace(replaceRegex, '$1$2');\n    }, string.match(regex) || []);\n    return result;\n  };\n\n  main = function (libOptions) {\n    var opts, defaults, required, traverse, getOption, parse;\n    opts = {};\n    defaults = {};\n    required = [];\n\n    if (toString$.call(libOptions.stdout).slice(8, -1) === 'Undefined') {\n      libOptions.stdout = process.stdout;\n    }\n\n    libOptions.positionalAnywhere == null && (libOptions.positionalAnywhere = true);\n    libOptions.typeAliases == null && (libOptions.typeAliases = {});\n    libOptions.defaults == null && (libOptions.defaults = {});\n\n    if (libOptions.concatRepeatedArrays != null) {\n      libOptions.defaults.concatRepeatedArrays = libOptions.concatRepeatedArrays;\n    }\n\n    if (libOptions.mergeRepeatedObjects != null) {\n      libOptions.defaults.mergeRepeatedObjects = libOptions.mergeRepeatedObjects;\n    }\n\n    traverse = function (options) {\n      var i$, len$, option, name, k, ref$, v, type, that, e, parsedPossibilities, parsedType, j$, len1$, possibility, rawDependsType, dependsOpts, dependsType, cra, alias, shortNames, longNames;\n\n      if (toString$.call(options).slice(8, -1) !== 'Array') {\n        throw new Error('No options defined.');\n      }\n\n      for (i$ = 0, len$ = options.length; i$ < len$; ++i$) {\n        option = options[i$];\n\n        if (option.heading == null) {\n          name = option.option;\n\n          if (opts[name] != null) {\n            throw new Error(\"Option '\" + name + \"' already defined.\");\n          }\n\n          for (k in ref$ = libOptions.defaults) {\n            v = ref$[k];\n            option[k] == null && (option[k] = v);\n          }\n\n          if (option.type === 'Boolean') {\n            option.boolean == null && (option.boolean = true);\n          }\n\n          if (option.parsedType == null) {\n            if (!option.type) {\n              throw new Error(\"No type defined for option '\" + name + \"'.\");\n            }\n\n            try {\n              type = (that = libOptions.typeAliases[option.type]) != null ? that : option.type;\n              option.parsedType = parseType(type);\n            } catch (e$) {\n              e = e$;\n              throw new Error(\"Option '\" + name + \"': Error parsing type '\" + option.type + \"': \" + e.message);\n            }\n          }\n\n          if (option['default']) {\n            try {\n              defaults[name] = parseLevn(option.parsedType, option['default']);\n            } catch (e$) {\n              e = e$;\n              throw new Error(\"Option '\" + name + \"': Error parsing default value '\" + option['default'] + \"' for type '\" + option.type + \"': \" + e.message);\n            }\n          }\n\n          if (option['enum'] && !option.parsedPossiblities) {\n            parsedPossibilities = [];\n            parsedType = option.parsedType;\n\n            for (j$ = 0, len1$ = (ref$ = option['enum']).length; j$ < len1$; ++j$) {\n              possibility = ref$[j$];\n\n              try {\n                parsedPossibilities.push(parseLevn(parsedType, possibility));\n              } catch (e$) {\n                e = e$;\n                throw new Error(\"Option '\" + name + \"': Error parsing enum value '\" + possibility + \"' for type '\" + option.type + \"': \" + e.message);\n              }\n            }\n\n            option.parsedPossibilities = parsedPossibilities;\n          }\n\n          if (that = option.dependsOn) {\n            if (that.length) {\n              ref$ = [].concat(option.dependsOn), rawDependsType = ref$[0], dependsOpts = slice$.call(ref$, 1);\n              dependsType = rawDependsType.toLowerCase();\n\n              if (dependsOpts.length) {\n                if (dependsType === 'and' || dependsType === 'or') {\n                  option.dependsOn = [dependsType].concat(arrayFrom$(dependsOpts));\n                } else {\n                  throw new Error(\"Option '\" + name + \"': If you have more than one dependency, you must specify either 'and' or 'or'\");\n                }\n              } else {\n                if ((ref$ = dependsType.toLowerCase()) === 'and' || ref$ === 'or') {\n                  option.dependsOn = null;\n                } else {\n                  option.dependsOn = ['and', rawDependsType];\n                }\n              }\n            } else {\n              option.dependsOn = null;\n            }\n          }\n\n          if (option.required) {\n            required.push(name);\n          }\n\n          opts[name] = option;\n\n          if (option.concatRepeatedArrays != null) {\n            cra = option.concatRepeatedArrays;\n\n            if ('Boolean' === toString$.call(cra).slice(8, -1)) {\n              option.concatRepeatedArrays = [cra, {}];\n            } else if (cra.length === 1) {\n              option.concatRepeatedArrays = [cra[0], {}];\n            } else if (cra.length !== 2) {\n              throw new Error(\"Invalid setting for concatRepeatedArrays\");\n            }\n          }\n\n          if (option.alias || option.aliases) {\n            if (name === 'NUM') {\n              throw new Error(\"-NUM option can't have aliases.\");\n            }\n\n            if (option.alias) {\n              option.aliases == null && (option.aliases = [].concat(option.alias));\n            }\n\n            for (j$ = 0, len1$ = (ref$ = option.aliases).length; j$ < len1$; ++j$) {\n              alias = ref$[j$];\n\n              if (opts[alias] != null) {\n                throw new Error(\"Option '\" + alias + \"' already defined.\");\n              }\n\n              opts[alias] = option;\n            }\n\n            ref$ = partition(fn$, option.aliases), shortNames = ref$[0], longNames = ref$[1];\n            option.shortNames == null && (option.shortNames = shortNames);\n            option.longNames == null && (option.longNames = longNames);\n          }\n\n          if ((!option.aliases || option.shortNames.length === 0) && option.type === 'Boolean' && option['default'] === 'true') {\n            option.negateName = true;\n          }\n        }\n      }\n\n      function fn$(it) {\n        return it.length === 1;\n      }\n    };\n\n    traverse(libOptions.options);\n\n    getOption = function (name) {\n      var opt, possiblyMeant;\n      opt = opts[name];\n\n      if (opt == null) {\n        possiblyMeant = closestString(keys(opts), name);\n        throw new Error(\"Invalid option '\" + nameToRaw(name) + \"'\" + (possiblyMeant ? \" - perhaps you meant '\" + nameToRaw(possiblyMeant) + \"'?\" : '.'));\n      }\n\n      return opt;\n    };\n\n    parse = function (input, arg$) {\n      var slice, obj, positional, restPositional, overrideRequired, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError, checkMutuallyExclusive, checkDependency, checkDependencies, checkProp, args, key, value, option, ref$, i$, len$, arg, that, result, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, valPrime, negated, noedName;\n      slice = (arg$ != null ? arg$ : {}).slice;\n      obj = {};\n      positional = [];\n      restPositional = false;\n      overrideRequired = false;\n      prop = null;\n\n      setValue = function (name, value) {\n        var opt, val, cra, e, currentType;\n        opt = getOption(name);\n\n        if (opt.boolean) {\n          val = value;\n        } else {\n          try {\n            cra = opt.concatRepeatedArrays;\n\n            if (cra != null && cra[0] && cra[1].oneValuePerFlag && opt.parsedType.length === 1 && opt.parsedType[0].structure === 'array') {\n              val = [parseLevn(opt.parsedType[0].of, value)];\n            } else {\n              val = parseLevn(opt.parsedType, value);\n            }\n          } catch (e$) {\n            e = e$;\n            throw new Error(\"Invalid value for option '\" + name + \"' - expected type \" + opt.type + \", received value: \" + value + \".\");\n          }\n\n          if (opt['enum'] && !any(function (it) {\n            return deepIs(it, val);\n          }, opt.parsedPossibilities)) {\n            throw new Error(\"Option \" + name + \": '\" + val + \"' not one of \" + naturalJoin(opt['enum']) + \".\");\n          }\n        }\n\n        currentType = toString$.call(obj[name]).slice(8, -1);\n\n        if (obj[name] != null) {\n          if (opt.concatRepeatedArrays != null && opt.concatRepeatedArrays[0] && currentType === 'Array') {\n            obj[name] = obj[name].concat(val);\n          } else if (opt.mergeRepeatedObjects && currentType === 'Object') {\n            import$(obj[name], val);\n          } else {\n            obj[name] = val;\n          }\n        } else {\n          obj[name] = val;\n        }\n\n        if (opt.restPositional) {\n          restPositional = true;\n        }\n\n        if (opt.overrideRequired) {\n          overrideRequired = true;\n        }\n      };\n\n      setDefaults = function () {\n        var name, ref$, value;\n\n        for (name in ref$ = defaults) {\n          value = ref$[name];\n\n          if (obj[name] == null) {\n            obj[name] = value;\n          }\n        }\n      };\n\n      checkRequired = function () {\n        var i$, ref$, len$, name;\n\n        if (overrideRequired) {\n          return;\n        }\n\n        for (i$ = 0, len$ = (ref$ = required).length; i$ < len$; ++i$) {\n          name = ref$[i$];\n\n          if (!obj[name]) {\n            throw new Error(\"Option \" + nameToRaw(name) + \" is required.\");\n          }\n        }\n      };\n\n      mutuallyExclusiveError = function (first, second) {\n        throw new Error(\"The options \" + nameToRaw(first) + \" and \" + nameToRaw(second) + \" are mutually exclusive - you cannot use them at the same time.\");\n      };\n\n      checkMutuallyExclusive = function () {\n        var rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;\n        rules = libOptions.mutuallyExclusive;\n\n        if (!rules) {\n          return;\n        }\n\n        for (i$ = 0, len$ = rules.length; i$ < len$; ++i$) {\n          rule = rules[i$];\n          present = null;\n\n          for (j$ = 0, len1$ = rule.length; j$ < len1$; ++j$) {\n            element = rule[j$];\n\n            if (toString$.call(element).slice(8, -1) === 'Array') {\n              for (k$ = 0, len2$ = element.length; k$ < len2$; ++k$) {\n                opt = element[k$];\n\n                if (opt in obj) {\n                  if (present != null) {\n                    mutuallyExclusiveError(present, opt);\n                  } else {\n                    present = opt;\n                    break;\n                  }\n                }\n              }\n            } else {\n              if (element in obj) {\n                if (present != null) {\n                  mutuallyExclusiveError(present, element);\n                } else {\n                  present = element;\n                }\n              }\n            }\n          }\n        }\n      };\n\n      checkDependency = function (option) {\n        var dependsOn, type, targetOptionNames, i$, len$, targetOptionName, targetOption;\n        dependsOn = option.dependsOn;\n\n        if (!dependsOn || option.dependenciesMet) {\n          return true;\n        }\n\n        type = dependsOn[0], targetOptionNames = slice$.call(dependsOn, 1);\n\n        for (i$ = 0, len$ = targetOptionNames.length; i$ < len$; ++i$) {\n          targetOptionName = targetOptionNames[i$];\n          targetOption = obj[targetOptionName];\n\n          if (targetOption && checkDependency(targetOption)) {\n            if (type === 'or') {\n              return true;\n            }\n          } else if (type === 'and') {\n            throw new Error(\"The option '\" + option.option + \"' did not have its dependencies met.\");\n          }\n        }\n\n        if (type === 'and') {\n          return true;\n        } else {\n          throw new Error(\"The option '\" + option.option + \"' did not meet any of its dependencies.\");\n        }\n      };\n\n      checkDependencies = function () {\n        var name;\n\n        for (name in obj) {\n          checkDependency(opts[name]);\n        }\n      };\n\n      checkProp = function () {\n        if (prop) {\n          throw new Error(\"Value for '\" + prop + \"' of type '\" + getOption(prop).type + \"' required.\");\n        }\n      };\n\n      switch (toString$.call(input).slice(8, -1)) {\n        case 'String':\n          args = parseString(input.slice(slice != null ? slice : 0));\n          break;\n\n        case 'Array':\n          args = input.slice(slice != null ? slice : 2);\n          break;\n\n        case 'Object':\n          obj = {};\n\n          for (key in input) {\n            value = input[key];\n\n            if (key !== '_') {\n              option = getOption(dasherize(key));\n\n              if (parsedTypeCheck(option.parsedType, value)) {\n                obj[option.option] = value;\n              } else {\n                throw new Error(\"Option '\" + option.option + \"': Invalid type for '\" + value + \"' - expected type '\" + option.type + \"'.\");\n              }\n            }\n          }\n\n          checkMutuallyExclusive();\n          checkDependencies();\n          setDefaults();\n          checkRequired();\n          return ref$ = camelizeKeys(obj), ref$._ = input._ || [], ref$;\n\n        default:\n          throw new Error(\"Invalid argument to 'parse': \" + input + \".\");\n      }\n\n      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {\n        arg = args[i$];\n\n        if (arg === '--') {\n          restPositional = true;\n        } else if (restPositional) {\n          positional.push(arg);\n        } else {\n          if (that = arg.match(/^(--?)([a-zA-Z][-a-zA-Z0-9]*)(=)?(.*)?$/)) {\n            result = that;\n            checkProp();\n            short = result[1].length === 1;\n            argName = result[2];\n            usingAssign = result[3] != null;\n            val = result[4];\n\n            if (usingAssign && val == null) {\n              throw new Error(\"No value for '\" + argName + \"' specified.\");\n            }\n\n            if (short) {\n              flags = chars(argName);\n              len = flags.length;\n\n              for (j$ = 0, len1$ = flags.length; j$ < len1$; ++j$) {\n                i = j$;\n                flag = flags[j$];\n                opt = getOption(flag);\n                name = opt.option;\n\n                if (restPositional) {\n                  positional.push(flag);\n                } else if (i === len - 1) {\n                  if (usingAssign) {\n                    valPrime = opt.boolean ? parseLevn([{\n                      type: 'Boolean'\n                    }], val) : val;\n                    setValue(name, valPrime);\n                  } else if (opt.boolean) {\n                    setValue(name, true);\n                  } else {\n                    prop = name;\n                  }\n                } else if (opt.boolean) {\n                  setValue(name, true);\n                } else {\n                  throw new Error(\"Can't set argument '\" + flag + \"' when not last flag in a group of short flags.\");\n                }\n              }\n            } else {\n              negated = false;\n\n              if (that = argName.match(/^no-(.+)$/)) {\n                negated = true;\n                noedName = that[1];\n                opt = getOption(noedName);\n              } else {\n                opt = getOption(argName);\n              }\n\n              name = opt.option;\n\n              if (opt.boolean) {\n                valPrime = usingAssign ? parseLevn([{\n                  type: 'Boolean'\n                }], val) : true;\n\n                if (negated) {\n                  setValue(name, !valPrime);\n                } else {\n                  setValue(name, valPrime);\n                }\n              } else {\n                if (negated) {\n                  throw new Error(\"Only use 'no-' prefix for Boolean options, not with '\" + noedName + \"'.\");\n                }\n\n                if (usingAssign) {\n                  setValue(name, val);\n                } else {\n                  prop = name;\n                }\n              }\n            }\n          } else if (that = arg.match(/^-([0-9]+(?:\\.[0-9]+)?)$/)) {\n            opt = opts.NUM;\n\n            if (!opt) {\n              throw new Error('No -NUM option defined.');\n            }\n\n            setValue(opt.option, that[1]);\n          } else {\n            if (prop) {\n              setValue(prop, arg);\n              prop = null;\n            } else {\n              positional.push(arg);\n\n              if (!libOptions.positionalAnywhere) {\n                restPositional = true;\n              }\n            }\n          }\n        }\n      }\n\n      checkProp();\n      checkMutuallyExclusive();\n      checkDependencies();\n      setDefaults();\n      checkRequired();\n      return ref$ = camelizeKeys(obj), ref$._ = positional, ref$;\n    };\n\n    return {\n      parse: parse,\n      parseArgv: function (it) {\n        return parse(it, {\n          slice: 2\n        });\n      },\n      generateHelp: generateHelp(libOptions),\n      generateHelpForOption: generateHelpForOption(getOption, libOptions)\n    };\n  };\n\n  main.VERSION = VERSION;\n  module.exports = main;\n\n  function import$(obj, src) {\n    var own = {}.hasOwnProperty;\n\n    for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n\n    return obj;\n  }\n}).call(this);","map":{"version":3,"names":["VERSION","ref$","id","map","compact","any","groupBy","partition","chars","isItNaN","keys","Obj","camelize","deepIs","closestString","nameToRaw","dasherize","naturalJoin","generateHelp","generateHelpForOption","parsedTypeCheck","parseType","parseLevn","camelizeKeys","parseString","main","toString$","toString","slice$","slice","arrayFrom$","Array","from","x","call","require","parsedTypeParse","obj","key","value","resultObj$","string","assignOpt","regex","replaceRegex","result","RegExp","it","replace","match","libOptions","opts","defaults","required","traverse","getOption","parse","stdout","process","positionalAnywhere","typeAliases","concatRepeatedArrays","mergeRepeatedObjects","options","i$","len$","option","name","k","v","type","that","e","parsedPossibilities","parsedType","j$","len1$","possibility","rawDependsType","dependsOpts","dependsType","cra","alias","shortNames","longNames","Error","length","heading","boolean","e$","message","parsedPossiblities","push","dependsOn","concat","toLowerCase","aliases","fn$","negateName","opt","possiblyMeant","input","arg$","positional","restPositional","overrideRequired","prop","setValue","setDefaults","checkRequired","mutuallyExclusiveError","checkMutuallyExclusive","checkDependency","checkDependencies","checkProp","args","arg","short","argName","usingAssign","val","flags","len","i","flag","valPrime","negated","noedName","currentType","oneValuePerFlag","structure","of","import$","first","second","rules","rule","present","element","k$","len2$","mutuallyExclusive","targetOptionNames","targetOptionName","targetOption","dependenciesMet","_","NUM","parseArgv","module","exports","src","own","hasOwnProperty"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/optionator/lib/index.js"],"sourcesContent":["// Generated by LiveScript 1.6.0\n(function(){\n  var VERSION, ref$, id, map, compact, any, groupBy, partition, chars, isItNaN, keys, Obj, camelize, deepIs, closestString, nameToRaw, dasherize, naturalJoin, generateHelp, generateHelpForOption, parsedTypeCheck, parseType, parseLevn, camelizeKeys, parseString, main, toString$ = {}.toString, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};\n  VERSION = '0.9.1';\n  ref$ = require('prelude-ls'), id = ref$.id, map = ref$.map, compact = ref$.compact, any = ref$.any, groupBy = ref$.groupBy, partition = ref$.partition, chars = ref$.chars, isItNaN = ref$.isItNaN, keys = ref$.keys, Obj = ref$.Obj, camelize = ref$.camelize;\n  deepIs = require('deep-is');\n  ref$ = require('./util'), closestString = ref$.closestString, nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize, naturalJoin = ref$.naturalJoin;\n  ref$ = require('./help'), generateHelp = ref$.generateHelp, generateHelpForOption = ref$.generateHelpForOption;\n  ref$ = require('type-check'), parsedTypeCheck = ref$.parsedTypeCheck, parseType = ref$.parseType;\n  parseLevn = require('levn').parsedTypeParse;\n  camelizeKeys = function(obj){\n    var key, value, resultObj$ = {};\n    for (key in obj) {\n      value = obj[key];\n      resultObj$[camelize(key)] = value;\n    }\n    return resultObj$;\n  };\n  parseString = function(string){\n    var assignOpt, regex, replaceRegex, result;\n    assignOpt = '--?[a-zA-Z][-a-z-A-Z0-9]*=';\n    regex = RegExp('(?:' + assignOpt + ')?(?:\\'(?:\\\\\\\\\\'|[^\\'])+\\'|\"(?:\\\\\\\\\"|[^\"])+\")|[^\\'\"\\\\s]+', 'g');\n    replaceRegex = RegExp('^(' + assignOpt + ')?[\\'\"]([\\\\s\\\\S]*)[\\'\"]$');\n    result = map(function(it){\n      return it.replace(replaceRegex, '$1$2');\n    }, string.match(regex) || []);\n    return result;\n  };\n  main = function(libOptions){\n    var opts, defaults, required, traverse, getOption, parse;\n    opts = {};\n    defaults = {};\n    required = [];\n    if (toString$.call(libOptions.stdout).slice(8, -1) === 'Undefined') {\n      libOptions.stdout = process.stdout;\n    }\n    libOptions.positionalAnywhere == null && (libOptions.positionalAnywhere = true);\n    libOptions.typeAliases == null && (libOptions.typeAliases = {});\n    libOptions.defaults == null && (libOptions.defaults = {});\n    if (libOptions.concatRepeatedArrays != null) {\n      libOptions.defaults.concatRepeatedArrays = libOptions.concatRepeatedArrays;\n    }\n    if (libOptions.mergeRepeatedObjects != null) {\n      libOptions.defaults.mergeRepeatedObjects = libOptions.mergeRepeatedObjects;\n    }\n    traverse = function(options){\n      var i$, len$, option, name, k, ref$, v, type, that, e, parsedPossibilities, parsedType, j$, len1$, possibility, rawDependsType, dependsOpts, dependsType, cra, alias, shortNames, longNames;\n      if (toString$.call(options).slice(8, -1) !== 'Array') {\n        throw new Error('No options defined.');\n      }\n      for (i$ = 0, len$ = options.length; i$ < len$; ++i$) {\n        option = options[i$];\n        if (option.heading == null) {\n          name = option.option;\n          if (opts[name] != null) {\n            throw new Error(\"Option '\" + name + \"' already defined.\");\n          }\n          for (k in ref$ = libOptions.defaults) {\n            v = ref$[k];\n            option[k] == null && (option[k] = v);\n          }\n          if (option.type === 'Boolean') {\n            option.boolean == null && (option.boolean = true);\n          }\n          if (option.parsedType == null) {\n            if (!option.type) {\n              throw new Error(\"No type defined for option '\" + name + \"'.\");\n            }\n            try {\n              type = (that = libOptions.typeAliases[option.type]) != null\n                ? that\n                : option.type;\n              option.parsedType = parseType(type);\n            } catch (e$) {\n              e = e$;\n              throw new Error(\"Option '\" + name + \"': Error parsing type '\" + option.type + \"': \" + e.message);\n            }\n          }\n          if (option['default']) {\n            try {\n              defaults[name] = parseLevn(option.parsedType, option['default']);\n            } catch (e$) {\n              e = e$;\n              throw new Error(\"Option '\" + name + \"': Error parsing default value '\" + option['default'] + \"' for type '\" + option.type + \"': \" + e.message);\n            }\n          }\n          if (option['enum'] && !option.parsedPossiblities) {\n            parsedPossibilities = [];\n            parsedType = option.parsedType;\n            for (j$ = 0, len1$ = (ref$ = option['enum']).length; j$ < len1$; ++j$) {\n              possibility = ref$[j$];\n              try {\n                parsedPossibilities.push(parseLevn(parsedType, possibility));\n              } catch (e$) {\n                e = e$;\n                throw new Error(\"Option '\" + name + \"': Error parsing enum value '\" + possibility + \"' for type '\" + option.type + \"': \" + e.message);\n              }\n            }\n            option.parsedPossibilities = parsedPossibilities;\n          }\n          if (that = option.dependsOn) {\n            if (that.length) {\n              ref$ = [].concat(option.dependsOn), rawDependsType = ref$[0], dependsOpts = slice$.call(ref$, 1);\n              dependsType = rawDependsType.toLowerCase();\n              if (dependsOpts.length) {\n                if (dependsType === 'and' || dependsType === 'or') {\n                  option.dependsOn = [dependsType].concat(arrayFrom$(dependsOpts));\n                } else {\n                  throw new Error(\"Option '\" + name + \"': If you have more than one dependency, you must specify either 'and' or 'or'\");\n                }\n              } else {\n                if ((ref$ = dependsType.toLowerCase()) === 'and' || ref$ === 'or') {\n                  option.dependsOn = null;\n                } else {\n                  option.dependsOn = ['and', rawDependsType];\n                }\n              }\n            } else {\n              option.dependsOn = null;\n            }\n          }\n          if (option.required) {\n            required.push(name);\n          }\n          opts[name] = option;\n          if (option.concatRepeatedArrays != null) {\n            cra = option.concatRepeatedArrays;\n            if ('Boolean' === toString$.call(cra).slice(8, -1)) {\n              option.concatRepeatedArrays = [cra, {}];\n            } else if (cra.length === 1) {\n              option.concatRepeatedArrays = [cra[0], {}];\n            } else if (cra.length !== 2) {\n              throw new Error(\"Invalid setting for concatRepeatedArrays\");\n            }\n          }\n          if (option.alias || option.aliases) {\n            if (name === 'NUM') {\n              throw new Error(\"-NUM option can't have aliases.\");\n            }\n            if (option.alias) {\n              option.aliases == null && (option.aliases = [].concat(option.alias));\n            }\n            for (j$ = 0, len1$ = (ref$ = option.aliases).length; j$ < len1$; ++j$) {\n              alias = ref$[j$];\n              if (opts[alias] != null) {\n                throw new Error(\"Option '\" + alias + \"' already defined.\");\n              }\n              opts[alias] = option;\n            }\n            ref$ = partition(fn$, option.aliases), shortNames = ref$[0], longNames = ref$[1];\n            option.shortNames == null && (option.shortNames = shortNames);\n            option.longNames == null && (option.longNames = longNames);\n          }\n          if ((!option.aliases || option.shortNames.length === 0) && option.type === 'Boolean' && option['default'] === 'true') {\n            option.negateName = true;\n          }\n        }\n      }\n      function fn$(it){\n        return it.length === 1;\n      }\n    };\n    traverse(libOptions.options);\n    getOption = function(name){\n      var opt, possiblyMeant;\n      opt = opts[name];\n      if (opt == null) {\n        possiblyMeant = closestString(keys(opts), name);\n        throw new Error(\"Invalid option '\" + nameToRaw(name) + \"'\" + (possiblyMeant ? \" - perhaps you meant '\" + nameToRaw(possiblyMeant) + \"'?\" : '.'));\n      }\n      return opt;\n    };\n    parse = function(input, arg$){\n      var slice, obj, positional, restPositional, overrideRequired, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError, checkMutuallyExclusive, checkDependency, checkDependencies, checkProp, args, key, value, option, ref$, i$, len$, arg, that, result, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, valPrime, negated, noedName;\n      slice = (arg$ != null\n        ? arg$\n        : {}).slice;\n      obj = {};\n      positional = [];\n      restPositional = false;\n      overrideRequired = false;\n      prop = null;\n      setValue = function(name, value){\n        var opt, val, cra, e, currentType;\n        opt = getOption(name);\n        if (opt.boolean) {\n          val = value;\n        } else {\n          try {\n            cra = opt.concatRepeatedArrays;\n            if (cra != null && cra[0] && cra[1].oneValuePerFlag && opt.parsedType.length === 1 && opt.parsedType[0].structure === 'array') {\n              val = [parseLevn(opt.parsedType[0].of, value)];\n            } else {\n              val = parseLevn(opt.parsedType, value);\n            }\n          } catch (e$) {\n            e = e$;\n            throw new Error(\"Invalid value for option '\" + name + \"' - expected type \" + opt.type + \", received value: \" + value + \".\");\n          }\n          if (opt['enum'] && !any(function(it){\n            return deepIs(it, val);\n          }, opt.parsedPossibilities)) {\n            throw new Error(\"Option \" + name + \": '\" + val + \"' not one of \" + naturalJoin(opt['enum']) + \".\");\n          }\n        }\n        currentType = toString$.call(obj[name]).slice(8, -1);\n        if (obj[name] != null) {\n          if (opt.concatRepeatedArrays != null && opt.concatRepeatedArrays[0] && currentType === 'Array') {\n            obj[name] = obj[name].concat(val);\n          } else if (opt.mergeRepeatedObjects && currentType === 'Object') {\n            import$(obj[name], val);\n          } else {\n            obj[name] = val;\n          }\n        } else {\n          obj[name] = val;\n        }\n        if (opt.restPositional) {\n          restPositional = true;\n        }\n        if (opt.overrideRequired) {\n          overrideRequired = true;\n        }\n      };\n      setDefaults = function(){\n        var name, ref$, value;\n        for (name in ref$ = defaults) {\n          value = ref$[name];\n          if (obj[name] == null) {\n            obj[name] = value;\n          }\n        }\n      };\n      checkRequired = function(){\n        var i$, ref$, len$, name;\n        if (overrideRequired) {\n          return;\n        }\n        for (i$ = 0, len$ = (ref$ = required).length; i$ < len$; ++i$) {\n          name = ref$[i$];\n          if (!obj[name]) {\n            throw new Error(\"Option \" + nameToRaw(name) + \" is required.\");\n          }\n        }\n      };\n      mutuallyExclusiveError = function(first, second){\n        throw new Error(\"The options \" + nameToRaw(first) + \" and \" + nameToRaw(second) + \" are mutually exclusive - you cannot use them at the same time.\");\n      };\n      checkMutuallyExclusive = function(){\n        var rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;\n        rules = libOptions.mutuallyExclusive;\n        if (!rules) {\n          return;\n        }\n        for (i$ = 0, len$ = rules.length; i$ < len$; ++i$) {\n          rule = rules[i$];\n          present = null;\n          for (j$ = 0, len1$ = rule.length; j$ < len1$; ++j$) {\n            element = rule[j$];\n            if (toString$.call(element).slice(8, -1) === 'Array') {\n              for (k$ = 0, len2$ = element.length; k$ < len2$; ++k$) {\n                opt = element[k$];\n                if (opt in obj) {\n                  if (present != null) {\n                    mutuallyExclusiveError(present, opt);\n                  } else {\n                    present = opt;\n                    break;\n                  }\n                }\n              }\n            } else {\n              if (element in obj) {\n                if (present != null) {\n                  mutuallyExclusiveError(present, element);\n                } else {\n                  present = element;\n                }\n              }\n            }\n          }\n        }\n      };\n      checkDependency = function(option){\n        var dependsOn, type, targetOptionNames, i$, len$, targetOptionName, targetOption;\n        dependsOn = option.dependsOn;\n        if (!dependsOn || option.dependenciesMet) {\n          return true;\n        }\n        type = dependsOn[0], targetOptionNames = slice$.call(dependsOn, 1);\n        for (i$ = 0, len$ = targetOptionNames.length; i$ < len$; ++i$) {\n          targetOptionName = targetOptionNames[i$];\n          targetOption = obj[targetOptionName];\n          if (targetOption && checkDependency(targetOption)) {\n            if (type === 'or') {\n              return true;\n            }\n          } else if (type === 'and') {\n            throw new Error(\"The option '\" + option.option + \"' did not have its dependencies met.\");\n          }\n        }\n        if (type === 'and') {\n          return true;\n        } else {\n          throw new Error(\"The option '\" + option.option + \"' did not meet any of its dependencies.\");\n        }\n      };\n      checkDependencies = function(){\n        var name;\n        for (name in obj) {\n          checkDependency(opts[name]);\n        }\n      };\n      checkProp = function(){\n        if (prop) {\n          throw new Error(\"Value for '\" + prop + \"' of type '\" + getOption(prop).type + \"' required.\");\n        }\n      };\n      switch (toString$.call(input).slice(8, -1)) {\n      case 'String':\n        args = parseString(input.slice(slice != null ? slice : 0));\n        break;\n      case 'Array':\n        args = input.slice(slice != null ? slice : 2);\n        break;\n      case 'Object':\n        obj = {};\n        for (key in input) {\n          value = input[key];\n          if (key !== '_') {\n            option = getOption(dasherize(key));\n            if (parsedTypeCheck(option.parsedType, value)) {\n              obj[option.option] = value;\n            } else {\n              throw new Error(\"Option '\" + option.option + \"': Invalid type for '\" + value + \"' - expected type '\" + option.type + \"'.\");\n            }\n          }\n        }\n        checkMutuallyExclusive();\n        checkDependencies();\n        setDefaults();\n        checkRequired();\n        return ref$ = camelizeKeys(obj), ref$._ = input._ || [], ref$;\n      default:\n        throw new Error(\"Invalid argument to 'parse': \" + input + \".\");\n      }\n      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {\n        arg = args[i$];\n        if (arg === '--') {\n          restPositional = true;\n        } else if (restPositional) {\n          positional.push(arg);\n        } else {\n          if (that = arg.match(/^(--?)([a-zA-Z][-a-zA-Z0-9]*)(=)?(.*)?$/)) {\n            result = that;\n            checkProp();\n            short = result[1].length === 1;\n            argName = result[2];\n            usingAssign = result[3] != null;\n            val = result[4];\n            if (usingAssign && val == null) {\n              throw new Error(\"No value for '\" + argName + \"' specified.\");\n            }\n            if (short) {\n              flags = chars(argName);\n              len = flags.length;\n              for (j$ = 0, len1$ = flags.length; j$ < len1$; ++j$) {\n                i = j$;\n                flag = flags[j$];\n                opt = getOption(flag);\n                name = opt.option;\n                if (restPositional) {\n                  positional.push(flag);\n                } else if (i === len - 1) {\n                  if (usingAssign) {\n                    valPrime = opt.boolean ? parseLevn([{\n                      type: 'Boolean'\n                    }], val) : val;\n                    setValue(name, valPrime);\n                  } else if (opt.boolean) {\n                    setValue(name, true);\n                  } else {\n                    prop = name;\n                  }\n                } else if (opt.boolean) {\n                  setValue(name, true);\n                } else {\n                  throw new Error(\"Can't set argument '\" + flag + \"' when not last flag in a group of short flags.\");\n                }\n              }\n            } else {\n              negated = false;\n              if (that = argName.match(/^no-(.+)$/)) {\n                negated = true;\n                noedName = that[1];\n                opt = getOption(noedName);\n              } else {\n                opt = getOption(argName);\n              }\n              name = opt.option;\n              if (opt.boolean) {\n                valPrime = usingAssign ? parseLevn([{\n                  type: 'Boolean'\n                }], val) : true;\n                if (negated) {\n                  setValue(name, !valPrime);\n                } else {\n                  setValue(name, valPrime);\n                }\n              } else {\n                if (negated) {\n                  throw new Error(\"Only use 'no-' prefix for Boolean options, not with '\" + noedName + \"'.\");\n                }\n                if (usingAssign) {\n                  setValue(name, val);\n                } else {\n                  prop = name;\n                }\n              }\n            }\n          } else if (that = arg.match(/^-([0-9]+(?:\\.[0-9]+)?)$/)) {\n            opt = opts.NUM;\n            if (!opt) {\n              throw new Error('No -NUM option defined.');\n            }\n            setValue(opt.option, that[1]);\n          } else {\n            if (prop) {\n              setValue(prop, arg);\n              prop = null;\n            } else {\n              positional.push(arg);\n              if (!libOptions.positionalAnywhere) {\n                restPositional = true;\n              }\n            }\n          }\n        }\n      }\n      checkProp();\n      checkMutuallyExclusive();\n      checkDependencies();\n      setDefaults();\n      checkRequired();\n      return ref$ = camelizeKeys(obj), ref$._ = positional, ref$;\n    };\n    return {\n      parse: parse,\n      parseArgv: function(it){\n        return parse(it, {\n          slice: 2\n        });\n      },\n      generateHelp: generateHelp(libOptions),\n      generateHelpForOption: generateHelpForOption(getOption, libOptions)\n    };\n  };\n  main.VERSION = VERSION;\n  module.exports = main;\n  function import$(obj, src){\n    var own = {}.hasOwnProperty;\n    for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n    return obj;\n  }\n}).call(this);\n"],"mappings":"AAAA;AACA,CAAC,YAAU;EACT,IAAIA,OAAJ;EAAA,IAAaC,IAAb;EAAA,IAAmBC,EAAnB;EAAA,IAAuBC,GAAvB;EAAA,IAA4BC,OAA5B;EAAA,IAAqCC,GAArC;EAAA,IAA0CC,OAA1C;EAAA,IAAmDC,SAAnD;EAAA,IAA8DC,KAA9D;EAAA,IAAqEC,OAArE;EAAA,IAA8EC,IAA9E;EAAA,IAAoFC,GAApF;EAAA,IAAyFC,QAAzF;EAAA,IAAmGC,MAAnG;EAAA,IAA2GC,aAA3G;EAAA,IAA0HC,SAA1H;EAAA,IAAqIC,SAArI;EAAA,IAAgJC,WAAhJ;EAAA,IAA6JC,YAA7J;EAAA,IAA2KC,qBAA3K;EAAA,IAAkMC,eAAlM;EAAA,IAAmNC,SAAnN;EAAA,IAA8NC,SAA9N;EAAA,IAAyOC,YAAzO;EAAA,IAAuPC,WAAvP;EAAA,IAAoQC,IAApQ;EAAA,IAA0QC,SAAS,GAAG,GAAGC,QAAzR;EAAA,IAAmSC,MAAM,GAAG,GAAGC,KAA/S;EAAA,IAAsTC,UAAU,GAAGC,KAAK,CAACC,IAAN,IAAc,UAASC,CAAT,EAAW;IAAC,OAAOL,MAAM,CAACM,IAAP,CAAYD,CAAZ,CAAP;EAAuB,CAApX;;EACAjC,OAAO,GAAG,OAAV;EACAC,IAAI,GAAGkC,OAAO,CAAC,YAAD,CAAd,EAA8BjC,EAAE,GAAGD,IAAI,CAACC,EAAxC,EAA4CC,GAAG,GAAGF,IAAI,CAACE,GAAvD,EAA4DC,OAAO,GAAGH,IAAI,CAACG,OAA3E,EAAoFC,GAAG,GAAGJ,IAAI,CAACI,GAA/F,EAAoGC,OAAO,GAAGL,IAAI,CAACK,OAAnH,EAA4HC,SAAS,GAAGN,IAAI,CAACM,SAA7I,EAAwJC,KAAK,GAAGP,IAAI,CAACO,KAArK,EAA4KC,OAAO,GAAGR,IAAI,CAACQ,OAA3L,EAAoMC,IAAI,GAAGT,IAAI,CAACS,IAAhN,EAAsNC,GAAG,GAAGV,IAAI,CAACU,GAAjO,EAAsOC,QAAQ,GAAGX,IAAI,CAACW,QAAtP;EACAC,MAAM,GAAGsB,OAAO,CAAC,SAAD,CAAhB;EACAlC,IAAI,GAAGkC,OAAO,CAAC,QAAD,CAAd,EAA0BrB,aAAa,GAAGb,IAAI,CAACa,aAA/C,EAA8DC,SAAS,GAAGd,IAAI,CAACc,SAA/E,EAA0FC,SAAS,GAAGf,IAAI,CAACe,SAA3G,EAAsHC,WAAW,GAAGhB,IAAI,CAACgB,WAAzI;EACAhB,IAAI,GAAGkC,OAAO,CAAC,QAAD,CAAd,EAA0BjB,YAAY,GAAGjB,IAAI,CAACiB,YAA9C,EAA4DC,qBAAqB,GAAGlB,IAAI,CAACkB,qBAAzF;EACAlB,IAAI,GAAGkC,OAAO,CAAC,YAAD,CAAd,EAA8Bf,eAAe,GAAGnB,IAAI,CAACmB,eAArD,EAAsEC,SAAS,GAAGpB,IAAI,CAACoB,SAAvF;EACAC,SAAS,GAAGa,OAAO,CAAC,MAAD,CAAP,CAAgBC,eAA5B;;EACAb,YAAY,GAAG,UAASc,GAAT,EAAa;IAC1B,IAAIC,GAAJ;IAAA,IAASC,KAAT;IAAA,IAAgBC,UAAU,GAAG,EAA7B;;IACA,KAAKF,GAAL,IAAYD,GAAZ,EAAiB;MACfE,KAAK,GAAGF,GAAG,CAACC,GAAD,CAAX;MACAE,UAAU,CAAC5B,QAAQ,CAAC0B,GAAD,CAAT,CAAV,GAA4BC,KAA5B;IACD;;IACD,OAAOC,UAAP;EACD,CAPD;;EAQAhB,WAAW,GAAG,UAASiB,MAAT,EAAgB;IAC5B,IAAIC,SAAJ,EAAeC,KAAf,EAAsBC,YAAtB,EAAoCC,MAApC;IACAH,SAAS,GAAG,4BAAZ;IACAC,KAAK,GAAGG,MAAM,CAAC,QAAQJ,SAAR,GAAoB,0DAArB,EAAiF,GAAjF,CAAd;IACAE,YAAY,GAAGE,MAAM,CAAC,OAAOJ,SAAP,GAAmB,0BAApB,CAArB;IACAG,MAAM,GAAG1C,GAAG,CAAC,UAAS4C,EAAT,EAAY;MACvB,OAAOA,EAAE,CAACC,OAAH,CAAWJ,YAAX,EAAyB,MAAzB,CAAP;IACD,CAFW,EAETH,MAAM,CAACQ,KAAP,CAAaN,KAAb,KAAuB,EAFd,CAAZ;IAGA,OAAOE,MAAP;EACD,CATD;;EAUApB,IAAI,GAAG,UAASyB,UAAT,EAAoB;IACzB,IAAIC,IAAJ,EAAUC,QAAV,EAAoBC,QAApB,EAA8BC,QAA9B,EAAwCC,SAAxC,EAAmDC,KAAnD;IACAL,IAAI,GAAG,EAAP;IACAC,QAAQ,GAAG,EAAX;IACAC,QAAQ,GAAG,EAAX;;IACA,IAAI3B,SAAS,CAACQ,IAAV,CAAegB,UAAU,CAACO,MAA1B,EAAkC5B,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,MAAmD,WAAvD,EAAoE;MAClEqB,UAAU,CAACO,MAAX,GAAoBC,OAAO,CAACD,MAA5B;IACD;;IACDP,UAAU,CAACS,kBAAX,IAAiC,IAAjC,KAA0CT,UAAU,CAACS,kBAAX,GAAgC,IAA1E;IACAT,UAAU,CAACU,WAAX,IAA0B,IAA1B,KAAmCV,UAAU,CAACU,WAAX,GAAyB,EAA5D;IACAV,UAAU,CAACE,QAAX,IAAuB,IAAvB,KAAgCF,UAAU,CAACE,QAAX,GAAsB,EAAtD;;IACA,IAAIF,UAAU,CAACW,oBAAX,IAAmC,IAAvC,EAA6C;MAC3CX,UAAU,CAACE,QAAX,CAAoBS,oBAApB,GAA2CX,UAAU,CAACW,oBAAtD;IACD;;IACD,IAAIX,UAAU,CAACY,oBAAX,IAAmC,IAAvC,EAA6C;MAC3CZ,UAAU,CAACE,QAAX,CAAoBU,oBAApB,GAA2CZ,UAAU,CAACY,oBAAtD;IACD;;IACDR,QAAQ,GAAG,UAASS,OAAT,EAAiB;MAC1B,IAAIC,EAAJ,EAAQC,IAAR,EAAcC,MAAd,EAAsBC,IAAtB,EAA4BC,CAA5B,EAA+BnE,IAA/B,EAAqCoE,CAArC,EAAwCC,IAAxC,EAA8CC,IAA9C,EAAoDC,CAApD,EAAuDC,mBAAvD,EAA4EC,UAA5E,EAAwFC,EAAxF,EAA4FC,KAA5F,EAAmGC,WAAnG,EAAgHC,cAAhH,EAAgIC,WAAhI,EAA6IC,WAA7I,EAA0JC,GAA1J,EAA+JC,KAA/J,EAAsKC,UAAtK,EAAkLC,SAAlL;;MACA,IAAI1D,SAAS,CAACQ,IAAV,CAAe6B,OAAf,EAAwBlC,KAAxB,CAA8B,CAA9B,EAAiC,CAAC,CAAlC,MAAyC,OAA7C,EAAsD;QACpD,MAAM,IAAIwD,KAAJ,CAAU,qBAAV,CAAN;MACD;;MACD,KAAKrB,EAAE,GAAG,CAAL,EAAQC,IAAI,GAAGF,OAAO,CAACuB,MAA5B,EAAoCtB,EAAE,GAAGC,IAAzC,EAA+C,EAAED,EAAjD,EAAqD;QACnDE,MAAM,GAAGH,OAAO,CAACC,EAAD,CAAhB;;QACA,IAAIE,MAAM,CAACqB,OAAP,IAAkB,IAAtB,EAA4B;UAC1BpB,IAAI,GAAGD,MAAM,CAACA,MAAd;;UACA,IAAIf,IAAI,CAACgB,IAAD,CAAJ,IAAc,IAAlB,EAAwB;YACtB,MAAM,IAAIkB,KAAJ,CAAU,aAAalB,IAAb,GAAoB,oBAA9B,CAAN;UACD;;UACD,KAAKC,CAAL,IAAUnE,IAAI,GAAGiD,UAAU,CAACE,QAA5B,EAAsC;YACpCiB,CAAC,GAAGpE,IAAI,CAACmE,CAAD,CAAR;YACAF,MAAM,CAACE,CAAD,CAAN,IAAa,IAAb,KAAsBF,MAAM,CAACE,CAAD,CAAN,GAAYC,CAAlC;UACD;;UACD,IAAIH,MAAM,CAACI,IAAP,KAAgB,SAApB,EAA+B;YAC7BJ,MAAM,CAACsB,OAAP,IAAkB,IAAlB,KAA2BtB,MAAM,CAACsB,OAAP,GAAiB,IAA5C;UACD;;UACD,IAAItB,MAAM,CAACQ,UAAP,IAAqB,IAAzB,EAA+B;YAC7B,IAAI,CAACR,MAAM,CAACI,IAAZ,EAAkB;cAChB,MAAM,IAAIe,KAAJ,CAAU,iCAAiClB,IAAjC,GAAwC,IAAlD,CAAN;YACD;;YACD,IAAI;cACFG,IAAI,GAAG,CAACC,IAAI,GAAGrB,UAAU,CAACU,WAAX,CAAuBM,MAAM,CAACI,IAA9B,CAAR,KAAgD,IAAhD,GACHC,IADG,GAEHL,MAAM,CAACI,IAFX;cAGAJ,MAAM,CAACQ,UAAP,GAAoBrD,SAAS,CAACiD,IAAD,CAA7B;YACD,CALD,CAKE,OAAOmB,EAAP,EAAW;cACXjB,CAAC,GAAGiB,EAAJ;cACA,MAAM,IAAIJ,KAAJ,CAAU,aAAalB,IAAb,GAAoB,yBAApB,GAAgDD,MAAM,CAACI,IAAvD,GAA8D,KAA9D,GAAsEE,CAAC,CAACkB,OAAlF,CAAN;YACD;UACF;;UACD,IAAIxB,MAAM,CAAC,SAAD,CAAV,EAAuB;YACrB,IAAI;cACFd,QAAQ,CAACe,IAAD,CAAR,GAAiB7C,SAAS,CAAC4C,MAAM,CAACQ,UAAR,EAAoBR,MAAM,CAAC,SAAD,CAA1B,CAA1B;YACD,CAFD,CAEE,OAAOuB,EAAP,EAAW;cACXjB,CAAC,GAAGiB,EAAJ;cACA,MAAM,IAAIJ,KAAJ,CAAU,aAAalB,IAAb,GAAoB,kCAApB,GAAyDD,MAAM,CAAC,SAAD,CAA/D,GAA6E,cAA7E,GAA8FA,MAAM,CAACI,IAArG,GAA4G,KAA5G,GAAoHE,CAAC,CAACkB,OAAhI,CAAN;YACD;UACF;;UACD,IAAIxB,MAAM,CAAC,MAAD,CAAN,IAAkB,CAACA,MAAM,CAACyB,kBAA9B,EAAkD;YAChDlB,mBAAmB,GAAG,EAAtB;YACAC,UAAU,GAAGR,MAAM,CAACQ,UAApB;;YACA,KAAKC,EAAE,GAAG,CAAL,EAAQC,KAAK,GAAG,CAAC3E,IAAI,GAAGiE,MAAM,CAAC,MAAD,CAAd,EAAwBoB,MAA7C,EAAqDX,EAAE,GAAGC,KAA1D,EAAiE,EAAED,EAAnE,EAAuE;cACrEE,WAAW,GAAG5E,IAAI,CAAC0E,EAAD,CAAlB;;cACA,IAAI;gBACFF,mBAAmB,CAACmB,IAApB,CAAyBtE,SAAS,CAACoD,UAAD,EAAaG,WAAb,CAAlC;cACD,CAFD,CAEE,OAAOY,EAAP,EAAW;gBACXjB,CAAC,GAAGiB,EAAJ;gBACA,MAAM,IAAIJ,KAAJ,CAAU,aAAalB,IAAb,GAAoB,+BAApB,GAAsDU,WAAtD,GAAoE,cAApE,GAAqFX,MAAM,CAACI,IAA5F,GAAmG,KAAnG,GAA2GE,CAAC,CAACkB,OAAvH,CAAN;cACD;YACF;;YACDxB,MAAM,CAACO,mBAAP,GAA6BA,mBAA7B;UACD;;UACD,IAAIF,IAAI,GAAGL,MAAM,CAAC2B,SAAlB,EAA6B;YAC3B,IAAItB,IAAI,CAACe,MAAT,EAAiB;cACfrF,IAAI,GAAG,GAAG6F,MAAH,CAAU5B,MAAM,CAAC2B,SAAjB,CAAP,EAAoCf,cAAc,GAAG7E,IAAI,CAAC,CAAD,CAAzD,EAA8D8E,WAAW,GAAGnD,MAAM,CAACM,IAAP,CAAYjC,IAAZ,EAAkB,CAAlB,CAA5E;cACA+E,WAAW,GAAGF,cAAc,CAACiB,WAAf,EAAd;;cACA,IAAIhB,WAAW,CAACO,MAAhB,EAAwB;gBACtB,IAAIN,WAAW,KAAK,KAAhB,IAAyBA,WAAW,KAAK,IAA7C,EAAmD;kBACjDd,MAAM,CAAC2B,SAAP,GAAmB,CAACb,WAAD,EAAcc,MAAd,CAAqBhE,UAAU,CAACiD,WAAD,CAA/B,CAAnB;gBACD,CAFD,MAEO;kBACL,MAAM,IAAIM,KAAJ,CAAU,aAAalB,IAAb,GAAoB,gFAA9B,CAAN;gBACD;cACF,CAND,MAMO;gBACL,IAAI,CAAClE,IAAI,GAAG+E,WAAW,CAACe,WAAZ,EAAR,MAAuC,KAAvC,IAAgD9F,IAAI,KAAK,IAA7D,EAAmE;kBACjEiE,MAAM,CAAC2B,SAAP,GAAmB,IAAnB;gBACD,CAFD,MAEO;kBACL3B,MAAM,CAAC2B,SAAP,GAAmB,CAAC,KAAD,EAAQf,cAAR,CAAnB;gBACD;cACF;YACF,CAhBD,MAgBO;cACLZ,MAAM,CAAC2B,SAAP,GAAmB,IAAnB;YACD;UACF;;UACD,IAAI3B,MAAM,CAACb,QAAX,EAAqB;YACnBA,QAAQ,CAACuC,IAAT,CAAczB,IAAd;UACD;;UACDhB,IAAI,CAACgB,IAAD,CAAJ,GAAaD,MAAb;;UACA,IAAIA,MAAM,CAACL,oBAAP,IAA+B,IAAnC,EAAyC;YACvCoB,GAAG,GAAGf,MAAM,CAACL,oBAAb;;YACA,IAAI,cAAcnC,SAAS,CAACQ,IAAV,CAAe+C,GAAf,EAAoBpD,KAApB,CAA0B,CAA1B,EAA6B,CAAC,CAA9B,CAAlB,EAAoD;cAClDqC,MAAM,CAACL,oBAAP,GAA8B,CAACoB,GAAD,EAAM,EAAN,CAA9B;YACD,CAFD,MAEO,IAAIA,GAAG,CAACK,MAAJ,KAAe,CAAnB,EAAsB;cAC3BpB,MAAM,CAACL,oBAAP,GAA8B,CAACoB,GAAG,CAAC,CAAD,CAAJ,EAAS,EAAT,CAA9B;YACD,CAFM,MAEA,IAAIA,GAAG,CAACK,MAAJ,KAAe,CAAnB,EAAsB;cAC3B,MAAM,IAAID,KAAJ,CAAU,0CAAV,CAAN;YACD;UACF;;UACD,IAAInB,MAAM,CAACgB,KAAP,IAAgBhB,MAAM,CAAC8B,OAA3B,EAAoC;YAClC,IAAI7B,IAAI,KAAK,KAAb,EAAoB;cAClB,MAAM,IAAIkB,KAAJ,CAAU,iCAAV,CAAN;YACD;;YACD,IAAInB,MAAM,CAACgB,KAAX,EAAkB;cAChBhB,MAAM,CAAC8B,OAAP,IAAkB,IAAlB,KAA2B9B,MAAM,CAAC8B,OAAP,GAAiB,GAAGF,MAAH,CAAU5B,MAAM,CAACgB,KAAjB,CAA5C;YACD;;YACD,KAAKP,EAAE,GAAG,CAAL,EAAQC,KAAK,GAAG,CAAC3E,IAAI,GAAGiE,MAAM,CAAC8B,OAAf,EAAwBV,MAA7C,EAAqDX,EAAE,GAAGC,KAA1D,EAAiE,EAAED,EAAnE,EAAuE;cACrEO,KAAK,GAAGjF,IAAI,CAAC0E,EAAD,CAAZ;;cACA,IAAIxB,IAAI,CAAC+B,KAAD,CAAJ,IAAe,IAAnB,EAAyB;gBACvB,MAAM,IAAIG,KAAJ,CAAU,aAAaH,KAAb,GAAqB,oBAA/B,CAAN;cACD;;cACD/B,IAAI,CAAC+B,KAAD,CAAJ,GAAchB,MAAd;YACD;;YACDjE,IAAI,GAAGM,SAAS,CAAC0F,GAAD,EAAM/B,MAAM,CAAC8B,OAAb,CAAhB,EAAuCb,UAAU,GAAGlF,IAAI,CAAC,CAAD,CAAxD,EAA6DmF,SAAS,GAAGnF,IAAI,CAAC,CAAD,CAA7E;YACAiE,MAAM,CAACiB,UAAP,IAAqB,IAArB,KAA8BjB,MAAM,CAACiB,UAAP,GAAoBA,UAAlD;YACAjB,MAAM,CAACkB,SAAP,IAAoB,IAApB,KAA6BlB,MAAM,CAACkB,SAAP,GAAmBA,SAAhD;UACD;;UACD,IAAI,CAAC,CAAClB,MAAM,CAAC8B,OAAR,IAAmB9B,MAAM,CAACiB,UAAP,CAAkBG,MAAlB,KAA6B,CAAjD,KAAuDpB,MAAM,CAACI,IAAP,KAAgB,SAAvE,IAAoFJ,MAAM,CAAC,SAAD,CAAN,KAAsB,MAA9G,EAAsH;YACpHA,MAAM,CAACgC,UAAP,GAAoB,IAApB;UACD;QACF;MACF;;MACD,SAASD,GAAT,CAAalD,EAAb,EAAgB;QACd,OAAOA,EAAE,CAACuC,MAAH,KAAc,CAArB;MACD;IACF,CApHD;;IAqHAhC,QAAQ,CAACJ,UAAU,CAACa,OAAZ,CAAR;;IACAR,SAAS,GAAG,UAASY,IAAT,EAAc;MACxB,IAAIgC,GAAJ,EAASC,aAAT;MACAD,GAAG,GAAGhD,IAAI,CAACgB,IAAD,CAAV;;MACA,IAAIgC,GAAG,IAAI,IAAX,EAAiB;QACfC,aAAa,GAAGtF,aAAa,CAACJ,IAAI,CAACyC,IAAD,CAAL,EAAagB,IAAb,CAA7B;QACA,MAAM,IAAIkB,KAAJ,CAAU,qBAAqBtE,SAAS,CAACoD,IAAD,CAA9B,GAAuC,GAAvC,IAA8CiC,aAAa,GAAG,2BAA2BrF,SAAS,CAACqF,aAAD,CAApC,GAAsD,IAAzD,GAAgE,GAA3H,CAAV,CAAN;MACD;;MACD,OAAOD,GAAP;IACD,CARD;;IASA3C,KAAK,GAAG,UAAS6C,KAAT,EAAgBC,IAAhB,EAAqB;MAC3B,IAAIzE,KAAJ,EAAWQ,GAAX,EAAgBkE,UAAhB,EAA4BC,cAA5B,EAA4CC,gBAA5C,EAA8DC,IAA9D,EAAoEC,QAApE,EAA8EC,WAA9E,EAA2FC,aAA3F,EAA0GC,sBAA1G,EAAkIC,sBAAlI,EAA0JC,eAA1J,EAA2KC,iBAA3K,EAA8LC,SAA9L,EAAyMC,IAAzM,EAA+M7E,GAA/M,EAAoNC,KAApN,EAA2N2B,MAA3N,EAAmOjE,IAAnO,EAAyO+D,EAAzO,EAA6OC,IAA7O,EAAmPmD,GAAnP,EAAwP7C,IAAxP,EAA8P1B,MAA9P,EAAsQwE,KAAtQ,EAA6QC,OAA7Q,EAAsRC,WAAtR,EAAmSC,GAAnS,EAAwSC,KAAxS,EAA+SC,GAA/S,EAAoT/C,EAApT,EAAwTC,KAAxT,EAA+T+C,CAA/T,EAAkUC,IAAlU,EAAwUzB,GAAxU,EAA6UhC,IAA7U,EAAmV0D,QAAnV,EAA6VC,OAA7V,EAAsWC,QAAtW;MACAlG,KAAK,GAAG,CAACyE,IAAI,IAAI,IAAR,GACLA,IADK,GAEL,EAFI,EAEAzE,KAFR;MAGAQ,GAAG,GAAG,EAAN;MACAkE,UAAU,GAAG,EAAb;MACAC,cAAc,GAAG,KAAjB;MACAC,gBAAgB,GAAG,KAAnB;MACAC,IAAI,GAAG,IAAP;;MACAC,QAAQ,GAAG,UAASxC,IAAT,EAAe5B,KAAf,EAAqB;QAC9B,IAAI4D,GAAJ,EAASqB,GAAT,EAAcvC,GAAd,EAAmBT,CAAnB,EAAsBwD,WAAtB;QACA7B,GAAG,GAAG5C,SAAS,CAACY,IAAD,CAAf;;QACA,IAAIgC,GAAG,CAACX,OAAR,EAAiB;UACfgC,GAAG,GAAGjF,KAAN;QACD,CAFD,MAEO;UACL,IAAI;YACF0C,GAAG,GAAGkB,GAAG,CAACtC,oBAAV;;YACA,IAAIoB,GAAG,IAAI,IAAP,IAAeA,GAAG,CAAC,CAAD,CAAlB,IAAyBA,GAAG,CAAC,CAAD,CAAH,CAAOgD,eAAhC,IAAmD9B,GAAG,CAACzB,UAAJ,CAAeY,MAAf,KAA0B,CAA7E,IAAkFa,GAAG,CAACzB,UAAJ,CAAe,CAAf,EAAkBwD,SAAlB,KAAgC,OAAtH,EAA+H;cAC7HV,GAAG,GAAG,CAAClG,SAAS,CAAC6E,GAAG,CAACzB,UAAJ,CAAe,CAAf,EAAkByD,EAAnB,EAAuB5F,KAAvB,CAAV,CAAN;YACD,CAFD,MAEO;cACLiF,GAAG,GAAGlG,SAAS,CAAC6E,GAAG,CAACzB,UAAL,EAAiBnC,KAAjB,CAAf;YACD;UACF,CAPD,CAOE,OAAOkD,EAAP,EAAW;YACXjB,CAAC,GAAGiB,EAAJ;YACA,MAAM,IAAIJ,KAAJ,CAAU,+BAA+BlB,IAA/B,GAAsC,oBAAtC,GAA6DgC,GAAG,CAAC7B,IAAjE,GAAwE,oBAAxE,GAA+F/B,KAA/F,GAAuG,GAAjH,CAAN;UACD;;UACD,IAAI4D,GAAG,CAAC,MAAD,CAAH,IAAe,CAAC9F,GAAG,CAAC,UAAS0C,EAAT,EAAY;YAClC,OAAOlC,MAAM,CAACkC,EAAD,EAAKyE,GAAL,CAAb;UACD,CAFsB,EAEpBrB,GAAG,CAAC1B,mBAFgB,CAAvB,EAE6B;YAC3B,MAAM,IAAIY,KAAJ,CAAU,YAAYlB,IAAZ,GAAmB,KAAnB,GAA2BqD,GAA3B,GAAiC,eAAjC,GAAmDvG,WAAW,CAACkF,GAAG,CAAC,MAAD,CAAJ,CAA9D,GAA8E,GAAxF,CAAN;UACD;QACF;;QACD6B,WAAW,GAAGtG,SAAS,CAACQ,IAAV,CAAeG,GAAG,CAAC8B,IAAD,CAAlB,EAA0BtC,KAA1B,CAAgC,CAAhC,EAAmC,CAAC,CAApC,CAAd;;QACA,IAAIQ,GAAG,CAAC8B,IAAD,CAAH,IAAa,IAAjB,EAAuB;UACrB,IAAIgC,GAAG,CAACtC,oBAAJ,IAA4B,IAA5B,IAAoCsC,GAAG,CAACtC,oBAAJ,CAAyB,CAAzB,CAApC,IAAmEmE,WAAW,KAAK,OAAvF,EAAgG;YAC9F3F,GAAG,CAAC8B,IAAD,CAAH,GAAY9B,GAAG,CAAC8B,IAAD,CAAH,CAAU2B,MAAV,CAAiB0B,GAAjB,CAAZ;UACD,CAFD,MAEO,IAAIrB,GAAG,CAACrC,oBAAJ,IAA4BkE,WAAW,KAAK,QAAhD,EAA0D;YAC/DI,OAAO,CAAC/F,GAAG,CAAC8B,IAAD,CAAJ,EAAYqD,GAAZ,CAAP;UACD,CAFM,MAEA;YACLnF,GAAG,CAAC8B,IAAD,CAAH,GAAYqD,GAAZ;UACD;QACF,CARD,MAQO;UACLnF,GAAG,CAAC8B,IAAD,CAAH,GAAYqD,GAAZ;QACD;;QACD,IAAIrB,GAAG,CAACK,cAAR,EAAwB;UACtBA,cAAc,GAAG,IAAjB;QACD;;QACD,IAAIL,GAAG,CAACM,gBAAR,EAA0B;UACxBA,gBAAgB,GAAG,IAAnB;QACD;MACF,CAzCD;;MA0CAG,WAAW,GAAG,YAAU;QACtB,IAAIzC,IAAJ,EAAUlE,IAAV,EAAgBsC,KAAhB;;QACA,KAAK4B,IAAL,IAAalE,IAAI,GAAGmD,QAApB,EAA8B;UAC5Bb,KAAK,GAAGtC,IAAI,CAACkE,IAAD,CAAZ;;UACA,IAAI9B,GAAG,CAAC8B,IAAD,CAAH,IAAa,IAAjB,EAAuB;YACrB9B,GAAG,CAAC8B,IAAD,CAAH,GAAY5B,KAAZ;UACD;QACF;MACF,CARD;;MASAsE,aAAa,GAAG,YAAU;QACxB,IAAI7C,EAAJ,EAAQ/D,IAAR,EAAcgE,IAAd,EAAoBE,IAApB;;QACA,IAAIsC,gBAAJ,EAAsB;UACpB;QACD;;QACD,KAAKzC,EAAE,GAAG,CAAL,EAAQC,IAAI,GAAG,CAAChE,IAAI,GAAGoD,QAAR,EAAkBiC,MAAtC,EAA8CtB,EAAE,GAAGC,IAAnD,EAAyD,EAAED,EAA3D,EAA+D;UAC7DG,IAAI,GAAGlE,IAAI,CAAC+D,EAAD,CAAX;;UACA,IAAI,CAAC3B,GAAG,CAAC8B,IAAD,CAAR,EAAgB;YACd,MAAM,IAAIkB,KAAJ,CAAU,YAAYtE,SAAS,CAACoD,IAAD,CAArB,GAA8B,eAAxC,CAAN;UACD;QACF;MACF,CAXD;;MAYA2C,sBAAsB,GAAG,UAASuB,KAAT,EAAgBC,MAAhB,EAAuB;QAC9C,MAAM,IAAIjD,KAAJ,CAAU,iBAAiBtE,SAAS,CAACsH,KAAD,CAA1B,GAAoC,OAApC,GAA8CtH,SAAS,CAACuH,MAAD,CAAvD,GAAkE,iEAA5E,CAAN;MACD,CAFD;;MAGAvB,sBAAsB,GAAG,YAAU;QACjC,IAAIwB,KAAJ,EAAWvE,EAAX,EAAeC,IAAf,EAAqBuE,IAArB,EAA2BC,OAA3B,EAAoC9D,EAApC,EAAwCC,KAAxC,EAA+C8D,OAA/C,EAAwDC,EAAxD,EAA4DC,KAA5D,EAAmEzC,GAAnE;QACAoC,KAAK,GAAGrF,UAAU,CAAC2F,iBAAnB;;QACA,IAAI,CAACN,KAAL,EAAY;UACV;QACD;;QACD,KAAKvE,EAAE,GAAG,CAAL,EAAQC,IAAI,GAAGsE,KAAK,CAACjD,MAA1B,EAAkCtB,EAAE,GAAGC,IAAvC,EAA6C,EAAED,EAA/C,EAAmD;UACjDwE,IAAI,GAAGD,KAAK,CAACvE,EAAD,CAAZ;UACAyE,OAAO,GAAG,IAAV;;UACA,KAAK9D,EAAE,GAAG,CAAL,EAAQC,KAAK,GAAG4D,IAAI,CAAClD,MAA1B,EAAkCX,EAAE,GAAGC,KAAvC,EAA8C,EAAED,EAAhD,EAAoD;YAClD+D,OAAO,GAAGF,IAAI,CAAC7D,EAAD,CAAd;;YACA,IAAIjD,SAAS,CAACQ,IAAV,CAAewG,OAAf,EAAwB7G,KAAxB,CAA8B,CAA9B,EAAiC,CAAC,CAAlC,MAAyC,OAA7C,EAAsD;cACpD,KAAK8G,EAAE,GAAG,CAAL,EAAQC,KAAK,GAAGF,OAAO,CAACpD,MAA7B,EAAqCqD,EAAE,GAAGC,KAA1C,EAAiD,EAAED,EAAnD,EAAuD;gBACrDxC,GAAG,GAAGuC,OAAO,CAACC,EAAD,CAAb;;gBACA,IAAIxC,GAAG,IAAI9D,GAAX,EAAgB;kBACd,IAAIoG,OAAO,IAAI,IAAf,EAAqB;oBACnB3B,sBAAsB,CAAC2B,OAAD,EAAUtC,GAAV,CAAtB;kBACD,CAFD,MAEO;oBACLsC,OAAO,GAAGtC,GAAV;oBACA;kBACD;gBACF;cACF;YACF,CAZD,MAYO;cACL,IAAIuC,OAAO,IAAIrG,GAAf,EAAoB;gBAClB,IAAIoG,OAAO,IAAI,IAAf,EAAqB;kBACnB3B,sBAAsB,CAAC2B,OAAD,EAAUC,OAAV,CAAtB;gBACD,CAFD,MAEO;kBACLD,OAAO,GAAGC,OAAV;gBACD;cACF;YACF;UACF;QACF;MACF,CAlCD;;MAmCA1B,eAAe,GAAG,UAAS9C,MAAT,EAAgB;QAChC,IAAI2B,SAAJ,EAAevB,IAAf,EAAqBwE,iBAArB,EAAwC9E,EAAxC,EAA4CC,IAA5C,EAAkD8E,gBAAlD,EAAoEC,YAApE;QACAnD,SAAS,GAAG3B,MAAM,CAAC2B,SAAnB;;QACA,IAAI,CAACA,SAAD,IAAc3B,MAAM,CAAC+E,eAAzB,EAA0C;UACxC,OAAO,IAAP;QACD;;QACD3E,IAAI,GAAGuB,SAAS,CAAC,CAAD,CAAhB,EAAqBiD,iBAAiB,GAAGlH,MAAM,CAACM,IAAP,CAAY2D,SAAZ,EAAuB,CAAvB,CAAzC;;QACA,KAAK7B,EAAE,GAAG,CAAL,EAAQC,IAAI,GAAG6E,iBAAiB,CAACxD,MAAtC,EAA8CtB,EAAE,GAAGC,IAAnD,EAAyD,EAAED,EAA3D,EAA+D;UAC7D+E,gBAAgB,GAAGD,iBAAiB,CAAC9E,EAAD,CAApC;UACAgF,YAAY,GAAG3G,GAAG,CAAC0G,gBAAD,CAAlB;;UACA,IAAIC,YAAY,IAAIhC,eAAe,CAACgC,YAAD,CAAnC,EAAmD;YACjD,IAAI1E,IAAI,KAAK,IAAb,EAAmB;cACjB,OAAO,IAAP;YACD;UACF,CAJD,MAIO,IAAIA,IAAI,KAAK,KAAb,EAAoB;YACzB,MAAM,IAAIe,KAAJ,CAAU,iBAAiBnB,MAAM,CAACA,MAAxB,GAAiC,sCAA3C,CAAN;UACD;QACF;;QACD,IAAII,IAAI,KAAK,KAAb,EAAoB;UAClB,OAAO,IAAP;QACD,CAFD,MAEO;UACL,MAAM,IAAIe,KAAJ,CAAU,iBAAiBnB,MAAM,CAACA,MAAxB,GAAiC,yCAA3C,CAAN;QACD;MACF,CAvBD;;MAwBA+C,iBAAiB,GAAG,YAAU;QAC5B,IAAI9C,IAAJ;;QACA,KAAKA,IAAL,IAAa9B,GAAb,EAAkB;UAChB2E,eAAe,CAAC7D,IAAI,CAACgB,IAAD,CAAL,CAAf;QACD;MACF,CALD;;MAMA+C,SAAS,GAAG,YAAU;QACpB,IAAIR,IAAJ,EAAU;UACR,MAAM,IAAIrB,KAAJ,CAAU,gBAAgBqB,IAAhB,GAAuB,aAAvB,GAAuCnD,SAAS,CAACmD,IAAD,CAAT,CAAgBpC,IAAvD,GAA8D,aAAxE,CAAN;QACD;MACF,CAJD;;MAKA,QAAQ5C,SAAS,CAACQ,IAAV,CAAemE,KAAf,EAAsBxE,KAAtB,CAA4B,CAA5B,EAA+B,CAAC,CAAhC,CAAR;QACA,KAAK,QAAL;UACEsF,IAAI,GAAG3F,WAAW,CAAC6E,KAAK,CAACxE,KAAN,CAAYA,KAAK,IAAI,IAAT,GAAgBA,KAAhB,GAAwB,CAApC,CAAD,CAAlB;UACA;;QACF,KAAK,OAAL;UACEsF,IAAI,GAAGd,KAAK,CAACxE,KAAN,CAAYA,KAAK,IAAI,IAAT,GAAgBA,KAAhB,GAAwB,CAApC,CAAP;UACA;;QACF,KAAK,QAAL;UACEQ,GAAG,GAAG,EAAN;;UACA,KAAKC,GAAL,IAAY+D,KAAZ,EAAmB;YACjB9D,KAAK,GAAG8D,KAAK,CAAC/D,GAAD,CAAb;;YACA,IAAIA,GAAG,KAAK,GAAZ,EAAiB;cACf4B,MAAM,GAAGX,SAAS,CAACvC,SAAS,CAACsB,GAAD,CAAV,CAAlB;;cACA,IAAIlB,eAAe,CAAC8C,MAAM,CAACQ,UAAR,EAAoBnC,KAApB,CAAnB,EAA+C;gBAC7CF,GAAG,CAAC6B,MAAM,CAACA,MAAR,CAAH,GAAqB3B,KAArB;cACD,CAFD,MAEO;gBACL,MAAM,IAAI8C,KAAJ,CAAU,aAAanB,MAAM,CAACA,MAApB,GAA6B,uBAA7B,GAAuD3B,KAAvD,GAA+D,qBAA/D,GAAuF2B,MAAM,CAACI,IAA9F,GAAqG,IAA/G,CAAN;cACD;YACF;UACF;;UACDyC,sBAAsB;UACtBE,iBAAiB;UACjBL,WAAW;UACXC,aAAa;UACb,OAAO5G,IAAI,GAAGsB,YAAY,CAACc,GAAD,CAAnB,EAA0BpC,IAAI,CAACiJ,CAAL,GAAS7C,KAAK,CAAC6C,CAAN,IAAW,EAA9C,EAAkDjJ,IAAzD;;QACF;UACE,MAAM,IAAIoF,KAAJ,CAAU,kCAAkCgB,KAAlC,GAA0C,GAApD,CAAN;MA1BF;;MA4BA,KAAKrC,EAAE,GAAG,CAAL,EAAQC,IAAI,GAAGkD,IAAI,CAAC7B,MAAzB,EAAiCtB,EAAE,GAAGC,IAAtC,EAA4C,EAAED,EAA9C,EAAkD;QAChDoD,GAAG,GAAGD,IAAI,CAACnD,EAAD,CAAV;;QACA,IAAIoD,GAAG,KAAK,IAAZ,EAAkB;UAChBZ,cAAc,GAAG,IAAjB;QACD,CAFD,MAEO,IAAIA,cAAJ,EAAoB;UACzBD,UAAU,CAACX,IAAX,CAAgBwB,GAAhB;QACD,CAFM,MAEA;UACL,IAAI7C,IAAI,GAAG6C,GAAG,CAACnE,KAAJ,CAAU,yCAAV,CAAX,EAAiE;YAC/DJ,MAAM,GAAG0B,IAAT;YACA2C,SAAS;YACTG,KAAK,GAAGxE,MAAM,CAAC,CAAD,CAAN,CAAUyC,MAAV,KAAqB,CAA7B;YACAgC,OAAO,GAAGzE,MAAM,CAAC,CAAD,CAAhB;YACA0E,WAAW,GAAG1E,MAAM,CAAC,CAAD,CAAN,IAAa,IAA3B;YACA2E,GAAG,GAAG3E,MAAM,CAAC,CAAD,CAAZ;;YACA,IAAI0E,WAAW,IAAIC,GAAG,IAAI,IAA1B,EAAgC;cAC9B,MAAM,IAAInC,KAAJ,CAAU,mBAAmBiC,OAAnB,GAA6B,cAAvC,CAAN;YACD;;YACD,IAAID,KAAJ,EAAW;cACTI,KAAK,GAAGjH,KAAK,CAAC8G,OAAD,CAAb;cACAI,GAAG,GAAGD,KAAK,CAACnC,MAAZ;;cACA,KAAKX,EAAE,GAAG,CAAL,EAAQC,KAAK,GAAG6C,KAAK,CAACnC,MAA3B,EAAmCX,EAAE,GAAGC,KAAxC,EAA+C,EAAED,EAAjD,EAAqD;gBACnDgD,CAAC,GAAGhD,EAAJ;gBACAiD,IAAI,GAAGH,KAAK,CAAC9C,EAAD,CAAZ;gBACAwB,GAAG,GAAG5C,SAAS,CAACqE,IAAD,CAAf;gBACAzD,IAAI,GAAGgC,GAAG,CAACjC,MAAX;;gBACA,IAAIsC,cAAJ,EAAoB;kBAClBD,UAAU,CAACX,IAAX,CAAgBgC,IAAhB;gBACD,CAFD,MAEO,IAAID,CAAC,KAAKD,GAAG,GAAG,CAAhB,EAAmB;kBACxB,IAAIH,WAAJ,EAAiB;oBACfM,QAAQ,GAAG1B,GAAG,CAACX,OAAJ,GAAclE,SAAS,CAAC,CAAC;sBAClCgD,IAAI,EAAE;oBAD4B,CAAD,CAAD,EAE9BkD,GAF8B,CAAvB,GAEAA,GAFX;oBAGAb,QAAQ,CAACxC,IAAD,EAAO0D,QAAP,CAAR;kBACD,CALD,MAKO,IAAI1B,GAAG,CAACX,OAAR,EAAiB;oBACtBmB,QAAQ,CAACxC,IAAD,EAAO,IAAP,CAAR;kBACD,CAFM,MAEA;oBACLuC,IAAI,GAAGvC,IAAP;kBACD;gBACF,CAXM,MAWA,IAAIgC,GAAG,CAACX,OAAR,EAAiB;kBACtBmB,QAAQ,CAACxC,IAAD,EAAO,IAAP,CAAR;gBACD,CAFM,MAEA;kBACL,MAAM,IAAIkB,KAAJ,CAAU,yBAAyBuC,IAAzB,GAAgC,iDAA1C,CAAN;gBACD;cACF;YACF,CA3BD,MA2BO;cACLE,OAAO,GAAG,KAAV;;cACA,IAAIvD,IAAI,GAAG+C,OAAO,CAACrE,KAAR,CAAc,WAAd,CAAX,EAAuC;gBACrC6E,OAAO,GAAG,IAAV;gBACAC,QAAQ,GAAGxD,IAAI,CAAC,CAAD,CAAf;gBACA4B,GAAG,GAAG5C,SAAS,CAACwE,QAAD,CAAf;cACD,CAJD,MAIO;gBACL5B,GAAG,GAAG5C,SAAS,CAAC+D,OAAD,CAAf;cACD;;cACDnD,IAAI,GAAGgC,GAAG,CAACjC,MAAX;;cACA,IAAIiC,GAAG,CAACX,OAAR,EAAiB;gBACfqC,QAAQ,GAAGN,WAAW,GAAGjG,SAAS,CAAC,CAAC;kBAClCgD,IAAI,EAAE;gBAD4B,CAAD,CAAD,EAE9BkD,GAF8B,CAAZ,GAEX,IAFX;;gBAGA,IAAIM,OAAJ,EAAa;kBACXnB,QAAQ,CAACxC,IAAD,EAAO,CAAC0D,QAAR,CAAR;gBACD,CAFD,MAEO;kBACLlB,QAAQ,CAACxC,IAAD,EAAO0D,QAAP,CAAR;gBACD;cACF,CATD,MASO;gBACL,IAAIC,OAAJ,EAAa;kBACX,MAAM,IAAIzC,KAAJ,CAAU,0DAA0D0C,QAA1D,GAAqE,IAA/E,CAAN;gBACD;;gBACD,IAAIR,WAAJ,EAAiB;kBACfZ,QAAQ,CAACxC,IAAD,EAAOqD,GAAP,CAAR;gBACD,CAFD,MAEO;kBACLd,IAAI,GAAGvC,IAAP;gBACD;cACF;YACF;UACF,CAnED,MAmEO,IAAII,IAAI,GAAG6C,GAAG,CAACnE,KAAJ,CAAU,0BAAV,CAAX,EAAkD;YACvDkD,GAAG,GAAGhD,IAAI,CAACgG,GAAX;;YACA,IAAI,CAAChD,GAAL,EAAU;cACR,MAAM,IAAId,KAAJ,CAAU,yBAAV,CAAN;YACD;;YACDsB,QAAQ,CAACR,GAAG,CAACjC,MAAL,EAAaK,IAAI,CAAC,CAAD,CAAjB,CAAR;UACD,CANM,MAMA;YACL,IAAImC,IAAJ,EAAU;cACRC,QAAQ,CAACD,IAAD,EAAOU,GAAP,CAAR;cACAV,IAAI,GAAG,IAAP;YACD,CAHD,MAGO;cACLH,UAAU,CAACX,IAAX,CAAgBwB,GAAhB;;cACA,IAAI,CAAClE,UAAU,CAACS,kBAAhB,EAAoC;gBAClC6C,cAAc,GAAG,IAAjB;cACD;YACF;UACF;QACF;MACF;;MACDU,SAAS;MACTH,sBAAsB;MACtBE,iBAAiB;MACjBL,WAAW;MACXC,aAAa;MACb,OAAO5G,IAAI,GAAGsB,YAAY,CAACc,GAAD,CAAnB,EAA0BpC,IAAI,CAACiJ,CAAL,GAAS3C,UAAnC,EAA+CtG,IAAtD;IACD,CAjRD;;IAkRA,OAAO;MACLuD,KAAK,EAAEA,KADF;MAEL4F,SAAS,EAAE,UAASrG,EAAT,EAAY;QACrB,OAAOS,KAAK,CAACT,EAAD,EAAK;UACflB,KAAK,EAAE;QADQ,CAAL,CAAZ;MAGD,CANI;MAOLX,YAAY,EAAEA,YAAY,CAACgC,UAAD,CAPrB;MAQL/B,qBAAqB,EAAEA,qBAAqB,CAACoC,SAAD,EAAYL,UAAZ;IARvC,CAAP;EAUD,CA5aD;;EA6aAzB,IAAI,CAACzB,OAAL,GAAeA,OAAf;EACAqJ,MAAM,CAACC,OAAP,GAAiB7H,IAAjB;;EACA,SAAS2G,OAAT,CAAiB/F,GAAjB,EAAsBkH,GAAtB,EAA0B;IACxB,IAAIC,GAAG,GAAG,GAAGC,cAAb;;IACA,KAAK,IAAInH,GAAT,IAAgBiH,GAAhB,EAAqB,IAAIC,GAAG,CAACtH,IAAJ,CAASqH,GAAT,EAAcjH,GAAd,CAAJ,EAAwBD,GAAG,CAACC,GAAD,CAAH,GAAWiH,GAAG,CAACjH,GAAD,CAAd;;IAC7C,OAAOD,GAAP;EACD;AACF,CA/cD,EA+cGH,IA/cH,CA+cQ,IA/cR"},"metadata":{},"sourceType":"script"}