{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst scope_1 = require(\"../compile/codegen/scope\");\n\nconst code_1 = require(\"../compile/codegen/code\");\n\nfunction standaloneCode(ajv, refsOrFunc) {\n  if (!ajv.opts.code.source) {\n    throw new Error(\"moduleCode: ajv instance must have code.source option\");\n  }\n\n  const {\n    _n\n  } = ajv.scope.opts;\n  return typeof refsOrFunc == \"function\" ? funcExportCode(refsOrFunc.source) : refsOrFunc !== undefined ? multiExportsCode(refsOrFunc, getValidate) : multiExportsCode(ajv.schemas, sch => sch.meta ? undefined : ajv.compile(sch.schema));\n\n  function getValidate(id) {\n    const v = ajv.getSchema(id);\n    if (!v) throw new Error(`moduleCode: no schema with id ${id}`);\n    return v;\n  }\n\n  function funcExportCode(source) {\n    const usedValues = {};\n    const n = source === null || source === void 0 ? void 0 : source.validateName;\n    const vCode = validateCode(usedValues, source);\n\n    if (ajv.opts.code.esm) {\n      // Always do named export as `validate` rather than the variable `n` which is `validateXX` for known export value\n      return `\"use strict\";${_n}export const validate = ${n};${_n}export default ${n};${_n}${vCode}`;\n    }\n\n    return `\"use strict\";${_n}module.exports = ${n};${_n}module.exports.default = ${n};${_n}${vCode}`;\n  }\n\n  function multiExportsCode(schemas, getValidateFunc) {\n    var _a;\n\n    const usedValues = {};\n    let code = (0, code_1._)`\"use strict\";`;\n\n    for (const name in schemas) {\n      const v = getValidateFunc(schemas[name]);\n\n      if (v) {\n        const vCode = validateCode(usedValues, v.source);\n        const exportSyntax = ajv.opts.code.esm ? (0, code_1._)`export const ${(0, code_1.getEsmExportName)(name)}` : (0, code_1._)`exports${(0, code_1.getProperty)(name)}`;\n        code = (0, code_1._)`${code}${_n}${exportSyntax} = ${(_a = v.source) === null || _a === void 0 ? void 0 : _a.validateName};${_n}${vCode}`;\n      }\n    }\n\n    return `${code}`;\n  }\n\n  function validateCode(usedValues, s) {\n    if (!s) throw new Error('moduleCode: function does not have \"source\" property');\n    if (usedState(s.validateName) === scope_1.UsedValueState.Completed) return code_1.nil;\n    setUsedState(s.validateName, scope_1.UsedValueState.Started);\n    const scopeCode = ajv.scope.scopeCode(s.scopeValues, usedValues, refValidateCode);\n    const code = new code_1._Code(`${scopeCode}${_n}${s.validateCode}`);\n    return s.evaluated ? (0, code_1._)`${code}${s.validateName}.evaluated = ${s.evaluated};${_n}` : code;\n\n    function refValidateCode(n) {\n      var _a;\n\n      const vRef = (_a = n.value) === null || _a === void 0 ? void 0 : _a.ref;\n\n      if (n.prefix === \"validate\" && typeof vRef == \"function\") {\n        const v = vRef;\n        return validateCode(usedValues, v.source);\n      } else if ((n.prefix === \"root\" || n.prefix === \"wrapper\") && typeof vRef == \"object\") {\n        const {\n          validate,\n          validateName\n        } = vRef;\n        if (!validateName) throw new Error(\"ajv internal error\");\n        const def = ajv.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;\n        const wrapper = (0, code_1._)`${def} ${n} = {validate: ${validateName}};`;\n        if (usedState(validateName) === scope_1.UsedValueState.Started) return wrapper;\n        const vCode = validateCode(usedValues, validate === null || validate === void 0 ? void 0 : validate.source);\n        return (0, code_1._)`${wrapper}${_n}${vCode}`;\n      }\n\n      return undefined;\n    }\n\n    function usedState(name) {\n      var _a;\n\n      return (_a = usedValues[name.prefix]) === null || _a === void 0 ? void 0 : _a.get(name);\n    }\n\n    function setUsedState(name, state) {\n      const {\n        prefix\n      } = name;\n      const names = usedValues[prefix] = usedValues[prefix] || new Map();\n      names.set(name, state);\n    }\n  }\n}\n\nmodule.exports = exports = standaloneCode;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = standaloneCode;","map":{"version":3,"mappings":"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","names":["standaloneCode","ajv","refsOrFunc","opts","code","source","Error","_n","scope","funcExportCode","undefined","multiExportsCode","getValidate","schemas","sch","meta","compile","schema","id","v","getSchema","usedValues","n","validateName","vCode","validateCode","esm","getValidateFunc","name","exportSyntax","_a","s","usedState","scope_1","Completed","code_1","setUsedState","Started","scopeCode","scopeValues","refValidateCode","evaluated","vRef","value","ref","prefix","validate","def","es5","var","const","wrapper","get","state","names","Map","set","module","exports","Object","defineProperty"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-webpack-plugin\\node_modules\\ajv\\lib\\standalone\\index.ts"],"sourcesContent":["import type AjvCore from \"../core\"\nimport type {AnyValidateFunction, SourceCode} from \"../types\"\nimport type {SchemaEnv} from \"../compile\"\nimport {UsedScopeValues, UsedValueState, ValueScopeName, varKinds} from \"../compile/codegen/scope\"\nimport {_, nil, _Code, Code, getProperty, getEsmExportName} from \"../compile/codegen/code\"\n\nfunction standaloneCode(\n  ajv: AjvCore,\n  refsOrFunc?: {[K in string]?: string} | AnyValidateFunction\n): string {\n  if (!ajv.opts.code.source) {\n    throw new Error(\"moduleCode: ajv instance must have code.source option\")\n  }\n  const {_n} = ajv.scope.opts\n  return typeof refsOrFunc == \"function\"\n    ? funcExportCode(refsOrFunc.source)\n    : refsOrFunc !== undefined\n    ? multiExportsCode<string>(refsOrFunc, getValidate)\n    : multiExportsCode<SchemaEnv>(ajv.schemas, (sch) =>\n        sch.meta ? undefined : ajv.compile(sch.schema)\n      )\n\n  function getValidate(id: string): AnyValidateFunction {\n    const v = ajv.getSchema(id)\n    if (!v) throw new Error(`moduleCode: no schema with id ${id}`)\n    return v\n  }\n\n  function funcExportCode(source?: SourceCode): string {\n    const usedValues: UsedScopeValues = {}\n    const n = source?.validateName\n    const vCode = validateCode(usedValues, source)\n    if (ajv.opts.code.esm) {\n      // Always do named export as `validate` rather than the variable `n` which is `validateXX` for known export value\n      return `\"use strict\";${_n}export const validate = ${n};${_n}export default ${n};${_n}${vCode}`\n    }\n    return `\"use strict\";${_n}module.exports = ${n};${_n}module.exports.default = ${n};${_n}${vCode}`\n  }\n\n  function multiExportsCode<T extends SchemaEnv | string>(\n    schemas: {[K in string]?: T},\n    getValidateFunc: (schOrId: T) => AnyValidateFunction | undefined\n  ): string {\n    const usedValues: UsedScopeValues = {}\n    let code = _`\"use strict\";`\n    for (const name in schemas) {\n      const v = getValidateFunc(schemas[name] as T)\n      if (v) {\n        const vCode = validateCode(usedValues, v.source)\n        const exportSyntax = ajv.opts.code.esm\n          ? _`export const ${getEsmExportName(name)}`\n          : _`exports${getProperty(name)}`\n        code = _`${code}${_n}${exportSyntax} = ${v.source?.validateName};${_n}${vCode}`\n      }\n    }\n    return `${code}`\n  }\n\n  function validateCode(usedValues: UsedScopeValues, s?: SourceCode): Code {\n    if (!s) throw new Error('moduleCode: function does not have \"source\" property')\n    if (usedState(s.validateName) === UsedValueState.Completed) return nil\n    setUsedState(s.validateName, UsedValueState.Started)\n\n    const scopeCode = ajv.scope.scopeCode(s.scopeValues, usedValues, refValidateCode)\n    const code = new _Code(`${scopeCode}${_n}${s.validateCode}`)\n    return s.evaluated ? _`${code}${s.validateName}.evaluated = ${s.evaluated};${_n}` : code\n\n    function refValidateCode(n: ValueScopeName): Code | undefined {\n      const vRef = n.value?.ref\n      if (n.prefix === \"validate\" && typeof vRef == \"function\") {\n        const v = vRef as AnyValidateFunction\n        return validateCode(usedValues, v.source)\n      } else if ((n.prefix === \"root\" || n.prefix === \"wrapper\") && typeof vRef == \"object\") {\n        const {validate, validateName} = vRef as SchemaEnv\n        if (!validateName) throw new Error(\"ajv internal error\")\n        const def = ajv.opts.code.es5 ? varKinds.var : varKinds.const\n        const wrapper = _`${def} ${n} = {validate: ${validateName}};`\n        if (usedState(validateName) === UsedValueState.Started) return wrapper\n        const vCode = validateCode(usedValues, validate?.source)\n        return _`${wrapper}${_n}${vCode}`\n      }\n      return undefined\n    }\n\n    function usedState(name: ValueScopeName): UsedValueState | undefined {\n      return usedValues[name.prefix]?.get(name)\n    }\n\n    function setUsedState(name: ValueScopeName, state: UsedValueState): void {\n      const {prefix} = name\n      const names = (usedValues[prefix] = usedValues[prefix] || new Map())\n      names.set(name, state)\n    }\n  }\n}\n\nmodule.exports = exports = standaloneCode\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default standaloneCode\n"]},"metadata":{},"sourceType":"script"}