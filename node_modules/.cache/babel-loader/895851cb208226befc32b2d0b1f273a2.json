{"ast":null,"code":"import * as t from \"../../lib/index.js\";\nimport stringifyValidator from \"../utils/stringifyValidator.js\";\nimport toFunctionName from \"../utils/toFunctionName.js\";\nlet code = `// NOTE: This file is autogenerated. Do not modify.\n// See packages/babel-types/scripts/generators/typescript-legacy.js for script used.\n\ninterface BaseComment {\n  value: string;\n  start: number;\n  end: number;\n  loc: SourceLocation;\n  type: \"CommentBlock\" | \"CommentLine\";\n}\n\nexport interface CommentBlock extends BaseComment {\n  type: \"CommentBlock\";\n}\n\nexport interface CommentLine extends BaseComment {\n  type: \"CommentLine\";\n}\n\nexport type Comment = CommentBlock | CommentLine;\n\nexport interface SourceLocation {\n  start: {\n    line: number;\n    column: number;\n  };\n\n  end: {\n    line: number;\n    column: number;\n  };\n}\n\ninterface BaseNode {\n  leadingComments: ReadonlyArray<Comment> | null;\n  innerComments: ReadonlyArray<Comment> | null;\n  trailingComments: ReadonlyArray<Comment> | null;\n  start: number | null;\n  end: number | null;\n  loc: SourceLocation | null;\n  type: Node[\"type\"];\n  extra?: Record<string, unknown>;\n}\n\nexport type Node = ${t.TYPES.sort().join(\" | \")};\\n\\n`; //\n\nconst lines = [];\n\nfor (const type in t.NODE_FIELDS) {\n  const fields = t.NODE_FIELDS[type];\n  const fieldNames = sortFieldNames(Object.keys(t.NODE_FIELDS[type]), type);\n  const builderNames = t.BUILDER_KEYS[type];\n  const struct = ['type: \"' + type + '\";'];\n  const args = [];\n  fieldNames.forEach(fieldName => {\n    const field = fields[fieldName]; // Future / annoying TODO:\n    // MemberExpression.property, ObjectProperty.key and ObjectMethod.key need special cases; either:\n    // - convert the declaration to chain() like ClassProperty.key and ClassMethod.key,\n    // - declare an alias type for valid keys, detect the case and reuse it here,\n    // - declare a disjoint union with, for example, ObjectPropertyBase,\n    //   ObjectPropertyLiteralKey and ObjectPropertyComputedKey, and declare ObjectProperty\n    //   as \"ObjectPropertyBase & (ObjectPropertyLiteralKey | ObjectPropertyComputedKey)\"\n\n    let typeAnnotation = stringifyValidator(field.validate, \"\");\n\n    if (isNullable(field) && !hasDefault(field)) {\n      typeAnnotation += \" | null\";\n    }\n\n    if (builderNames.includes(fieldName)) {\n      if (areAllRemainingFieldsNullable(fieldName, builderNames, fields)) {\n        args.push(`${t.toBindingIdentifierName(fieldName)}${isNullable(field) ? \"?:\" : \":\"} ${typeAnnotation}`);\n      } else {\n        args.push(`${t.toBindingIdentifierName(fieldName)}: ${typeAnnotation}${isNullable(field) ? \" | undefined\" : \"\"}`);\n      }\n    }\n\n    const alphaNumeric = /^\\w+$/;\n\n    if (t.isValidIdentifier(fieldName) || alphaNumeric.test(fieldName)) {\n      struct.push(`${fieldName}: ${typeAnnotation};`);\n    } else {\n      struct.push(`\"${fieldName}\": ${typeAnnotation};`);\n    }\n  });\n  code += `export interface ${type} extends BaseNode {\n  ${struct.join(\"\\n  \").trim()}\n}\\n\\n`; // super and import are reserved words in JavaScript\n\n  if (type !== \"Super\" && type !== \"Import\") {\n    lines.push(`export function ${toFunctionName(type)}(${args.join(\", \")}): ${type};`);\n  } else {\n    const functionName = toFunctionName(type);\n    lines.push(`declare function _${functionName}(${args.join(\", \")}): ${type};`, `export { _${functionName} as ${functionName}}`);\n  }\n}\n\nfor (const typeName of t.TYPES) {\n  const isDeprecated = !!t.DEPRECATED_KEYS[typeName];\n  const realName = isDeprecated ? t.DEPRECATED_KEYS[typeName] : typeName;\n  const result = t.NODE_FIELDS[realName] || t.FLIPPED_ALIAS_KEYS[realName] ? `node is ${realName}` : \"boolean\";\n\n  if (isDeprecated) {\n    lines.push(`/** @deprecated Use \\`is${realName}\\` */`);\n  }\n\n  lines.push(`export function is${typeName}(node: object | null | undefined, opts?: object | null): ${result};`);\n\n  if (isDeprecated) {\n    lines.push(`/** @deprecated Use \\`assert${realName}\\` */`);\n  }\n\n  lines.push(`export function assert${typeName}(node: object | null | undefined, opts?: object | null): void;`);\n}\n\nlines.push( // assert/\n`export function assertNode(obj: any): void`, // builders/\n// eslint-disable-next-line max-len\n`export function createTypeAnnotationBasedOnTypeof(type: 'string' | 'number' | 'undefined' | 'boolean' | 'function' | 'object' | 'symbol'): StringTypeAnnotation | VoidTypeAnnotation | NumberTypeAnnotation | BooleanTypeAnnotation | GenericTypeAnnotation`, `export function createUnionTypeAnnotation<T extends FlowType>(types: [T]): T`, `export function createFlowUnionType<T extends FlowType>(types: [T]): T`, // this probably misbehaves if there are 0 elements, and it's not a UnionTypeAnnotation if there's only 1\n// it is possible to require \"2 or more\" for this overload ([T, T, ...T[]]) but it requires typescript 3.0\n`export function createUnionTypeAnnotation(types: ReadonlyArray<FlowType>): UnionTypeAnnotation`, `export function createFlowUnionType(types: ReadonlyArray<FlowType>): UnionTypeAnnotation`, // this smells like \"internal API\"\n// eslint-disable-next-line max-len\n`export function buildChildren(node: { children: ReadonlyArray<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment | JSXEmptyExpression> }): JSXElement['children']`, // clone/\n`export function clone<T extends Node>(n: T): T;`, `export function cloneDeep<T extends Node>(n: T): T;`, `export function cloneDeepWithoutLoc<T extends Node>(n: T): T;`, `export function cloneNode<T extends Node>(n: T, deep?: boolean, withoutLoc?: boolean): T;`, `export function cloneWithoutLoc<T extends Node>(n: T): T;`, // comments/\n`export type CommentTypeShorthand = 'leading' | 'inner' | 'trailing'`, // eslint-disable-next-line max-len\n`export function addComment<T extends Node>(node: T, type: CommentTypeShorthand, content: string, line?: boolean): T`, // eslint-disable-next-line max-len\n`export function addComments<T extends Node>(node: T, type: CommentTypeShorthand, comments: ReadonlyArray<Comment>): T`, `export function inheritInnerComments(node: Node, parent: Node): void`, `export function inheritLeadingComments(node: Node, parent: Node): void`, `export function inheritsComments<T extends Node>(node: T, parent: Node): void`, `export function inheritTrailingComments(node: Node, parent: Node): void`, `export function removeComments<T extends Node>(node: T): T`, // converters/\n// eslint-disable-next-line max-len\n`export function ensureBlock(node: Extract<Node, { body: BlockStatement | Statement | Expression }>): BlockStatement`, // too complex?\n// eslint-disable-next-line max-len\n`export function ensureBlock<K extends keyof Extract<Node, { body: BlockStatement | Statement | Expression }> = 'body'>(node: Extract<Node, Record<K, BlockStatement | Statement | Expression>>, key: K): BlockStatement`, // gatherSequenceExpressions is not exported\n`export function toBindingIdentifierName(name: { toString(): string } | null | undefined): string`, `export function toBlock(node: Statement | Expression, parent?: Function | null): BlockStatement`, // it is possible for `node` to be an arbitrary object if `key` is always provided,\n// but that doesn't look like intended API\n// eslint-disable-next-line max-len\n`export function toComputedKey<T extends Extract<Node, { computed: boolean | null }>>(node: T, key?: Expression | Identifier): Expression`, `export function toExpression(node: Function): FunctionExpression`, `export function toExpression(node: Class): ClassExpression`, `export function toExpression(node: ExpressionStatement | Expression | Class | Function): Expression`, `export function toIdentifier(name: { toString(): string } | null | undefined): string`, `export function toKeyAlias(node: Method | Property, key?: Node): string`, // NOTE: this actually uses Scope from @babel/traverse, but we can't add a dependency on its types,\n// as they live in @types. Declare the structural subset that is required.\n// eslint-disable-next-line max-len\n`export function toSequenceExpression(nodes: ReadonlyArray<Node>, scope: { push(value: { id: LVal; kind: 'var'; init?: Expression}): void; buildUndefinedNode(): Node }): SequenceExpression | undefined`, `export function toStatement(node: AssignmentExpression, ignore?: boolean): ExpressionStatement`, `export function toStatement(node: Statement | AssignmentExpression, ignore?: boolean): Statement`, `export function toStatement(node: Class, ignore: true): ClassDeclaration | undefined`, `export function toStatement(node: Class, ignore?: boolean): ClassDeclaration`, `export function toStatement(node: Function, ignore: true): FunctionDeclaration | undefined`, `export function toStatement(node: Function, ignore?: boolean): FunctionDeclaration`, // eslint-disable-next-line max-len\n`export function toStatement(node: Statement | Class | Function | AssignmentExpression, ignore: true): Statement | undefined`, // eslint-disable-next-line max-len\n`export function toStatement(node: Statement | Class | Function | AssignmentExpression, ignore?: boolean): Statement`, // eslint-disable-next-line max-len\n`export function valueToNode(value: undefined): Identifier`, // (should this not be a UnaryExpression to avoid shadowing?)\n`export function valueToNode(value: boolean): BooleanLiteral`, `export function valueToNode(value: null): NullLiteral`, `export function valueToNode(value: string): StringLiteral`, // Infinities and NaN need to use a BinaryExpression; negative values must be wrapped in UnaryExpression\n`export function valueToNode(value: number): NumericLiteral | BinaryExpression | UnaryExpression`, `export function valueToNode(value: RegExp): RegExpLiteral`, // eslint-disable-next-line max-len\n`export function valueToNode(value: ReadonlyArray<undefined | boolean | null | string | number | RegExp | object>): ArrayExpression`, // this throws with objects that are not PlainObject according to lodash,\n// or if there are non-valueToNode-able values\n`export function valueToNode(value: object): ObjectExpression`, // eslint-disable-next-line max-len\n`export function valueToNode(value: undefined | boolean | null | string | number | RegExp | object): Expression`, // modifications/\n// eslint-disable-next-line max-len\n`export function removeTypeDuplicates(types: ReadonlyArray<FlowType | false | null | undefined>): FlowType[]`, // eslint-disable-next-line max-len\n`export function appendToMemberExpression<T extends Pick<MemberExpression, 'object' | 'property'>>(member: T, append: MemberExpression['property'], computed?: boolean): T`, // eslint-disable-next-line max-len\n`export function inherits<T extends Node | null | undefined>(child: T, parent: Node | null | undefined): T`, // eslint-disable-next-line max-len\n`export function prependToMemberExpression<T extends Pick<MemberExpression, 'object' | 'property'>>(member: T, prepend: MemberExpression['object']): T`, `export function removeProperties(\n  n: Node,\n  opts?: { preserveComments: boolean } | null\n): void;`, `export function removePropertiesDeep<T extends Node>(\n  n: T,\n  opts?: { preserveComments: boolean } | null\n): T;`, // retrievers/\n// eslint-disable-next-line max-len\n`export function getBindingIdentifiers(node: Node, duplicates: true, outerOnly?: boolean): Record<string, Array<Identifier>>`, // eslint-disable-next-line max-len\n`export function getBindingIdentifiers(node: Node, duplicates?: false, outerOnly?: boolean): Record<string, Identifier>`, // eslint-disable-next-line max-len\n`export function getBindingIdentifiers(node: Node, duplicates: boolean, outerOnly?: boolean): Record<string, Identifier | Array<Identifier>>`, // eslint-disable-next-line max-len\n`export function getOuterBindingIdentifiers(node: Node, duplicates: true): Record<string, Array<Identifier>>`, `export function getOuterBindingIdentifiers(node: Node, duplicates?: false): Record<string, Identifier>`, // eslint-disable-next-line max-len\n`export function getOuterBindingIdentifiers(node: Node, duplicates: boolean): Record<string, Identifier | Array<Identifier>>`, // traverse/\n`export type TraversalAncestors = ReadonlyArray<{\n    node: Node,\n    key: string,\n    index?: number,\n  }>;\n  export type TraversalHandler<T> = (\n    this: undefined, node: Node, parent: TraversalAncestors, type: T\n  ) => void;\n  export type TraversalHandlers<T> = {\n    enter?: TraversalHandler<T>,\n    exit?: TraversalHandler<T>,\n  };`.replace(/(^|\\n) {2}/g, \"$1\"), // eslint-disable-next-line\n`export function traverse<T>(n: Node, h: TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;`, `export function traverseFast<T>(n: Node, h: TraversalHandler<T>, state?: T): void;`, // utils/\n// cleanJSXElementLiteralChild is not exported\n// inherit is not exported\n`export function shallowEqual<T extends object>(actual: object, expected: T): actual is T`, // validators/\n// eslint-disable-next-line max-len\n`export function buildMatchMemberExpression(match: string, allowPartial?: boolean): (node: Node | null | undefined) => node is MemberExpression`, // eslint-disable-next-line max-len\n`export function is<T extends Node['type']>(type: T, n: Node | null | undefined, required?: undefined): n is Extract<Node, { type: T }>`, // eslint-disable-next-line max-len\n`export function is<T extends Node['type'], P extends Extract<Node, { type: T }>>(type: T, n: Node | null | undefined, required: Partial<P>): n is P`, // eslint-disable-next-line max-len\n`export function is<P extends Node>(type: string, n: Node | null | undefined, required: Partial<P>): n is P`, `export function is(type: string, n: Node | null | undefined, required?: Partial<Node>): n is Node`, `export function isBinding(node: Node, parent: Node, grandparent?: Node): boolean`, // eslint-disable-next-line max-len\n`export function isBlockScoped(node: Node): node is FunctionDeclaration | ClassDeclaration | VariableDeclaration`, `export function isImmutable(node: Node): node is Immutable`, `export function isLet(node: Node): node is VariableDeclaration`, `export function isNode(node: object | null | undefined): node is Node`, `export function isNodesEquivalent<T extends Partial<Node>>(a: T, b: any): b is T`, `export function isNodesEquivalent(a: any, b: any): boolean`, `export function isPlaceholderType(placeholderType: Node['type'], targetType: Node['type']): boolean`, `export function isReferenced(node: Node, parent: Node, grandparent?: Node): boolean`, `export function isScope(node: Node, parent: Node): node is Scopable`, `export function isSpecifierDefault(specifier: ModuleSpecifier): boolean`, `export function isType<T extends Node['type']>(nodetype: string, targetType: T): nodetype is T`, `export function isType(nodetype: string | null | undefined, targetType: string): boolean`, `export function isValidES3Identifier(name: string): boolean`, `export function isValidIdentifier(name: string): boolean`, `export function isVar(node: Node): node is VariableDeclaration`, // the MemberExpression implication is incidental, but it follows from the implementation\n// eslint-disable-next-line max-len\n`export function matchesPattern(node: Node | null | undefined, match: string | ReadonlyArray<string>, allowPartial?: boolean): node is MemberExpression`, // eslint-disable-next-line max-len\n`export function validate<T extends Node, K extends keyof T>(n: Node | null | undefined, key: K, value: T[K]): void;`, `export function validate(n: Node, key: string, value: any): void;`);\n\nfor (const type in t.DEPRECATED_KEYS) {\n  code += `/**\n * @deprecated Use \\`${t.DEPRECATED_KEYS[type]}\\`\n */\nexport type ${type} = ${t.DEPRECATED_KEYS[type]};\\n\n`;\n}\n\nfor (const type in t.FLIPPED_ALIAS_KEYS) {\n  const types = t.FLIPPED_ALIAS_KEYS[type];\n  code += `export type ${type} = ${types.map(type => `${type}`).join(\" | \")};\\n`;\n}\n\ncode += \"\\n\";\ncode += \"export interface Aliases {\\n\";\n\nfor (const type in t.FLIPPED_ALIAS_KEYS) {\n  code += `  ${type}: ${type};\\n`;\n}\n\ncode += \"}\\n\\n\";\ncode += lines.join(\"\\n\") + \"\\n\"; //\n\nprocess.stdout.write(code); //\n\nfunction areAllRemainingFieldsNullable(fieldName, fieldNames, fields) {\n  const index = fieldNames.indexOf(fieldName);\n  return fieldNames.slice(index).every(_ => isNullable(fields[_]));\n}\n\nfunction hasDefault(field) {\n  return field.default != null;\n}\n\nfunction isNullable(field) {\n  return field.optional || hasDefault(field);\n}\n\nfunction sortFieldNames(fields, type) {\n  return fields.sort((fieldA, fieldB) => {\n    const indexA = t.BUILDER_KEYS[type].indexOf(fieldA);\n    const indexB = t.BUILDER_KEYS[type].indexOf(fieldB);\n    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;\n    if (indexA === -1) return 1;\n    if (indexB === -1) return -1;\n    return indexA - indexB;\n  });\n}","map":{"version":3,"names":["t","stringifyValidator","toFunctionName","code","TYPES","sort","join","lines","type","NODE_FIELDS","fields","fieldNames","sortFieldNames","Object","keys","builderNames","BUILDER_KEYS","struct","args","forEach","fieldName","field","typeAnnotation","validate","isNullable","hasDefault","includes","areAllRemainingFieldsNullable","push","toBindingIdentifierName","alphaNumeric","isValidIdentifier","test","trim","functionName","typeName","isDeprecated","DEPRECATED_KEYS","realName","result","FLIPPED_ALIAS_KEYS","replace","types","map","process","stdout","write","index","indexOf","slice","every","_","default","optional","fieldA","fieldB","indexA","indexB"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/types/scripts/generators/typescript-legacy.js"],"sourcesContent":["import * as t from \"../../lib/index.js\";\nimport stringifyValidator from \"../utils/stringifyValidator.js\";\nimport toFunctionName from \"../utils/toFunctionName.js\";\n\nlet code = `// NOTE: This file is autogenerated. Do not modify.\n// See packages/babel-types/scripts/generators/typescript-legacy.js for script used.\n\ninterface BaseComment {\n  value: string;\n  start: number;\n  end: number;\n  loc: SourceLocation;\n  type: \"CommentBlock\" | \"CommentLine\";\n}\n\nexport interface CommentBlock extends BaseComment {\n  type: \"CommentBlock\";\n}\n\nexport interface CommentLine extends BaseComment {\n  type: \"CommentLine\";\n}\n\nexport type Comment = CommentBlock | CommentLine;\n\nexport interface SourceLocation {\n  start: {\n    line: number;\n    column: number;\n  };\n\n  end: {\n    line: number;\n    column: number;\n  };\n}\n\ninterface BaseNode {\n  leadingComments: ReadonlyArray<Comment> | null;\n  innerComments: ReadonlyArray<Comment> | null;\n  trailingComments: ReadonlyArray<Comment> | null;\n  start: number | null;\n  end: number | null;\n  loc: SourceLocation | null;\n  type: Node[\"type\"];\n  extra?: Record<string, unknown>;\n}\n\nexport type Node = ${t.TYPES.sort().join(\" | \")};\\n\\n`;\n\n//\n\nconst lines = [];\n\nfor (const type in t.NODE_FIELDS) {\n  const fields = t.NODE_FIELDS[type];\n  const fieldNames = sortFieldNames(Object.keys(t.NODE_FIELDS[type]), type);\n  const builderNames = t.BUILDER_KEYS[type];\n\n  const struct = ['type: \"' + type + '\";'];\n  const args = [];\n\n  fieldNames.forEach(fieldName => {\n    const field = fields[fieldName];\n    // Future / annoying TODO:\n    // MemberExpression.property, ObjectProperty.key and ObjectMethod.key need special cases; either:\n    // - convert the declaration to chain() like ClassProperty.key and ClassMethod.key,\n    // - declare an alias type for valid keys, detect the case and reuse it here,\n    // - declare a disjoint union with, for example, ObjectPropertyBase,\n    //   ObjectPropertyLiteralKey and ObjectPropertyComputedKey, and declare ObjectProperty\n    //   as \"ObjectPropertyBase & (ObjectPropertyLiteralKey | ObjectPropertyComputedKey)\"\n    let typeAnnotation = stringifyValidator(field.validate, \"\");\n\n    if (isNullable(field) && !hasDefault(field)) {\n      typeAnnotation += \" | null\";\n    }\n\n    if (builderNames.includes(fieldName)) {\n      if (areAllRemainingFieldsNullable(fieldName, builderNames, fields)) {\n        args.push(\n          `${t.toBindingIdentifierName(fieldName)}${\n            isNullable(field) ? \"?:\" : \":\"\n          } ${typeAnnotation}`\n        );\n      } else {\n        args.push(\n          `${t.toBindingIdentifierName(fieldName)}: ${typeAnnotation}${\n            isNullable(field) ? \" | undefined\" : \"\"\n          }`\n        );\n      }\n    }\n\n    const alphaNumeric = /^\\w+$/;\n\n    if (t.isValidIdentifier(fieldName) || alphaNumeric.test(fieldName)) {\n      struct.push(`${fieldName}: ${typeAnnotation};`);\n    } else {\n      struct.push(`\"${fieldName}\": ${typeAnnotation};`);\n    }\n  });\n\n  code += `export interface ${type} extends BaseNode {\n  ${struct.join(\"\\n  \").trim()}\n}\\n\\n`;\n\n  // super and import are reserved words in JavaScript\n  if (type !== \"Super\" && type !== \"Import\") {\n    lines.push(\n      `export function ${toFunctionName(type)}(${args.join(\", \")}): ${type};`\n    );\n  } else {\n    const functionName = toFunctionName(type);\n    lines.push(\n      `declare function _${functionName}(${args.join(\", \")}): ${type};`,\n      `export { _${functionName} as ${functionName}}`\n    );\n  }\n}\n\nfor (const typeName of t.TYPES) {\n  const isDeprecated = !!t.DEPRECATED_KEYS[typeName];\n  const realName = isDeprecated ? t.DEPRECATED_KEYS[typeName] : typeName;\n\n  const result =\n    t.NODE_FIELDS[realName] || t.FLIPPED_ALIAS_KEYS[realName]\n      ? `node is ${realName}`\n      : \"boolean\";\n\n  if (isDeprecated) {\n    lines.push(`/** @deprecated Use \\`is${realName}\\` */`);\n  }\n  lines.push(\n    `export function is${typeName}(node: object | null | undefined, opts?: object | null): ${result};`\n  );\n\n  if (isDeprecated) {\n    lines.push(`/** @deprecated Use \\`assert${realName}\\` */`);\n  }\n  lines.push(\n    `export function assert${typeName}(node: object | null | undefined, opts?: object | null): void;`\n  );\n}\n\nlines.push(\n  // assert/\n  `export function assertNode(obj: any): void`,\n\n  // builders/\n  // eslint-disable-next-line max-len\n  `export function createTypeAnnotationBasedOnTypeof(type: 'string' | 'number' | 'undefined' | 'boolean' | 'function' | 'object' | 'symbol'): StringTypeAnnotation | VoidTypeAnnotation | NumberTypeAnnotation | BooleanTypeAnnotation | GenericTypeAnnotation`,\n  `export function createUnionTypeAnnotation<T extends FlowType>(types: [T]): T`,\n  `export function createFlowUnionType<T extends FlowType>(types: [T]): T`,\n  // this probably misbehaves if there are 0 elements, and it's not a UnionTypeAnnotation if there's only 1\n  // it is possible to require \"2 or more\" for this overload ([T, T, ...T[]]) but it requires typescript 3.0\n  `export function createUnionTypeAnnotation(types: ReadonlyArray<FlowType>): UnionTypeAnnotation`,\n  `export function createFlowUnionType(types: ReadonlyArray<FlowType>): UnionTypeAnnotation`,\n  // this smells like \"internal API\"\n  // eslint-disable-next-line max-len\n  `export function buildChildren(node: { children: ReadonlyArray<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment | JSXEmptyExpression> }): JSXElement['children']`,\n\n  // clone/\n  `export function clone<T extends Node>(n: T): T;`,\n  `export function cloneDeep<T extends Node>(n: T): T;`,\n  `export function cloneDeepWithoutLoc<T extends Node>(n: T): T;`,\n  `export function cloneNode<T extends Node>(n: T, deep?: boolean, withoutLoc?: boolean): T;`,\n  `export function cloneWithoutLoc<T extends Node>(n: T): T;`,\n\n  // comments/\n  `export type CommentTypeShorthand = 'leading' | 'inner' | 'trailing'`,\n  // eslint-disable-next-line max-len\n  `export function addComment<T extends Node>(node: T, type: CommentTypeShorthand, content: string, line?: boolean): T`,\n  // eslint-disable-next-line max-len\n  `export function addComments<T extends Node>(node: T, type: CommentTypeShorthand, comments: ReadonlyArray<Comment>): T`,\n  `export function inheritInnerComments(node: Node, parent: Node): void`,\n  `export function inheritLeadingComments(node: Node, parent: Node): void`,\n  `export function inheritsComments<T extends Node>(node: T, parent: Node): void`,\n  `export function inheritTrailingComments(node: Node, parent: Node): void`,\n  `export function removeComments<T extends Node>(node: T): T`,\n\n  // converters/\n  // eslint-disable-next-line max-len\n  `export function ensureBlock(node: Extract<Node, { body: BlockStatement | Statement | Expression }>): BlockStatement`,\n  // too complex?\n  // eslint-disable-next-line max-len\n  `export function ensureBlock<K extends keyof Extract<Node, { body: BlockStatement | Statement | Expression }> = 'body'>(node: Extract<Node, Record<K, BlockStatement | Statement | Expression>>, key: K): BlockStatement`,\n  // gatherSequenceExpressions is not exported\n  `export function toBindingIdentifierName(name: { toString(): string } | null | undefined): string`,\n  `export function toBlock(node: Statement | Expression, parent?: Function | null): BlockStatement`,\n  // it is possible for `node` to be an arbitrary object if `key` is always provided,\n  // but that doesn't look like intended API\n  // eslint-disable-next-line max-len\n  `export function toComputedKey<T extends Extract<Node, { computed: boolean | null }>>(node: T, key?: Expression | Identifier): Expression`,\n  `export function toExpression(node: Function): FunctionExpression`,\n  `export function toExpression(node: Class): ClassExpression`,\n  `export function toExpression(node: ExpressionStatement | Expression | Class | Function): Expression`,\n  `export function toIdentifier(name: { toString(): string } | null | undefined): string`,\n  `export function toKeyAlias(node: Method | Property, key?: Node): string`,\n  // NOTE: this actually uses Scope from @babel/traverse, but we can't add a dependency on its types,\n  // as they live in @types. Declare the structural subset that is required.\n  // eslint-disable-next-line max-len\n  `export function toSequenceExpression(nodes: ReadonlyArray<Node>, scope: { push(value: { id: LVal; kind: 'var'; init?: Expression}): void; buildUndefinedNode(): Node }): SequenceExpression | undefined`,\n  `export function toStatement(node: AssignmentExpression, ignore?: boolean): ExpressionStatement`,\n  `export function toStatement(node: Statement | AssignmentExpression, ignore?: boolean): Statement`,\n  `export function toStatement(node: Class, ignore: true): ClassDeclaration | undefined`,\n  `export function toStatement(node: Class, ignore?: boolean): ClassDeclaration`,\n  `export function toStatement(node: Function, ignore: true): FunctionDeclaration | undefined`,\n  `export function toStatement(node: Function, ignore?: boolean): FunctionDeclaration`,\n  // eslint-disable-next-line max-len\n  `export function toStatement(node: Statement | Class | Function | AssignmentExpression, ignore: true): Statement | undefined`,\n  // eslint-disable-next-line max-len\n  `export function toStatement(node: Statement | Class | Function | AssignmentExpression, ignore?: boolean): Statement`,\n  // eslint-disable-next-line max-len\n  `export function valueToNode(value: undefined): Identifier`, // (should this not be a UnaryExpression to avoid shadowing?)\n  `export function valueToNode(value: boolean): BooleanLiteral`,\n  `export function valueToNode(value: null): NullLiteral`,\n  `export function valueToNode(value: string): StringLiteral`,\n  // Infinities and NaN need to use a BinaryExpression; negative values must be wrapped in UnaryExpression\n  `export function valueToNode(value: number): NumericLiteral | BinaryExpression | UnaryExpression`,\n  `export function valueToNode(value: RegExp): RegExpLiteral`,\n  // eslint-disable-next-line max-len\n  `export function valueToNode(value: ReadonlyArray<undefined | boolean | null | string | number | RegExp | object>): ArrayExpression`,\n  // this throws with objects that are not PlainObject according to lodash,\n  // or if there are non-valueToNode-able values\n  `export function valueToNode(value: object): ObjectExpression`,\n  // eslint-disable-next-line max-len\n  `export function valueToNode(value: undefined | boolean | null | string | number | RegExp | object): Expression`,\n\n  // modifications/\n  // eslint-disable-next-line max-len\n  `export function removeTypeDuplicates(types: ReadonlyArray<FlowType | false | null | undefined>): FlowType[]`,\n  // eslint-disable-next-line max-len\n  `export function appendToMemberExpression<T extends Pick<MemberExpression, 'object' | 'property'>>(member: T, append: MemberExpression['property'], computed?: boolean): T`,\n  // eslint-disable-next-line max-len\n  `export function inherits<T extends Node | null | undefined>(child: T, parent: Node | null | undefined): T`,\n  // eslint-disable-next-line max-len\n  `export function prependToMemberExpression<T extends Pick<MemberExpression, 'object' | 'property'>>(member: T, prepend: MemberExpression['object']): T`,\n  `export function removeProperties(\n  n: Node,\n  opts?: { preserveComments: boolean } | null\n): void;`,\n  `export function removePropertiesDeep<T extends Node>(\n  n: T,\n  opts?: { preserveComments: boolean } | null\n): T;`,\n\n  // retrievers/\n  // eslint-disable-next-line max-len\n  `export function getBindingIdentifiers(node: Node, duplicates: true, outerOnly?: boolean): Record<string, Array<Identifier>>`,\n  // eslint-disable-next-line max-len\n  `export function getBindingIdentifiers(node: Node, duplicates?: false, outerOnly?: boolean): Record<string, Identifier>`,\n  // eslint-disable-next-line max-len\n  `export function getBindingIdentifiers(node: Node, duplicates: boolean, outerOnly?: boolean): Record<string, Identifier | Array<Identifier>>`,\n  // eslint-disable-next-line max-len\n  `export function getOuterBindingIdentifiers(node: Node, duplicates: true): Record<string, Array<Identifier>>`,\n  `export function getOuterBindingIdentifiers(node: Node, duplicates?: false): Record<string, Identifier>`,\n  // eslint-disable-next-line max-len\n  `export function getOuterBindingIdentifiers(node: Node, duplicates: boolean): Record<string, Identifier | Array<Identifier>>`,\n\n  // traverse/\n  `export type TraversalAncestors = ReadonlyArray<{\n    node: Node,\n    key: string,\n    index?: number,\n  }>;\n  export type TraversalHandler<T> = (\n    this: undefined, node: Node, parent: TraversalAncestors, type: T\n  ) => void;\n  export type TraversalHandlers<T> = {\n    enter?: TraversalHandler<T>,\n    exit?: TraversalHandler<T>,\n  };`.replace(/(^|\\n) {2}/g, \"$1\"),\n  // eslint-disable-next-line\n  `export function traverse<T>(n: Node, h: TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;`,\n  `export function traverseFast<T>(n: Node, h: TraversalHandler<T>, state?: T): void;`,\n\n  // utils/\n  // cleanJSXElementLiteralChild is not exported\n  // inherit is not exported\n  `export function shallowEqual<T extends object>(actual: object, expected: T): actual is T`,\n\n  // validators/\n  // eslint-disable-next-line max-len\n  `export function buildMatchMemberExpression(match: string, allowPartial?: boolean): (node: Node | null | undefined) => node is MemberExpression`,\n  // eslint-disable-next-line max-len\n  `export function is<T extends Node['type']>(type: T, n: Node | null | undefined, required?: undefined): n is Extract<Node, { type: T }>`,\n  // eslint-disable-next-line max-len\n  `export function is<T extends Node['type'], P extends Extract<Node, { type: T }>>(type: T, n: Node | null | undefined, required: Partial<P>): n is P`,\n  // eslint-disable-next-line max-len\n  `export function is<P extends Node>(type: string, n: Node | null | undefined, required: Partial<P>): n is P`,\n  `export function is(type: string, n: Node | null | undefined, required?: Partial<Node>): n is Node`,\n  `export function isBinding(node: Node, parent: Node, grandparent?: Node): boolean`,\n  // eslint-disable-next-line max-len\n  `export function isBlockScoped(node: Node): node is FunctionDeclaration | ClassDeclaration | VariableDeclaration`,\n  `export function isImmutable(node: Node): node is Immutable`,\n  `export function isLet(node: Node): node is VariableDeclaration`,\n  `export function isNode(node: object | null | undefined): node is Node`,\n  `export function isNodesEquivalent<T extends Partial<Node>>(a: T, b: any): b is T`,\n  `export function isNodesEquivalent(a: any, b: any): boolean`,\n  `export function isPlaceholderType(placeholderType: Node['type'], targetType: Node['type']): boolean`,\n  `export function isReferenced(node: Node, parent: Node, grandparent?: Node): boolean`,\n  `export function isScope(node: Node, parent: Node): node is Scopable`,\n  `export function isSpecifierDefault(specifier: ModuleSpecifier): boolean`,\n  `export function isType<T extends Node['type']>(nodetype: string, targetType: T): nodetype is T`,\n  `export function isType(nodetype: string | null | undefined, targetType: string): boolean`,\n  `export function isValidES3Identifier(name: string): boolean`,\n  `export function isValidIdentifier(name: string): boolean`,\n  `export function isVar(node: Node): node is VariableDeclaration`,\n  // the MemberExpression implication is incidental, but it follows from the implementation\n  // eslint-disable-next-line max-len\n  `export function matchesPattern(node: Node | null | undefined, match: string | ReadonlyArray<string>, allowPartial?: boolean): node is MemberExpression`,\n  // eslint-disable-next-line max-len\n  `export function validate<T extends Node, K extends keyof T>(n: Node | null | undefined, key: K, value: T[K]): void;`,\n  `export function validate(n: Node, key: string, value: any): void;`\n);\n\nfor (const type in t.DEPRECATED_KEYS) {\n  code += `/**\n * @deprecated Use \\`${t.DEPRECATED_KEYS[type]}\\`\n */\nexport type ${type} = ${t.DEPRECATED_KEYS[type]};\\n\n`;\n}\n\nfor (const type in t.FLIPPED_ALIAS_KEYS) {\n  const types = t.FLIPPED_ALIAS_KEYS[type];\n  code += `export type ${type} = ${types\n    .map(type => `${type}`)\n    .join(\" | \")};\\n`;\n}\ncode += \"\\n\";\n\ncode += \"export interface Aliases {\\n\";\nfor (const type in t.FLIPPED_ALIAS_KEYS) {\n  code += `  ${type}: ${type};\\n`;\n}\ncode += \"}\\n\\n\";\n\ncode += lines.join(\"\\n\") + \"\\n\";\n\n//\n\nprocess.stdout.write(code);\n\n//\n\nfunction areAllRemainingFieldsNullable(fieldName, fieldNames, fields) {\n  const index = fieldNames.indexOf(fieldName);\n  return fieldNames.slice(index).every(_ => isNullable(fields[_]));\n}\n\nfunction hasDefault(field) {\n  return field.default != null;\n}\n\nfunction isNullable(field) {\n  return field.optional || hasDefault(field);\n}\n\nfunction sortFieldNames(fields, type) {\n  return fields.sort((fieldA, fieldB) => {\n    const indexA = t.BUILDER_KEYS[type].indexOf(fieldA);\n    const indexB = t.BUILDER_KEYS[type].indexOf(fieldB);\n    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;\n    if (indexA === -1) return 1;\n    if (indexB === -1) return -1;\n    return indexA - indexB;\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}