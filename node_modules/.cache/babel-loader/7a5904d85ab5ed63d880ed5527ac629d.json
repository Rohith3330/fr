{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _mapGenerator = _interopRequireDefault(require(\"./map-generator\"));\n\nvar _stringify2 = _interopRequireDefault(require(\"./stringify\"));\n\nvar _warnOnce = _interopRequireDefault(require(\"./warn-once\"));\n\nvar _result = _interopRequireDefault(require(\"./result\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction isPromise(obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function';\n}\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([autoprefixer]).process(css)\n */\n\n\nvar LazyResult = /*#__PURE__*/function () {\n  function LazyResult(processor, css, opts) {\n    this.stringified = false;\n    this.processed = false;\n    var root;\n\n    if (typeof css === 'object' && css !== null && css.type === 'root') {\n      root = css;\n    } else if (css instanceof LazyResult || css instanceof _result.default) {\n      root = css.root;\n\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = {};\n        if (!opts.map.inline) opts.map.inline = false;\n        opts.map.prev = css.map;\n      }\n    } else {\n      var parser = _parse.default;\n      if (opts.syntax) parser = opts.syntax.parse;\n      if (opts.parser) parser = opts.parser;\n      if (parser.parse) parser = parser.parse;\n\n      try {\n        root = parser(css, opts);\n      } catch (error) {\n        this.error = error;\n      }\n    }\n\n    this.result = new _result.default(processor, root, opts);\n  }\n  /**\n   * Returns a {@link Processor} instance, which will be used\n   * for CSS transformations.\n   *\n   * @type {Processor}\n   */\n\n\n  var _proto = LazyResult.prototype;\n  /**\n   * Processes input CSS through synchronous plugins\n   * and calls {@link Result#warnings()}.\n   *\n   * @return {Warning[]} Warnings from plugins.\n   */\n\n  _proto.warnings = function warnings() {\n    return this.sync().warnings();\n  }\n  /**\n   * Alias for the {@link LazyResult#css} property.\n   *\n   * @example\n   * lazy + '' === lazy.css\n   *\n   * @return {string} Output CSS.\n   */\n  ;\n\n  _proto.toString = function toString() {\n    return this.css;\n  }\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls `onFulfilled` with a Result instance. If a plugin throws\n   * an error, the `onRejected` callback will be executed.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFulfilled} onFulfilled Callback will be executed\n   *                                  when all plugins will finish work.\n   * @param {onRejected}  onRejected  Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {\n   *   console.log(result.css)\n   * })\n   */\n  ;\n\n  _proto.then = function then(onFulfilled, onRejected) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!('from' in this.opts)) {\n        (0, _warnOnce.default)('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');\n      }\n    }\n\n    return this.async().then(onFulfilled, onRejected);\n  }\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onRejected for each error thrown in any plugin.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onRejected} onRejected Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).then(result => {\n   *   console.log(result.css)\n   * }).catch(error => {\n   *   console.error(error)\n   * })\n   */\n  ;\n\n  _proto.catch = function _catch(onRejected) {\n    return this.async().catch(onRejected);\n  }\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onFinally on any error or when all plugins will finish work.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFinally} onFinally Callback will be executed on any error or\n   *                              when all plugins will finish work.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).finally(() => {\n   *   console.log('processing ended')\n   * })\n   */\n  ;\n\n  _proto.finally = function _finally(onFinally) {\n    return this.async().then(onFinally, onFinally);\n  };\n\n  _proto.handleError = function handleError(error, plugin) {\n    try {\n      this.error = error;\n\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin;\n        error.setMessage();\n      } else if (plugin.postcssVersion) {\n        if (process.env.NODE_ENV !== 'production') {\n          var pluginName = plugin.postcssPlugin;\n          var pluginVer = plugin.postcssVersion;\n          var runtimeVer = this.result.processor.version;\n          var a = pluginVer.split('.');\n          var b = runtimeVer.split('.');\n\n          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n            console.error('Unknown error from PostCSS plugin. Your current PostCSS ' + 'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' + pluginVer + '. Perhaps this is the source of the error below.');\n          }\n        }\n      }\n    } catch (err) {\n      if (console && console.error) console.error(err);\n    }\n  };\n\n  _proto.asyncTick = function asyncTick(resolve, reject) {\n    var _this = this;\n\n    if (this.plugin >= this.processor.plugins.length) {\n      this.processed = true;\n      return resolve();\n    }\n\n    try {\n      var plugin = this.processor.plugins[this.plugin];\n      var promise = this.run(plugin);\n      this.plugin += 1;\n\n      if (isPromise(promise)) {\n        promise.then(function () {\n          _this.asyncTick(resolve, reject);\n        }).catch(function (error) {\n          _this.handleError(error, plugin);\n\n          _this.processed = true;\n          reject(error);\n        });\n      } else {\n        this.asyncTick(resolve, reject);\n      }\n    } catch (error) {\n      this.processed = true;\n      reject(error);\n    }\n  };\n\n  _proto.async = function async() {\n    var _this2 = this;\n\n    if (this.processed) {\n      return new Promise(function (resolve, reject) {\n        if (_this2.error) {\n          reject(_this2.error);\n        } else {\n          resolve(_this2.stringify());\n        }\n      });\n    }\n\n    if (this.processing) {\n      return this.processing;\n    }\n\n    this.processing = new Promise(function (resolve, reject) {\n      if (_this2.error) return reject(_this2.error);\n      _this2.plugin = 0;\n\n      _this2.asyncTick(resolve, reject);\n    }).then(function () {\n      _this2.processed = true;\n      return _this2.stringify();\n    });\n    return this.processing;\n  };\n\n  _proto.sync = function sync() {\n    if (this.processed) return this.result;\n    this.processed = true;\n\n    if (this.processing) {\n      throw new Error('Use process(css).then(cb) to work with async plugins');\n    }\n\n    if (this.error) throw this.error;\n\n    for (var _iterator = _createForOfIteratorHelperLoose(this.result.processor.plugins), _step; !(_step = _iterator()).done;) {\n      var plugin = _step.value;\n      var promise = this.run(plugin);\n\n      if (isPromise(promise)) {\n        throw new Error('Use process(css).then(cb) to work with async plugins');\n      }\n    }\n\n    return this.result;\n  };\n\n  _proto.run = function run(plugin) {\n    this.result.lastPlugin = plugin;\n\n    try {\n      return plugin(this.result.root, this.result);\n    } catch (error) {\n      this.handleError(error, plugin);\n      throw error;\n    }\n  };\n\n  _proto.stringify = function stringify() {\n    if (this.stringified) return this.result;\n    this.stringified = true;\n    this.sync();\n    var opts = this.result.opts;\n    var str = _stringify2.default;\n    if (opts.syntax) str = opts.syntax.stringify;\n    if (opts.stringifier) str = opts.stringifier;\n    if (str.stringify) str = str.stringify;\n    var map = new _mapGenerator.default(str, this.result.root, this.result.opts);\n    var data = map.generate();\n    this.result.css = data[0];\n    this.result.map = data[1];\n    return this.result;\n  };\n\n  _createClass(LazyResult, [{\n    key: \"processor\",\n    get: function get() {\n      return this.result.processor;\n    }\n    /**\n     * Options from the {@link Processor#process} call.\n     *\n     * @type {processOptions}\n     */\n\n  }, {\n    key: \"opts\",\n    get: function get() {\n      return this.result.opts;\n    }\n    /**\n     * Processes input CSS through synchronous plugins, converts `Root`\n     * to a CSS string and returns {@link Result#css}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#css\n     */\n\n  }, {\n    key: \"css\",\n    get: function get() {\n      return this.stringify().css;\n    }\n    /**\n     * An alias for the `css` property. Use it with syntaxes\n     * that generate non-CSS output.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#content\n     */\n\n  }, {\n    key: \"content\",\n    get: function get() {\n      return this.stringify().content;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#map}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {SourceMapGenerator}\n     * @see Result#map\n     */\n\n  }, {\n    key: \"map\",\n    get: function get() {\n      return this.stringify().map;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#root}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Root}\n     * @see Result#root\n     */\n\n  }, {\n    key: \"root\",\n    get: function get() {\n      return this.sync().root;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#messages}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Message[]}\n     * @see Result#messages\n     */\n\n  }, {\n    key: \"messages\",\n    get: function get() {\n      return this.sync().messages;\n    }\n  }]);\n\n  return LazyResult;\n}();\n\nvar _default = LazyResult;\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"mappings":"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","names":["isPromise","obj","then","LazyResult","processor","css","opts","stringified","processed","root","type","Result","map","inline","prev","parser","parse","syntax","error","result","warnings","sync","toString","onFulfilled","onRejected","process","env","NODE_ENV","async","catch","finally","onFinally","handleError","plugin","name","postcssPlugin","setMessage","postcssVersion","pluginName","pluginVer","runtimeVer","version","a","split","b","parseInt","console","err","asyncTick","resolve","reject","plugins","length","promise","run","_this","Promise","_this2","stringify","processing","Error","lastPlugin","str","stringifier","MapGenerator","data","generate","content","messages"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\resolve-url-loader\\node_modules\\postcss\\lib\\lazy-result.es6"],"sourcesContent":["import MapGenerator from './map-generator'\nimport stringify from './stringify'\nimport warnOnce from './warn-once'\nimport Result from './result'\nimport parse from './parse'\n\nfunction isPromise (obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function'\n}\n\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([autoprefixer]).process(css)\n */\nclass LazyResult {\n  constructor (processor, css, opts) {\n    this.stringified = false\n    this.processed = false\n\n    let root\n    if (typeof css === 'object' && css !== null && css.type === 'root') {\n      root = css\n    } else if (css instanceof LazyResult || css instanceof Result) {\n      root = css.root\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = { }\n        if (!opts.map.inline) opts.map.inline = false\n        opts.map.prev = css.map\n      }\n    } else {\n      let parser = parse\n      if (opts.syntax) parser = opts.syntax.parse\n      if (opts.parser) parser = opts.parser\n      if (parser.parse) parser = parser.parse\n\n      try {\n        root = parser(css, opts)\n      } catch (error) {\n        this.error = error\n      }\n    }\n\n    this.result = new Result(processor, root, opts)\n  }\n\n  /**\n   * Returns a {@link Processor} instance, which will be used\n   * for CSS transformations.\n   *\n   * @type {Processor}\n   */\n  get processor () {\n    return this.result.processor\n  }\n\n  /**\n   * Options from the {@link Processor#process} call.\n   *\n   * @type {processOptions}\n   */\n  get opts () {\n    return this.result.opts\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins, converts `Root`\n   * to a CSS string and returns {@link Result#css}.\n   *\n   * This property will only work with synchronous plugins.\n   * If the processor contains any asynchronous plugins\n   * it will throw an error. This is why this method is only\n   * for debug purpose, you should always use {@link LazyResult#then}.\n   *\n   * @type {string}\n   * @see Result#css\n   */\n  get css () {\n    return this.stringify().css\n  }\n\n  /**\n   * An alias for the `css` property. Use it with syntaxes\n   * that generate non-CSS output.\n   *\n   * This property will only work with synchronous plugins.\n   * If the processor contains any asynchronous plugins\n   * it will throw an error. This is why this method is only\n   * for debug purpose, you should always use {@link LazyResult#then}.\n   *\n   * @type {string}\n   * @see Result#content\n   */\n  get content () {\n    return this.stringify().content\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and returns {@link Result#map}.\n   *\n   * This property will only work with synchronous plugins.\n   * If the processor contains any asynchronous plugins\n   * it will throw an error. This is why this method is only\n   * for debug purpose, you should always use {@link LazyResult#then}.\n   *\n   * @type {SourceMapGenerator}\n   * @see Result#map\n   */\n  get map () {\n    return this.stringify().map\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and returns {@link Result#root}.\n   *\n   * This property will only work with synchronous plugins. If the processor\n   * contains any asynchronous plugins it will throw an error.\n   *\n   * This is why this method is only for debug purpose,\n   * you should always use {@link LazyResult#then}.\n   *\n   * @type {Root}\n   * @see Result#root\n   */\n  get root () {\n    return this.sync().root\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and returns {@link Result#messages}.\n   *\n   * This property will only work with synchronous plugins. If the processor\n   * contains any asynchronous plugins it will throw an error.\n   *\n   * This is why this method is only for debug purpose,\n   * you should always use {@link LazyResult#then}.\n   *\n   * @type {Message[]}\n   * @see Result#messages\n   */\n  get messages () {\n    return this.sync().messages\n  }\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and calls {@link Result#warnings()}.\n   *\n   * @return {Warning[]} Warnings from plugins.\n   */\n  warnings () {\n    return this.sync().warnings()\n  }\n\n  /**\n   * Alias for the {@link LazyResult#css} property.\n   *\n   * @example\n   * lazy + '' === lazy.css\n   *\n   * @return {string} Output CSS.\n   */\n  toString () {\n    return this.css\n  }\n\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls `onFulfilled` with a Result instance. If a plugin throws\n   * an error, the `onRejected` callback will be executed.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFulfilled} onFulfilled Callback will be executed\n   *                                  when all plugins will finish work.\n   * @param {onRejected}  onRejected  Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {\n   *   console.log(result.css)\n   * })\n   */\n  then (onFulfilled, onRejected) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!('from' in this.opts)) {\n        warnOnce(\n          'Without `from` option PostCSS could generate wrong source map ' +\n          'and will not find Browserslist config. Set it to CSS file path ' +\n          'or to `undefined` to prevent this warning.'\n        )\n      }\n    }\n    return this.async().then(onFulfilled, onRejected)\n  }\n\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onRejected for each error thrown in any plugin.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onRejected} onRejected Callback will be executed on any error.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).then(result => {\n   *   console.log(result.css)\n   * }).catch(error => {\n   *   console.error(error)\n   * })\n   */\n  catch (onRejected) {\n    return this.async().catch(onRejected)\n  }\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onFinally on any error or when all plugins will finish work.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFinally} onFinally Callback will be executed on any error or\n   *                              when all plugins will finish work.\n   *\n   * @return {Promise} Promise API to make queue.\n   *\n   * @example\n   * postcss([autoprefixer]).process(css).finally(() => {\n   *   console.log('processing ended')\n   * })\n   */\n  finally (onFinally) {\n    return this.async().then(onFinally, onFinally)\n  }\n\n  handleError (error, plugin) {\n    try {\n      this.error = error\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin\n        error.setMessage()\n      } else if (plugin.postcssVersion) {\n        if (process.env.NODE_ENV !== 'production') {\n          let pluginName = plugin.postcssPlugin\n          let pluginVer = plugin.postcssVersion\n          let runtimeVer = this.result.processor.version\n          let a = pluginVer.split('.')\n          let b = runtimeVer.split('.')\n\n          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n            console.error(\n              'Unknown error from PostCSS plugin. Your current PostCSS ' +\n              'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' +\n              pluginVer + '. Perhaps this is the source of the error below.'\n            )\n          }\n        }\n      }\n    } catch (err) {\n      if (console && console.error) console.error(err)\n    }\n  }\n\n  asyncTick (resolve, reject) {\n    if (this.plugin >= this.processor.plugins.length) {\n      this.processed = true\n      return resolve()\n    }\n\n    try {\n      let plugin = this.processor.plugins[this.plugin]\n      let promise = this.run(plugin)\n      this.plugin += 1\n\n      if (isPromise(promise)) {\n        promise.then(() => {\n          this.asyncTick(resolve, reject)\n        }).catch(error => {\n          this.handleError(error, plugin)\n          this.processed = true\n          reject(error)\n        })\n      } else {\n        this.asyncTick(resolve, reject)\n      }\n    } catch (error) {\n      this.processed = true\n      reject(error)\n    }\n  }\n\n  async () {\n    if (this.processed) {\n      return new Promise((resolve, reject) => {\n        if (this.error) {\n          reject(this.error)\n        } else {\n          resolve(this.stringify())\n        }\n      })\n    }\n    if (this.processing) {\n      return this.processing\n    }\n\n    this.processing = new Promise((resolve, reject) => {\n      if (this.error) return reject(this.error)\n      this.plugin = 0\n      this.asyncTick(resolve, reject)\n    }).then(() => {\n      this.processed = true\n      return this.stringify()\n    })\n\n    return this.processing\n  }\n\n  sync () {\n    if (this.processed) return this.result\n    this.processed = true\n\n    if (this.processing) {\n      throw new Error(\n        'Use process(css).then(cb) to work with async plugins')\n    }\n\n    if (this.error) throw this.error\n\n    for (let plugin of this.result.processor.plugins) {\n      let promise = this.run(plugin)\n      if (isPromise(promise)) {\n        throw new Error(\n          'Use process(css).then(cb) to work with async plugins')\n      }\n    }\n\n    return this.result\n  }\n\n  run (plugin) {\n    this.result.lastPlugin = plugin\n\n    try {\n      return plugin(this.result.root, this.result)\n    } catch (error) {\n      this.handleError(error, plugin)\n      throw error\n    }\n  }\n\n  stringify () {\n    if (this.stringified) return this.result\n    this.stringified = true\n\n    this.sync()\n\n    let opts = this.result.opts\n    let str = stringify\n    if (opts.syntax) str = opts.syntax.stringify\n    if (opts.stringifier) str = opts.stringifier\n    if (str.stringify) str = str.stringify\n\n    let map = new MapGenerator(str, this.result.root, this.result.opts)\n    let data = map.generate()\n    this.result.css = data[0]\n    this.result.map = data[1]\n\n    return this.result\n  }\n}\n\nexport default LazyResult\n\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n"]},"metadata":{},"sourceType":"script"}