{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport assert from \"assert\";\nimport { getTypes } from \"./util.js\";\nconst mMap = new WeakMap();\n\nfunction m(node) {\n  if (!mMap.has(node)) {\n    mMap.set(node, {});\n  }\n\n  return mMap.get(node);\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    const t = getTypes();\n    t.assertNode(node); // Assume no side effects until we find out otherwise.\n\n    let result = false;\n\n    function check(child) {\n      if (result) {// Do nothing.\n      } else if (Array.isArray(child)) {\n        child.some(check);\n      } else if (t.isNode(child)) {\n        assert.strictEqual(result, false);\n        result = predicate(child);\n      }\n\n      return result;\n    }\n\n    let keys = t.VISITOR_KEYS[node.type];\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        let key = keys[i];\n        let child = node[key];\n        check(child);\n      }\n    }\n\n    return result;\n  }\n\n  function predicate(node) {\n    getTypes().assertNode(node);\n    let meta = m(node);\n    if (hasOwn.call(meta, propertyName)) return meta[propertyName]; // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n\n    if (hasOwn.call(opaqueTypes, node.type)) return meta[propertyName] = false;\n    if (hasOwn.call(knownTypes, node.type)) return meta[propertyName] = true;\n    return meta[propertyName] = onlyChildren(node);\n  }\n\n  predicate.onlyChildren = onlyChildren;\n  return predicate;\n}\n\nlet opaqueTypes = {\n  FunctionExpression: true,\n  ArrowFunctionExpression: true\n}; // These types potentially have side effects regardless of what side\n// effects their subexpressions have.\n\nlet sideEffectTypes = {\n  CallExpression: true,\n  // Anything could happen!\n  ForInStatement: true,\n  // Modifies the key variable.\n  UnaryExpression: true,\n  // Think delete.\n  BinaryExpression: true,\n  // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true,\n  // Side-effecting by definition.\n  UpdateExpression: true,\n  // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n\n}; // These types are the direct cause of all leaps in control flow.\n\nlet leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n}; // All leap types are also side effect types.\n\nfor (let type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\n\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);","map":{"version":3,"names":["assert","getTypes","mMap","WeakMap","m","node","has","set","get","hasOwn","Object","prototype","hasOwnProperty","makePredicate","propertyName","knownTypes","onlyChildren","t","assertNode","result","check","child","Array","isArray","some","isNode","strictEqual","predicate","keys","VISITOR_KEYS","type","i","length","key","meta","call","opaqueTypes","FunctionExpression","ArrowFunctionExpression","sideEffectTypes","CallExpression","ForInStatement","UnaryExpression","BinaryExpression","AssignmentExpression","UpdateExpression","NewExpression","leapTypes","YieldExpression","BreakStatement","ContinueStatement","ReturnStatement","ThrowStatement","exports","hasSideEffects","containsLeap"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/regenerator-transform/src/meta.js"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport assert from \"assert\";\nimport { getTypes } from \"./util.js\";\n\nconst mMap = new WeakMap();\nfunction m(node) {\n  if (!mMap.has(node)) {\n    mMap.set(node, {});\n  }\n  return mMap.get(node);\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    const t = getTypes();\n    t.assertNode(node);\n\n    // Assume no side effects until we find out otherwise.\n    let result = false;\n\n    function check(child) {\n      if (result) {\n        // Do nothing.\n      } else if (Array.isArray(child)) {\n        child.some(check);\n      } else if (t.isNode(child)) {\n        assert.strictEqual(result, false);\n        result = predicate(child);\n      }\n      return result;\n    }\n\n    let keys = t.VISITOR_KEYS[node.type];\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        let key = keys[i];\n        let child = node[key];\n        check(child);\n      }\n    }\n\n    return result;\n  }\n\n  function predicate(node) {\n    getTypes().assertNode(node);\n\n    let meta = m(node);\n    if (hasOwn.call(meta, propertyName))\n      return meta[propertyName];\n\n    // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n    if (hasOwn.call(opaqueTypes, node.type))\n      return meta[propertyName] = false;\n\n    if (hasOwn.call(knownTypes, node.type))\n      return meta[propertyName] = true;\n\n    return meta[propertyName] = onlyChildren(node);\n  }\n\n  predicate.onlyChildren = onlyChildren;\n\n  return predicate;\n}\n\nlet opaqueTypes = {\n  FunctionExpression: true,\n  ArrowFunctionExpression: true\n};\n\n// These types potentially have side effects regardless of what side\n// effects their subexpressions have.\nlet sideEffectTypes = {\n  CallExpression: true, // Anything could happen!\n  ForInStatement: true, // Modifies the key variable.\n  UnaryExpression: true, // Think delete.\n  BinaryExpression: true, // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true, // Side-effecting by definition.\n  UpdateExpression: true, // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n};\n\n// These types are the direct cause of all leaps in control flow.\nlet leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n};\n\n// All leap types are also side effect types.\nfor (let type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\n\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}