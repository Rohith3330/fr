{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _util_1 = require(\"./_util\");\n\nfunction getDef(opts) {\n  return {\n    keyword: \"deepProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    macro: function (schema) {\n      const allOf = [];\n\n      for (const pointer in schema) allOf.push(getSchema(pointer, schema[pointer]));\n\n      return {\n        allOf\n      };\n    },\n    metaSchema: {\n      type: \"object\",\n      propertyNames: {\n        type: \"string\",\n        format: \"json-pointer\"\n      },\n      additionalProperties: (0, _util_1.metaSchemaRef)(opts)\n    }\n  };\n}\n\nexports.default = getDef;\n\nfunction getSchema(jsonPointer, schema) {\n  const segments = jsonPointer.split(\"/\");\n  const rootSchema = {};\n  let pointerSchema = rootSchema;\n\n  for (let i = 1; i < segments.length; i++) {\n    let segment = segments[i];\n    const isLast = i === segments.length - 1;\n    segment = unescapeJsonPointer(segment);\n    const properties = pointerSchema.properties = {};\n    let items;\n\n    if (/[0-9]+/.test(segment)) {\n      let count = +segment;\n      items = pointerSchema.items = [];\n      pointerSchema.type = [\"object\", \"array\"];\n\n      while (count--) items.push({});\n    } else {\n      pointerSchema.type = \"object\";\n    }\n\n    pointerSchema = isLast ? schema : {};\n    properties[segment] = pointerSchema;\n    if (items) items.push(pointerSchema);\n  }\n\n  return rootSchema;\n}\n\nfunction unescapeJsonPointer(str) {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n\nmodule.exports = getDef;","map":{"version":3,"mappings":";;;;;;AAEA;;AAEA,SAAwBA,MAAxB,CAA+BC,IAA/B,EAAuD;EACrD,OAAO;IACLC,OAAO,EAAE,gBADJ;IAELC,IAAI,EAAE,QAFD;IAGLC,UAAU,EAAE,QAHP;IAILC,KAAK,EAAE,UAAUC,MAAV,EAA8C;MACnD,MAAMC,KAAK,GAAG,EAAd;;MACA,KAAK,MAAMC,OAAX,IAAsBF,MAAtB,EAA8BC,KAAK,CAACE,IAAN,CAAWC,SAAS,CAACF,OAAD,EAAUF,MAAM,CAACE,OAAD,CAAhB,CAApB;;MAC9B,OAAO;QAACD;MAAD,CAAP;IACD,CARI;IASLI,UAAU,EAAE;MACVR,IAAI,EAAE,QADI;MAEVS,aAAa,EAAE;QAACT,IAAI,EAAE,QAAP;QAAiBU,MAAM,EAAE;MAAzB,CAFL;MAGVC,oBAAoB,EAAE,2BAAcb,IAAd;IAHZ;EATP,CAAP;AAeD;;AAhBDc;;AAkBA,SAASL,SAAT,CAAmBM,WAAnB,EAAwCV,MAAxC,EAA4D;EAC1D,MAAMW,QAAQ,GAAGD,WAAW,CAACE,KAAZ,CAAkB,GAAlB,CAAjB;EACA,MAAMC,UAAU,GAAiB,EAAjC;EACA,IAAIC,aAAa,GAAiBD,UAAlC;;EACA,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAAQ,CAACK,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;IACxC,IAAIE,OAAO,GAAWN,QAAQ,CAACI,CAAD,CAA9B;IACA,MAAMG,MAAM,GAAGH,CAAC,KAAKJ,QAAQ,CAACK,MAAT,GAAkB,CAAvC;IACAC,OAAO,GAAGE,mBAAmB,CAACF,OAAD,CAA7B;IACA,MAAMG,UAAU,GAA4BN,aAAa,CAACM,UAAd,GAA2B,EAAvE;IACA,IAAIC,KAAJ;;IACA,IAAI,SAASC,IAAT,CAAcL,OAAd,CAAJ,EAA4B;MAC1B,IAAIM,KAAK,GAAG,CAACN,OAAb;MACAI,KAAK,GAAGP,aAAa,CAACO,KAAd,GAAsB,EAA9B;MACAP,aAAa,CAACjB,IAAd,GAAqB,CAAC,QAAD,EAAW,OAAX,CAArB;;MACA,OAAO0B,KAAK,EAAZ,EAAgBF,KAAK,CAAClB,IAAN,CAAW,EAAX;IACjB,CALD,MAKO;MACLW,aAAa,CAACjB,IAAd,GAAqB,QAArB;IACD;;IACDiB,aAAa,GAAGI,MAAM,GAAGlB,MAAH,GAAY,EAAlC;IACAoB,UAAU,CAACH,OAAD,CAAV,GAAsBH,aAAtB;IACA,IAAIO,KAAJ,EAAWA,KAAK,CAAClB,IAAN,CAAWW,aAAX;EACZ;;EACD,OAAOD,UAAP;AACD;;AAED,SAASM,mBAAT,CAA6BK,GAA7B,EAAwC;EACtC,OAAOA,GAAG,CAACC,OAAJ,CAAY,KAAZ,EAAmB,GAAnB,EAAwBA,OAAxB,CAAgC,KAAhC,EAAuC,GAAvC,CAAP;AACD;;AAEDC,MAAM,CAACjB,OAAP,GAAiBf,MAAjB","names":["getDef","opts","keyword","type","schemaType","macro","schema","allOf","pointer","push","getSchema","metaSchema","propertyNames","format","additionalProperties","exports","jsonPointer","segments","split","rootSchema","pointerSchema","i","length","segment","isLast","unescapeJsonPointer","properties","items","test","count","str","replace","module"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-webpack-plugin\\node_modules\\ajv-keywords\\src\\definitions\\deepProperties.ts"],"sourcesContent":["import type {MacroKeywordDefinition, SchemaObject, Schema} from \"ajv\"\nimport type {DefinitionOptions} from \"./_types\"\nimport {metaSchemaRef} from \"./_util\"\n\nexport default function getDef(opts?: DefinitionOptions): MacroKeywordDefinition {\n  return {\n    keyword: \"deepProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    macro: function (schema: Record<string, SchemaObject>) {\n      const allOf = []\n      for (const pointer in schema) allOf.push(getSchema(pointer, schema[pointer]))\n      return {allOf}\n    },\n    metaSchema: {\n      type: \"object\",\n      propertyNames: {type: \"string\", format: \"json-pointer\"},\n      additionalProperties: metaSchemaRef(opts),\n    },\n  }\n}\n\nfunction getSchema(jsonPointer: string, schema: SchemaObject): SchemaObject {\n  const segments = jsonPointer.split(\"/\")\n  const rootSchema: SchemaObject = {}\n  let pointerSchema: SchemaObject = rootSchema\n  for (let i = 1; i < segments.length; i++) {\n    let segment: string = segments[i]\n    const isLast = i === segments.length - 1\n    segment = unescapeJsonPointer(segment)\n    const properties: Record<string, Schema> = (pointerSchema.properties = {})\n    let items: SchemaObject[] | undefined\n    if (/[0-9]+/.test(segment)) {\n      let count = +segment\n      items = pointerSchema.items = []\n      pointerSchema.type = [\"object\", \"array\"]\n      while (count--) items.push({})\n    } else {\n      pointerSchema.type = \"object\"\n    }\n    pointerSchema = isLast ? schema : {}\n    properties[segment] = pointerSchema\n    if (items) items.push(pointerSchema)\n  }\n  return rootSchema\n}\n\nfunction unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nmodule.exports = getDef\n"]},"metadata":{},"sourceType":"script"}