{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = autoInject;\n\nvar _auto = require('./auto.js');\n\nvar _auto2 = _interopRequireDefault(_auto);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar FN_ARGS = /^(?:async\\s+)?(?:function)?\\s*\\w*\\s*\\(\\s*([^)]+)\\s*\\)(?:\\s*{)/;\nvar ARROW_FN_ARGS = /^(?:async\\s+)?\\(?\\s*([^)=]+)\\s*\\)?(?:\\s*=>)/;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\n\nfunction stripComments(string) {\n  let stripped = '';\n  let index = 0;\n  let endBlockComment = string.indexOf('*/');\n\n  while (index < string.length) {\n    if (string[index] === '/' && string[index + 1] === '/') {\n      // inline comment\n      let endIndex = string.indexOf('\\n', index);\n      index = endIndex === -1 ? string.length : endIndex;\n    } else if (endBlockComment !== -1 && string[index] === '/' && string[index + 1] === '*') {\n      // block comment\n      let endIndex = string.indexOf('*/', index);\n\n      if (endIndex !== -1) {\n        index = endIndex + 2;\n        endBlockComment = string.indexOf('*/', index);\n      } else {\n        stripped += string[index];\n        index++;\n      }\n    } else {\n      stripped += string[index];\n      index++;\n    }\n  }\n\n  return stripped;\n}\n\nfunction parseParams(func) {\n  const src = stripComments(func.toString());\n  let match = src.match(FN_ARGS);\n\n  if (!match) {\n    match = src.match(ARROW_FN_ARGS);\n  }\n\n  if (!match) throw new Error('could not parse args in autoInject\\nSource:\\n' + src);\n  let [, args] = match;\n  return args.replace(/\\s/g, '').split(FN_ARG_SPLIT).map(arg => arg.replace(FN_ARG, '').trim());\n}\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\n\n\nfunction autoInject(tasks, callback) {\n  var newTasks = {};\n  Object.keys(tasks).forEach(key => {\n    var taskFn = tasks[key];\n    var params;\n    var fnIsAsync = (0, _wrapAsync.isAsync)(taskFn);\n    var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;\n\n    if (Array.isArray(taskFn)) {\n      params = [...taskFn];\n      taskFn = params.pop();\n      newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n    } else if (hasNoDeps) {\n      // no dependencies, use the function as-is\n      newTasks[key] = taskFn;\n    } else {\n      params = parseParams(taskFn);\n\n      if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n        throw new Error(\"autoInject task functions require explicit parameters.\");\n      } // remove callback param\n\n\n      if (!fnIsAsync) params.pop();\n      newTasks[key] = params.concat(newTask);\n    }\n\n    function newTask(results, taskCb) {\n      var newArgs = params.map(name => results[name]);\n      newArgs.push(taskCb);\n      (0, _wrapAsync2.default)(taskFn)(...newArgs);\n    }\n  });\n  return (0, _auto2.default)(newTasks, callback);\n}\n\nmodule.exports = exports['default'];","map":{"version":3,"names":["Object","defineProperty","exports","value","default","autoInject","_auto","require","_auto2","_interopRequireDefault","_wrapAsync","_wrapAsync2","obj","__esModule","FN_ARGS","ARROW_FN_ARGS","FN_ARG_SPLIT","FN_ARG","stripComments","string","stripped","index","endBlockComment","indexOf","length","endIndex","parseParams","func","src","toString","match","Error","args","replace","split","map","arg","trim","tasks","callback","newTasks","keys","forEach","key","taskFn","params","fnIsAsync","isAsync","hasNoDeps","Array","isArray","pop","concat","newTask","results","taskCb","newArgs","name","push","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/async/autoInject.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = autoInject;\n\nvar _auto = require('./auto.js');\n\nvar _auto2 = _interopRequireDefault(_auto);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar FN_ARGS = /^(?:async\\s+)?(?:function)?\\s*\\w*\\s*\\(\\s*([^)]+)\\s*\\)(?:\\s*{)/;\nvar ARROW_FN_ARGS = /^(?:async\\s+)?\\(?\\s*([^)=]+)\\s*\\)?(?:\\s*=>)/;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\n\nfunction stripComments(string) {\n    let stripped = '';\n    let index = 0;\n    let endBlockComment = string.indexOf('*/');\n    while (index < string.length) {\n        if (string[index] === '/' && string[index + 1] === '/') {\n            // inline comment\n            let endIndex = string.indexOf('\\n', index);\n            index = endIndex === -1 ? string.length : endIndex;\n        } else if (endBlockComment !== -1 && string[index] === '/' && string[index + 1] === '*') {\n            // block comment\n            let endIndex = string.indexOf('*/', index);\n            if (endIndex !== -1) {\n                index = endIndex + 2;\n                endBlockComment = string.indexOf('*/', index);\n            } else {\n                stripped += string[index];\n                index++;\n            }\n        } else {\n            stripped += string[index];\n            index++;\n        }\n    }\n    return stripped;\n}\n\nfunction parseParams(func) {\n    const src = stripComments(func.toString());\n    let match = src.match(FN_ARGS);\n    if (!match) {\n        match = src.match(ARROW_FN_ARGS);\n    }\n    if (!match) throw new Error('could not parse args in autoInject\\nSource:\\n' + src);\n    let [, args] = match;\n    return args.replace(/\\s/g, '').split(FN_ARG_SPLIT).map(arg => arg.replace(FN_ARG, '').trim());\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    Object.keys(tasks).forEach(key => {\n        var taskFn = tasks[key];\n        var params;\n        var fnIsAsync = (0, _wrapAsync.isAsync)(taskFn);\n        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;\n\n        if (Array.isArray(taskFn)) {\n            params = [...taskFn];\n            taskFn = params.pop();\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = params.map(name => results[name]);\n            newArgs.push(taskCb);\n            (0, _wrapAsync2.default)(taskFn)(...newArgs);\n        }\n    });\n\n    return (0, _auto2.default)(newTasks, callback);\n}\nmodule.exports = exports['default'];"],"mappings":"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"},"metadata":{},"sourceType":"script"}