{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\nimport { AST_Array, AST_Arrow, AST_Assign, AST_Binary, AST_Block, AST_BlockStatement, AST_Call, AST_Case, AST_Chain, AST_Class, AST_DefClass, AST_ClassStaticBlock, AST_ClassProperty, AST_ConciseMethod, AST_Conditional, AST_Constant, AST_Definitions, AST_Dot, AST_EmptyStatement, AST_Expansion, AST_False, AST_Function, AST_If, AST_Import, AST_Jump, AST_LabeledStatement, AST_Lambda, AST_New, AST_Node, AST_Null, AST_Number, AST_Object, AST_ObjectGetter, AST_ObjectKeyVal, AST_ObjectProperty, AST_ObjectSetter, AST_PropAccess, AST_RegExp, AST_Return, AST_Sequence, AST_SimpleStatement, AST_Statement, AST_String, AST_Sub, AST_Switch, AST_SwitchBranch, AST_SymbolClassProperty, AST_SymbolDeclaration, AST_SymbolRef, AST_TemplateSegment, AST_TemplateString, AST_This, AST_Toplevel, AST_True, AST_Try, AST_Unary, AST_UnaryPostfix, AST_UnaryPrefix, AST_Undefined, AST_VarDef, TreeTransformer, walk, walk_abort, _PURE } from \"../ast.js\";\nimport { makePredicate, return_true, return_false, return_null, return_this, make_node, member, noop, has_annotation, HOP } from \"../utils/index.js\";\nimport { make_node_from_constant, make_sequence, best_of_expression, read_property } from \"./common.js\";\nimport { INLINED, UNDEFINED, has_flag } from \"./compressor-flags.js\";\nimport { pure_prop_access_globals, is_pure_native_fn, is_pure_native_method } from \"./native-objects.js\"; // Functions and methods to infer certain facts about expressions\n// It's not always possible to be 100% sure about something just by static analysis,\n// so `true` means yes, and `false` means maybe\n\nexport const is_undeclared_ref = node => node instanceof AST_SymbolRef && node.definition().undeclared;\nexport const lazy_op = makePredicate(\"&& || ??\");\nexport const unary_side_effects = makePredicate(\"delete ++ --\"); // methods to determine whether an expression has a boolean result type\n\n(function (def_is_boolean) {\n  const unary_bool = makePredicate(\"! delete\");\n  const binary_bool = makePredicate(\"in instanceof == != === !== < <= >= >\");\n  def_is_boolean(AST_Node, return_false);\n  def_is_boolean(AST_UnaryPrefix, function () {\n    return unary_bool.has(this.operator);\n  });\n  def_is_boolean(AST_Binary, function () {\n    return binary_bool.has(this.operator) || lazy_op.has(this.operator) && this.left.is_boolean() && this.right.is_boolean();\n  });\n  def_is_boolean(AST_Conditional, function () {\n    return this.consequent.is_boolean() && this.alternative.is_boolean();\n  });\n  def_is_boolean(AST_Assign, function () {\n    return this.operator == \"=\" && this.right.is_boolean();\n  });\n  def_is_boolean(AST_Sequence, function () {\n    return this.tail_node().is_boolean();\n  });\n  def_is_boolean(AST_True, return_true);\n  def_is_boolean(AST_False, return_true);\n})(function (node, func) {\n  node.DEFMETHOD(\"is_boolean\", func);\n}); // methods to determine if an expression has a numeric result type\n\n\n(function (def_is_number) {\n  def_is_number(AST_Node, return_false);\n  def_is_number(AST_Number, return_true);\n  const unary = makePredicate(\"+ - ~ ++ --\");\n  def_is_number(AST_Unary, function () {\n    return unary.has(this.operator);\n  });\n  const numeric_ops = makePredicate(\"- * / % & | ^ << >> >>>\");\n  def_is_number(AST_Binary, function (compressor) {\n    return numeric_ops.has(this.operator) || this.operator == \"+\" && this.left.is_number(compressor) && this.right.is_number(compressor);\n  });\n  def_is_number(AST_Assign, function (compressor) {\n    return numeric_ops.has(this.operator.slice(0, -1)) || this.operator == \"=\" && this.right.is_number(compressor);\n  });\n  def_is_number(AST_Sequence, function (compressor) {\n    return this.tail_node().is_number(compressor);\n  });\n  def_is_number(AST_Conditional, function (compressor) {\n    return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"is_number\", func);\n}); // methods to determine if an expression has a string result type\n\n\n(function (def_is_string) {\n  def_is_string(AST_Node, return_false);\n  def_is_string(AST_String, return_true);\n  def_is_string(AST_TemplateString, return_true);\n  def_is_string(AST_UnaryPrefix, function () {\n    return this.operator == \"typeof\";\n  });\n  def_is_string(AST_Binary, function (compressor) {\n    return this.operator == \"+\" && (this.left.is_string(compressor) || this.right.is_string(compressor));\n  });\n  def_is_string(AST_Assign, function (compressor) {\n    return (this.operator == \"=\" || this.operator == \"+=\") && this.right.is_string(compressor);\n  });\n  def_is_string(AST_Sequence, function (compressor) {\n    return this.tail_node().is_string(compressor);\n  });\n  def_is_string(AST_Conditional, function (compressor) {\n    return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"is_string\", func);\n});\n\nexport function is_undefined(node, compressor) {\n  return has_flag(node, UNDEFINED) || node instanceof AST_Undefined || node instanceof AST_UnaryPrefix && node.operator == \"void\" && !node.expression.has_side_effects(compressor);\n} // Is the node explicitly null or undefined.\n\nfunction is_null_or_undefined(node, compressor) {\n  let fixed;\n  return node instanceof AST_Null || is_undefined(node, compressor) || node instanceof AST_SymbolRef && (fixed = node.definition().fixed) instanceof AST_Node && is_nullish(fixed, compressor);\n} // Find out if this expression is optionally chained from a base-point that we\n// can statically analyze as null or undefined.\n\n\nexport function is_nullish_shortcircuited(node, compressor) {\n  if (node instanceof AST_PropAccess || node instanceof AST_Call) {\n    return node.optional && is_null_or_undefined(node.expression, compressor) || is_nullish_shortcircuited(node.expression, compressor);\n  }\n\n  if (node instanceof AST_Chain) return is_nullish_shortcircuited(node.expression, compressor);\n  return false;\n} // Find out if something is == null, or can short circuit into nullish.\n// Used to optimize ?. and ??\n\nexport function is_nullish(node, compressor) {\n  if (is_null_or_undefined(node, compressor)) return true;\n  return is_nullish_shortcircuited(node, compressor);\n} // Determine if expression might cause side effects\n// If there's a possibility that a node may change something when it's executed, this returns true\n\n(function (def_has_side_effects) {\n  def_has_side_effects(AST_Node, return_true);\n  def_has_side_effects(AST_EmptyStatement, return_false);\n  def_has_side_effects(AST_Constant, return_false);\n  def_has_side_effects(AST_This, return_false);\n\n  function any(list, compressor) {\n    for (var i = list.length; --i >= 0;) if (list[i].has_side_effects(compressor)) return true;\n\n    return false;\n  }\n\n  def_has_side_effects(AST_Block, function (compressor) {\n    return any(this.body, compressor);\n  });\n  def_has_side_effects(AST_Call, function (compressor) {\n    if (!this.is_callee_pure(compressor) && (!this.expression.is_call_pure(compressor) || this.expression.has_side_effects(compressor))) {\n      return true;\n    }\n\n    return any(this.args, compressor);\n  });\n  def_has_side_effects(AST_Switch, function (compressor) {\n    return this.expression.has_side_effects(compressor) || any(this.body, compressor);\n  });\n  def_has_side_effects(AST_Case, function (compressor) {\n    return this.expression.has_side_effects(compressor) || any(this.body, compressor);\n  });\n  def_has_side_effects(AST_Try, function (compressor) {\n    return any(this.body, compressor) || this.bcatch && this.bcatch.has_side_effects(compressor) || this.bfinally && this.bfinally.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_If, function (compressor) {\n    return this.condition.has_side_effects(compressor) || this.body && this.body.has_side_effects(compressor) || this.alternative && this.alternative.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_LabeledStatement, function (compressor) {\n    return this.body.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_SimpleStatement, function (compressor) {\n    return this.body.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Lambda, return_false);\n  def_has_side_effects(AST_Class, function (compressor) {\n    if (this.extends && this.extends.has_side_effects(compressor)) {\n      return true;\n    }\n\n    return any(this.properties, compressor);\n  });\n  def_has_side_effects(AST_ClassStaticBlock, function (compressor) {\n    return any(this.body, compressor);\n  });\n  def_has_side_effects(AST_Binary, function (compressor) {\n    return this.left.has_side_effects(compressor) || this.right.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Assign, return_true);\n  def_has_side_effects(AST_Conditional, function (compressor) {\n    return this.condition.has_side_effects(compressor) || this.consequent.has_side_effects(compressor) || this.alternative.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Unary, function (compressor) {\n    return unary_side_effects.has(this.operator) || this.expression.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_SymbolRef, function (compressor) {\n    return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);\n  });\n  def_has_side_effects(AST_SymbolClassProperty, return_false);\n  def_has_side_effects(AST_SymbolDeclaration, return_false);\n  def_has_side_effects(AST_Object, function (compressor) {\n    return any(this.properties, compressor);\n  });\n  def_has_side_effects(AST_ObjectProperty, function (compressor) {\n    return this.computed_key() && this.key.has_side_effects(compressor) || this.value && this.value.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_ClassProperty, function (compressor) {\n    return this.computed_key() && this.key.has_side_effects(compressor) || this.static && this.value && this.value.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_ConciseMethod, function (compressor) {\n    return this.computed_key() && this.key.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_ObjectGetter, function (compressor) {\n    return this.computed_key() && this.key.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_ObjectSetter, function (compressor) {\n    return this.computed_key() && this.key.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Array, function (compressor) {\n    return any(this.elements, compressor);\n  });\n  def_has_side_effects(AST_Dot, function (compressor) {\n    if (is_nullish(this, compressor)) return false;\n    return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Sub, function (compressor) {\n    if (is_nullish(this, compressor)) return false;\n    return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.has_side_effects(compressor) || this.property.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Chain, function (compressor) {\n    return this.expression.has_side_effects(compressor);\n  });\n  def_has_side_effects(AST_Sequence, function (compressor) {\n    return any(this.expressions, compressor);\n  });\n  def_has_side_effects(AST_Definitions, function (compressor) {\n    return any(this.definitions, compressor);\n  });\n  def_has_side_effects(AST_VarDef, function () {\n    return this.value;\n  });\n  def_has_side_effects(AST_TemplateSegment, return_false);\n  def_has_side_effects(AST_TemplateString, function (compressor) {\n    return any(this.segments, compressor);\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"has_side_effects\", func);\n}); // determine if expression may throw\n\n\n(function (def_may_throw) {\n  def_may_throw(AST_Node, return_true);\n  def_may_throw(AST_Constant, return_false);\n  def_may_throw(AST_EmptyStatement, return_false);\n  def_may_throw(AST_Lambda, return_false);\n  def_may_throw(AST_SymbolDeclaration, return_false);\n  def_may_throw(AST_This, return_false);\n\n  function any(list, compressor) {\n    for (var i = list.length; --i >= 0;) if (list[i].may_throw(compressor)) return true;\n\n    return false;\n  }\n\n  def_may_throw(AST_Class, function (compressor) {\n    if (this.extends && this.extends.may_throw(compressor)) return true;\n    return any(this.properties, compressor);\n  });\n  def_may_throw(AST_ClassStaticBlock, function (compressor) {\n    return any(this.body, compressor);\n  });\n  def_may_throw(AST_Array, function (compressor) {\n    return any(this.elements, compressor);\n  });\n  def_may_throw(AST_Assign, function (compressor) {\n    if (this.right.may_throw(compressor)) return true;\n\n    if (!compressor.has_directive(\"use strict\") && this.operator == \"=\" && this.left instanceof AST_SymbolRef) {\n      return false;\n    }\n\n    return this.left.may_throw(compressor);\n  });\n  def_may_throw(AST_Binary, function (compressor) {\n    return this.left.may_throw(compressor) || this.right.may_throw(compressor);\n  });\n  def_may_throw(AST_Block, function (compressor) {\n    return any(this.body, compressor);\n  });\n  def_may_throw(AST_Call, function (compressor) {\n    if (is_nullish(this, compressor)) return false;\n    if (any(this.args, compressor)) return true;\n    if (this.is_callee_pure(compressor)) return false;\n    if (this.expression.may_throw(compressor)) return true;\n    return !(this.expression instanceof AST_Lambda) || any(this.expression.body, compressor);\n  });\n  def_may_throw(AST_Case, function (compressor) {\n    return this.expression.may_throw(compressor) || any(this.body, compressor);\n  });\n  def_may_throw(AST_Conditional, function (compressor) {\n    return this.condition.may_throw(compressor) || this.consequent.may_throw(compressor) || this.alternative.may_throw(compressor);\n  });\n  def_may_throw(AST_Definitions, function (compressor) {\n    return any(this.definitions, compressor);\n  });\n  def_may_throw(AST_If, function (compressor) {\n    return this.condition.may_throw(compressor) || this.body && this.body.may_throw(compressor) || this.alternative && this.alternative.may_throw(compressor);\n  });\n  def_may_throw(AST_LabeledStatement, function (compressor) {\n    return this.body.may_throw(compressor);\n  });\n  def_may_throw(AST_Object, function (compressor) {\n    return any(this.properties, compressor);\n  });\n  def_may_throw(AST_ObjectProperty, function (compressor) {\n    // TODO key may throw too\n    return this.value ? this.value.may_throw(compressor) : false;\n  });\n  def_may_throw(AST_ClassProperty, function (compressor) {\n    return this.computed_key() && this.key.may_throw(compressor) || this.static && this.value && this.value.may_throw(compressor);\n  });\n  def_may_throw(AST_ConciseMethod, function (compressor) {\n    return this.computed_key() && this.key.may_throw(compressor);\n  });\n  def_may_throw(AST_ObjectGetter, function (compressor) {\n    return this.computed_key() && this.key.may_throw(compressor);\n  });\n  def_may_throw(AST_ObjectSetter, function (compressor) {\n    return this.computed_key() && this.key.may_throw(compressor);\n  });\n  def_may_throw(AST_Return, function (compressor) {\n    return this.value && this.value.may_throw(compressor);\n  });\n  def_may_throw(AST_Sequence, function (compressor) {\n    return any(this.expressions, compressor);\n  });\n  def_may_throw(AST_SimpleStatement, function (compressor) {\n    return this.body.may_throw(compressor);\n  });\n  def_may_throw(AST_Dot, function (compressor) {\n    if (is_nullish(this, compressor)) return false;\n    return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor);\n  });\n  def_may_throw(AST_Sub, function (compressor) {\n    if (is_nullish(this, compressor)) return false;\n    return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor) || this.property.may_throw(compressor);\n  });\n  def_may_throw(AST_Chain, function (compressor) {\n    return this.expression.may_throw(compressor);\n  });\n  def_may_throw(AST_Switch, function (compressor) {\n    return this.expression.may_throw(compressor) || any(this.body, compressor);\n  });\n  def_may_throw(AST_SymbolRef, function (compressor) {\n    return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);\n  });\n  def_may_throw(AST_SymbolClassProperty, return_false);\n  def_may_throw(AST_Try, function (compressor) {\n    return this.bcatch ? this.bcatch.may_throw(compressor) : any(this.body, compressor) || this.bfinally && this.bfinally.may_throw(compressor);\n  });\n  def_may_throw(AST_Unary, function (compressor) {\n    if (this.operator == \"typeof\" && this.expression instanceof AST_SymbolRef) return false;\n    return this.expression.may_throw(compressor);\n  });\n  def_may_throw(AST_VarDef, function (compressor) {\n    if (!this.value) return false;\n    return this.value.may_throw(compressor);\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"may_throw\", func);\n}); // determine if expression is constant\n\n\n(function (def_is_constant_expression) {\n  function all_refs_local(scope) {\n    let result = true;\n    walk(this, node => {\n      if (node instanceof AST_SymbolRef) {\n        if (has_flag(this, INLINED)) {\n          result = false;\n          return walk_abort;\n        }\n\n        var def = node.definition();\n\n        if (member(def, this.enclosed) && !this.variables.has(def.name)) {\n          if (scope) {\n            var scope_def = scope.find_variable(node);\n\n            if (def.undeclared ? !scope_def : scope_def === def) {\n              result = \"f\";\n              return true;\n            }\n          }\n\n          result = false;\n          return walk_abort;\n        }\n\n        return true;\n      }\n\n      if (node instanceof AST_This && this instanceof AST_Arrow) {\n        // TODO check arguments too!\n        result = false;\n        return walk_abort;\n      }\n    });\n    return result;\n  }\n\n  def_is_constant_expression(AST_Node, return_false);\n  def_is_constant_expression(AST_Constant, return_true);\n  def_is_constant_expression(AST_Class, function (scope) {\n    if (this.extends && !this.extends.is_constant_expression(scope)) {\n      return false;\n    }\n\n    for (const prop of this.properties) {\n      if (prop.computed_key() && !prop.key.is_constant_expression(scope)) {\n        return false;\n      }\n\n      if (prop.static && prop.value && !prop.value.is_constant_expression(scope)) {\n        return false;\n      }\n\n      if (prop instanceof AST_ClassStaticBlock) {\n        return false;\n      }\n    }\n\n    return all_refs_local.call(this, scope);\n  });\n  def_is_constant_expression(AST_Lambda, all_refs_local);\n  def_is_constant_expression(AST_Unary, function () {\n    return this.expression.is_constant_expression();\n  });\n  def_is_constant_expression(AST_Binary, function () {\n    return this.left.is_constant_expression() && this.right.is_constant_expression();\n  });\n  def_is_constant_expression(AST_Array, function () {\n    return this.elements.every(l => l.is_constant_expression());\n  });\n  def_is_constant_expression(AST_Object, function () {\n    return this.properties.every(l => l.is_constant_expression());\n  });\n  def_is_constant_expression(AST_ObjectProperty, function () {\n    return !!(!(this.key instanceof AST_Node) && this.value && this.value.is_constant_expression());\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"is_constant_expression\", func);\n}); // may_throw_on_access()\n// returns true if this node may be null, undefined or contain `AST_Accessor`\n\n\n(function (def_may_throw_on_access) {\n  AST_Node.DEFMETHOD(\"may_throw_on_access\", function (compressor) {\n    return !compressor.option(\"pure_getters\") || this._dot_throw(compressor);\n  });\n\n  function is_strict(compressor) {\n    return /strict/.test(compressor.option(\"pure_getters\"));\n  }\n\n  def_may_throw_on_access(AST_Node, is_strict);\n  def_may_throw_on_access(AST_Null, return_true);\n  def_may_throw_on_access(AST_Undefined, return_true);\n  def_may_throw_on_access(AST_Constant, return_false);\n  def_may_throw_on_access(AST_Array, return_false);\n  def_may_throw_on_access(AST_Object, function (compressor) {\n    if (!is_strict(compressor)) return false;\n\n    for (var i = this.properties.length; --i >= 0;) if (this.properties[i]._dot_throw(compressor)) return true;\n\n    return false;\n  }); // Do not be as strict with classes as we are with objects.\n  // Hopefully the community is not going to abuse static getters and setters.\n  // https://github.com/terser/terser/issues/724#issuecomment-643655656\n\n  def_may_throw_on_access(AST_Class, return_false);\n  def_may_throw_on_access(AST_ObjectProperty, return_false);\n  def_may_throw_on_access(AST_ObjectGetter, return_true);\n  def_may_throw_on_access(AST_Expansion, function (compressor) {\n    return this.expression._dot_throw(compressor);\n  });\n  def_may_throw_on_access(AST_Function, return_false);\n  def_may_throw_on_access(AST_Arrow, return_false);\n  def_may_throw_on_access(AST_UnaryPostfix, return_false);\n  def_may_throw_on_access(AST_UnaryPrefix, function () {\n    return this.operator == \"void\";\n  });\n  def_may_throw_on_access(AST_Binary, function (compressor) {\n    return (this.operator == \"&&\" || this.operator == \"||\" || this.operator == \"??\") && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));\n  });\n  def_may_throw_on_access(AST_Assign, function (compressor) {\n    if (this.logical) return true;\n    return this.operator == \"=\" && this.right._dot_throw(compressor);\n  });\n  def_may_throw_on_access(AST_Conditional, function (compressor) {\n    return this.consequent._dot_throw(compressor) || this.alternative._dot_throw(compressor);\n  });\n  def_may_throw_on_access(AST_Dot, function (compressor) {\n    if (!is_strict(compressor)) return false;\n\n    if (this.property == \"prototype\") {\n      return !(this.expression instanceof AST_Function || this.expression instanceof AST_Class);\n    }\n\n    return true;\n  });\n  def_may_throw_on_access(AST_Chain, function (compressor) {\n    return this.expression._dot_throw(compressor);\n  });\n  def_may_throw_on_access(AST_Sequence, function (compressor) {\n    return this.tail_node()._dot_throw(compressor);\n  });\n  def_may_throw_on_access(AST_SymbolRef, function (compressor) {\n    if (this.name === \"arguments\") return false;\n    if (has_flag(this, UNDEFINED)) return true;\n    if (!is_strict(compressor)) return false;\n    if (is_undeclared_ref(this) && this.is_declared(compressor)) return false;\n    if (this.is_immutable()) return false;\n    var fixed = this.fixed_value();\n    return !fixed || fixed._dot_throw(compressor);\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"_dot_throw\", func);\n});\n\nexport function is_lhs(node, parent) {\n  if (parent instanceof AST_Unary && unary_side_effects.has(parent.operator)) return parent.expression;\n  if (parent instanceof AST_Assign && parent.left === node) return node;\n}\n\n(function (def_find_defs) {\n  function to_node(value, orig) {\n    if (value instanceof AST_Node) {\n      if (!(value instanceof AST_Constant)) {\n        // Value may be a function, an array including functions and even a complex assign / block expression,\n        // so it should never be shared in different places.\n        // Otherwise wrong information may be used in the compression phase\n        value = value.clone(true);\n      }\n\n      return make_node(value.CTOR, orig, value);\n    }\n\n    if (Array.isArray(value)) return make_node(AST_Array, orig, {\n      elements: value.map(function (value) {\n        return to_node(value, orig);\n      })\n    });\n\n    if (value && typeof value == \"object\") {\n      var props = [];\n\n      for (var key in value) if (HOP(value, key)) {\n        props.push(make_node(AST_ObjectKeyVal, orig, {\n          key: key,\n          value: to_node(value[key], orig)\n        }));\n      }\n\n      return make_node(AST_Object, orig, {\n        properties: props\n      });\n    }\n\n    return make_node_from_constant(value, orig);\n  }\n\n  AST_Toplevel.DEFMETHOD(\"resolve_defines\", function (compressor) {\n    if (!compressor.option(\"global_defs\")) return this;\n    this.figure_out_scope({\n      ie8: compressor.option(\"ie8\")\n    });\n    return this.transform(new TreeTransformer(function (node) {\n      var def = node._find_defs(compressor, \"\");\n\n      if (!def) return;\n      var level = 0,\n          child = node,\n          parent;\n\n      while (parent = this.parent(level++)) {\n        if (!(parent instanceof AST_PropAccess)) break;\n        if (parent.expression !== child) break;\n        child = parent;\n      }\n\n      if (is_lhs(child, parent)) {\n        return;\n      }\n\n      return def;\n    }));\n  });\n  def_find_defs(AST_Node, noop);\n  def_find_defs(AST_Chain, function (compressor, suffix) {\n    return this.expression._find_defs(compressor, suffix);\n  });\n  def_find_defs(AST_Dot, function (compressor, suffix) {\n    return this.expression._find_defs(compressor, \".\" + this.property + suffix);\n  });\n  def_find_defs(AST_SymbolDeclaration, function () {\n    if (!this.global()) return;\n  });\n  def_find_defs(AST_SymbolRef, function (compressor, suffix) {\n    if (!this.global()) return;\n    var defines = compressor.option(\"global_defs\");\n    var name = this.name + suffix;\n    if (HOP(defines, name)) return to_node(defines[name], this);\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"_find_defs\", func);\n}); // method to negate an expression\n\n\n(function (def_negate) {\n  function basic_negation(exp) {\n    return make_node(AST_UnaryPrefix, exp, {\n      operator: \"!\",\n      expression: exp\n    });\n  }\n\n  function best(orig, alt, first_in_statement) {\n    var negated = basic_negation(orig);\n\n    if (first_in_statement) {\n      var stat = make_node(AST_SimpleStatement, alt, {\n        body: alt\n      });\n      return best_of_expression(negated, stat) === stat ? alt : negated;\n    }\n\n    return best_of_expression(negated, alt);\n  }\n\n  def_negate(AST_Node, function () {\n    return basic_negation(this);\n  });\n  def_negate(AST_Statement, function () {\n    throw new Error(\"Cannot negate a statement\");\n  });\n  def_negate(AST_Function, function () {\n    return basic_negation(this);\n  });\n  def_negate(AST_Arrow, function () {\n    return basic_negation(this);\n  });\n  def_negate(AST_UnaryPrefix, function () {\n    if (this.operator == \"!\") return this.expression;\n    return basic_negation(this);\n  });\n  def_negate(AST_Sequence, function (compressor) {\n    var expressions = this.expressions.slice();\n    expressions.push(expressions.pop().negate(compressor));\n    return make_sequence(this, expressions);\n  });\n  def_negate(AST_Conditional, function (compressor, first_in_statement) {\n    var self = this.clone();\n    self.consequent = self.consequent.negate(compressor);\n    self.alternative = self.alternative.negate(compressor);\n    return best(this, self, first_in_statement);\n  });\n  def_negate(AST_Binary, function (compressor, first_in_statement) {\n    var self = this.clone(),\n        op = this.operator;\n\n    if (compressor.option(\"unsafe_comps\")) {\n      switch (op) {\n        case \"<=\":\n          self.operator = \">\";\n          return self;\n\n        case \"<\":\n          self.operator = \">=\";\n          return self;\n\n        case \">=\":\n          self.operator = \"<\";\n          return self;\n\n        case \">\":\n          self.operator = \"<=\";\n          return self;\n      }\n    }\n\n    switch (op) {\n      case \"==\":\n        self.operator = \"!=\";\n        return self;\n\n      case \"!=\":\n        self.operator = \"==\";\n        return self;\n\n      case \"===\":\n        self.operator = \"!==\";\n        return self;\n\n      case \"!==\":\n        self.operator = \"===\";\n        return self;\n\n      case \"&&\":\n        self.operator = \"||\";\n        self.left = self.left.negate(compressor, first_in_statement);\n        self.right = self.right.negate(compressor);\n        return best(this, self, first_in_statement);\n\n      case \"||\":\n        self.operator = \"&&\";\n        self.left = self.left.negate(compressor, first_in_statement);\n        self.right = self.right.negate(compressor);\n        return best(this, self, first_in_statement);\n    }\n\n    return basic_negation(this);\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"negate\", function (compressor, first_in_statement) {\n    return func.call(this, compressor, first_in_statement);\n  });\n}); // Is the callee of this function pure?\n\n\nvar global_pure_fns = makePredicate(\"Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError\");\nAST_Call.DEFMETHOD(\"is_callee_pure\", function (compressor) {\n  if (compressor.option(\"unsafe\")) {\n    var expr = this.expression;\n    var first_arg = this.args && this.args[0] && this.args[0].evaluate(compressor);\n\n    if (expr.expression && expr.expression.name === \"hasOwnProperty\" && (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)) {\n      return false;\n    }\n\n    if (is_undeclared_ref(expr) && global_pure_fns.has(expr.name)) return true;\n\n    if (expr instanceof AST_Dot && is_undeclared_ref(expr.expression) && is_pure_native_fn(expr.expression.name, expr.property)) {\n      return true;\n    }\n  }\n\n  return !!has_annotation(this, _PURE) || !compressor.pure_funcs(this);\n}); // If I call this, is it a pure function?\n\nAST_Node.DEFMETHOD(\"is_call_pure\", return_false);\nAST_Dot.DEFMETHOD(\"is_call_pure\", function (compressor) {\n  if (!compressor.option(\"unsafe\")) return;\n  const expr = this.expression;\n  let native_obj;\n\n  if (expr instanceof AST_Array) {\n    native_obj = \"Array\";\n  } else if (expr.is_boolean()) {\n    native_obj = \"Boolean\";\n  } else if (expr.is_number(compressor)) {\n    native_obj = \"Number\";\n  } else if (expr instanceof AST_RegExp) {\n    native_obj = \"RegExp\";\n  } else if (expr.is_string(compressor)) {\n    native_obj = \"String\";\n  } else if (!this.may_throw_on_access(compressor)) {\n    native_obj = \"Object\";\n  }\n\n  return native_obj != null && is_pure_native_method(native_obj, this.property);\n}); // tell me if a statement aborts\n\nexport const aborts = thing => thing && thing.aborts();\n\n(function (def_aborts) {\n  def_aborts(AST_Statement, return_null);\n  def_aborts(AST_Jump, return_this);\n\n  function block_aborts() {\n    for (var i = 0; i < this.body.length; i++) {\n      if (aborts(this.body[i])) {\n        return this.body[i];\n      }\n    }\n\n    return null;\n  }\n\n  def_aborts(AST_Import, return_null);\n  def_aborts(AST_BlockStatement, block_aborts);\n  def_aborts(AST_SwitchBranch, block_aborts);\n  def_aborts(AST_DefClass, function () {\n    for (const prop of this.properties) {\n      if (prop instanceof AST_ClassStaticBlock) {\n        if (prop.aborts()) return prop;\n      }\n    }\n\n    return null;\n  });\n  def_aborts(AST_ClassStaticBlock, block_aborts);\n  def_aborts(AST_If, function () {\n    return this.alternative && aborts(this.body) && aborts(this.alternative) && this;\n  });\n})(function (node, func) {\n  node.DEFMETHOD(\"aborts\", func);\n});\n\nexport function is_modified(compressor, tw, node, value, level, immutable) {\n  var parent = tw.parent(level);\n  var lhs = is_lhs(node, parent);\n  if (lhs) return lhs;\n\n  if (!immutable && parent instanceof AST_Call && parent.expression === node && !(value instanceof AST_Arrow) && !(value instanceof AST_Class) && !parent.is_callee_pure(compressor) && (!(value instanceof AST_Function) || !(parent instanceof AST_New) && value.contains_this())) {\n    return true;\n  }\n\n  if (parent instanceof AST_Array) {\n    return is_modified(compressor, tw, parent, parent, level + 1);\n  }\n\n  if (parent instanceof AST_ObjectKeyVal && node === parent.value) {\n    var obj = tw.parent(level + 1);\n    return is_modified(compressor, tw, obj, obj, level + 2);\n  }\n\n  if (parent instanceof AST_PropAccess && parent.expression === node) {\n    var prop = read_property(value, parent.property);\n    return !immutable && is_modified(compressor, tw, parent, prop, level + 1);\n  }\n}","map":{"version":3,"names":["AST_Array","AST_Arrow","AST_Assign","AST_Binary","AST_Block","AST_BlockStatement","AST_Call","AST_Case","AST_Chain","AST_Class","AST_DefClass","AST_ClassStaticBlock","AST_ClassProperty","AST_ConciseMethod","AST_Conditional","AST_Constant","AST_Definitions","AST_Dot","AST_EmptyStatement","AST_Expansion","AST_False","AST_Function","AST_If","AST_Import","AST_Jump","AST_LabeledStatement","AST_Lambda","AST_New","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectProperty","AST_ObjectSetter","AST_PropAccess","AST_RegExp","AST_Return","AST_Sequence","AST_SimpleStatement","AST_Statement","AST_String","AST_Sub","AST_Switch","AST_SwitchBranch","AST_SymbolClassProperty","AST_SymbolDeclaration","AST_SymbolRef","AST_TemplateSegment","AST_TemplateString","AST_This","AST_Toplevel","AST_True","AST_Try","AST_Unary","AST_UnaryPostfix","AST_UnaryPrefix","AST_Undefined","AST_VarDef","TreeTransformer","walk","walk_abort","_PURE","makePredicate","return_true","return_false","return_null","return_this","make_node","member","noop","has_annotation","HOP","make_node_from_constant","make_sequence","best_of_expression","read_property","INLINED","UNDEFINED","has_flag","pure_prop_access_globals","is_pure_native_fn","is_pure_native_method","is_undeclared_ref","node","definition","undeclared","lazy_op","unary_side_effects","def_is_boolean","unary_bool","binary_bool","has","operator","left","is_boolean","right","consequent","alternative","tail_node","func","DEFMETHOD","def_is_number","unary","numeric_ops","compressor","is_number","slice","def_is_string","is_string","is_undefined","expression","has_side_effects","is_null_or_undefined","fixed","is_nullish","is_nullish_shortcircuited","optional","def_has_side_effects","any","list","i","length","body","is_callee_pure","is_call_pure","args","bcatch","bfinally","condition","extends","properties","is_declared","name","computed_key","key","value","static","elements","may_throw_on_access","property","expressions","definitions","segments","def_may_throw","may_throw","has_directive","def_is_constant_expression","all_refs_local","scope","result","def","enclosed","variables","scope_def","find_variable","is_constant_expression","prop","call","every","l","def_may_throw_on_access","option","_dot_throw","is_strict","test","logical","is_immutable","fixed_value","is_lhs","parent","def_find_defs","to_node","orig","clone","CTOR","Array","isArray","map","props","push","figure_out_scope","ie8","transform","_find_defs","level","child","suffix","global","defines","def_negate","basic_negation","exp","best","alt","first_in_statement","negated","stat","Error","pop","negate","self","op","global_pure_fns","expr","first_arg","evaluate","thedef","pure_funcs","native_obj","aborts","thing","def_aborts","block_aborts","is_modified","tw","immutable","lhs","contains_this","obj"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/terser/lib/compress/inference.js"],"sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nimport {\n  AST_Array,\n  AST_Arrow,\n  AST_Assign,\n  AST_Binary,\n  AST_Block,\n  AST_BlockStatement,\n  AST_Call,\n  AST_Case,\n  AST_Chain,\n  AST_Class,\n  AST_DefClass,\n  AST_ClassStaticBlock,\n  AST_ClassProperty,\n  AST_ConciseMethod,\n  AST_Conditional,\n  AST_Constant,\n  AST_Definitions,\n  AST_Dot,\n  AST_EmptyStatement,\n  AST_Expansion,\n  AST_False,\n  AST_Function,\n  AST_If,\n  AST_Import,\n  AST_Jump,\n  AST_LabeledStatement,\n  AST_Lambda,\n  AST_New,\n  AST_Node,\n  AST_Null,\n  AST_Number,\n  AST_Object,\n  AST_ObjectGetter,\n  AST_ObjectKeyVal,\n  AST_ObjectProperty,\n  AST_ObjectSetter,\n  AST_PropAccess,\n  AST_RegExp,\n  AST_Return,\n  AST_Sequence,\n  AST_SimpleStatement,\n  AST_Statement,\n  AST_String,\n  AST_Sub,\n  AST_Switch,\n  AST_SwitchBranch,\n  AST_SymbolClassProperty,\n  AST_SymbolDeclaration,\n  AST_SymbolRef,\n  AST_TemplateSegment,\n  AST_TemplateString,\n  AST_This,\n  AST_Toplevel,\n  AST_True,\n  AST_Try,\n  AST_Unary,\n  AST_UnaryPostfix,\n  AST_UnaryPrefix,\n  AST_Undefined,\n  AST_VarDef,\n\n  TreeTransformer,\n  walk,\n  walk_abort,\n\n  _PURE\n} from \"../ast.js\";\nimport {\n    makePredicate,\n    return_true,\n    return_false,\n    return_null,\n    return_this,\n    make_node,\n    member,\n    noop,\n    has_annotation,\n    HOP\n} from \"../utils/index.js\";\nimport { make_node_from_constant, make_sequence, best_of_expression, read_property } from \"./common.js\";\n\nimport { INLINED, UNDEFINED, has_flag } from \"./compressor-flags.js\";\nimport { pure_prop_access_globals, is_pure_native_fn, is_pure_native_method } from \"./native-objects.js\";\n\n// Functions and methods to infer certain facts about expressions\n// It's not always possible to be 100% sure about something just by static analysis,\n// so `true` means yes, and `false` means maybe\n\nexport const is_undeclared_ref = (node) =>\n    node instanceof AST_SymbolRef && node.definition().undeclared;\n\nexport const lazy_op = makePredicate(\"&& || ??\");\nexport const unary_side_effects = makePredicate(\"delete ++ --\");\n\n// methods to determine whether an expression has a boolean result type\n(function(def_is_boolean) {\n    const unary_bool = makePredicate(\"! delete\");\n    const binary_bool = makePredicate(\"in instanceof == != === !== < <= >= >\");\n    def_is_boolean(AST_Node, return_false);\n    def_is_boolean(AST_UnaryPrefix, function() {\n        return unary_bool.has(this.operator);\n    });\n    def_is_boolean(AST_Binary, function() {\n        return binary_bool.has(this.operator)\n            || lazy_op.has(this.operator)\n                && this.left.is_boolean()\n                && this.right.is_boolean();\n    });\n    def_is_boolean(AST_Conditional, function() {\n        return this.consequent.is_boolean() && this.alternative.is_boolean();\n    });\n    def_is_boolean(AST_Assign, function() {\n        return this.operator == \"=\" && this.right.is_boolean();\n    });\n    def_is_boolean(AST_Sequence, function() {\n        return this.tail_node().is_boolean();\n    });\n    def_is_boolean(AST_True, return_true);\n    def_is_boolean(AST_False, return_true);\n})(function(node, func) {\n    node.DEFMETHOD(\"is_boolean\", func);\n});\n\n// methods to determine if an expression has a numeric result type\n(function(def_is_number) {\n    def_is_number(AST_Node, return_false);\n    def_is_number(AST_Number, return_true);\n    const unary = makePredicate(\"+ - ~ ++ --\");\n    def_is_number(AST_Unary, function() {\n        return unary.has(this.operator);\n    });\n    const numeric_ops = makePredicate(\"- * / % & | ^ << >> >>>\");\n    def_is_number(AST_Binary, function(compressor) {\n        return numeric_ops.has(this.operator) || this.operator == \"+\"\n            && this.left.is_number(compressor)\n            && this.right.is_number(compressor);\n    });\n    def_is_number(AST_Assign, function(compressor) {\n        return numeric_ops.has(this.operator.slice(0, -1))\n            || this.operator == \"=\" && this.right.is_number(compressor);\n    });\n    def_is_number(AST_Sequence, function(compressor) {\n        return this.tail_node().is_number(compressor);\n    });\n    def_is_number(AST_Conditional, function(compressor) {\n        return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_number\", func);\n});\n\n// methods to determine if an expression has a string result type\n(function(def_is_string) {\n    def_is_string(AST_Node, return_false);\n    def_is_string(AST_String, return_true);\n    def_is_string(AST_TemplateString, return_true);\n    def_is_string(AST_UnaryPrefix, function() {\n        return this.operator == \"typeof\";\n    });\n    def_is_string(AST_Binary, function(compressor) {\n        return this.operator == \"+\" &&\n            (this.left.is_string(compressor) || this.right.is_string(compressor));\n    });\n    def_is_string(AST_Assign, function(compressor) {\n        return (this.operator == \"=\" || this.operator == \"+=\") && this.right.is_string(compressor);\n    });\n    def_is_string(AST_Sequence, function(compressor) {\n        return this.tail_node().is_string(compressor);\n    });\n    def_is_string(AST_Conditional, function(compressor) {\n        return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_string\", func);\n});\n\nexport function is_undefined(node, compressor) {\n    return (\n        has_flag(node, UNDEFINED)\n        || node instanceof AST_Undefined\n        || node instanceof AST_UnaryPrefix\n            && node.operator == \"void\"\n            && !node.expression.has_side_effects(compressor)\n    );\n}\n\n// Is the node explicitly null or undefined.\nfunction is_null_or_undefined(node, compressor) {\n    let fixed;\n    return (\n        node instanceof AST_Null\n        || is_undefined(node, compressor)\n        || (\n            node instanceof AST_SymbolRef\n            && (fixed = node.definition().fixed) instanceof AST_Node\n            && is_nullish(fixed, compressor)\n        )\n    );\n}\n\n// Find out if this expression is optionally chained from a base-point that we\n// can statically analyze as null or undefined.\nexport function is_nullish_shortcircuited(node, compressor) {\n    if (node instanceof AST_PropAccess || node instanceof AST_Call) {\n        return (\n            (node.optional && is_null_or_undefined(node.expression, compressor))\n            || is_nullish_shortcircuited(node.expression, compressor)\n        );\n    }\n    if (node instanceof AST_Chain) return is_nullish_shortcircuited(node.expression, compressor);\n    return false;\n}\n\n// Find out if something is == null, or can short circuit into nullish.\n// Used to optimize ?. and ??\nexport function is_nullish(node, compressor) {\n    if (is_null_or_undefined(node, compressor)) return true;\n    return is_nullish_shortcircuited(node, compressor);\n}\n\n// Determine if expression might cause side effects\n// If there's a possibility that a node may change something when it's executed, this returns true\n(function(def_has_side_effects) {\n    def_has_side_effects(AST_Node, return_true);\n\n    def_has_side_effects(AST_EmptyStatement, return_false);\n    def_has_side_effects(AST_Constant, return_false);\n    def_has_side_effects(AST_This, return_false);\n\n    function any(list, compressor) {\n        for (var i = list.length; --i >= 0;)\n            if (list[i].has_side_effects(compressor))\n                return true;\n        return false;\n    }\n\n    def_has_side_effects(AST_Block, function(compressor) {\n        return any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Call, function(compressor) {\n        if (\n            !this.is_callee_pure(compressor)\n            && (!this.expression.is_call_pure(compressor)\n                || this.expression.has_side_effects(compressor))\n        ) {\n            return true;\n        }\n        return any(this.args, compressor);\n    });\n    def_has_side_effects(AST_Switch, function(compressor) {\n        return this.expression.has_side_effects(compressor)\n            || any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Case, function(compressor) {\n        return this.expression.has_side_effects(compressor)\n            || any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Try, function(compressor) {\n        return any(this.body, compressor)\n            || this.bcatch && this.bcatch.has_side_effects(compressor)\n            || this.bfinally && this.bfinally.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_If, function(compressor) {\n        return this.condition.has_side_effects(compressor)\n            || this.body && this.body.has_side_effects(compressor)\n            || this.alternative && this.alternative.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_LabeledStatement, function(compressor) {\n        return this.body.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_SimpleStatement, function(compressor) {\n        return this.body.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Lambda, return_false);\n    def_has_side_effects(AST_Class, function (compressor) {\n        if (this.extends && this.extends.has_side_effects(compressor)) {\n            return true;\n        }\n        return any(this.properties, compressor);\n    });\n    def_has_side_effects(AST_ClassStaticBlock, function(compressor) {\n        return any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Binary, function(compressor) {\n        return this.left.has_side_effects(compressor)\n            || this.right.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Assign, return_true);\n    def_has_side_effects(AST_Conditional, function(compressor) {\n        return this.condition.has_side_effects(compressor)\n            || this.consequent.has_side_effects(compressor)\n            || this.alternative.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Unary, function(compressor) {\n        return unary_side_effects.has(this.operator)\n            || this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_SymbolRef, function(compressor) {\n        return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);\n    });\n    def_has_side_effects(AST_SymbolClassProperty, return_false);\n    def_has_side_effects(AST_SymbolDeclaration, return_false);\n    def_has_side_effects(AST_Object, function(compressor) {\n        return any(this.properties, compressor);\n    });\n    def_has_side_effects(AST_ObjectProperty, function(compressor) {\n        return (\n            this.computed_key() && this.key.has_side_effects(compressor)\n            || this.value && this.value.has_side_effects(compressor)\n        );\n    });\n    def_has_side_effects(AST_ClassProperty, function(compressor) {\n        return (\n            this.computed_key() && this.key.has_side_effects(compressor)\n            || this.static && this.value && this.value.has_side_effects(compressor)\n        );\n    });\n    def_has_side_effects(AST_ConciseMethod, function(compressor) {\n        return this.computed_key() && this.key.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_ObjectGetter, function(compressor) {\n        return this.computed_key() && this.key.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_ObjectSetter, function(compressor) {\n        return this.computed_key() && this.key.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Array, function(compressor) {\n        return any(this.elements, compressor);\n    });\n    def_has_side_effects(AST_Dot, function(compressor) {\n        if (is_nullish(this, compressor)) return false;\n        return !this.optional && this.expression.may_throw_on_access(compressor)\n            || this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Sub, function(compressor) {\n        if (is_nullish(this, compressor)) return false;\n\n        return !this.optional && this.expression.may_throw_on_access(compressor)\n            || this.expression.has_side_effects(compressor)\n            || this.property.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Chain, function (compressor) {\n        return this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Sequence, function(compressor) {\n        return any(this.expressions, compressor);\n    });\n    def_has_side_effects(AST_Definitions, function(compressor) {\n        return any(this.definitions, compressor);\n    });\n    def_has_side_effects(AST_VarDef, function() {\n        return this.value;\n    });\n    def_has_side_effects(AST_TemplateSegment, return_false);\n    def_has_side_effects(AST_TemplateString, function(compressor) {\n        return any(this.segments, compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"has_side_effects\", func);\n});\n\n// determine if expression may throw\n(function(def_may_throw) {\n    def_may_throw(AST_Node, return_true);\n\n    def_may_throw(AST_Constant, return_false);\n    def_may_throw(AST_EmptyStatement, return_false);\n    def_may_throw(AST_Lambda, return_false);\n    def_may_throw(AST_SymbolDeclaration, return_false);\n    def_may_throw(AST_This, return_false);\n\n    function any(list, compressor) {\n        for (var i = list.length; --i >= 0;)\n            if (list[i].may_throw(compressor))\n                return true;\n        return false;\n    }\n\n    def_may_throw(AST_Class, function(compressor) {\n        if (this.extends && this.extends.may_throw(compressor)) return true;\n        return any(this.properties, compressor);\n    });\n    def_may_throw(AST_ClassStaticBlock, function (compressor) {\n        return any(this.body, compressor);\n    });\n\n    def_may_throw(AST_Array, function(compressor) {\n        return any(this.elements, compressor);\n    });\n    def_may_throw(AST_Assign, function(compressor) {\n        if (this.right.may_throw(compressor)) return true;\n        if (!compressor.has_directive(\"use strict\")\n            && this.operator == \"=\"\n            && this.left instanceof AST_SymbolRef) {\n            return false;\n        }\n        return this.left.may_throw(compressor);\n    });\n    def_may_throw(AST_Binary, function(compressor) {\n        return this.left.may_throw(compressor)\n            || this.right.may_throw(compressor);\n    });\n    def_may_throw(AST_Block, function(compressor) {\n        return any(this.body, compressor);\n    });\n    def_may_throw(AST_Call, function(compressor) {\n        if (is_nullish(this, compressor)) return false;\n        if (any(this.args, compressor)) return true;\n        if (this.is_callee_pure(compressor)) return false;\n        if (this.expression.may_throw(compressor)) return true;\n        return !(this.expression instanceof AST_Lambda)\n            || any(this.expression.body, compressor);\n    });\n    def_may_throw(AST_Case, function(compressor) {\n        return this.expression.may_throw(compressor)\n            || any(this.body, compressor);\n    });\n    def_may_throw(AST_Conditional, function(compressor) {\n        return this.condition.may_throw(compressor)\n            || this.consequent.may_throw(compressor)\n            || this.alternative.may_throw(compressor);\n    });\n    def_may_throw(AST_Definitions, function(compressor) {\n        return any(this.definitions, compressor);\n    });\n    def_may_throw(AST_If, function(compressor) {\n        return this.condition.may_throw(compressor)\n            || this.body && this.body.may_throw(compressor)\n            || this.alternative && this.alternative.may_throw(compressor);\n    });\n    def_may_throw(AST_LabeledStatement, function(compressor) {\n        return this.body.may_throw(compressor);\n    });\n    def_may_throw(AST_Object, function(compressor) {\n        return any(this.properties, compressor);\n    });\n    def_may_throw(AST_ObjectProperty, function(compressor) {\n        // TODO key may throw too\n        return this.value ? this.value.may_throw(compressor) : false;\n    });\n    def_may_throw(AST_ClassProperty, function(compressor) {\n        return (\n            this.computed_key() && this.key.may_throw(compressor)\n            || this.static && this.value && this.value.may_throw(compressor)\n        );\n    });\n    def_may_throw(AST_ConciseMethod, function(compressor) {\n        return this.computed_key() && this.key.may_throw(compressor);\n    });\n    def_may_throw(AST_ObjectGetter, function(compressor) {\n        return this.computed_key() && this.key.may_throw(compressor);\n    });\n    def_may_throw(AST_ObjectSetter, function(compressor) {\n        return this.computed_key() && this.key.may_throw(compressor);\n    });\n    def_may_throw(AST_Return, function(compressor) {\n        return this.value && this.value.may_throw(compressor);\n    });\n    def_may_throw(AST_Sequence, function(compressor) {\n        return any(this.expressions, compressor);\n    });\n    def_may_throw(AST_SimpleStatement, function(compressor) {\n        return this.body.may_throw(compressor);\n    });\n    def_may_throw(AST_Dot, function(compressor) {\n        if (is_nullish(this, compressor)) return false;\n        return !this.optional && this.expression.may_throw_on_access(compressor)\n            || this.expression.may_throw(compressor);\n    });\n    def_may_throw(AST_Sub, function(compressor) {\n        if (is_nullish(this, compressor)) return false;\n        return !this.optional && this.expression.may_throw_on_access(compressor)\n            || this.expression.may_throw(compressor)\n            || this.property.may_throw(compressor);\n    });\n    def_may_throw(AST_Chain, function(compressor) {\n        return this.expression.may_throw(compressor);\n    });\n    def_may_throw(AST_Switch, function(compressor) {\n        return this.expression.may_throw(compressor)\n            || any(this.body, compressor);\n    });\n    def_may_throw(AST_SymbolRef, function(compressor) {\n        return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);\n    });\n    def_may_throw(AST_SymbolClassProperty, return_false);\n    def_may_throw(AST_Try, function(compressor) {\n        return this.bcatch ? this.bcatch.may_throw(compressor) : any(this.body, compressor)\n            || this.bfinally && this.bfinally.may_throw(compressor);\n    });\n    def_may_throw(AST_Unary, function(compressor) {\n        if (this.operator == \"typeof\" && this.expression instanceof AST_SymbolRef)\n            return false;\n        return this.expression.may_throw(compressor);\n    });\n    def_may_throw(AST_VarDef, function(compressor) {\n        if (!this.value) return false;\n        return this.value.may_throw(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"may_throw\", func);\n});\n\n// determine if expression is constant\n(function(def_is_constant_expression) {\n    function all_refs_local(scope) {\n        let result = true;\n        walk(this, node => {\n            if (node instanceof AST_SymbolRef) {\n                if (has_flag(this, INLINED)) {\n                    result = false;\n                    return walk_abort;\n                }\n                var def = node.definition();\n                if (\n                    member(def, this.enclosed)\n                    && !this.variables.has(def.name)\n                ) {\n                    if (scope) {\n                        var scope_def = scope.find_variable(node);\n                        if (def.undeclared ? !scope_def : scope_def === def) {\n                            result = \"f\";\n                            return true;\n                        }\n                    }\n                    result = false;\n                    return walk_abort;\n                }\n                return true;\n            }\n            if (node instanceof AST_This && this instanceof AST_Arrow) {\n                // TODO check arguments too!\n                result = false;\n                return walk_abort;\n            }\n        });\n        return result;\n    }\n\n    def_is_constant_expression(AST_Node, return_false);\n    def_is_constant_expression(AST_Constant, return_true);\n    def_is_constant_expression(AST_Class, function(scope) {\n        if (this.extends && !this.extends.is_constant_expression(scope)) {\n            return false;\n        }\n\n        for (const prop of this.properties) {\n            if (prop.computed_key() && !prop.key.is_constant_expression(scope)) {\n                return false;\n            }\n            if (prop.static && prop.value && !prop.value.is_constant_expression(scope)) {\n                return false;\n            }\n            if (prop instanceof AST_ClassStaticBlock) {\n                return false;\n            }\n        }\n\n        return all_refs_local.call(this, scope);\n    });\n    def_is_constant_expression(AST_Lambda, all_refs_local);\n    def_is_constant_expression(AST_Unary, function() {\n        return this.expression.is_constant_expression();\n    });\n    def_is_constant_expression(AST_Binary, function() {\n        return this.left.is_constant_expression()\n            && this.right.is_constant_expression();\n    });\n    def_is_constant_expression(AST_Array, function() {\n        return this.elements.every((l) => l.is_constant_expression());\n    });\n    def_is_constant_expression(AST_Object, function() {\n        return this.properties.every((l) => l.is_constant_expression());\n    });\n    def_is_constant_expression(AST_ObjectProperty, function() {\n        return !!(!(this.key instanceof AST_Node) && this.value && this.value.is_constant_expression());\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_constant_expression\", func);\n});\n\n\n// may_throw_on_access()\n// returns true if this node may be null, undefined or contain `AST_Accessor`\n(function(def_may_throw_on_access) {\n    AST_Node.DEFMETHOD(\"may_throw_on_access\", function(compressor) {\n        return !compressor.option(\"pure_getters\")\n            || this._dot_throw(compressor);\n    });\n\n    function is_strict(compressor) {\n        return /strict/.test(compressor.option(\"pure_getters\"));\n    }\n\n    def_may_throw_on_access(AST_Node, is_strict);\n    def_may_throw_on_access(AST_Null, return_true);\n    def_may_throw_on_access(AST_Undefined, return_true);\n    def_may_throw_on_access(AST_Constant, return_false);\n    def_may_throw_on_access(AST_Array, return_false);\n    def_may_throw_on_access(AST_Object, function(compressor) {\n        if (!is_strict(compressor)) return false;\n        for (var i = this.properties.length; --i >=0;)\n            if (this.properties[i]._dot_throw(compressor)) return true;\n        return false;\n    });\n    // Do not be as strict with classes as we are with objects.\n    // Hopefully the community is not going to abuse static getters and setters.\n    // https://github.com/terser/terser/issues/724#issuecomment-643655656\n    def_may_throw_on_access(AST_Class, return_false);\n    def_may_throw_on_access(AST_ObjectProperty, return_false);\n    def_may_throw_on_access(AST_ObjectGetter, return_true);\n    def_may_throw_on_access(AST_Expansion, function(compressor) {\n        return this.expression._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Function, return_false);\n    def_may_throw_on_access(AST_Arrow, return_false);\n    def_may_throw_on_access(AST_UnaryPostfix, return_false);\n    def_may_throw_on_access(AST_UnaryPrefix, function() {\n        return this.operator == \"void\";\n    });\n    def_may_throw_on_access(AST_Binary, function(compressor) {\n        return (this.operator == \"&&\" || this.operator == \"||\" || this.operator == \"??\")\n            && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));\n    });\n    def_may_throw_on_access(AST_Assign, function(compressor) {\n        if (this.logical) return true;\n\n        return this.operator == \"=\"\n            && this.right._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Conditional, function(compressor) {\n        return this.consequent._dot_throw(compressor)\n            || this.alternative._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Dot, function(compressor) {\n        if (!is_strict(compressor)) return false;\n\n        if (this.property == \"prototype\") {\n            return !(\n                this.expression instanceof AST_Function\n                || this.expression instanceof AST_Class\n            );\n        }\n        return true;\n    });\n    def_may_throw_on_access(AST_Chain, function(compressor) {\n        return this.expression._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Sequence, function(compressor) {\n        return this.tail_node()._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_SymbolRef, function(compressor) {\n        if (this.name === \"arguments\") return false;\n        if (has_flag(this, UNDEFINED)) return true;\n        if (!is_strict(compressor)) return false;\n        if (is_undeclared_ref(this) && this.is_declared(compressor)) return false;\n        if (this.is_immutable()) return false;\n        var fixed = this.fixed_value();\n        return !fixed || fixed._dot_throw(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"_dot_throw\", func);\n});\n\nexport function is_lhs(node, parent) {\n    if (parent instanceof AST_Unary && unary_side_effects.has(parent.operator)) return parent.expression;\n    if (parent instanceof AST_Assign && parent.left === node) return node;\n}\n\n(function(def_find_defs) {\n    function to_node(value, orig) {\n        if (value instanceof AST_Node) {\n            if (!(value instanceof AST_Constant)) {\n                // Value may be a function, an array including functions and even a complex assign / block expression,\n                // so it should never be shared in different places.\n                // Otherwise wrong information may be used in the compression phase\n                value = value.clone(true);\n            }\n            return make_node(value.CTOR, orig, value);\n        }\n        if (Array.isArray(value)) return make_node(AST_Array, orig, {\n            elements: value.map(function(value) {\n                return to_node(value, orig);\n            })\n        });\n        if (value && typeof value == \"object\") {\n            var props = [];\n            for (var key in value) if (HOP(value, key)) {\n                props.push(make_node(AST_ObjectKeyVal, orig, {\n                    key: key,\n                    value: to_node(value[key], orig)\n                }));\n            }\n            return make_node(AST_Object, orig, {\n                properties: props\n            });\n        }\n        return make_node_from_constant(value, orig);\n    }\n\n    AST_Toplevel.DEFMETHOD(\"resolve_defines\", function(compressor) {\n        if (!compressor.option(\"global_defs\")) return this;\n        this.figure_out_scope({ ie8: compressor.option(\"ie8\") });\n        return this.transform(new TreeTransformer(function(node) {\n            var def = node._find_defs(compressor, \"\");\n            if (!def) return;\n            var level = 0, child = node, parent;\n            while (parent = this.parent(level++)) {\n                if (!(parent instanceof AST_PropAccess)) break;\n                if (parent.expression !== child) break;\n                child = parent;\n            }\n            if (is_lhs(child, parent)) {\n                return;\n            }\n            return def;\n        }));\n    });\n    def_find_defs(AST_Node, noop);\n    def_find_defs(AST_Chain, function(compressor, suffix) {\n        return this.expression._find_defs(compressor, suffix);\n    });\n    def_find_defs(AST_Dot, function(compressor, suffix) {\n        return this.expression._find_defs(compressor, \".\" + this.property + suffix);\n    });\n    def_find_defs(AST_SymbolDeclaration, function() {\n        if (!this.global()) return;\n    });\n    def_find_defs(AST_SymbolRef, function(compressor, suffix) {\n        if (!this.global()) return;\n        var defines = compressor.option(\"global_defs\");\n        var name = this.name + suffix;\n        if (HOP(defines, name)) return to_node(defines[name], this);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"_find_defs\", func);\n});\n\n// method to negate an expression\n(function(def_negate) {\n    function basic_negation(exp) {\n        return make_node(AST_UnaryPrefix, exp, {\n            operator: \"!\",\n            expression: exp\n        });\n    }\n    function best(orig, alt, first_in_statement) {\n        var negated = basic_negation(orig);\n        if (first_in_statement) {\n            var stat = make_node(AST_SimpleStatement, alt, {\n                body: alt\n            });\n            return best_of_expression(negated, stat) === stat ? alt : negated;\n        }\n        return best_of_expression(negated, alt);\n    }\n    def_negate(AST_Node, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_Statement, function() {\n        throw new Error(\"Cannot negate a statement\");\n    });\n    def_negate(AST_Function, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_Arrow, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_UnaryPrefix, function() {\n        if (this.operator == \"!\")\n            return this.expression;\n        return basic_negation(this);\n    });\n    def_negate(AST_Sequence, function(compressor) {\n        var expressions = this.expressions.slice();\n        expressions.push(expressions.pop().negate(compressor));\n        return make_sequence(this, expressions);\n    });\n    def_negate(AST_Conditional, function(compressor, first_in_statement) {\n        var self = this.clone();\n        self.consequent = self.consequent.negate(compressor);\n        self.alternative = self.alternative.negate(compressor);\n        return best(this, self, first_in_statement);\n    });\n    def_negate(AST_Binary, function(compressor, first_in_statement) {\n        var self = this.clone(), op = this.operator;\n        if (compressor.option(\"unsafe_comps\")) {\n            switch (op) {\n              case \"<=\" : self.operator = \">\"  ; return self;\n              case \"<\"  : self.operator = \">=\" ; return self;\n              case \">=\" : self.operator = \"<\"  ; return self;\n              case \">\"  : self.operator = \"<=\" ; return self;\n            }\n        }\n        switch (op) {\n          case \"==\" : self.operator = \"!=\"; return self;\n          case \"!=\" : self.operator = \"==\"; return self;\n          case \"===\": self.operator = \"!==\"; return self;\n          case \"!==\": self.operator = \"===\"; return self;\n          case \"&&\":\n            self.operator = \"||\";\n            self.left = self.left.negate(compressor, first_in_statement);\n            self.right = self.right.negate(compressor);\n            return best(this, self, first_in_statement);\n          case \"||\":\n            self.operator = \"&&\";\n            self.left = self.left.negate(compressor, first_in_statement);\n            self.right = self.right.negate(compressor);\n            return best(this, self, first_in_statement);\n        }\n        return basic_negation(this);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"negate\", function(compressor, first_in_statement) {\n        return func.call(this, compressor, first_in_statement);\n    });\n});\n\n// Is the callee of this function pure?\nvar global_pure_fns = makePredicate(\"Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError\");\nAST_Call.DEFMETHOD(\"is_callee_pure\", function(compressor) {\n    if (compressor.option(\"unsafe\")) {\n        var expr = this.expression;\n        var first_arg = (this.args && this.args[0] && this.args[0].evaluate(compressor));\n        if (\n            expr.expression && expr.expression.name === \"hasOwnProperty\" &&\n            (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)\n        ) {\n            return false;\n        }\n        if (is_undeclared_ref(expr) && global_pure_fns.has(expr.name)) return true;\n        if (\n            expr instanceof AST_Dot\n            && is_undeclared_ref(expr.expression)\n            && is_pure_native_fn(expr.expression.name, expr.property)\n        ) {\n            return true;\n        }\n    }\n    return !!has_annotation(this, _PURE) || !compressor.pure_funcs(this);\n});\n\n// If I call this, is it a pure function?\nAST_Node.DEFMETHOD(\"is_call_pure\", return_false);\nAST_Dot.DEFMETHOD(\"is_call_pure\", function(compressor) {\n    if (!compressor.option(\"unsafe\")) return;\n    const expr = this.expression;\n\n    let native_obj;\n    if (expr instanceof AST_Array) {\n        native_obj = \"Array\";\n    } else if (expr.is_boolean()) {\n        native_obj = \"Boolean\";\n    } else if (expr.is_number(compressor)) {\n        native_obj = \"Number\";\n    } else if (expr instanceof AST_RegExp) {\n        native_obj = \"RegExp\";\n    } else if (expr.is_string(compressor)) {\n        native_obj = \"String\";\n    } else if (!this.may_throw_on_access(compressor)) {\n        native_obj = \"Object\";\n    }\n    return native_obj != null && is_pure_native_method(native_obj, this.property);\n});\n\n// tell me if a statement aborts\nexport const aborts = (thing) => thing && thing.aborts();\n\n(function(def_aborts) {\n    def_aborts(AST_Statement, return_null);\n    def_aborts(AST_Jump, return_this);\n    function block_aborts() {\n        for (var i = 0; i < this.body.length; i++) {\n            if (aborts(this.body[i])) {\n                return this.body[i];\n            }\n        }\n        return null;\n    }\n    def_aborts(AST_Import, return_null);\n    def_aborts(AST_BlockStatement, block_aborts);\n    def_aborts(AST_SwitchBranch, block_aborts);\n    def_aborts(AST_DefClass, function () {\n        for (const prop of this.properties) {\n            if (prop instanceof AST_ClassStaticBlock) {\n                if (prop.aborts()) return prop;\n            }\n        }\n        return null;\n    });\n    def_aborts(AST_ClassStaticBlock, block_aborts);\n    def_aborts(AST_If, function() {\n        return this.alternative && aborts(this.body) && aborts(this.alternative) && this;\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"aborts\", func);\n});\n\nexport function is_modified(compressor, tw, node, value, level, immutable) {\n    var parent = tw.parent(level);\n    var lhs = is_lhs(node, parent);\n    if (lhs) return lhs;\n    if (!immutable\n        && parent instanceof AST_Call\n        && parent.expression === node\n        && !(value instanceof AST_Arrow)\n        && !(value instanceof AST_Class)\n        && !parent.is_callee_pure(compressor)\n        && (!(value instanceof AST_Function)\n            || !(parent instanceof AST_New) && value.contains_this())) {\n        return true;\n    }\n    if (parent instanceof AST_Array) {\n        return is_modified(compressor, tw, parent, parent, level + 1);\n    }\n    if (parent instanceof AST_ObjectKeyVal && node === parent.value) {\n        var obj = tw.parent(level + 1);\n        return is_modified(compressor, tw, obj, obj, level + 2);\n    }\n    if (parent instanceof AST_PropAccess && parent.expression === node) {\n        var prop = read_property(value, parent.property);\n        return !immutable && is_modified(compressor, tw, parent, prop, level + 1);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}