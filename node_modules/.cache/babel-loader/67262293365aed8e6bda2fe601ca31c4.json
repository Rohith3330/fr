{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'no-invalid-void-type',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow `void` type outside of generic or return types',\n      recommended: 'strict'\n    },\n    messages: {\n      invalidVoidForGeneric: '{{ generic }} may not have void as a type variable.',\n      invalidVoidNotReturnOrGeneric: 'void is only valid as a return type or generic type variable.',\n      invalidVoidNotReturn: 'void is only valid as a return type.',\n      invalidVoidNotReturnOrThisParam: 'void is only valid as return type or type of `this` parameter.',\n      invalidVoidNotReturnOrThisParamOrGeneric: 'void is only valid as a return type or generic type variable or the type of a `this` parameter.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowInGenericTypeArguments: {\n          oneOf: [{\n            type: 'boolean'\n          }, {\n            type: 'array',\n            items: {\n              type: 'string'\n            },\n            minLength: 1\n          }]\n        },\n        allowAsThisParameter: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    allowInGenericTypeArguments: true,\n    allowAsThisParameter: false\n  }],\n\n  create(context, _ref) {\n    let [{\n      allowInGenericTypeArguments,\n      allowAsThisParameter\n    }] = _ref;\n    const validParents = [utils_1.AST_NODE_TYPES.TSTypeAnnotation //\n    ];\n    const invalidGrandParents = [utils_1.AST_NODE_TYPES.TSPropertySignature, utils_1.AST_NODE_TYPES.CallExpression, utils_1.AST_NODE_TYPES.PropertyDefinition, utils_1.AST_NODE_TYPES.Identifier];\n    const validUnionMembers = [utils_1.AST_NODE_TYPES.TSVoidKeyword, utils_1.AST_NODE_TYPES.TSNeverKeyword];\n\n    if (allowInGenericTypeArguments === true) {\n      validParents.push(utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation);\n    }\n    /**\n     * @brief check if the given void keyword is used as a valid generic type\n     *\n     * reports if the type parametrized by void is not in the whitelist, or\n     * allowInGenericTypeArguments is false.\n     * no-op if the given void keyword is not used as generic type\n     */\n\n\n    function checkGenericTypeArgument(node) {\n      var _a, _b; // only matches T<..., void, ...>\n      // extra check for precaution\n\n      /* istanbul ignore next */\n\n\n      if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) !== utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation || ((_b = node.parent.parent) === null || _b === void 0 ? void 0 : _b.type) !== utils_1.AST_NODE_TYPES.TSTypeReference) {\n        return;\n      } // check whitelist\n\n\n      if (Array.isArray(allowInGenericTypeArguments)) {\n        const sourceCode = context.getSourceCode();\n        const fullyQualifiedName = sourceCode.getText(node.parent.parent.typeName).replace(/ /gu, '');\n\n        if (!allowInGenericTypeArguments.map(s => s.replace(/ /gu, '')).includes(fullyQualifiedName)) {\n          context.report({\n            messageId: 'invalidVoidForGeneric',\n            data: {\n              generic: fullyQualifiedName\n            },\n            node\n          });\n        }\n\n        return;\n      }\n\n      if (!allowInGenericTypeArguments) {\n        context.report({\n          messageId: allowAsThisParameter ? 'invalidVoidNotReturnOrThisParam' : 'invalidVoidNotReturn',\n          node\n        });\n      }\n    }\n    /**\n     * @brief checks that a union containing void is valid\n     * @return true if every member of the union is specified as a valid type in\n     * validUnionMembers, or is a valid generic type parametrized by void\n     */\n\n\n    function isValidUnionType(node) {\n      return node.types.every(member => {\n        var _a, _b;\n\n        return validUnionMembers.includes(member.type) || // allows any T<..., void, ...> here, checked by checkGenericTypeArgument\n        member.type === utils_1.AST_NODE_TYPES.TSTypeReference && ((_a = member.typeParameters) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation && ((_b = member.typeParameters) === null || _b === void 0 ? void 0 : _b.params.map(param => param.type).includes(utils_1.AST_NODE_TYPES.TSVoidKeyword));\n      });\n    }\n\n    return {\n      TSVoidKeyword(node) {\n        var _a;\n        /* istanbul ignore next */\n\n\n        if (!((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent)) {\n          return;\n        } // checks T<..., void, ...> against specification of allowInGenericArguments option\n\n\n        if (node.parent.type === utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation && node.parent.parent.type === utils_1.AST_NODE_TYPES.TSTypeReference) {\n          checkGenericTypeArgument(node);\n          return;\n        } // union w/ void must contain types from validUnionMembers, or a valid generic void type\n\n\n        if (node.parent.type === utils_1.AST_NODE_TYPES.TSUnionType && isValidUnionType(node.parent)) {\n          return;\n        } // this parameter is ok to be void.\n\n\n        if (allowAsThisParameter && node.parent.type === utils_1.AST_NODE_TYPES.TSTypeAnnotation && node.parent.parent.type === utils_1.AST_NODE_TYPES.Identifier && node.parent.parent.name === 'this') {\n          return;\n        } // default cases\n\n\n        if (validParents.includes(node.parent.type) && !invalidGrandParents.includes(node.parent.parent.type)) {\n          return;\n        }\n\n        context.report({\n          messageId: allowInGenericTypeArguments && allowAsThisParameter ? 'invalidVoidNotReturnOrThisParamOrGeneric' : allowInGenericTypeArguments ? 'invalidVoidNotReturnOrGeneric' : allowAsThisParameter ? 'invalidVoidNotReturnOrThisParam' : 'invalidVoidNotReturn',\n          node\n        });\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","messages","invalidVoidForGeneric","invalidVoidNotReturnOrGeneric","invalidVoidNotReturn","invalidVoidNotReturnOrThisParam","invalidVoidNotReturnOrThisParamOrGeneric","schema","properties","allowInGenericTypeArguments","oneOf","items","minLength","allowAsThisParameter","additionalProperties","defaultOptions","create","context","validParents","utils_1","TSTypeAnnotation","invalidGrandParents","TSPropertySignature","CallExpression","PropertyDefinition","Identifier","validUnionMembers","TSVoidKeyword","TSNeverKeyword","push","TSTypeParameterInstantiation","checkGenericTypeArgument","node","parent","_a","_b","TSTypeReference","Array","isArray","sourceCode","getSourceCode","fullyQualifiedName","getText","typeName","replace","map","s","includes","report","messageId","data","generic","isValidUnionType","types","every","member","typeParameters","params","param","TSUnionType"],"sources":["../../src/rules/no-invalid-void-type.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}