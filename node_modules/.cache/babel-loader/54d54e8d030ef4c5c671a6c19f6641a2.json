{"ast":null,"code":"import postcss from 'postcss';\nimport selectorParser from 'postcss-selector-parser';\nimport parseObjectStyles from '../util/parseObjectStyles';\nimport isPlainObject from '../util/isPlainObject';\nimport prefixSelector from '../util/prefixSelector';\nimport { updateAllClasses } from '../util/pluginUtils';\nimport log from '../util/log';\nimport * as sharedState from './sharedState';\nimport { formatVariantSelector, finalizeSelector } from '../util/formatVariantSelector';\nimport { asClass } from '../util/nameClass';\nimport { normalize } from '../util/dataTypes';\nimport { isValidVariantFormatString, parseVariant } from './setupContextUtils';\nimport isValidArbitraryValue from '../util/isValidArbitraryValue';\nimport { splitAtTopLevelOnly } from '../util/splitAtTopLevelOnly.js';\nimport { flagEnabled } from '../featureFlags';\nlet classNameParser = selectorParser(selectors => {\n  return selectors.first.filter(_ref => {\n    let {\n      type\n    } = _ref;\n    return type === 'class';\n  }).pop().value;\n});\n\nfunction getClassNameFromSelector(selector) {\n  return classNameParser.transformSync(selector);\n} // Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\n\n\nfunction* candidatePermutations(candidate) {\n  let lastIndex = Infinity;\n\n  while (lastIndex >= 0) {\n    let dashIdx;\n\n    if (lastIndex === Infinity && candidate.endsWith(']')) {\n      let bracketIdx = candidate.indexOf('['); // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n      // eg. string[]\n\n      dashIdx = ['-', '/'].includes(candidate[bracketIdx - 1]) ? bracketIdx - 1 : -1;\n    } else {\n      dashIdx = candidate.lastIndexOf('-', lastIndex);\n    }\n\n    if (dashIdx < 0) {\n      break;\n    }\n\n    let prefix = candidate.slice(0, dashIdx);\n    let modifier = candidate.slice(dashIdx + 1);\n    yield [prefix, modifier];\n    lastIndex = dashIdx - 1;\n  }\n}\n\nfunction applyPrefix(matches, context) {\n  if (matches.length === 0 || context.tailwindConfig.prefix === '') {\n    return matches;\n  }\n\n  for (let match of matches) {\n    let [meta] = match;\n\n    if (meta.options.respectPrefix) {\n      let container = postcss.root({\n        nodes: [match[1].clone()]\n      });\n      let classCandidate = match[1].raws.tailwind.classCandidate;\n      container.walkRules(r => {\n        // If this is a negative utility with a dash *before* the prefix we\n        // have to ensure that the generated selector matches the candidate\n        // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`\n        // The disconnect between candidate <-> class can cause @apply to hard crash.\n        let shouldPrependNegative = classCandidate.startsWith('-');\n        r.selector = prefixSelector(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);\n      });\n      match[1] = container.nodes[0];\n    }\n  }\n\n  return matches;\n}\n\nfunction applyImportant(matches, classCandidate) {\n  if (matches.length === 0) {\n    return matches;\n  }\n\n  let result = [];\n\n  for (let [meta, rule] of matches) {\n    let container = postcss.root({\n      nodes: [rule.clone()]\n    });\n    container.walkRules(r => {\n      r.selector = updateAllClasses(r.selector, className => {\n        if (className === classCandidate) {\n          return `!${className}`;\n        }\n\n        return className;\n      });\n      r.walkDecls(d => d.important = true);\n    });\n    result.push([{ ...meta,\n      important: true\n    }, container.nodes[0]]);\n  }\n\n  return result;\n} // Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\n\n\nfunction applyVariant(variant, matches, context) {\n  if (matches.length === 0) {\n    return matches;\n  }\n\n  let args; // Find partial arbitrary variants\n\n  if (variant.endsWith(']') && !variant.startsWith('[')) {\n    args = variant.slice(variant.lastIndexOf('[') + 1, -1);\n    variant = variant.slice(0, variant.indexOf(args) - 1\n    /* - */\n    - 1\n    /* [ */\n    );\n  } // Register arbitrary variants\n\n\n  if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {\n    let selector = normalize(variant.slice(1, -1));\n\n    if (!isValidVariantFormatString(selector)) {\n      return [];\n    }\n\n    let fn = parseVariant(selector);\n    let sort = Array.from(context.variantOrder.values()).pop() << 1n;\n    context.variantMap.set(variant, [[sort, fn]]);\n    context.variantOrder.set(variant, sort);\n  }\n\n  if (context.variantMap.has(variant)) {\n    let variantFunctionTuples = context.variantMap.get(variant).slice();\n    let result = [];\n\n    for (let [meta, rule] of matches) {\n      // Don't generate variants for user css\n      if (meta.layer === 'user') {\n        continue;\n      }\n\n      let container = postcss.root({\n        nodes: [rule.clone()]\n      });\n\n      for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples) {\n        let clone = containerFromArray ?? container.clone();\n        let collectedFormats = [];\n\n        function prepareBackup() {\n          // Already prepared, chicken out\n          if (clone.raws.neededBackup) {\n            return;\n          }\n\n          clone.raws.neededBackup = true;\n          clone.walkRules(rule => rule.raws.originalSelector = rule.selector);\n        }\n\n        function modifySelectors(modifierFunction) {\n          prepareBackup();\n          clone.each(rule => {\n            if (rule.type !== 'rule') {\n              return;\n            }\n\n            rule.selectors = rule.selectors.map(selector => {\n              return modifierFunction({\n                get className() {\n                  return getClassNameFromSelector(selector);\n                },\n\n                selector\n              });\n            });\n          });\n          return clone;\n        }\n\n        let ruleWithVariant = variantFunction({\n          // Public API\n          get container() {\n            prepareBackup();\n            return clone;\n          },\n\n          separator: context.tailwindConfig.separator,\n          modifySelectors,\n\n          // Private API for now\n          wrap(wrapper) {\n            let nodes = clone.nodes;\n            clone.removeAll();\n            wrapper.append(nodes);\n            clone.append(wrapper);\n          },\n\n          format(selectorFormat) {\n            collectedFormats.push(selectorFormat);\n          },\n\n          args\n        }); // It can happen that a list of format strings is returned from within the function. In that\n        // case, we have to process them as well. We can use the existing `variantSort`.\n\n        if (Array.isArray(ruleWithVariant)) {\n          for (let [idx, variantFunction] of ruleWithVariant.entries()) {\n            // This is a little bit scary since we are pushing to an array of items that we are\n            // currently looping over. However, you can also think of it like a processing queue\n            // where you keep handling jobs until everything is done and each job can queue more\n            // jobs if needed.\n            variantFunctionTuples.push([// TODO: This could have potential bugs if we shift the sort order from variant A far\n            // enough into the sort space of variant B. The chances are low, but if this happens\n            // then this might be the place too look at. One potential solution to this problem is\n            // reserving additional X places for these 'unknown' variants in between.\n            variantSort | BigInt(idx << ruleWithVariant.length), variantFunction, // If the clone has been modified we have to pass that back\n            // though so each rule can use the modified container\n            clone.clone()]);\n          }\n\n          continue;\n        }\n\n        if (typeof ruleWithVariant === 'string') {\n          collectedFormats.push(ruleWithVariant);\n        }\n\n        if (ruleWithVariant === null) {\n          continue;\n        } // We had to backup selectors, therefore we assume that somebody touched\n        // `container` or `modifySelectors`. Let's see if they did, so that we\n        // can restore the selectors, and collect the format strings.\n\n\n        if (clone.raws.neededBackup) {\n          delete clone.raws.neededBackup;\n          clone.walkRules(rule => {\n            let before = rule.raws.originalSelector;\n            if (!before) return;\n            delete rule.raws.originalSelector;\n            if (before === rule.selector) return; // No mutation happened\n\n            let modified = rule.selector; // Rebuild the base selector, this is what plugin authors would do\n            // as well. E.g.: `${variant}${separator}${className}`.\n            // However, plugin authors probably also prepend or append certain\n            // classes, pseudos, ids, ...\n\n            let rebuiltBase = selectorParser(selectors => {\n              selectors.walkClasses(classNode => {\n                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;\n              });\n            }).processSync(before); // Now that we know the original selector, the new selector, and\n            // the rebuild part in between, we can replace the part that plugin\n            // authors need to rebuild with `&`, and eventually store it in the\n            // collectedFormats. Similar to what `format('...')` would do.\n            //\n            // E.g.:\n            //                   variant: foo\n            //                  selector: .markdown > p\n            //      modified (by plugin): .foo .foo\\\\:markdown > p\n            //    rebuiltBase (internal): .foo\\\\:markdown > p\n            //                    format: .foo &\n\n            collectedFormats.push(modified.replace(rebuiltBase, '&'));\n            rule.selector = before;\n          });\n        } // This tracks the originating layer for the variant\n        // For example:\n        // .sm:underline {} is a variant of something in the utilities layer\n        // .sm:container {} is a variant of the container component\n\n\n        clone.nodes[0].raws.tailwind = { ...clone.nodes[0].raws.tailwind,\n          parentLayer: meta.layer\n        };\n        let withOffset = [{ ...meta,\n          sort: variantSort | meta.sort,\n          collectedFormats: (meta.collectedFormats ?? []).concat(collectedFormats),\n          isArbitraryVariant: isArbitraryValue(variant)\n        }, clone.nodes[0]];\n        result.push(withOffset);\n      }\n    }\n\n    return result;\n  }\n\n  return [];\n}\n\nfunction parseRules(rule, cache) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  // PostCSS node\n  if (!isPlainObject(rule) && !Array.isArray(rule)) {\n    return [[rule], options];\n  } // Tuple\n\n\n  if (Array.isArray(rule)) {\n    return parseRules(rule[0], cache, rule[1]);\n  } // Simple object\n\n\n  if (!cache.has(rule)) {\n    cache.set(rule, parseObjectStyles(rule));\n  }\n\n  return [cache.get(rule), options];\n}\n\nconst IS_VALID_PROPERTY_NAME = /^[a-z_-]/;\n\nfunction isValidPropName(name) {\n  return IS_VALID_PROPERTY_NAME.test(name);\n}\n/**\n * @param {string} declaration\n * @returns {boolean}\n */\n\n\nfunction looksLikeUri(declaration) {\n  // Quick bailout for obvious non-urls\n  // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem\n  if (!declaration.includes('://')) {\n    return false;\n  }\n\n  try {\n    const url = new URL(declaration);\n    return url.scheme !== '' && url.host !== '';\n  } catch (err) {\n    // Definitely not a valid url\n    return false;\n  }\n}\n\nfunction isParsableNode(node) {\n  let isParsable = true;\n  node.walkDecls(decl => {\n    if (!isParsableCssValue(decl.name, decl.value)) {\n      isParsable = false;\n      return false;\n    }\n  });\n  return isParsable;\n}\n\nfunction isParsableCssValue(property, value) {\n  // We don't want to to treat [https://example.com] as a custom property\n  // Even though, according to the CSS grammar, it's a totally valid CSS declaration\n  // So we short-circuit here by checking if the custom property looks like a url\n  if (looksLikeUri(`${property}:${value}`)) {\n    return false;\n  }\n\n  try {\n    postcss.parse(`a{${property}:${value}}`).toResult();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction extractArbitraryProperty(classCandidate, context) {\n  let [, property, value] = classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/) ?? [];\n\n  if (value === undefined) {\n    return null;\n  }\n\n  if (!isValidPropName(property)) {\n    return null;\n  }\n\n  if (!isValidArbitraryValue(value)) {\n    return null;\n  }\n\n  let normalized = normalize(value);\n\n  if (!isParsableCssValue(property, normalized)) {\n    return null;\n  }\n\n  return [[{\n    sort: context.arbitraryPropertiesSort,\n    layer: 'utilities'\n  }, () => ({\n    [asClass(classCandidate)]: {\n      [property]: normalized\n    }\n  })]];\n}\n\nfunction* resolveMatchedPlugins(classCandidate, context) {\n  if (context.candidateRuleMap.has(classCandidate)) {\n    yield [context.candidateRuleMap.get(classCandidate), 'DEFAULT'];\n  }\n\n  yield* function* (arbitraryPropertyRule) {\n    if (arbitraryPropertyRule !== null) {\n      yield [arbitraryPropertyRule, 'DEFAULT'];\n    }\n  }(extractArbitraryProperty(classCandidate, context));\n  let candidatePrefix = classCandidate;\n  let negative = false;\n  const twConfigPrefix = context.tailwindConfig.prefix;\n  const twConfigPrefixLen = twConfigPrefix.length;\n  const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);\n\n  if (candidatePrefix[twConfigPrefixLen] === '-' && hasMatchingPrefix) {\n    negative = true;\n    candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n  }\n\n  if (negative && context.candidateRuleMap.has(candidatePrefix)) {\n    yield [context.candidateRuleMap.get(candidatePrefix), '-DEFAULT'];\n  }\n\n  for (let [prefix, modifier] of candidatePermutations(candidatePrefix)) {\n    if (context.candidateRuleMap.has(prefix)) {\n      yield [context.candidateRuleMap.get(prefix), negative ? `-${modifier}` : modifier];\n    }\n  }\n}\n\nfunction splitWithSeparator(input, separator) {\n  if (input === sharedState.NOT_ON_DEMAND) {\n    return [sharedState.NOT_ON_DEMAND];\n  }\n\n  return Array.from(splitAtTopLevelOnly(input, separator));\n}\n\nfunction* recordCandidates(matches, classCandidate) {\n  for (const match of matches) {\n    match[1].raws.tailwind = { ...match[1].raws.tailwind,\n      classCandidate,\n      preserveSource: match[0].options?.preserveSource ?? false\n    };\n    yield match;\n  }\n}\n\nfunction* resolveMatches(candidate, context) {\n  let original = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : candidate;\n  let separator = context.tailwindConfig.separator;\n  let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();\n  let important = false;\n\n  if (classCandidate.startsWith('!')) {\n    important = true;\n    classCandidate = classCandidate.slice(1);\n  }\n\n  if (flagEnabled(context.tailwindConfig, 'variantGrouping')) {\n    if (classCandidate.startsWith('(') && classCandidate.endsWith(')')) {\n      let base = variants.slice().reverse().join(separator);\n\n      for (let part of splitAtTopLevelOnly(classCandidate.slice(1, -1), ',')) {\n        yield* resolveMatches(base + separator + part, context, original);\n      }\n    }\n  } // TODO: Reintroduce this in ways that doesn't break on false positives\n  // function sortAgainst(toSort, against) {\n  //   return toSort.slice().sort((a, z) => {\n  //     return bigSign(against.get(a)[0] - against.get(z)[0])\n  //   })\n  // }\n  // let sorted = sortAgainst(variants, context.variantMap)\n  // if (sorted.toString() !== variants.toString()) {\n  //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n  //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n  // }\n\n\n  for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {\n    let matches = [];\n    let typesByMatches = new Map();\n    let [plugins, modifier] = matchedPlugins;\n    let isOnlyPlugin = plugins.length === 1;\n\n    for (let [sort, plugin] of plugins) {\n      let matchesPerPlugin = [];\n\n      if (typeof plugin === 'function') {\n        for (let ruleSet of [].concat(plugin(modifier, {\n          isOnlyPlugin\n        }))) {\n          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n\n          for (let rule of rules) {\n            matchesPerPlugin.push([{ ...sort,\n              options: { ...sort.options,\n                ...options\n              }\n            }, rule]);\n          }\n        }\n      } // Only process static plugins on exact matches\n      else if (modifier === 'DEFAULT' || modifier === '-DEFAULT') {\n        let ruleSet = plugin;\n        let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n\n        for (let rule of rules) {\n          matchesPerPlugin.push([{ ...sort,\n            options: { ...sort.options,\n              ...options\n            }\n          }, rule]);\n        }\n      }\n\n      if (matchesPerPlugin.length > 0) {\n        typesByMatches.set(matchesPerPlugin, sort.options?.type);\n        matches.push(matchesPerPlugin);\n      }\n    }\n\n    if (isArbitraryValue(modifier)) {\n      // When generated arbitrary values are ambiguous, we can't know\n      // which to pick so don't generate any utilities for them\n      if (matches.length > 1) {\n        let typesPerPlugin = matches.map(match => new Set([...(typesByMatches.get(match) ?? [])])); // Remove duplicates, so that we can detect proper unique types for each plugin.\n\n        for (let pluginTypes of typesPerPlugin) {\n          for (let type of pluginTypes) {\n            let removeFromOwnGroup = false;\n\n            for (let otherGroup of typesPerPlugin) {\n              if (pluginTypes === otherGroup) continue;\n\n              if (otherGroup.has(type)) {\n                otherGroup.delete(type);\n                removeFromOwnGroup = true;\n              }\n            }\n\n            if (removeFromOwnGroup) pluginTypes.delete(type);\n          }\n        }\n\n        let messages = [];\n\n        for (let [idx, group] of typesPerPlugin.entries()) {\n          for (let type of group) {\n            let rules = matches[idx].map(_ref2 => {\n              let [, rule] = _ref2;\n              return rule;\n            }).flat().map(rule => rule.toString().split('\\n').slice(1, -1) // Remove selector and closing '}'\n            .map(line => line.trim()).map(x => `      ${x}`) // Re-indent\n            .join('\\n')).join('\\n\\n');\n            messages.push(`  Use \\`${candidate.replace('[', `[${type}:`)}\\` for \\`${rules.trim()}\\``);\n            break;\n          }\n        }\n\n        log.warn([`The class \\`${candidate}\\` is ambiguous and matches multiple utilities.`, ...messages, `If this is content and not a class, replace it with \\`${candidate.replace('[', '&lsqb;').replace(']', '&rsqb;')}\\` to silence this warning.`]);\n        continue;\n      }\n\n      matches = matches.map(list => list.filter(match => isParsableNode(match[1])));\n    }\n\n    matches = matches.flat();\n    matches = Array.from(recordCandidates(matches, classCandidate));\n    matches = applyPrefix(matches, context);\n\n    if (important) {\n      matches = applyImportant(matches, classCandidate);\n    }\n\n    for (let variant of variants) {\n      matches = applyVariant(variant, matches, context);\n    }\n\n    for (let match of matches) {\n      match[1].raws.tailwind = { ...match[1].raws.tailwind,\n        candidate\n      }; // Apply final format selector\n\n      if (match[0].collectedFormats) {\n        let finalFormat = formatVariantSelector('&', ...match[0].collectedFormats);\n        let container = postcss.root({\n          nodes: [match[1].clone()]\n        });\n        container.walkRules(rule => {\n          if (inKeyframes(rule)) return;\n          rule.selector = finalizeSelector(finalFormat, {\n            selector: rule.selector,\n            candidate: original,\n            base: candidate.split(new RegExp(`\\\\${context?.tailwindConfig?.separator ?? ':'}(?![^[]*\\\\])`)).pop(),\n            isArbitraryVariant: match[0].isArbitraryVariant,\n            context\n          });\n        });\n        match[1] = container.nodes[0];\n      }\n\n      yield match;\n    }\n  }\n}\n\nfunction inKeyframes(rule) {\n  return rule.parent && rule.parent.type === 'atrule' && rule.parent.name === 'keyframes';\n}\n\nfunction generateRules(candidates, context) {\n  let allRules = [];\n\n  for (let candidate of candidates) {\n    if (context.notClassCache.has(candidate)) {\n      continue;\n    }\n\n    if (context.classCache.has(candidate)) {\n      allRules.push(context.classCache.get(candidate));\n      continue;\n    }\n\n    let matches = Array.from(resolveMatches(candidate, context));\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n\n    context.classCache.set(candidate, matches);\n    allRules.push(matches);\n  } // Strategy based on `tailwindConfig.important`\n\n\n  let strategy = (important => {\n    if (important === true) {\n      return rule => {\n        rule.walkDecls(d => {\n          if (d.parent.type === 'rule' && !inKeyframes(d.parent)) {\n            d.important = true;\n          }\n        });\n      };\n    }\n\n    if (typeof important === 'string') {\n      return rule => {\n        rule.selectors = rule.selectors.map(selector => {\n          return `${important} ${selector}`;\n        });\n      };\n    }\n  })(context.tailwindConfig.important);\n\n  return allRules.flat(1).map(_ref3 => {\n    let [{\n      sort,\n      layer,\n      options\n    }, rule] = _ref3;\n\n    if (options.respectImportant) {\n      if (strategy) {\n        let container = postcss.root({\n          nodes: [rule.clone()]\n        });\n        container.walkRules(r => {\n          if (inKeyframes(r)) {\n            return;\n          }\n\n          strategy(r);\n        });\n        rule = container.nodes[0];\n      }\n    }\n\n    return [sort | context.layerOrder[layer], rule];\n  });\n}\n\nfunction isArbitraryValue(input) {\n  return input.startsWith('[') && input.endsWith(']');\n}\n\nexport { resolveMatches, generateRules };","map":{"version":3,"names":["postcss","selectorParser","parseObjectStyles","isPlainObject","prefixSelector","updateAllClasses","log","sharedState","formatVariantSelector","finalizeSelector","asClass","normalize","isValidVariantFormatString","parseVariant","isValidArbitraryValue","splitAtTopLevelOnly","flagEnabled","classNameParser","selectors","first","filter","type","pop","value","getClassNameFromSelector","selector","transformSync","candidatePermutations","candidate","lastIndex","Infinity","dashIdx","endsWith","bracketIdx","indexOf","includes","lastIndexOf","prefix","slice","modifier","applyPrefix","matches","context","length","tailwindConfig","match","meta","options","respectPrefix","container","root","nodes","clone","classCandidate","raws","tailwind","walkRules","r","shouldPrependNegative","startsWith","applyImportant","result","rule","className","walkDecls","d","important","push","applyVariant","variant","args","isArbitraryValue","variantMap","has","fn","sort","Array","from","variantOrder","values","set","variantFunctionTuples","get","layer","variantSort","variantFunction","containerFromArray","collectedFormats","prepareBackup","neededBackup","originalSelector","modifySelectors","modifierFunction","each","map","ruleWithVariant","separator","wrap","wrapper","removeAll","append","format","selectorFormat","isArray","idx","entries","BigInt","before","modified","rebuiltBase","walkClasses","classNode","processSync","replace","parentLayer","withOffset","concat","isArbitraryVariant","parseRules","cache","IS_VALID_PROPERTY_NAME","isValidPropName","name","test","looksLikeUri","declaration","url","URL","scheme","host","err","isParsableNode","node","isParsable","decl","isParsableCssValue","property","parse","toResult","extractArbitraryProperty","undefined","normalized","arbitraryPropertiesSort","resolveMatchedPlugins","candidateRuleMap","arbitraryPropertyRule","candidatePrefix","negative","twConfigPrefix","twConfigPrefixLen","hasMatchingPrefix","splitWithSeparator","input","NOT_ON_DEMAND","recordCandidates","preserveSource","resolveMatches","original","variants","reverse","base","join","part","matchedPlugins","typesByMatches","Map","plugins","isOnlyPlugin","plugin","matchesPerPlugin","ruleSet","rules","postCssNodeCache","typesPerPlugin","Set","pluginTypes","removeFromOwnGroup","otherGroup","delete","messages","group","flat","toString","split","line","trim","x","warn","list","finalFormat","inKeyframes","RegExp","parent","generateRules","candidates","allRules","notClassCache","classCache","add","strategy","respectImportant","layerOrder"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/src/lib/generateRules.js"],"sourcesContent":["import postcss from 'postcss'\nimport selectorParser from 'postcss-selector-parser'\nimport parseObjectStyles from '../util/parseObjectStyles'\nimport isPlainObject from '../util/isPlainObject'\nimport prefixSelector from '../util/prefixSelector'\nimport { updateAllClasses } from '../util/pluginUtils'\nimport log from '../util/log'\nimport * as sharedState from './sharedState'\nimport { formatVariantSelector, finalizeSelector } from '../util/formatVariantSelector'\nimport { asClass } from '../util/nameClass'\nimport { normalize } from '../util/dataTypes'\nimport { isValidVariantFormatString, parseVariant } from './setupContextUtils'\nimport isValidArbitraryValue from '../util/isValidArbitraryValue'\nimport { splitAtTopLevelOnly } from '../util/splitAtTopLevelOnly.js'\nimport { flagEnabled } from '../featureFlags'\n\nlet classNameParser = selectorParser((selectors) => {\n  return selectors.first.filter(({ type }) => type === 'class').pop().value\n})\n\nfunction getClassNameFromSelector(selector) {\n  return classNameParser.transformSync(selector)\n}\n\n// Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\nfunction* candidatePermutations(candidate) {\n  let lastIndex = Infinity\n\n  while (lastIndex >= 0) {\n    let dashIdx\n\n    if (lastIndex === Infinity && candidate.endsWith(']')) {\n      let bracketIdx = candidate.indexOf('[')\n\n      // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n      // eg. string[]\n      dashIdx = ['-', '/'].includes(candidate[bracketIdx - 1]) ? bracketIdx - 1 : -1\n    } else {\n      dashIdx = candidate.lastIndexOf('-', lastIndex)\n    }\n\n    if (dashIdx < 0) {\n      break\n    }\n\n    let prefix = candidate.slice(0, dashIdx)\n    let modifier = candidate.slice(dashIdx + 1)\n\n    yield [prefix, modifier]\n\n    lastIndex = dashIdx - 1\n  }\n}\n\nfunction applyPrefix(matches, context) {\n  if (matches.length === 0 || context.tailwindConfig.prefix === '') {\n    return matches\n  }\n\n  for (let match of matches) {\n    let [meta] = match\n    if (meta.options.respectPrefix) {\n      let container = postcss.root({ nodes: [match[1].clone()] })\n      let classCandidate = match[1].raws.tailwind.classCandidate\n\n      container.walkRules((r) => {\n        // If this is a negative utility with a dash *before* the prefix we\n        // have to ensure that the generated selector matches the candidate\n\n        // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`\n        // The disconnect between candidate <-> class can cause @apply to hard crash.\n        let shouldPrependNegative = classCandidate.startsWith('-')\n\n        r.selector = prefixSelector(\n          context.tailwindConfig.prefix,\n          r.selector,\n          shouldPrependNegative\n        )\n      })\n\n      match[1] = container.nodes[0]\n    }\n  }\n\n  return matches\n}\n\nfunction applyImportant(matches, classCandidate) {\n  if (matches.length === 0) {\n    return matches\n  }\n  let result = []\n\n  for (let [meta, rule] of matches) {\n    let container = postcss.root({ nodes: [rule.clone()] })\n    container.walkRules((r) => {\n      r.selector = updateAllClasses(r.selector, (className) => {\n        if (className === classCandidate) {\n          return `!${className}`\n        }\n        return className\n      })\n      r.walkDecls((d) => (d.important = true))\n    })\n    result.push([{ ...meta, important: true }, container.nodes[0]])\n  }\n\n  return result\n}\n\n// Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\n\nfunction applyVariant(variant, matches, context) {\n  if (matches.length === 0) {\n    return matches\n  }\n\n  let args\n\n  // Find partial arbitrary variants\n  if (variant.endsWith(']') && !variant.startsWith('[')) {\n    args = variant.slice(variant.lastIndexOf('[') + 1, -1)\n    variant = variant.slice(0, variant.indexOf(args) - 1 /* - */ - 1 /* [ */)\n  }\n\n  // Register arbitrary variants\n  if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {\n    let selector = normalize(variant.slice(1, -1))\n\n    if (!isValidVariantFormatString(selector)) {\n      return []\n    }\n\n    let fn = parseVariant(selector)\n\n    let sort = Array.from(context.variantOrder.values()).pop() << 1n\n    context.variantMap.set(variant, [[sort, fn]])\n    context.variantOrder.set(variant, sort)\n  }\n\n  if (context.variantMap.has(variant)) {\n    let variantFunctionTuples = context.variantMap.get(variant).slice()\n    let result = []\n\n    for (let [meta, rule] of matches) {\n      // Don't generate variants for user css\n      if (meta.layer === 'user') {\n        continue\n      }\n\n      let container = postcss.root({ nodes: [rule.clone()] })\n\n      for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples) {\n        let clone = containerFromArray ?? container.clone()\n        let collectedFormats = []\n\n        function prepareBackup() {\n          // Already prepared, chicken out\n          if (clone.raws.neededBackup) {\n            return\n          }\n          clone.raws.neededBackup = true\n          clone.walkRules((rule) => (rule.raws.originalSelector = rule.selector))\n        }\n\n        function modifySelectors(modifierFunction) {\n          prepareBackup()\n          clone.each((rule) => {\n            if (rule.type !== 'rule') {\n              return\n            }\n\n            rule.selectors = rule.selectors.map((selector) => {\n              return modifierFunction({\n                get className() {\n                  return getClassNameFromSelector(selector)\n                },\n                selector,\n              })\n            })\n          })\n\n          return clone\n        }\n\n        let ruleWithVariant = variantFunction({\n          // Public API\n          get container() {\n            prepareBackup()\n            return clone\n          },\n          separator: context.tailwindConfig.separator,\n          modifySelectors,\n\n          // Private API for now\n          wrap(wrapper) {\n            let nodes = clone.nodes\n            clone.removeAll()\n            wrapper.append(nodes)\n            clone.append(wrapper)\n          },\n          format(selectorFormat) {\n            collectedFormats.push(selectorFormat)\n          },\n          args,\n        })\n\n        // It can happen that a list of format strings is returned from within the function. In that\n        // case, we have to process them as well. We can use the existing `variantSort`.\n        if (Array.isArray(ruleWithVariant)) {\n          for (let [idx, variantFunction] of ruleWithVariant.entries()) {\n            // This is a little bit scary since we are pushing to an array of items that we are\n            // currently looping over. However, you can also think of it like a processing queue\n            // where you keep handling jobs until everything is done and each job can queue more\n            // jobs if needed.\n            variantFunctionTuples.push([\n              // TODO: This could have potential bugs if we shift the sort order from variant A far\n              // enough into the sort space of variant B. The chances are low, but if this happens\n              // then this might be the place too look at. One potential solution to this problem is\n              // reserving additional X places for these 'unknown' variants in between.\n              variantSort | BigInt(idx << ruleWithVariant.length),\n              variantFunction,\n\n              // If the clone has been modified we have to pass that back\n              // though so each rule can use the modified container\n              clone.clone(),\n            ])\n          }\n          continue\n        }\n\n        if (typeof ruleWithVariant === 'string') {\n          collectedFormats.push(ruleWithVariant)\n        }\n\n        if (ruleWithVariant === null) {\n          continue\n        }\n\n        // We had to backup selectors, therefore we assume that somebody touched\n        // `container` or `modifySelectors`. Let's see if they did, so that we\n        // can restore the selectors, and collect the format strings.\n        if (clone.raws.neededBackup) {\n          delete clone.raws.neededBackup\n          clone.walkRules((rule) => {\n            let before = rule.raws.originalSelector\n            if (!before) return\n            delete rule.raws.originalSelector\n            if (before === rule.selector) return // No mutation happened\n\n            let modified = rule.selector\n\n            // Rebuild the base selector, this is what plugin authors would do\n            // as well. E.g.: `${variant}${separator}${className}`.\n            // However, plugin authors probably also prepend or append certain\n            // classes, pseudos, ids, ...\n            let rebuiltBase = selectorParser((selectors) => {\n              selectors.walkClasses((classNode) => {\n                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`\n              })\n            }).processSync(before)\n\n            // Now that we know the original selector, the new selector, and\n            // the rebuild part in between, we can replace the part that plugin\n            // authors need to rebuild with `&`, and eventually store it in the\n            // collectedFormats. Similar to what `format('...')` would do.\n            //\n            // E.g.:\n            //                   variant: foo\n            //                  selector: .markdown > p\n            //      modified (by plugin): .foo .foo\\\\:markdown > p\n            //    rebuiltBase (internal): .foo\\\\:markdown > p\n            //                    format: .foo &\n            collectedFormats.push(modified.replace(rebuiltBase, '&'))\n            rule.selector = before\n          })\n        }\n\n        // This tracks the originating layer for the variant\n        // For example:\n        // .sm:underline {} is a variant of something in the utilities layer\n        // .sm:container {} is a variant of the container component\n        clone.nodes[0].raws.tailwind = { ...clone.nodes[0].raws.tailwind, parentLayer: meta.layer }\n\n        let withOffset = [\n          {\n            ...meta,\n            sort: variantSort | meta.sort,\n            collectedFormats: (meta.collectedFormats ?? []).concat(collectedFormats),\n            isArbitraryVariant: isArbitraryValue(variant),\n          },\n          clone.nodes[0],\n        ]\n        result.push(withOffset)\n      }\n    }\n\n    return result\n  }\n\n  return []\n}\n\nfunction parseRules(rule, cache, options = {}) {\n  // PostCSS node\n  if (!isPlainObject(rule) && !Array.isArray(rule)) {\n    return [[rule], options]\n  }\n\n  // Tuple\n  if (Array.isArray(rule)) {\n    return parseRules(rule[0], cache, rule[1])\n  }\n\n  // Simple object\n  if (!cache.has(rule)) {\n    cache.set(rule, parseObjectStyles(rule))\n  }\n\n  return [cache.get(rule), options]\n}\n\nconst IS_VALID_PROPERTY_NAME = /^[a-z_-]/\n\nfunction isValidPropName(name) {\n  return IS_VALID_PROPERTY_NAME.test(name)\n}\n\n/**\n * @param {string} declaration\n * @returns {boolean}\n */\nfunction looksLikeUri(declaration) {\n  // Quick bailout for obvious non-urls\n  // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem\n  if (!declaration.includes('://')) {\n    return false\n  }\n\n  try {\n    const url = new URL(declaration)\n    return url.scheme !== '' && url.host !== ''\n  } catch (err) {\n    // Definitely not a valid url\n    return false\n  }\n}\n\nfunction isParsableNode(node) {\n  let isParsable = true\n\n  node.walkDecls((decl) => {\n    if (!isParsableCssValue(decl.name, decl.value)) {\n      isParsable = false\n      return false\n    }\n  })\n\n  return isParsable\n}\n\nfunction isParsableCssValue(property, value) {\n  // We don't want to to treat [https://example.com] as a custom property\n  // Even though, according to the CSS grammar, it's a totally valid CSS declaration\n  // So we short-circuit here by checking if the custom property looks like a url\n  if (looksLikeUri(`${property}:${value}`)) {\n    return false\n  }\n\n  try {\n    postcss.parse(`a{${property}:${value}}`).toResult()\n    return true\n  } catch (err) {\n    return false\n  }\n}\n\nfunction extractArbitraryProperty(classCandidate, context) {\n  let [, property, value] = classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/) ?? []\n\n  if (value === undefined) {\n    return null\n  }\n\n  if (!isValidPropName(property)) {\n    return null\n  }\n\n  if (!isValidArbitraryValue(value)) {\n    return null\n  }\n\n  let normalized = normalize(value)\n\n  if (!isParsableCssValue(property, normalized)) {\n    return null\n  }\n\n  return [\n    [\n      { sort: context.arbitraryPropertiesSort, layer: 'utilities' },\n      () => ({\n        [asClass(classCandidate)]: {\n          [property]: normalized,\n        },\n      }),\n    ],\n  ]\n}\n\nfunction* resolveMatchedPlugins(classCandidate, context) {\n  if (context.candidateRuleMap.has(classCandidate)) {\n    yield [context.candidateRuleMap.get(classCandidate), 'DEFAULT']\n  }\n\n  yield* (function* (arbitraryPropertyRule) {\n    if (arbitraryPropertyRule !== null) {\n      yield [arbitraryPropertyRule, 'DEFAULT']\n    }\n  })(extractArbitraryProperty(classCandidate, context))\n\n  let candidatePrefix = classCandidate\n  let negative = false\n\n  const twConfigPrefix = context.tailwindConfig.prefix\n\n  const twConfigPrefixLen = twConfigPrefix.length\n\n  const hasMatchingPrefix =\n    candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`)\n\n  if (candidatePrefix[twConfigPrefixLen] === '-' && hasMatchingPrefix) {\n    negative = true\n    candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1)\n  }\n\n  if (negative && context.candidateRuleMap.has(candidatePrefix)) {\n    yield [context.candidateRuleMap.get(candidatePrefix), '-DEFAULT']\n  }\n\n  for (let [prefix, modifier] of candidatePermutations(candidatePrefix)) {\n    if (context.candidateRuleMap.has(prefix)) {\n      yield [context.candidateRuleMap.get(prefix), negative ? `-${modifier}` : modifier]\n    }\n  }\n}\n\nfunction splitWithSeparator(input, separator) {\n  if (input === sharedState.NOT_ON_DEMAND) {\n    return [sharedState.NOT_ON_DEMAND]\n  }\n\n  return Array.from(splitAtTopLevelOnly(input, separator))\n}\n\nfunction* recordCandidates(matches, classCandidate) {\n  for (const match of matches) {\n    match[1].raws.tailwind = {\n      ...match[1].raws.tailwind,\n      classCandidate,\n      preserveSource: match[0].options?.preserveSource ?? false,\n    }\n\n    yield match\n  }\n}\n\nfunction* resolveMatches(candidate, context, original = candidate) {\n  let separator = context.tailwindConfig.separator\n  let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse()\n  let important = false\n\n  if (classCandidate.startsWith('!')) {\n    important = true\n    classCandidate = classCandidate.slice(1)\n  }\n\n  if (flagEnabled(context.tailwindConfig, 'variantGrouping')) {\n    if (classCandidate.startsWith('(') && classCandidate.endsWith(')')) {\n      let base = variants.slice().reverse().join(separator)\n      for (let part of splitAtTopLevelOnly(classCandidate.slice(1, -1), ',')) {\n        yield* resolveMatches(base + separator + part, context, original)\n      }\n    }\n  }\n\n  // TODO: Reintroduce this in ways that doesn't break on false positives\n  // function sortAgainst(toSort, against) {\n  //   return toSort.slice().sort((a, z) => {\n  //     return bigSign(against.get(a)[0] - against.get(z)[0])\n  //   })\n  // }\n  // let sorted = sortAgainst(variants, context.variantMap)\n  // if (sorted.toString() !== variants.toString()) {\n  //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n  //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n  // }\n\n  for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {\n    let matches = []\n    let typesByMatches = new Map()\n\n    let [plugins, modifier] = matchedPlugins\n    let isOnlyPlugin = plugins.length === 1\n\n    for (let [sort, plugin] of plugins) {\n      let matchesPerPlugin = []\n\n      if (typeof plugin === 'function') {\n        for (let ruleSet of [].concat(plugin(modifier, { isOnlyPlugin }))) {\n          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache)\n          for (let rule of rules) {\n            matchesPerPlugin.push([{ ...sort, options: { ...sort.options, ...options } }, rule])\n          }\n        }\n      }\n      // Only process static plugins on exact matches\n      else if (modifier === 'DEFAULT' || modifier === '-DEFAULT') {\n        let ruleSet = plugin\n        let [rules, options] = parseRules(ruleSet, context.postCssNodeCache)\n        for (let rule of rules) {\n          matchesPerPlugin.push([{ ...sort, options: { ...sort.options, ...options } }, rule])\n        }\n      }\n\n      if (matchesPerPlugin.length > 0) {\n        typesByMatches.set(matchesPerPlugin, sort.options?.type)\n        matches.push(matchesPerPlugin)\n      }\n    }\n\n    if (isArbitraryValue(modifier)) {\n      // When generated arbitrary values are ambiguous, we can't know\n      // which to pick so don't generate any utilities for them\n      if (matches.length > 1) {\n        let typesPerPlugin = matches.map((match) => new Set([...(typesByMatches.get(match) ?? [])]))\n\n        // Remove duplicates, so that we can detect proper unique types for each plugin.\n        for (let pluginTypes of typesPerPlugin) {\n          for (let type of pluginTypes) {\n            let removeFromOwnGroup = false\n\n            for (let otherGroup of typesPerPlugin) {\n              if (pluginTypes === otherGroup) continue\n\n              if (otherGroup.has(type)) {\n                otherGroup.delete(type)\n                removeFromOwnGroup = true\n              }\n            }\n\n            if (removeFromOwnGroup) pluginTypes.delete(type)\n          }\n        }\n\n        let messages = []\n\n        for (let [idx, group] of typesPerPlugin.entries()) {\n          for (let type of group) {\n            let rules = matches[idx]\n              .map(([, rule]) => rule)\n              .flat()\n              .map((rule) =>\n                rule\n                  .toString()\n                  .split('\\n')\n                  .slice(1, -1) // Remove selector and closing '}'\n                  .map((line) => line.trim())\n                  .map((x) => `      ${x}`) // Re-indent\n                  .join('\\n')\n              )\n              .join('\\n\\n')\n\n            messages.push(\n              `  Use \\`${candidate.replace('[', `[${type}:`)}\\` for \\`${rules.trim()}\\``\n            )\n            break\n          }\n        }\n\n        log.warn([\n          `The class \\`${candidate}\\` is ambiguous and matches multiple utilities.`,\n          ...messages,\n          `If this is content and not a class, replace it with \\`${candidate\n            .replace('[', '&lsqb;')\n            .replace(']', '&rsqb;')}\\` to silence this warning.`,\n        ])\n        continue\n      }\n\n      matches = matches.map((list) => list.filter((match) => isParsableNode(match[1])))\n    }\n\n    matches = matches.flat()\n    matches = Array.from(recordCandidates(matches, classCandidate))\n    matches = applyPrefix(matches, context)\n\n    if (important) {\n      matches = applyImportant(matches, classCandidate)\n    }\n\n    for (let variant of variants) {\n      matches = applyVariant(variant, matches, context)\n    }\n\n    for (let match of matches) {\n      match[1].raws.tailwind = { ...match[1].raws.tailwind, candidate }\n\n      // Apply final format selector\n      if (match[0].collectedFormats) {\n        let finalFormat = formatVariantSelector('&', ...match[0].collectedFormats)\n        let container = postcss.root({ nodes: [match[1].clone()] })\n        container.walkRules((rule) => {\n          if (inKeyframes(rule)) return\n\n          rule.selector = finalizeSelector(finalFormat, {\n            selector: rule.selector,\n            candidate: original,\n            base: candidate\n              .split(new RegExp(`\\\\${context?.tailwindConfig?.separator ?? ':'}(?![^[]*\\\\])`))\n              .pop(),\n            isArbitraryVariant: match[0].isArbitraryVariant,\n\n            context,\n          })\n        })\n        match[1] = container.nodes[0]\n      }\n\n      yield match\n    }\n  }\n}\n\nfunction inKeyframes(rule) {\n  return rule.parent && rule.parent.type === 'atrule' && rule.parent.name === 'keyframes'\n}\n\nfunction generateRules(candidates, context) {\n  let allRules = []\n\n  for (let candidate of candidates) {\n    if (context.notClassCache.has(candidate)) {\n      continue\n    }\n\n    if (context.classCache.has(candidate)) {\n      allRules.push(context.classCache.get(candidate))\n      continue\n    }\n\n    let matches = Array.from(resolveMatches(candidate, context))\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate)\n      continue\n    }\n\n    context.classCache.set(candidate, matches)\n    allRules.push(matches)\n  }\n\n  // Strategy based on `tailwindConfig.important`\n  let strategy = ((important) => {\n    if (important === true) {\n      return (rule) => {\n        rule.walkDecls((d) => {\n          if (d.parent.type === 'rule' && !inKeyframes(d.parent)) {\n            d.important = true\n          }\n        })\n      }\n    }\n\n    if (typeof important === 'string') {\n      return (rule) => {\n        rule.selectors = rule.selectors.map((selector) => {\n          return `${important} ${selector}`\n        })\n      }\n    }\n  })(context.tailwindConfig.important)\n\n  return allRules.flat(1).map(([{ sort, layer, options }, rule]) => {\n    if (options.respectImportant) {\n      if (strategy) {\n        let container = postcss.root({ nodes: [rule.clone()] })\n        container.walkRules((r) => {\n          if (inKeyframes(r)) {\n            return\n          }\n\n          strategy(r)\n        })\n        rule = container.nodes[0]\n      }\n    }\n\n    return [sort | context.layerOrder[layer], rule]\n  })\n}\n\nfunction isArbitraryValue(input) {\n  return input.startsWith('[') && input.endsWith(']')\n}\n\nexport { resolveMatches, generateRules }\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}