{"ast":null,"code":"// @ts-check\n// Import types\n\n/** @typedef {import(\"./typings\").HtmlTagObject} HtmlTagObject */\n\n/** @typedef {import(\"./typings\").Options} HtmlWebpackOptions */\n\n/** @typedef {import(\"./typings\").ProcessedOptions} ProcessedHtmlWebpackOptions */\n\n/** @typedef {import(\"./typings\").TemplateParameter} TemplateParameter */\n\n/** @typedef {import(\"webpack/lib/Compiler.js\")} WebpackCompiler */\n\n/** @typedef {import(\"webpack/lib/Compilation.js\")} WebpackCompilation */\n'use strict';\n\nconst promisify = require('util').promisify;\n\nconst vm = require('vm');\n\nconst fs = require('fs');\n\nconst _ = require('lodash');\n\nconst path = require('path');\n\nconst {\n  CachedChildCompilation\n} = require('./lib/cached-child-compiler');\n\nconst {\n  createHtmlTagObject,\n  htmlTagObjectToString,\n  HtmlTagArray\n} = require('./lib/html-tags');\n\nconst prettyError = require('./lib/errors.js');\n\nconst chunkSorter = require('./lib/chunksorter.js');\n\nconst getHtmlWebpackPluginHooks = require('./lib/hooks.js').getHtmlWebpackPluginHooks;\n\nconst {\n  assert\n} = require('console');\n\nconst fsReadFileAsync = promisify(fs.readFile);\n\nclass HtmlWebpackPlugin {\n  /**\n   * @param {HtmlWebpackOptions} [options]\n   */\n  constructor(options) {\n    /** @type {HtmlWebpackOptions} */\n    this.userOptions = options || {};\n    this.version = HtmlWebpackPlugin.version;\n  }\n\n  apply(compiler) {\n    // Wait for configuration preset plugions to apply all configure webpack defaults\n    compiler.hooks.initialize.tap('HtmlWebpackPlugin', () => {\n      const userOptions = this.userOptions; // Default options\n\n      /** @type {ProcessedHtmlWebpackOptions} */\n\n      const defaultOptions = {\n        template: 'auto',\n        templateContent: false,\n        templateParameters: templateParametersGenerator,\n        filename: 'index.html',\n        publicPath: userOptions.publicPath === undefined ? 'auto' : userOptions.publicPath,\n        hash: false,\n        inject: userOptions.scriptLoading === 'blocking' ? 'body' : 'head',\n        scriptLoading: 'defer',\n        compile: true,\n        favicon: false,\n        minify: 'auto',\n        cache: true,\n        showErrors: true,\n        chunks: 'all',\n        excludeChunks: [],\n        chunksSortMode: 'auto',\n        meta: {},\n        base: false,\n        title: 'Webpack App',\n        xhtml: false\n      };\n      /** @type {ProcessedHtmlWebpackOptions} */\n\n      const options = Object.assign(defaultOptions, userOptions);\n      this.options = options; // Assert correct option spelling\n\n      assert(options.scriptLoading === 'defer' || options.scriptLoading === 'blocking' || options.scriptLoading === 'module', 'scriptLoading needs to be set to \"defer\", \"blocking\" or \"module\"');\n      assert(options.inject === true || options.inject === false || options.inject === 'head' || options.inject === 'body', 'inject needs to be set to true, false, \"head\" or \"body'); // Default metaOptions if no template is provided\n\n      if (!userOptions.template && options.templateContent === false && options.meta) {\n        const defaultMeta = {\n          // From https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag\n          viewport: 'width=device-width, initial-scale=1'\n        };\n        options.meta = Object.assign({}, options.meta, defaultMeta, userOptions.meta);\n      } // entryName to fileName conversion function\n\n\n      const userOptionFilename = userOptions.filename || defaultOptions.filename;\n      const filenameFunction = typeof userOptionFilename === 'function' ? userOptionFilename // Replace '[name]' with entry name\n      : entryName => userOptionFilename.replace(/\\[name\\]/g, entryName);\n      /** output filenames for the given entry names */\n\n      const entryNames = Object.keys(compiler.options.entry);\n      const outputFileNames = new Set((entryNames.length ? entryNames : ['main']).map(filenameFunction));\n      /** Option for every entry point */\n\n      const entryOptions = Array.from(outputFileNames).map(filename => ({ ...options,\n        filename\n      })); // Hook all options into the webpack compiler\n\n      entryOptions.forEach(instanceOptions => {\n        hookIntoCompiler(compiler, instanceOptions, this);\n      });\n    });\n  }\n  /**\n   * Once webpack is done with compiling the template into a NodeJS code this function\n   * evaluates it to generate the html result\n   *\n   * The evaluateCompilationResult is only a class function to allow spying during testing.\n   * Please change that in a further refactoring\n   *\n   * @param {string} source\n   * @param {string} templateFilename\n   * @returns {Promise<string | (() => string | Promise<string>)>}\n   */\n\n\n  evaluateCompilationResult(source, publicPath, templateFilename) {\n    if (!source) {\n      return Promise.reject(new Error('The child compilation didn\\'t provide a result'));\n    } // The LibraryTemplatePlugin stores the template result in a local variable.\n    // By adding it to the end the value gets extracted during evaluation\n\n\n    if (source.indexOf('HTML_WEBPACK_PLUGIN_RESULT') >= 0) {\n      source += ';\\nHTML_WEBPACK_PLUGIN_RESULT';\n    }\n\n    const templateWithoutLoaders = templateFilename.replace(/^.+!/, '').replace(/\\?.+$/, '');\n    const vmContext = vm.createContext({ ...global,\n      HTML_WEBPACK_PLUGIN: true,\n      require: require,\n      htmlWebpackPluginPublicPath: publicPath,\n      URL: require('url').URL,\n      __filename: templateWithoutLoaders\n    });\n    const vmScript = new vm.Script(source, {\n      filename: templateWithoutLoaders\n    }); // Evaluate code and cast to string\n\n    let newSource;\n\n    try {\n      newSource = vmScript.runInContext(vmContext);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    if (typeof newSource === 'object' && newSource.__esModule && newSource.default) {\n      newSource = newSource.default;\n    }\n\n    return typeof newSource === 'string' || typeof newSource === 'function' ? Promise.resolve(newSource) : Promise.reject(new Error('The loader \"' + templateWithoutLoaders + '\" didn\\'t return html.'));\n  }\n\n}\n/**\n * connect the html-webpack-plugin to the webpack compiler lifecycle hooks\n *\n * @param {import('webpack').Compiler} compiler\n * @param {ProcessedHtmlWebpackOptions} options\n * @param {HtmlWebpackPlugin} plugin\n */\n\n\nfunction hookIntoCompiler(compiler, options, plugin) {\n  const webpack = compiler.webpack; // Instance variables to keep caching information\n  // for multiple builds\n\n  let assetJson;\n  /**\n   * store the previous generated asset to emit them even if the content did not change\n   * to support watch mode for third party plugins like the clean-webpack-plugin or the compression plugin\n   * @type {Array<{html: string, name: string}>}\n   */\n\n  let previousEmittedAssets = [];\n  options.template = getFullTemplatePath(options.template, compiler.context); // Inject child compiler plugin\n\n  const childCompilerPlugin = new CachedChildCompilation(compiler);\n\n  if (!options.templateContent) {\n    childCompilerPlugin.addEntry(options.template);\n  } // convert absolute filename into relative so that webpack can\n  // generate it at correct location\n\n\n  const filename = options.filename;\n\n  if (path.resolve(filename) === path.normalize(filename)) {\n    const outputPath =\n    /** @type {string} - Once initialized the path is always a string */\n    compiler.options.output.path;\n    options.filename = path.relative(outputPath, filename);\n  } // Check if webpack is running in production mode\n  // @see https://github.com/webpack/webpack/blob/3366421f1784c449f415cda5930a8e445086f688/lib/WebpackOptionsDefaulter.js#L12-L14\n\n\n  const isProductionLikeMode = compiler.options.mode === 'production' || !compiler.options.mode;\n  const minify = options.minify;\n\n  if (minify === true || minify === 'auto' && isProductionLikeMode) {\n    /** @type { import('html-minifier-terser').Options } */\n    options.minify = {\n      // https://www.npmjs.com/package/html-minifier-terser#options-quick-reference\n      collapseWhitespace: true,\n      keepClosingSlash: true,\n      removeComments: true,\n      removeRedundantAttributes: true,\n      removeScriptTypeAttributes: true,\n      removeStyleLinkTypeAttributes: true,\n      useShortDoctype: true\n    };\n  }\n\n  compiler.hooks.thisCompilation.tap('HtmlWebpackPlugin',\n  /**\n     * Hook into the webpack compilation\n     * @param {WebpackCompilation} compilation\n    */\n  compilation => {\n    compilation.hooks.processAssets.tapAsync({\n      name: 'HtmlWebpackPlugin',\n      stage:\n      /**\n       * Generate the html after minification and dev tooling is done\n       */\n      webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE\n    },\n    /**\n     * Hook into the process assets hook\n     * @param {WebpackCompilation} compilationAssets\n     * @param {(err?: Error) => void} callback\n     */\n    (compilationAssets, callback) => {\n      // Get all entry point names for this html file\n      const entryNames = Array.from(compilation.entrypoints.keys());\n      const filteredEntryNames = filterChunks(entryNames, options.chunks, options.excludeChunks);\n      const sortedEntryNames = sortEntryChunks(filteredEntryNames, options.chunksSortMode, compilation);\n      const templateResult = options.templateContent ? {\n        mainCompilationHash: compilation.hash\n      } : childCompilerPlugin.getCompilationEntryResult(options.template);\n\n      if ('error' in templateResult) {\n        compilation.errors.push(prettyError(templateResult.error, compiler.context).toString());\n      } // If the child compilation was not executed during a previous main compile run\n      // it is a cached result\n\n\n      const isCompilationCached = templateResult.mainCompilationHash !== compilation.hash;\n      /** The public path used inside the html file */\n\n      const htmlPublicPath = getPublicPath(compilation, options.filename, options.publicPath);\n      /** Generated file paths from the entry point names */\n\n      const assets = htmlWebpackPluginAssets(compilation, sortedEntryNames, htmlPublicPath); // If the template and the assets did not change we don't have to emit the html\n\n      const newAssetJson = JSON.stringify(getAssetFiles(assets));\n\n      if (isCompilationCached && options.cache && assetJson === newAssetJson) {\n        previousEmittedAssets.forEach(_ref => {\n          let {\n            name,\n            html\n          } = _ref;\n          compilation.emitAsset(name, new webpack.sources.RawSource(html, false));\n        });\n        return callback();\n      } else {\n        previousEmittedAssets = [];\n        assetJson = newAssetJson;\n      } // The html-webpack plugin uses a object representation for the html-tags which will be injected\n      // to allow altering them more easily\n      // Just before they are converted a third-party-plugin author might change the order and content\n\n\n      const assetsPromise = getFaviconPublicPath(options.favicon, compilation, assets.publicPath).then(faviconPath => {\n        assets.favicon = faviconPath;\n        return getHtmlWebpackPluginHooks(compilation).beforeAssetTagGeneration.promise({\n          assets: assets,\n          outputName: options.filename,\n          plugin: plugin\n        });\n      }); // Turn the js and css paths into grouped HtmlTagObjects\n\n      const assetTagGroupsPromise = assetsPromise // And allow third-party-plugin authors to reorder and change the assetTags before they are grouped\n      .then(_ref2 => {\n        let {\n          assets\n        } = _ref2;\n        return getHtmlWebpackPluginHooks(compilation).alterAssetTags.promise({\n          assetTags: {\n            scripts: generatedScriptTags(assets.js),\n            styles: generateStyleTags(assets.css),\n            meta: [...generateBaseTag(options.base), ...generatedMetaTags(options.meta), ...generateFaviconTags(assets.favicon)]\n          },\n          outputName: options.filename,\n          publicPath: htmlPublicPath,\n          plugin: plugin\n        });\n      }).then(_ref3 => {\n        let {\n          assetTags\n        } = _ref3;\n        // Inject scripts to body unless it set explicitly to head\n        const scriptTarget = options.inject === 'head' || options.inject !== 'body' && options.scriptLoading !== 'blocking' ? 'head' : 'body'; // Group assets to `head` and `body` tag arrays\n\n        const assetGroups = generateAssetGroups(assetTags, scriptTarget); // Allow third-party-plugin authors to reorder and change the assetTags once they are grouped\n\n        return getHtmlWebpackPluginHooks(compilation).alterAssetTagGroups.promise({\n          headTags: assetGroups.headTags,\n          bodyTags: assetGroups.bodyTags,\n          outputName: options.filename,\n          publicPath: htmlPublicPath,\n          plugin: plugin\n        });\n      }); // Turn the compiled template into a nodejs function or into a nodejs string\n\n      const templateEvaluationPromise = Promise.resolve().then(() => {\n        if ('error' in templateResult) {\n          return options.showErrors ? prettyError(templateResult.error, compiler.context).toHtml() : 'ERROR';\n        } // Allow to use a custom function / string instead\n\n\n        if (options.templateContent !== false) {\n          return options.templateContent;\n        } // Once everything is compiled evaluate the html factory\n        // and replace it with its content\n\n\n        return 'compiledEntry' in templateResult ? plugin.evaluateCompilationResult(templateResult.compiledEntry.content, htmlPublicPath, options.template) : Promise.reject(new Error('Child compilation contained no compiledEntry'));\n      });\n      const templateExectutionPromise = Promise.all([assetsPromise, assetTagGroupsPromise, templateEvaluationPromise]) // Execute the template\n      .then(_ref4 => {\n        let [assetsHookResult, assetTags, compilationResult] = _ref4;\n        return typeof compilationResult !== 'function' ? compilationResult : executeTemplate(compilationResult, assetsHookResult.assets, {\n          headTags: assetTags.headTags,\n          bodyTags: assetTags.bodyTags\n        }, compilation);\n      });\n      const injectedHtmlPromise = Promise.all([assetTagGroupsPromise, templateExectutionPromise]) // Allow plugins to change the html before assets are injected\n      .then(_ref5 => {\n        let [assetTags, html] = _ref5;\n        const pluginArgs = {\n          html,\n          headTags: assetTags.headTags,\n          bodyTags: assetTags.bodyTags,\n          plugin: plugin,\n          outputName: options.filename\n        };\n        return getHtmlWebpackPluginHooks(compilation).afterTemplateExecution.promise(pluginArgs);\n      }).then(_ref6 => {\n        let {\n          html,\n          headTags,\n          bodyTags\n        } = _ref6;\n        return postProcessHtml(html, assets, {\n          headTags,\n          bodyTags\n        });\n      });\n      const emitHtmlPromise = injectedHtmlPromise // Allow plugins to change the html after assets are injected\n      .then(html => {\n        const pluginArgs = {\n          html,\n          plugin: plugin,\n          outputName: options.filename\n        };\n        return getHtmlWebpackPluginHooks(compilation).beforeEmit.promise(pluginArgs).then(result => result.html);\n      }).catch(err => {\n        // In case anything went wrong the promise is resolved\n        // with the error message and an error is logged\n        compilation.errors.push(prettyError(err, compiler.context).toString());\n        return options.showErrors ? prettyError(err, compiler.context).toHtml() : 'ERROR';\n      }).then(html => {\n        const filename = options.filename.replace(/\\[templatehash([^\\]]*)\\]/g, require('util').deprecate((match, options) => `[contenthash${options}]`, '[templatehash] is now [contenthash]'));\n        const replacedFilename = replacePlaceholdersInFilename(filename, html, compilation); // Add the evaluated html code to the webpack assets\n\n        compilation.emitAsset(replacedFilename.path, new webpack.sources.RawSource(html, false), replacedFilename.info);\n        previousEmittedAssets.push({\n          name: replacedFilename.path,\n          html\n        });\n        return replacedFilename.path;\n      }).then(finalOutputName => getHtmlWebpackPluginHooks(compilation).afterEmit.promise({\n        outputName: finalOutputName,\n        plugin: plugin\n      }).catch(err => {\n        console.error(err);\n        return null;\n      }).then(() => null)); // Once all files are added to the webpack compilation\n      // let the webpack compiler continue\n\n      emitHtmlPromise.then(() => {\n        callback();\n      });\n    });\n  });\n  /**\n   * Generate the template parameters for the template function\n   * @param {WebpackCompilation} compilation\n   * @param {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * @returns {Promise<{[key: any]: any}>}\n   */\n\n  function getTemplateParameters(compilation, assets, assetTags) {\n    const templateParameters = options.templateParameters;\n\n    if (templateParameters === false) {\n      return Promise.resolve({});\n    }\n\n    if (typeof templateParameters !== 'function' && typeof templateParameters !== 'object') {\n      throw new Error('templateParameters has to be either a function or an object');\n    }\n\n    const templateParameterFunction = typeof templateParameters === 'function' // A custom function can overwrite the entire template parameter preparation\n    ? templateParameters // If the template parameters is an object merge it with the default values\n    : (compilation, assets, assetTags, options) => Object.assign({}, templateParametersGenerator(compilation, assets, assetTags, options), templateParameters);\n    const preparedAssetTags = {\n      headTags: prepareAssetTagGroupForRendering(assetTags.headTags),\n      bodyTags: prepareAssetTagGroupForRendering(assetTags.bodyTags)\n    };\n    return Promise.resolve().then(() => templateParameterFunction(compilation, assets, preparedAssetTags, options));\n  }\n  /**\n   * This function renders the actual html by executing the template function\n   *\n   * @param {(templateParameters) => string | Promise<string>} templateFunction\n   * @param {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * @param {WebpackCompilation} compilation\n   *\n   * @returns Promise<string>\n   */\n\n\n  function executeTemplate(templateFunction, assets, assetTags, compilation) {\n    // Template processing\n    const templateParamsPromise = getTemplateParameters(compilation, assets, assetTags);\n    return templateParamsPromise.then(templateParams => {\n      try {\n        // If html is a promise return the promise\n        // If html is a string turn it into a promise\n        return templateFunction(templateParams);\n      } catch (e) {\n        compilation.errors.push(new Error('Template execution failed: ' + e));\n        return Promise.reject(e);\n      }\n    });\n  }\n  /**\n   * Html Post processing\n   *\n   * @param {any} html\n   * The input html\n   * @param {any} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * The asset tags to inject\n   *\n   * @returns {Promise<string>}\n   */\n\n\n  function postProcessHtml(html, assets, assetTags) {\n    if (typeof html !== 'string') {\n      return Promise.reject(new Error('Expected html to be a string but got ' + JSON.stringify(html)));\n    }\n\n    const htmlAfterInjection = options.inject ? injectAssetsIntoHtml(html, assets, assetTags) : html;\n    const htmlAfterMinification = minifyHtml(htmlAfterInjection);\n    return Promise.resolve(htmlAfterMinification);\n  }\n  /*\n   * Pushes the content of the given filename to the compilation assets\n   * @param {string} filename\n   * @param {WebpackCompilation} compilation\n   *\n   * @returns {string} file basename\n   */\n\n\n  function addFileToAssets(filename, compilation) {\n    filename = path.resolve(compilation.compiler.context, filename);\n    return fsReadFileAsync(filename).then(source => new webpack.sources.RawSource(source, false)).catch(() => Promise.reject(new Error('HtmlWebpackPlugin: could not load file ' + filename))).then(rawSource => {\n      const basename = path.basename(filename);\n      compilation.fileDependencies.add(filename);\n      compilation.emitAsset(basename, rawSource);\n      return basename;\n    });\n  }\n  /**\n   * Replace [contenthash] in filename\n   *\n   * @see https://survivejs.com/webpack/optimizing/adding-hashes-to-filenames/\n   *\n   * @param {string} filename\n   * @param {string|Buffer} fileContent\n   * @param {WebpackCompilation} compilation\n   * @returns {{ path: string, info: {} }}\n   */\n\n\n  function replacePlaceholdersInFilename(filename, fileContent, compilation) {\n    if (/\\[\\\\*([\\w:]+)\\\\*\\]/i.test(filename) === false) {\n      return {\n        path: filename,\n        info: {}\n      };\n    }\n\n    const hash = compiler.webpack.util.createHash(compilation.outputOptions.hashFunction);\n    hash.update(fileContent);\n\n    if (compilation.outputOptions.hashSalt) {\n      hash.update(compilation.outputOptions.hashSalt);\n    }\n\n    const contentHash = hash.digest(compilation.outputOptions.hashDigest).slice(0, compilation.outputOptions.hashDigestLength);\n    return compilation.getPathWithInfo(filename, {\n      contentHash,\n      chunk: {\n        hash: contentHash,\n        contentHash\n      }\n    });\n  }\n  /**\n   * Helper to sort chunks\n   * @param {string[]} entryNames\n   * @param {string|((entryNameA: string, entryNameB: string) => number)} sortMode\n   * @param {WebpackCompilation} compilation\n   */\n\n\n  function sortEntryChunks(entryNames, sortMode, compilation) {\n    // Custom function\n    if (typeof sortMode === 'function') {\n      return entryNames.sort(sortMode);\n    } // Check if the given sort mode is a valid chunkSorter sort mode\n\n\n    if (typeof chunkSorter[sortMode] !== 'undefined') {\n      return chunkSorter[sortMode](entryNames, compilation, options);\n    }\n\n    throw new Error('\"' + sortMode + '\" is not a valid chunk sort mode');\n  }\n  /**\n   * Return all chunks from the compilation result which match the exclude and include filters\n   * @param {any} chunks\n   * @param {string[]|'all'} includedChunks\n   * @param {string[]} excludedChunks\n   */\n\n\n  function filterChunks(chunks, includedChunks, excludedChunks) {\n    return chunks.filter(chunkName => {\n      // Skip if the chunks should be filtered and the given chunk was not added explicity\n      if (Array.isArray(includedChunks) && includedChunks.indexOf(chunkName) === -1) {\n        return false;\n      } // Skip if the chunks should be filtered and the given chunk was excluded explicity\n\n\n      if (Array.isArray(excludedChunks) && excludedChunks.indexOf(chunkName) !== -1) {\n        return false;\n      } // Add otherwise\n\n\n      return true;\n    });\n  }\n  /**\n   * Generate the relative or absolute base url to reference images, css, and javascript files\n   * from within the html file - the publicPath\n   *\n   * @param {WebpackCompilation} compilation\n   * @param {string} childCompilationOutputName\n   * @param {string | 'auto'} customPublicPath\n   * @returns {string}\n   */\n\n\n  function getPublicPath(compilation, childCompilationOutputName, customPublicPath) {\n    const compilationHash = compilation.hash;\n    /**\n     * @type {string} the configured public path to the asset root\n     * if a path publicPath is set in the current webpack config use it otherwise\n     * fallback to a relative path\n     */\n\n    const webpackPublicPath = compilation.getAssetPath(compilation.outputOptions.publicPath, {\n      hash: compilationHash\n    }); // Webpack 5 introduced \"auto\" as default value\n\n    const isPublicPathDefined = webpackPublicPath !== 'auto';\n    let publicPath = // If the html-webpack-plugin options contain a custom public path uset it\n    customPublicPath !== 'auto' ? customPublicPath : isPublicPathDefined // If a hard coded public path exists use it\n    ? webpackPublicPath // If no public path was set get a relative url path\n    : path.relative(path.resolve(compilation.options.output.path, path.dirname(childCompilationOutputName)), compilation.options.output.path).split(path.sep).join('/');\n\n    if (publicPath.length && publicPath.substr(-1, 1) !== '/') {\n      publicPath += '/';\n    }\n\n    return publicPath;\n  }\n  /**\n   * The htmlWebpackPluginAssets extracts the asset information of a webpack compilation\n   * for all given entry names\n   * @param {WebpackCompilation} compilation\n   * @param {string[]} entryNames\n   * @param {string | 'auto'} publicPath\n   * @returns {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }}\n   */\n\n\n  function htmlWebpackPluginAssets(compilation, entryNames, publicPath) {\n    const compilationHash = compilation.hash;\n    /**\n     * @type {{\n        publicPath: string,\n        js: Array<string>,\n        css: Array<string>,\n        manifest?: string,\n        favicon?: string\n      }}\n     */\n\n    const assets = {\n      // The public path\n      publicPath,\n      // Will contain all js and mjs files\n      js: [],\n      // Will contain all css files\n      css: [],\n      // Will contain the html5 appcache manifest files if it exists\n      manifest: Object.keys(compilation.assets).find(assetFile => path.extname(assetFile) === '.appcache'),\n      // Favicon\n      favicon: undefined\n    }; // Append a hash for cache busting\n\n    if (options.hash && assets.manifest) {\n      assets.manifest = appendHash(assets.manifest, compilationHash);\n    } // Extract paths to .js, .mjs and .css files from the current compilation\n\n\n    const entryPointPublicPathMap = {};\n    const extensionRegexp = /\\.(css|js|mjs)(\\?|$)/;\n\n    for (let i = 0; i < entryNames.length; i++) {\n      const entryName = entryNames[i];\n      /** entryPointUnfilteredFiles - also includes hot module update files */\n\n      const entryPointUnfilteredFiles = compilation.entrypoints.get(entryName).getFiles();\n      const entryPointFiles = entryPointUnfilteredFiles.filter(chunkFile => {\n        // compilation.getAsset was introduced in webpack 4.4.0\n        // once the support pre webpack 4.4.0 is dropped please\n        // remove the following guard:\n        const asset = compilation.getAsset && compilation.getAsset(chunkFile);\n\n        if (!asset) {\n          return true;\n        } // Prevent hot-module files from being included:\n\n\n        const assetMetaInformation = asset.info || {};\n        return !(assetMetaInformation.hotModuleReplacement || assetMetaInformation.development);\n      }); // Prepend the publicPath and append the hash depending on the\n      // webpack.output.publicPath and hashOptions\n      // E.g. bundle.js -> /bundle.js?hash\n\n      const entryPointPublicPaths = entryPointFiles.map(chunkFile => {\n        const entryPointPublicPath = publicPath + urlencodePath(chunkFile);\n        return options.hash ? appendHash(entryPointPublicPath, compilationHash) : entryPointPublicPath;\n      });\n      entryPointPublicPaths.forEach(entryPointPublicPath => {\n        const extMatch = extensionRegexp.exec(entryPointPublicPath); // Skip if the public path is not a .css, .mjs or .js file\n\n        if (!extMatch) {\n          return;\n        } // Skip if this file is already known\n        // (e.g. because of common chunk optimizations)\n\n\n        if (entryPointPublicPathMap[entryPointPublicPath]) {\n          return;\n        }\n\n        entryPointPublicPathMap[entryPointPublicPath] = true; // ext will contain .js or .css, because .mjs recognizes as .js\n\n        const ext = extMatch[1] === 'mjs' ? 'js' : extMatch[1];\n        assets[ext].push(entryPointPublicPath);\n      });\n    }\n\n    return assets;\n  }\n  /**\n   * Converts a favicon file from disk to a webpack resource\n   * and returns the url to the resource\n   *\n   * @param {string|false} faviconFilePath\n   * @param {WebpackCompilation} compilation\n   * @param {string} publicPath\n   * @returns {Promise<string|undefined>}\n   */\n\n\n  function getFaviconPublicPath(faviconFilePath, compilation, publicPath) {\n    if (!faviconFilePath) {\n      return Promise.resolve(undefined);\n    }\n\n    return addFileToAssets(faviconFilePath, compilation).then(faviconName => {\n      const faviconPath = publicPath + faviconName;\n\n      if (options.hash) {\n        return appendHash(faviconPath, compilation.hash);\n      }\n\n      return faviconPath;\n    });\n  }\n  /**\n   * Generate all tags script for the given file paths\n   * @param {Array<string>} jsAssets\n   * @returns {Array<HtmlTagObject>}\n   */\n\n\n  function generatedScriptTags(jsAssets) {\n    return jsAssets.map(scriptAsset => ({\n      tagName: 'script',\n      voidTag: false,\n      meta: {\n        plugin: 'html-webpack-plugin'\n      },\n      attributes: {\n        defer: options.scriptLoading === 'defer',\n        type: options.scriptLoading === 'module' ? 'module' : undefined,\n        src: scriptAsset\n      }\n    }));\n  }\n  /**\n   * Generate all style tags for the given file paths\n   * @param {Array<string>} cssAssets\n   * @returns {Array<HtmlTagObject>}\n   */\n\n\n  function generateStyleTags(cssAssets) {\n    return cssAssets.map(styleAsset => ({\n      tagName: 'link',\n      voidTag: true,\n      meta: {\n        plugin: 'html-webpack-plugin'\n      },\n      attributes: {\n        href: styleAsset,\n        rel: 'stylesheet'\n      }\n    }));\n  }\n  /**\n   * Generate an optional base tag\n   * @param { false\n            | string\n            | {[attributeName: string]: string} // attributes e.g. { href:\"http://example.com/page.html\" target:\"_blank\" }\n            } baseOption\n  * @returns {Array<HtmlTagObject>}\n  */\n\n\n  function generateBaseTag(baseOption) {\n    if (baseOption === false) {\n      return [];\n    } else {\n      return [{\n        tagName: 'base',\n        voidTag: true,\n        meta: {\n          plugin: 'html-webpack-plugin'\n        },\n        attributes: typeof baseOption === 'string' ? {\n          href: baseOption\n        } : baseOption\n      }];\n    }\n  }\n  /**\n   * Generate all meta tags for the given meta configuration\n   * @param {false | {\n            [name: string]:\n              false // disabled\n              | string // name content pair e.g. {viewport: 'width=device-width, initial-scale=1, shrink-to-fit=no'}`\n              | {[attributeName: string]: string|boolean} // custom properties e.g. { name:\"viewport\" content:\"width=500, initial-scale=1\" }\n        }} metaOptions\n  * @returns {Array<HtmlTagObject>}\n  */\n\n\n  function generatedMetaTags(metaOptions) {\n    if (metaOptions === false) {\n      return [];\n    } // Make tags self-closing in case of xhtml\n    // Turn { \"viewport\" : \"width=500, initial-scale=1\" } into\n    // [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }]\n\n\n    const metaTagAttributeObjects = Object.keys(metaOptions).map(metaName => {\n      const metaTagContent = metaOptions[metaName];\n      return typeof metaTagContent === 'string' ? {\n        name: metaName,\n        content: metaTagContent\n      } : metaTagContent;\n    }).filter(attribute => attribute !== false); // Turn [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }] into\n    // the html-webpack-plugin tag structure\n\n    return metaTagAttributeObjects.map(metaTagAttributes => {\n      if (metaTagAttributes === false) {\n        throw new Error('Invalid meta tag');\n      }\n\n      return {\n        tagName: 'meta',\n        voidTag: true,\n        meta: {\n          plugin: 'html-webpack-plugin'\n        },\n        attributes: metaTagAttributes\n      };\n    });\n  }\n  /**\n   * Generate a favicon tag for the given file path\n   * @param {string| undefined} faviconPath\n   * @returns {Array<HtmlTagObject>}\n   */\n\n\n  function generateFaviconTags(faviconPath) {\n    if (!faviconPath) {\n      return [];\n    }\n\n    return [{\n      tagName: 'link',\n      voidTag: true,\n      meta: {\n        plugin: 'html-webpack-plugin'\n      },\n      attributes: {\n        rel: 'icon',\n        href: faviconPath\n      }\n    }];\n  }\n  /**\n   * Group assets to head and bottom tags\n   *\n   * @param {{\n      scripts: Array<HtmlTagObject>;\n      styles: Array<HtmlTagObject>;\n      meta: Array<HtmlTagObject>;\n    }} assetTags\n  * @param {\"body\" | \"head\"} scriptTarget\n  * @returns {{\n      headTags: Array<HtmlTagObject>;\n      bodyTags: Array<HtmlTagObject>;\n    }}\n  */\n\n\n  function generateAssetGroups(assetTags, scriptTarget) {\n    /** @type {{ headTags: Array<HtmlTagObject>; bodyTags: Array<HtmlTagObject>; }} */\n    const result = {\n      headTags: [...assetTags.meta, ...assetTags.styles],\n      bodyTags: []\n    }; // Add script tags to head or body depending on\n    // the htmlPluginOptions\n\n    if (scriptTarget === 'body') {\n      result.bodyTags.push(...assetTags.scripts);\n    } else {\n      // If script loading is blocking add the scripts to the end of the head\n      // If script loading is non-blocking add the scripts infront of the css files\n      const insertPosition = options.scriptLoading === 'blocking' ? result.headTags.length : assetTags.meta.length;\n      result.headTags.splice(insertPosition, 0, ...assetTags.scripts);\n    }\n\n    return result;\n  }\n  /**\n   * Add toString methods for easier rendering\n   * inside the template\n   *\n   * @param {Array<HtmlTagObject>} assetTagGroup\n   * @returns {Array<HtmlTagObject>}\n   */\n\n\n  function prepareAssetTagGroupForRendering(assetTagGroup) {\n    const xhtml = options.xhtml;\n    return HtmlTagArray.from(assetTagGroup.map(assetTag => {\n      const copiedAssetTag = Object.assign({}, assetTag);\n\n      copiedAssetTag.toString = function () {\n        return htmlTagObjectToString(this, xhtml);\n      };\n\n      return copiedAssetTag;\n    }));\n  }\n  /**\n   * Injects the assets into the given html string\n   *\n   * @param {string} html\n   * The input html\n   * @param {any} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * The asset tags to inject\n   *\n   * @returns {string}\n   */\n\n\n  function injectAssetsIntoHtml(html, assets, assetTags) {\n    const htmlRegExp = /(<html[^>]*>)/i;\n    const headRegExp = /(<\\/head\\s*>)/i;\n    const bodyRegExp = /(<\\/body\\s*>)/i;\n    const body = assetTags.bodyTags.map(assetTagObject => htmlTagObjectToString(assetTagObject, options.xhtml));\n    const head = assetTags.headTags.map(assetTagObject => htmlTagObjectToString(assetTagObject, options.xhtml));\n\n    if (body.length) {\n      if (bodyRegExp.test(html)) {\n        // Append assets to body element\n        html = html.replace(bodyRegExp, match => body.join('') + match);\n      } else {\n        // Append scripts to the end of the file if no <body> element exists:\n        html += body.join('');\n      }\n    }\n\n    if (head.length) {\n      // Create a head tag if none exists\n      if (!headRegExp.test(html)) {\n        if (!htmlRegExp.test(html)) {\n          html = '<head></head>' + html;\n        } else {\n          html = html.replace(htmlRegExp, match => match + '<head></head>');\n        }\n      } // Append assets to head element\n\n\n      html = html.replace(headRegExp, match => head.join('') + match);\n    } // Inject manifest into the opening html tag\n\n\n    if (assets.manifest) {\n      html = html.replace(/(<html[^>]*)(>)/i, (match, start, end) => {\n        // Append the manifest only if no manifest was specified\n        if (/\\smanifest\\s*=/.test(match)) {\n          return match;\n        }\n\n        return start + ' manifest=\"' + assets.manifest + '\"' + end;\n      });\n    }\n\n    return html;\n  }\n  /**\n   * Appends a cache busting hash to the query string of the url\n   * E.g. http://localhost:8080/ -> http://localhost:8080/?50c9096ba6183fd728eeb065a26ec175\n   * @param {string} url\n   * @param {string} hash\n   */\n\n\n  function appendHash(url, hash) {\n    if (!url) {\n      return url;\n    }\n\n    return url + (url.indexOf('?') === -1 ? '?' : '&') + hash;\n  }\n  /**\n   * Encode each path component using `encodeURIComponent` as files can contain characters\n   * which needs special encoding in URLs like `+ `.\n   *\n   * Valid filesystem characters which need to be encoded for urls:\n   *\n   * # pound, % percent, & ampersand, { left curly bracket, } right curly bracket,\n   * \\ back slash, < left angle bracket, > right angle bracket, * asterisk, ? question mark,\n   * blank spaces, $ dollar sign, ! exclamation point, ' single quotes, \" double quotes,\n   * : colon, @ at sign, + plus sign, ` backtick, | pipe, = equal sign\n   *\n   * However the query string must not be encoded:\n   *\n   *  fo:demonstration-path/very fancy+name.js?path=/home?value=abc&value=def#zzz\n   *    ^             ^    ^    ^     ^    ^  ^    ^^    ^     ^   ^     ^   ^\n   *    |             |    |    |     |    |  |    ||    |     |   |     |   |\n   *    encoded       |    |    encoded    |  |    ||    |     |   |     |   |\n   *                 ignored              ignored  ignored     ignored   ignored\n   *\n   * @param {string} filePath\n   */\n\n\n  function urlencodePath(filePath) {\n    // People use the filepath in quite unexpected ways.\n    // Try to extract the first querystring of the url:\n    //\n    // some+path/demo.html?value=abc?def\n    //\n    const queryStringStart = filePath.indexOf('?');\n    const urlPath = queryStringStart === -1 ? filePath : filePath.substr(0, queryStringStart);\n    const queryString = filePath.substr(urlPath.length); // Encode all parts except '/' which are not part of the querystring:\n\n    const encodedUrlPath = urlPath.split('/').map(encodeURIComponent).join('/');\n    return encodedUrlPath + queryString;\n  }\n  /**\n   * Helper to return the absolute template path with a fallback loader\n   * @param {string} template\n   * The path to the template e.g. './index.html'\n   * @param {string} context\n   * The webpack base resolution path for relative paths e.g. process.cwd()\n   */\n\n\n  function getFullTemplatePath(template, context) {\n    if (template === 'auto') {\n      template = path.resolve(context, 'src/index.ejs');\n\n      if (!fs.existsSync(template)) {\n        template = path.join(__dirname, 'default_index.ejs');\n      }\n    } // If the template doesn't use a loader use the lodash template loader\n\n\n    if (template.indexOf('!') === -1) {\n      template = require.resolve('./lib/loader.js') + '!' + path.resolve(context, template);\n    } // Resolve template path\n\n\n    return template.replace(/([!])([^/\\\\][^!?]+|[^/\\\\!?])($|\\?[^!?\\n]+$)/, (match, prefix, filepath, postfix) => prefix + path.resolve(filepath) + postfix);\n  }\n  /**\n   * Minify the given string using html-minifier-terser\n   *\n   * As this is a breaking change to html-webpack-plugin 3.x\n   * provide an extended error message to explain how to get back\n   * to the old behaviour\n   *\n   * @param {string} html\n   */\n\n\n  function minifyHtml(html) {\n    if (typeof options.minify !== 'object') {\n      return html;\n    }\n\n    try {\n      return require('html-minifier-terser').minify(html, options.minify);\n    } catch (e) {\n      const isParseError = String(e.message).indexOf('Parse Error') === 0;\n\n      if (isParseError) {\n        e.message = 'html-webpack-plugin could not minify the generated output.\\n' + 'In production mode the html minifcation is enabled by default.\\n' + 'If you are not generating a valid html output please disable it manually.\\n' + 'You can do so by adding the following setting to your HtmlWebpackPlugin config:\\n|\\n|' + '    minify: false\\n|\\n' + 'See https://github.com/jantimon/html-webpack-plugin#options for details.\\n\\n' + 'For parser dedicated bugs please create an issue here:\\n' + 'https://danielruf.github.io/html-minifier-terser/' + '\\n' + e.message;\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Helper to return a sorted unique array of all asset files out of the\n   * asset object\n   */\n\n\n  function getAssetFiles(assets) {\n    const files = _.uniq(Object.keys(assets).filter(assetType => assetType !== 'chunks' && assets[assetType]).reduce((files, assetType) => files.concat(assets[assetType]), []));\n\n    files.sort();\n    return files;\n  }\n}\n/**\n * The default for options.templateParameter\n * Generate the template parameters\n *\n * Generate the template parameters for the template function\n * @param {WebpackCompilation} compilation\n * @param {{\n   publicPath: string,\n   js: Array<string>,\n   css: Array<string>,\n   manifest?: string,\n   favicon?: string\n }} assets\n * @param {{\n     headTags: HtmlTagObject[],\n     bodyTags: HtmlTagObject[]\n   }} assetTags\n * @param {ProcessedHtmlWebpackOptions} options\n * @returns {TemplateParameter}\n */\n\n\nfunction templateParametersGenerator(compilation, assets, assetTags, options) {\n  return {\n    compilation: compilation,\n    webpackConfig: compilation.options,\n    htmlWebpackPlugin: {\n      tags: assetTags,\n      files: assets,\n      options: options\n    }\n  };\n} // Statics:\n\n/**\n * The major version number of this plugin\n */\n\n\nHtmlWebpackPlugin.version = 5;\n/**\n * A static helper to get the hooks for this plugin\n *\n * Usage: HtmlWebpackPlugin.getHooks(compilation).HOOK_NAME.tapAsync('YourPluginName', () => { ... });\n */\n\nHtmlWebpackPlugin.getHooks = getHtmlWebpackPluginHooks;\nHtmlWebpackPlugin.createHtmlTagObject = createHtmlTagObject;\nmodule.exports = HtmlWebpackPlugin;","map":{"version":3,"names":["promisify","require","vm","fs","_","path","CachedChildCompilation","createHtmlTagObject","htmlTagObjectToString","HtmlTagArray","prettyError","chunkSorter","getHtmlWebpackPluginHooks","assert","fsReadFileAsync","readFile","HtmlWebpackPlugin","constructor","options","userOptions","version","apply","compiler","hooks","initialize","tap","defaultOptions","template","templateContent","templateParameters","templateParametersGenerator","filename","publicPath","undefined","hash","inject","scriptLoading","compile","favicon","minify","cache","showErrors","chunks","excludeChunks","chunksSortMode","meta","base","title","xhtml","Object","assign","defaultMeta","viewport","userOptionFilename","filenameFunction","entryName","replace","entryNames","keys","entry","outputFileNames","Set","length","map","entryOptions","Array","from","forEach","instanceOptions","hookIntoCompiler","evaluateCompilationResult","source","templateFilename","Promise","reject","Error","indexOf","templateWithoutLoaders","vmContext","createContext","global","HTML_WEBPACK_PLUGIN","htmlWebpackPluginPublicPath","URL","__filename","vmScript","Script","newSource","runInContext","e","__esModule","default","resolve","plugin","webpack","assetJson","previousEmittedAssets","getFullTemplatePath","context","childCompilerPlugin","addEntry","normalize","outputPath","output","relative","isProductionLikeMode","mode","collapseWhitespace","keepClosingSlash","removeComments","removeRedundantAttributes","removeScriptTypeAttributes","removeStyleLinkTypeAttributes","useShortDoctype","thisCompilation","compilation","processAssets","tapAsync","name","stage","Compilation","PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE","compilationAssets","callback","entrypoints","filteredEntryNames","filterChunks","sortedEntryNames","sortEntryChunks","templateResult","mainCompilationHash","getCompilationEntryResult","errors","push","error","toString","isCompilationCached","htmlPublicPath","getPublicPath","assets","htmlWebpackPluginAssets","newAssetJson","JSON","stringify","getAssetFiles","html","emitAsset","sources","RawSource","assetsPromise","getFaviconPublicPath","then","faviconPath","beforeAssetTagGeneration","promise","outputName","assetTagGroupsPromise","alterAssetTags","assetTags","scripts","generatedScriptTags","js","styles","generateStyleTags","css","generateBaseTag","generatedMetaTags","generateFaviconTags","scriptTarget","assetGroups","generateAssetGroups","alterAssetTagGroups","headTags","bodyTags","templateEvaluationPromise","toHtml","compiledEntry","content","templateExectutionPromise","all","assetsHookResult","compilationResult","executeTemplate","injectedHtmlPromise","pluginArgs","afterTemplateExecution","postProcessHtml","emitHtmlPromise","beforeEmit","result","catch","err","deprecate","match","replacedFilename","replacePlaceholdersInFilename","info","finalOutputName","afterEmit","console","getTemplateParameters","templateParameterFunction","preparedAssetTags","prepareAssetTagGroupForRendering","templateFunction","templateParamsPromise","templateParams","htmlAfterInjection","injectAssetsIntoHtml","htmlAfterMinification","minifyHtml","addFileToAssets","rawSource","basename","fileDependencies","add","fileContent","test","util","createHash","outputOptions","hashFunction","update","hashSalt","contentHash","digest","hashDigest","slice","hashDigestLength","getPathWithInfo","chunk","sortMode","sort","includedChunks","excludedChunks","filter","chunkName","isArray","childCompilationOutputName","customPublicPath","compilationHash","webpackPublicPath","getAssetPath","isPublicPathDefined","dirname","split","sep","join","substr","manifest","find","assetFile","extname","appendHash","entryPointPublicPathMap","extensionRegexp","i","entryPointUnfilteredFiles","get","getFiles","entryPointFiles","chunkFile","asset","getAsset","assetMetaInformation","hotModuleReplacement","development","entryPointPublicPaths","entryPointPublicPath","urlencodePath","extMatch","exec","ext","faviconFilePath","faviconName","jsAssets","scriptAsset","tagName","voidTag","attributes","defer","type","src","cssAssets","styleAsset","href","rel","baseOption","metaOptions","metaTagAttributeObjects","metaName","metaTagContent","attribute","metaTagAttributes","insertPosition","splice","assetTagGroup","assetTag","copiedAssetTag","htmlRegExp","headRegExp","bodyRegExp","body","assetTagObject","head","start","end","url","filePath","queryStringStart","urlPath","queryString","encodedUrlPath","encodeURIComponent","existsSync","__dirname","prefix","filepath","postfix","isParseError","String","message","files","uniq","assetType","reduce","concat","webpackConfig","htmlWebpackPlugin","tags","getHooks","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/html-webpack-plugin/index.js"],"sourcesContent":["// @ts-check\n// Import types\n/** @typedef {import(\"./typings\").HtmlTagObject} HtmlTagObject */\n/** @typedef {import(\"./typings\").Options} HtmlWebpackOptions */\n/** @typedef {import(\"./typings\").ProcessedOptions} ProcessedHtmlWebpackOptions */\n/** @typedef {import(\"./typings\").TemplateParameter} TemplateParameter */\n/** @typedef {import(\"webpack/lib/Compiler.js\")} WebpackCompiler */\n/** @typedef {import(\"webpack/lib/Compilation.js\")} WebpackCompilation */\n'use strict';\n\nconst promisify = require('util').promisify;\n\nconst vm = require('vm');\nconst fs = require('fs');\nconst _ = require('lodash');\nconst path = require('path');\nconst { CachedChildCompilation } = require('./lib/cached-child-compiler');\n\nconst { createHtmlTagObject, htmlTagObjectToString, HtmlTagArray } = require('./lib/html-tags');\n\nconst prettyError = require('./lib/errors.js');\nconst chunkSorter = require('./lib/chunksorter.js');\nconst getHtmlWebpackPluginHooks = require('./lib/hooks.js').getHtmlWebpackPluginHooks;\nconst { assert } = require('console');\n\nconst fsReadFileAsync = promisify(fs.readFile);\n\nclass HtmlWebpackPlugin {\n  /**\n   * @param {HtmlWebpackOptions} [options]\n   */\n  constructor (options) {\n    /** @type {HtmlWebpackOptions} */\n    this.userOptions = options || {};\n    this.version = HtmlWebpackPlugin.version;\n  }\n\n  apply (compiler) {\n    // Wait for configuration preset plugions to apply all configure webpack defaults\n    compiler.hooks.initialize.tap('HtmlWebpackPlugin', () => {\n      const userOptions = this.userOptions;\n\n      // Default options\n      /** @type {ProcessedHtmlWebpackOptions} */\n      const defaultOptions = {\n        template: 'auto',\n        templateContent: false,\n        templateParameters: templateParametersGenerator,\n        filename: 'index.html',\n        publicPath: userOptions.publicPath === undefined ? 'auto' : userOptions.publicPath,\n        hash: false,\n        inject: userOptions.scriptLoading === 'blocking' ? 'body' : 'head',\n        scriptLoading: 'defer',\n        compile: true,\n        favicon: false,\n        minify: 'auto',\n        cache: true,\n        showErrors: true,\n        chunks: 'all',\n        excludeChunks: [],\n        chunksSortMode: 'auto',\n        meta: {},\n        base: false,\n        title: 'Webpack App',\n        xhtml: false\n      };\n\n      /** @type {ProcessedHtmlWebpackOptions} */\n      const options = Object.assign(defaultOptions, userOptions);\n      this.options = options;\n\n      // Assert correct option spelling\n      assert(options.scriptLoading === 'defer' || options.scriptLoading === 'blocking' || options.scriptLoading === 'module', 'scriptLoading needs to be set to \"defer\", \"blocking\" or \"module\"');\n      assert(options.inject === true || options.inject === false || options.inject === 'head' || options.inject === 'body', 'inject needs to be set to true, false, \"head\" or \"body');\n\n      // Default metaOptions if no template is provided\n      if (!userOptions.template && options.templateContent === false && options.meta) {\n        const defaultMeta = {\n        // From https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag\n          viewport: 'width=device-width, initial-scale=1'\n        };\n        options.meta = Object.assign({}, options.meta, defaultMeta, userOptions.meta);\n      }\n\n      // entryName to fileName conversion function\n      const userOptionFilename = userOptions.filename || defaultOptions.filename;\n      const filenameFunction = typeof userOptionFilename === 'function'\n        ? userOptionFilename\n        // Replace '[name]' with entry name\n        : (entryName) => userOptionFilename.replace(/\\[name\\]/g, entryName);\n\n      /** output filenames for the given entry names */\n      const entryNames = Object.keys(compiler.options.entry);\n      const outputFileNames = new Set((entryNames.length ? entryNames : ['main']).map(filenameFunction));\n\n      /** Option for every entry point */\n      const entryOptions = Array.from(outputFileNames).map((filename) => ({\n        ...options,\n        filename\n      }));\n\n      // Hook all options into the webpack compiler\n      entryOptions.forEach((instanceOptions) => {\n        hookIntoCompiler(compiler, instanceOptions, this);\n      });\n    });\n  }\n\n  /**\n   * Once webpack is done with compiling the template into a NodeJS code this function\n   * evaluates it to generate the html result\n   *\n   * The evaluateCompilationResult is only a class function to allow spying during testing.\n   * Please change that in a further refactoring\n   *\n   * @param {string} source\n   * @param {string} templateFilename\n   * @returns {Promise<string | (() => string | Promise<string>)>}\n   */\n  evaluateCompilationResult (source, publicPath, templateFilename) {\n    if (!source) {\n      return Promise.reject(new Error('The child compilation didn\\'t provide a result'));\n    }\n    // The LibraryTemplatePlugin stores the template result in a local variable.\n    // By adding it to the end the value gets extracted during evaluation\n    if (source.indexOf('HTML_WEBPACK_PLUGIN_RESULT') >= 0) {\n      source += ';\\nHTML_WEBPACK_PLUGIN_RESULT';\n    }\n    const templateWithoutLoaders = templateFilename.replace(/^.+!/, '').replace(/\\?.+$/, '');\n    const vmContext = vm.createContext({\n      ...global,\n      HTML_WEBPACK_PLUGIN: true,\n      require: require,\n      htmlWebpackPluginPublicPath: publicPath,\n      URL: require('url').URL,\n      __filename: templateWithoutLoaders\n    });\n    const vmScript = new vm.Script(source, { filename: templateWithoutLoaders });\n    // Evaluate code and cast to string\n    let newSource;\n    try {\n      newSource = vmScript.runInContext(vmContext);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n    if (typeof newSource === 'object' && newSource.__esModule && newSource.default) {\n      newSource = newSource.default;\n    }\n    return typeof newSource === 'string' || typeof newSource === 'function'\n      ? Promise.resolve(newSource)\n      : Promise.reject(new Error('The loader \"' + templateWithoutLoaders + '\" didn\\'t return html.'));\n  }\n}\n\n/**\n * connect the html-webpack-plugin to the webpack compiler lifecycle hooks\n *\n * @param {import('webpack').Compiler} compiler\n * @param {ProcessedHtmlWebpackOptions} options\n * @param {HtmlWebpackPlugin} plugin\n */\nfunction hookIntoCompiler (compiler, options, plugin) {\n  const webpack = compiler.webpack;\n  // Instance variables to keep caching information\n  // for multiple builds\n  let assetJson;\n  /**\n   * store the previous generated asset to emit them even if the content did not change\n   * to support watch mode for third party plugins like the clean-webpack-plugin or the compression plugin\n   * @type {Array<{html: string, name: string}>}\n   */\n  let previousEmittedAssets = [];\n\n  options.template = getFullTemplatePath(options.template, compiler.context);\n\n  // Inject child compiler plugin\n  const childCompilerPlugin = new CachedChildCompilation(compiler);\n  if (!options.templateContent) {\n    childCompilerPlugin.addEntry(options.template);\n  }\n\n  // convert absolute filename into relative so that webpack can\n  // generate it at correct location\n  const filename = options.filename;\n  if (path.resolve(filename) === path.normalize(filename)) {\n    const outputPath = /** @type {string} - Once initialized the path is always a string */(compiler.options.output.path);\n    options.filename = path.relative(outputPath, filename);\n  }\n\n  // Check if webpack is running in production mode\n  // @see https://github.com/webpack/webpack/blob/3366421f1784c449f415cda5930a8e445086f688/lib/WebpackOptionsDefaulter.js#L12-L14\n  const isProductionLikeMode = compiler.options.mode === 'production' || !compiler.options.mode;\n\n  const minify = options.minify;\n  if (minify === true || (minify === 'auto' && isProductionLikeMode)) {\n    /** @type { import('html-minifier-terser').Options } */\n    options.minify = {\n      // https://www.npmjs.com/package/html-minifier-terser#options-quick-reference\n      collapseWhitespace: true,\n      keepClosingSlash: true,\n      removeComments: true,\n      removeRedundantAttributes: true,\n      removeScriptTypeAttributes: true,\n      removeStyleLinkTypeAttributes: true,\n      useShortDoctype: true\n    };\n  }\n\n  compiler.hooks.thisCompilation.tap('HtmlWebpackPlugin',\n    /**\n       * Hook into the webpack compilation\n       * @param {WebpackCompilation} compilation\n      */\n    (compilation) => {\n      compilation.hooks.processAssets.tapAsync(\n        {\n          name: 'HtmlWebpackPlugin',\n          stage:\n          /**\n           * Generate the html after minification and dev tooling is done\n           */\n          webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE\n        },\n        /**\n         * Hook into the process assets hook\n         * @param {WebpackCompilation} compilationAssets\n         * @param {(err?: Error) => void} callback\n         */\n        (compilationAssets, callback) => {\n          // Get all entry point names for this html file\n          const entryNames = Array.from(compilation.entrypoints.keys());\n          const filteredEntryNames = filterChunks(entryNames, options.chunks, options.excludeChunks);\n          const sortedEntryNames = sortEntryChunks(filteredEntryNames, options.chunksSortMode, compilation);\n\n          const templateResult = options.templateContent\n            ? { mainCompilationHash: compilation.hash }\n            : childCompilerPlugin.getCompilationEntryResult(options.template);\n\n          if ('error' in templateResult) {\n            compilation.errors.push(prettyError(templateResult.error, compiler.context).toString());\n          }\n\n          // If the child compilation was not executed during a previous main compile run\n          // it is a cached result\n          const isCompilationCached = templateResult.mainCompilationHash !== compilation.hash;\n\n          /** The public path used inside the html file */\n          const htmlPublicPath = getPublicPath(compilation, options.filename, options.publicPath);\n\n          /** Generated file paths from the entry point names */\n          const assets = htmlWebpackPluginAssets(compilation, sortedEntryNames, htmlPublicPath);\n\n          // If the template and the assets did not change we don't have to emit the html\n          const newAssetJson = JSON.stringify(getAssetFiles(assets));\n          if (isCompilationCached && options.cache && assetJson === newAssetJson) {\n            previousEmittedAssets.forEach(({ name, html }) => {\n              compilation.emitAsset(name, new webpack.sources.RawSource(html, false));\n            });\n            return callback();\n          } else {\n            previousEmittedAssets = [];\n            assetJson = newAssetJson;\n          }\n\n          // The html-webpack plugin uses a object representation for the html-tags which will be injected\n          // to allow altering them more easily\n          // Just before they are converted a third-party-plugin author might change the order and content\n          const assetsPromise = getFaviconPublicPath(options.favicon, compilation, assets.publicPath)\n            .then((faviconPath) => {\n              assets.favicon = faviconPath;\n              return getHtmlWebpackPluginHooks(compilation).beforeAssetTagGeneration.promise({\n                assets: assets,\n                outputName: options.filename,\n                plugin: plugin\n              });\n            });\n\n          // Turn the js and css paths into grouped HtmlTagObjects\n          const assetTagGroupsPromise = assetsPromise\n          // And allow third-party-plugin authors to reorder and change the assetTags before they are grouped\n            .then(({ assets }) => getHtmlWebpackPluginHooks(compilation).alterAssetTags.promise({\n              assetTags: {\n                scripts: generatedScriptTags(assets.js),\n                styles: generateStyleTags(assets.css),\n                meta: [\n                  ...generateBaseTag(options.base),\n                  ...generatedMetaTags(options.meta),\n                  ...generateFaviconTags(assets.favicon)\n                ]\n              },\n              outputName: options.filename,\n              publicPath: htmlPublicPath,\n              plugin: plugin\n            }))\n            .then(({ assetTags }) => {\n              // Inject scripts to body unless it set explicitly to head\n              const scriptTarget = options.inject === 'head' ||\n                (options.inject !== 'body' && options.scriptLoading !== 'blocking') ? 'head' : 'body';\n              // Group assets to `head` and `body` tag arrays\n              const assetGroups = generateAssetGroups(assetTags, scriptTarget);\n              // Allow third-party-plugin authors to reorder and change the assetTags once they are grouped\n              return getHtmlWebpackPluginHooks(compilation).alterAssetTagGroups.promise({\n                headTags: assetGroups.headTags,\n                bodyTags: assetGroups.bodyTags,\n                outputName: options.filename,\n                publicPath: htmlPublicPath,\n                plugin: plugin\n              });\n            });\n\n          // Turn the compiled template into a nodejs function or into a nodejs string\n          const templateEvaluationPromise = Promise.resolve()\n            .then(() => {\n              if ('error' in templateResult) {\n                return options.showErrors ? prettyError(templateResult.error, compiler.context).toHtml() : 'ERROR';\n              }\n              // Allow to use a custom function / string instead\n              if (options.templateContent !== false) {\n                return options.templateContent;\n              }\n              // Once everything is compiled evaluate the html factory\n              // and replace it with its content\n              return ('compiledEntry' in templateResult)\n                ? plugin.evaluateCompilationResult(templateResult.compiledEntry.content, htmlPublicPath, options.template)\n                : Promise.reject(new Error('Child compilation contained no compiledEntry'));\n            });\n          const templateExectutionPromise = Promise.all([assetsPromise, assetTagGroupsPromise, templateEvaluationPromise])\n          // Execute the template\n            .then(([assetsHookResult, assetTags, compilationResult]) => typeof compilationResult !== 'function'\n              ? compilationResult\n              : executeTemplate(compilationResult, assetsHookResult.assets, { headTags: assetTags.headTags, bodyTags: assetTags.bodyTags }, compilation));\n\n          const injectedHtmlPromise = Promise.all([assetTagGroupsPromise, templateExectutionPromise])\n          // Allow plugins to change the html before assets are injected\n            .then(([assetTags, html]) => {\n              const pluginArgs = { html, headTags: assetTags.headTags, bodyTags: assetTags.bodyTags, plugin: plugin, outputName: options.filename };\n              return getHtmlWebpackPluginHooks(compilation).afterTemplateExecution.promise(pluginArgs);\n            })\n            .then(({ html, headTags, bodyTags }) => {\n              return postProcessHtml(html, assets, { headTags, bodyTags });\n            });\n\n          const emitHtmlPromise = injectedHtmlPromise\n          // Allow plugins to change the html after assets are injected\n            .then((html) => {\n              const pluginArgs = { html, plugin: plugin, outputName: options.filename };\n              return getHtmlWebpackPluginHooks(compilation).beforeEmit.promise(pluginArgs)\n                .then(result => result.html);\n            })\n            .catch(err => {\n              // In case anything went wrong the promise is resolved\n              // with the error message and an error is logged\n              compilation.errors.push(prettyError(err, compiler.context).toString());\n              return options.showErrors ? prettyError(err, compiler.context).toHtml() : 'ERROR';\n            })\n            .then(html => {\n              const filename = options.filename.replace(/\\[templatehash([^\\]]*)\\]/g, require('util').deprecate(\n                (match, options) => `[contenthash${options}]`,\n                '[templatehash] is now [contenthash]')\n              );\n              const replacedFilename = replacePlaceholdersInFilename(filename, html, compilation);\n              // Add the evaluated html code to the webpack assets\n              compilation.emitAsset(replacedFilename.path, new webpack.sources.RawSource(html, false), replacedFilename.info);\n              previousEmittedAssets.push({ name: replacedFilename.path, html });\n              return replacedFilename.path;\n            })\n            .then((finalOutputName) => getHtmlWebpackPluginHooks(compilation).afterEmit.promise({\n              outputName: finalOutputName,\n              plugin: plugin\n            }).catch(err => {\n              console.error(err);\n              return null;\n            }).then(() => null));\n\n          // Once all files are added to the webpack compilation\n          // let the webpack compiler continue\n          emitHtmlPromise.then(() => {\n            callback();\n          });\n        });\n    });\n\n  /**\n   * Generate the template parameters for the template function\n   * @param {WebpackCompilation} compilation\n   * @param {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * @returns {Promise<{[key: any]: any}>}\n   */\n  function getTemplateParameters (compilation, assets, assetTags) {\n    const templateParameters = options.templateParameters;\n    if (templateParameters === false) {\n      return Promise.resolve({});\n    }\n    if (typeof templateParameters !== 'function' && typeof templateParameters !== 'object') {\n      throw new Error('templateParameters has to be either a function or an object');\n    }\n    const templateParameterFunction = typeof templateParameters === 'function'\n      // A custom function can overwrite the entire template parameter preparation\n      ? templateParameters\n      // If the template parameters is an object merge it with the default values\n      : (compilation, assets, assetTags, options) => Object.assign({},\n        templateParametersGenerator(compilation, assets, assetTags, options),\n        templateParameters\n      );\n    const preparedAssetTags = {\n      headTags: prepareAssetTagGroupForRendering(assetTags.headTags),\n      bodyTags: prepareAssetTagGroupForRendering(assetTags.bodyTags)\n    };\n    return Promise\n      .resolve()\n      .then(() => templateParameterFunction(compilation, assets, preparedAssetTags, options));\n  }\n\n  /**\n   * This function renders the actual html by executing the template function\n   *\n   * @param {(templateParameters) => string | Promise<string>} templateFunction\n   * @param {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * @param {WebpackCompilation} compilation\n   *\n   * @returns Promise<string>\n   */\n  function executeTemplate (templateFunction, assets, assetTags, compilation) {\n    // Template processing\n    const templateParamsPromise = getTemplateParameters(compilation, assets, assetTags);\n    return templateParamsPromise.then((templateParams) => {\n      try {\n        // If html is a promise return the promise\n        // If html is a string turn it into a promise\n        return templateFunction(templateParams);\n      } catch (e) {\n        compilation.errors.push(new Error('Template execution failed: ' + e));\n        return Promise.reject(e);\n      }\n    });\n  }\n\n  /**\n   * Html Post processing\n   *\n   * @param {any} html\n   * The input html\n   * @param {any} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * The asset tags to inject\n   *\n   * @returns {Promise<string>}\n   */\n  function postProcessHtml (html, assets, assetTags) {\n    if (typeof html !== 'string') {\n      return Promise.reject(new Error('Expected html to be a string but got ' + JSON.stringify(html)));\n    }\n    const htmlAfterInjection = options.inject\n      ? injectAssetsIntoHtml(html, assets, assetTags)\n      : html;\n    const htmlAfterMinification = minifyHtml(htmlAfterInjection);\n    return Promise.resolve(htmlAfterMinification);\n  }\n\n  /*\n   * Pushes the content of the given filename to the compilation assets\n   * @param {string} filename\n   * @param {WebpackCompilation} compilation\n   *\n   * @returns {string} file basename\n   */\n  function addFileToAssets (filename, compilation) {\n    filename = path.resolve(compilation.compiler.context, filename);\n    return fsReadFileAsync(filename)\n      .then(source => new webpack.sources.RawSource(source, false))\n      .catch(() => Promise.reject(new Error('HtmlWebpackPlugin: could not load file ' + filename)))\n      .then(rawSource => {\n        const basename = path.basename(filename);\n        compilation.fileDependencies.add(filename);\n        compilation.emitAsset(basename, rawSource);\n        return basename;\n      });\n  }\n\n  /**\n   * Replace [contenthash] in filename\n   *\n   * @see https://survivejs.com/webpack/optimizing/adding-hashes-to-filenames/\n   *\n   * @param {string} filename\n   * @param {string|Buffer} fileContent\n   * @param {WebpackCompilation} compilation\n   * @returns {{ path: string, info: {} }}\n   */\n  function replacePlaceholdersInFilename (filename, fileContent, compilation) {\n    if (/\\[\\\\*([\\w:]+)\\\\*\\]/i.test(filename) === false) {\n      return { path: filename, info: {} };\n    }\n    const hash = compiler.webpack.util.createHash(compilation.outputOptions.hashFunction);\n    hash.update(fileContent);\n    if (compilation.outputOptions.hashSalt) {\n      hash.update(compilation.outputOptions.hashSalt);\n    }\n    const contentHash = hash.digest(compilation.outputOptions.hashDigest).slice(0, compilation.outputOptions.hashDigestLength);\n    return compilation.getPathWithInfo(\n      filename,\n      {\n        contentHash,\n        chunk: {\n          hash: contentHash,\n          contentHash\n        }\n      }\n    );\n  }\n\n  /**\n   * Helper to sort chunks\n   * @param {string[]} entryNames\n   * @param {string|((entryNameA: string, entryNameB: string) => number)} sortMode\n   * @param {WebpackCompilation} compilation\n   */\n  function sortEntryChunks (entryNames, sortMode, compilation) {\n    // Custom function\n    if (typeof sortMode === 'function') {\n      return entryNames.sort(sortMode);\n    }\n    // Check if the given sort mode is a valid chunkSorter sort mode\n    if (typeof chunkSorter[sortMode] !== 'undefined') {\n      return chunkSorter[sortMode](entryNames, compilation, options);\n    }\n    throw new Error('\"' + sortMode + '\" is not a valid chunk sort mode');\n  }\n\n  /**\n   * Return all chunks from the compilation result which match the exclude and include filters\n   * @param {any} chunks\n   * @param {string[]|'all'} includedChunks\n   * @param {string[]} excludedChunks\n   */\n  function filterChunks (chunks, includedChunks, excludedChunks) {\n    return chunks.filter(chunkName => {\n      // Skip if the chunks should be filtered and the given chunk was not added explicity\n      if (Array.isArray(includedChunks) && includedChunks.indexOf(chunkName) === -1) {\n        return false;\n      }\n      // Skip if the chunks should be filtered and the given chunk was excluded explicity\n      if (Array.isArray(excludedChunks) && excludedChunks.indexOf(chunkName) !== -1) {\n        return false;\n      }\n      // Add otherwise\n      return true;\n    });\n  }\n\n  /**\n   * Generate the relative or absolute base url to reference images, css, and javascript files\n   * from within the html file - the publicPath\n   *\n   * @param {WebpackCompilation} compilation\n   * @param {string} childCompilationOutputName\n   * @param {string | 'auto'} customPublicPath\n   * @returns {string}\n   */\n  function getPublicPath (compilation, childCompilationOutputName, customPublicPath) {\n    const compilationHash = compilation.hash;\n\n    /**\n     * @type {string} the configured public path to the asset root\n     * if a path publicPath is set in the current webpack config use it otherwise\n     * fallback to a relative path\n     */\n    const webpackPublicPath = compilation.getAssetPath(compilation.outputOptions.publicPath, { hash: compilationHash });\n\n    // Webpack 5 introduced \"auto\" as default value\n    const isPublicPathDefined = webpackPublicPath !== 'auto';\n\n    let publicPath =\n      // If the html-webpack-plugin options contain a custom public path uset it\n      customPublicPath !== 'auto'\n        ? customPublicPath\n        : (isPublicPathDefined\n          // If a hard coded public path exists use it\n          ? webpackPublicPath\n          // If no public path was set get a relative url path\n          : path.relative(path.resolve(compilation.options.output.path, path.dirname(childCompilationOutputName)), compilation.options.output.path)\n            .split(path.sep).join('/')\n        );\n\n    if (publicPath.length && publicPath.substr(-1, 1) !== '/') {\n      publicPath += '/';\n    }\n\n    return publicPath;\n  }\n\n  /**\n   * The htmlWebpackPluginAssets extracts the asset information of a webpack compilation\n   * for all given entry names\n   * @param {WebpackCompilation} compilation\n   * @param {string[]} entryNames\n   * @param {string | 'auto'} publicPath\n   * @returns {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }}\n   */\n  function htmlWebpackPluginAssets (compilation, entryNames, publicPath) {\n    const compilationHash = compilation.hash;\n    /**\n     * @type {{\n        publicPath: string,\n        js: Array<string>,\n        css: Array<string>,\n        manifest?: string,\n        favicon?: string\n      }}\n     */\n    const assets = {\n      // The public path\n      publicPath,\n      // Will contain all js and mjs files\n      js: [],\n      // Will contain all css files\n      css: [],\n      // Will contain the html5 appcache manifest files if it exists\n      manifest: Object.keys(compilation.assets).find(assetFile => path.extname(assetFile) === '.appcache'),\n      // Favicon\n      favicon: undefined\n    };\n\n    // Append a hash for cache busting\n    if (options.hash && assets.manifest) {\n      assets.manifest = appendHash(assets.manifest, compilationHash);\n    }\n\n    // Extract paths to .js, .mjs and .css files from the current compilation\n    const entryPointPublicPathMap = {};\n    const extensionRegexp = /\\.(css|js|mjs)(\\?|$)/;\n    for (let i = 0; i < entryNames.length; i++) {\n      const entryName = entryNames[i];\n      /** entryPointUnfilteredFiles - also includes hot module update files */\n      const entryPointUnfilteredFiles = compilation.entrypoints.get(entryName).getFiles();\n\n      const entryPointFiles = entryPointUnfilteredFiles.filter((chunkFile) => {\n        // compilation.getAsset was introduced in webpack 4.4.0\n        // once the support pre webpack 4.4.0 is dropped please\n        // remove the following guard:\n        const asset = compilation.getAsset && compilation.getAsset(chunkFile);\n        if (!asset) {\n          return true;\n        }\n        // Prevent hot-module files from being included:\n        const assetMetaInformation = asset.info || {};\n        return !(assetMetaInformation.hotModuleReplacement || assetMetaInformation.development);\n      });\n\n      // Prepend the publicPath and append the hash depending on the\n      // webpack.output.publicPath and hashOptions\n      // E.g. bundle.js -> /bundle.js?hash\n      const entryPointPublicPaths = entryPointFiles\n        .map(chunkFile => {\n          const entryPointPublicPath = publicPath + urlencodePath(chunkFile);\n          return options.hash\n            ? appendHash(entryPointPublicPath, compilationHash)\n            : entryPointPublicPath;\n        });\n\n      entryPointPublicPaths.forEach((entryPointPublicPath) => {\n        const extMatch = extensionRegexp.exec(entryPointPublicPath);\n        // Skip if the public path is not a .css, .mjs or .js file\n        if (!extMatch) {\n          return;\n        }\n        // Skip if this file is already known\n        // (e.g. because of common chunk optimizations)\n        if (entryPointPublicPathMap[entryPointPublicPath]) {\n          return;\n        }\n        entryPointPublicPathMap[entryPointPublicPath] = true;\n        // ext will contain .js or .css, because .mjs recognizes as .js\n        const ext = extMatch[1] === 'mjs' ? 'js' : extMatch[1];\n        assets[ext].push(entryPointPublicPath);\n      });\n    }\n    return assets;\n  }\n\n  /**\n   * Converts a favicon file from disk to a webpack resource\n   * and returns the url to the resource\n   *\n   * @param {string|false} faviconFilePath\n   * @param {WebpackCompilation} compilation\n   * @param {string} publicPath\n   * @returns {Promise<string|undefined>}\n   */\n  function getFaviconPublicPath (faviconFilePath, compilation, publicPath) {\n    if (!faviconFilePath) {\n      return Promise.resolve(undefined);\n    }\n    return addFileToAssets(faviconFilePath, compilation)\n      .then((faviconName) => {\n        const faviconPath = publicPath + faviconName;\n        if (options.hash) {\n          return appendHash(faviconPath, compilation.hash);\n        }\n        return faviconPath;\n      });\n  }\n\n  /**\n   * Generate all tags script for the given file paths\n   * @param {Array<string>} jsAssets\n   * @returns {Array<HtmlTagObject>}\n   */\n  function generatedScriptTags (jsAssets) {\n    return jsAssets.map(scriptAsset => ({\n      tagName: 'script',\n      voidTag: false,\n      meta: { plugin: 'html-webpack-plugin' },\n      attributes: {\n        defer: options.scriptLoading === 'defer',\n        type: options.scriptLoading === 'module' ? 'module' : undefined,\n        src: scriptAsset\n      }\n    }));\n  }\n\n  /**\n   * Generate all style tags for the given file paths\n   * @param {Array<string>} cssAssets\n   * @returns {Array<HtmlTagObject>}\n   */\n  function generateStyleTags (cssAssets) {\n    return cssAssets.map(styleAsset => ({\n      tagName: 'link',\n      voidTag: true,\n      meta: { plugin: 'html-webpack-plugin' },\n      attributes: {\n        href: styleAsset,\n        rel: 'stylesheet'\n      }\n    }));\n  }\n\n  /**\n   * Generate an optional base tag\n   * @param { false\n            | string\n            | {[attributeName: string]: string} // attributes e.g. { href:\"http://example.com/page.html\" target:\"_blank\" }\n            } baseOption\n  * @returns {Array<HtmlTagObject>}\n  */\n  function generateBaseTag (baseOption) {\n    if (baseOption === false) {\n      return [];\n    } else {\n      return [{\n        tagName: 'base',\n        voidTag: true,\n        meta: { plugin: 'html-webpack-plugin' },\n        attributes: (typeof baseOption === 'string') ? {\n          href: baseOption\n        } : baseOption\n      }];\n    }\n  }\n\n  /**\n   * Generate all meta tags for the given meta configuration\n   * @param {false | {\n            [name: string]:\n              false // disabled\n              | string // name content pair e.g. {viewport: 'width=device-width, initial-scale=1, shrink-to-fit=no'}`\n              | {[attributeName: string]: string|boolean} // custom properties e.g. { name:\"viewport\" content:\"width=500, initial-scale=1\" }\n        }} metaOptions\n  * @returns {Array<HtmlTagObject>}\n  */\n  function generatedMetaTags (metaOptions) {\n    if (metaOptions === false) {\n      return [];\n    }\n    // Make tags self-closing in case of xhtml\n    // Turn { \"viewport\" : \"width=500, initial-scale=1\" } into\n    // [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }]\n    const metaTagAttributeObjects = Object.keys(metaOptions)\n      .map((metaName) => {\n        const metaTagContent = metaOptions[metaName];\n        return (typeof metaTagContent === 'string') ? {\n          name: metaName,\n          content: metaTagContent\n        } : metaTagContent;\n      })\n      .filter((attribute) => attribute !== false);\n      // Turn [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }] into\n      // the html-webpack-plugin tag structure\n    return metaTagAttributeObjects.map((metaTagAttributes) => {\n      if (metaTagAttributes === false) {\n        throw new Error('Invalid meta tag');\n      }\n      return {\n        tagName: 'meta',\n        voidTag: true,\n        meta: { plugin: 'html-webpack-plugin' },\n        attributes: metaTagAttributes\n      };\n    });\n  }\n\n  /**\n   * Generate a favicon tag for the given file path\n   * @param {string| undefined} faviconPath\n   * @returns {Array<HtmlTagObject>}\n   */\n  function generateFaviconTags (faviconPath) {\n    if (!faviconPath) {\n      return [];\n    }\n    return [{\n      tagName: 'link',\n      voidTag: true,\n      meta: { plugin: 'html-webpack-plugin' },\n      attributes: {\n        rel: 'icon',\n        href: faviconPath\n      }\n    }];\n  }\n\n  /**\n   * Group assets to head and bottom tags\n   *\n   * @param {{\n      scripts: Array<HtmlTagObject>;\n      styles: Array<HtmlTagObject>;\n      meta: Array<HtmlTagObject>;\n    }} assetTags\n  * @param {\"body\" | \"head\"} scriptTarget\n  * @returns {{\n      headTags: Array<HtmlTagObject>;\n      bodyTags: Array<HtmlTagObject>;\n    }}\n  */\n  function generateAssetGroups (assetTags, scriptTarget) {\n    /** @type {{ headTags: Array<HtmlTagObject>; bodyTags: Array<HtmlTagObject>; }} */\n    const result = {\n      headTags: [\n        ...assetTags.meta,\n        ...assetTags.styles\n      ],\n      bodyTags: []\n    };\n    // Add script tags to head or body depending on\n    // the htmlPluginOptions\n    if (scriptTarget === 'body') {\n      result.bodyTags.push(...assetTags.scripts);\n    } else {\n      // If script loading is blocking add the scripts to the end of the head\n      // If script loading is non-blocking add the scripts infront of the css files\n      const insertPosition = options.scriptLoading === 'blocking' ? result.headTags.length : assetTags.meta.length;\n      result.headTags.splice(insertPosition, 0, ...assetTags.scripts);\n    }\n    return result;\n  }\n\n  /**\n   * Add toString methods for easier rendering\n   * inside the template\n   *\n   * @param {Array<HtmlTagObject>} assetTagGroup\n   * @returns {Array<HtmlTagObject>}\n   */\n  function prepareAssetTagGroupForRendering (assetTagGroup) {\n    const xhtml = options.xhtml;\n    return HtmlTagArray.from(assetTagGroup.map((assetTag) => {\n      const copiedAssetTag = Object.assign({}, assetTag);\n      copiedAssetTag.toString = function () {\n        return htmlTagObjectToString(this, xhtml);\n      };\n      return copiedAssetTag;\n    }));\n  }\n\n  /**\n   * Injects the assets into the given html string\n   *\n   * @param {string} html\n   * The input html\n   * @param {any} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * The asset tags to inject\n   *\n   * @returns {string}\n   */\n  function injectAssetsIntoHtml (html, assets, assetTags) {\n    const htmlRegExp = /(<html[^>]*>)/i;\n    const headRegExp = /(<\\/head\\s*>)/i;\n    const bodyRegExp = /(<\\/body\\s*>)/i;\n    const body = assetTags.bodyTags.map((assetTagObject) => htmlTagObjectToString(assetTagObject, options.xhtml));\n    const head = assetTags.headTags.map((assetTagObject) => htmlTagObjectToString(assetTagObject, options.xhtml));\n\n    if (body.length) {\n      if (bodyRegExp.test(html)) {\n        // Append assets to body element\n        html = html.replace(bodyRegExp, match => body.join('') + match);\n      } else {\n        // Append scripts to the end of the file if no <body> element exists:\n        html += body.join('');\n      }\n    }\n\n    if (head.length) {\n      // Create a head tag if none exists\n      if (!headRegExp.test(html)) {\n        if (!htmlRegExp.test(html)) {\n          html = '<head></head>' + html;\n        } else {\n          html = html.replace(htmlRegExp, match => match + '<head></head>');\n        }\n      }\n\n      // Append assets to head element\n      html = html.replace(headRegExp, match => head.join('') + match);\n    }\n\n    // Inject manifest into the opening html tag\n    if (assets.manifest) {\n      html = html.replace(/(<html[^>]*)(>)/i, (match, start, end) => {\n        // Append the manifest only if no manifest was specified\n        if (/\\smanifest\\s*=/.test(match)) {\n          return match;\n        }\n        return start + ' manifest=\"' + assets.manifest + '\"' + end;\n      });\n    }\n    return html;\n  }\n\n  /**\n   * Appends a cache busting hash to the query string of the url\n   * E.g. http://localhost:8080/ -> http://localhost:8080/?50c9096ba6183fd728eeb065a26ec175\n   * @param {string} url\n   * @param {string} hash\n   */\n  function appendHash (url, hash) {\n    if (!url) {\n      return url;\n    }\n    return url + (url.indexOf('?') === -1 ? '?' : '&') + hash;\n  }\n\n  /**\n   * Encode each path component using `encodeURIComponent` as files can contain characters\n   * which needs special encoding in URLs like `+ `.\n   *\n   * Valid filesystem characters which need to be encoded for urls:\n   *\n   * # pound, % percent, & ampersand, { left curly bracket, } right curly bracket,\n   * \\ back slash, < left angle bracket, > right angle bracket, * asterisk, ? question mark,\n   * blank spaces, $ dollar sign, ! exclamation point, ' single quotes, \" double quotes,\n   * : colon, @ at sign, + plus sign, ` backtick, | pipe, = equal sign\n   *\n   * However the query string must not be encoded:\n   *\n   *  fo:demonstration-path/very fancy+name.js?path=/home?value=abc&value=def#zzz\n   *    ^             ^    ^    ^     ^    ^  ^    ^^    ^     ^   ^     ^   ^\n   *    |             |    |    |     |    |  |    ||    |     |   |     |   |\n   *    encoded       |    |    encoded    |  |    ||    |     |   |     |   |\n   *                 ignored              ignored  ignored     ignored   ignored\n   *\n   * @param {string} filePath\n   */\n  function urlencodePath (filePath) {\n    // People use the filepath in quite unexpected ways.\n    // Try to extract the first querystring of the url:\n    //\n    // some+path/demo.html?value=abc?def\n    //\n    const queryStringStart = filePath.indexOf('?');\n    const urlPath = queryStringStart === -1 ? filePath : filePath.substr(0, queryStringStart);\n    const queryString = filePath.substr(urlPath.length);\n    // Encode all parts except '/' which are not part of the querystring:\n    const encodedUrlPath = urlPath.split('/').map(encodeURIComponent).join('/');\n    return encodedUrlPath + queryString;\n  }\n\n  /**\n   * Helper to return the absolute template path with a fallback loader\n   * @param {string} template\n   * The path to the template e.g. './index.html'\n   * @param {string} context\n   * The webpack base resolution path for relative paths e.g. process.cwd()\n   */\n  function getFullTemplatePath (template, context) {\n    if (template === 'auto') {\n      template = path.resolve(context, 'src/index.ejs');\n      if (!fs.existsSync(template)) {\n        template = path.join(__dirname, 'default_index.ejs');\n      }\n    }\n    // If the template doesn't use a loader use the lodash template loader\n    if (template.indexOf('!') === -1) {\n      template = require.resolve('./lib/loader.js') + '!' + path.resolve(context, template);\n    }\n    // Resolve template path\n    return template.replace(\n      /([!])([^/\\\\][^!?]+|[^/\\\\!?])($|\\?[^!?\\n]+$)/,\n      (match, prefix, filepath, postfix) => prefix + path.resolve(filepath) + postfix);\n  }\n\n  /**\n   * Minify the given string using html-minifier-terser\n   *\n   * As this is a breaking change to html-webpack-plugin 3.x\n   * provide an extended error message to explain how to get back\n   * to the old behaviour\n   *\n   * @param {string} html\n   */\n  function minifyHtml (html) {\n    if (typeof options.minify !== 'object') {\n      return html;\n    }\n    try {\n      return require('html-minifier-terser').minify(html, options.minify);\n    } catch (e) {\n      const isParseError = String(e.message).indexOf('Parse Error') === 0;\n      if (isParseError) {\n        e.message = 'html-webpack-plugin could not minify the generated output.\\n' +\n            'In production mode the html minifcation is enabled by default.\\n' +\n            'If you are not generating a valid html output please disable it manually.\\n' +\n            'You can do so by adding the following setting to your HtmlWebpackPlugin config:\\n|\\n|' +\n            '    minify: false\\n|\\n' +\n            'See https://github.com/jantimon/html-webpack-plugin#options for details.\\n\\n' +\n            'For parser dedicated bugs please create an issue here:\\n' +\n            'https://danielruf.github.io/html-minifier-terser/' +\n          '\\n' + e.message;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Helper to return a sorted unique array of all asset files out of the\n   * asset object\n   */\n  function getAssetFiles (assets) {\n    const files = _.uniq(Object.keys(assets).filter(assetType => assetType !== 'chunks' && assets[assetType]).reduce((files, assetType) => files.concat(assets[assetType]), []));\n    files.sort();\n    return files;\n  }\n}\n\n/**\n * The default for options.templateParameter\n * Generate the template parameters\n *\n * Generate the template parameters for the template function\n * @param {WebpackCompilation} compilation\n * @param {{\n   publicPath: string,\n   js: Array<string>,\n   css: Array<string>,\n   manifest?: string,\n   favicon?: string\n }} assets\n * @param {{\n     headTags: HtmlTagObject[],\n     bodyTags: HtmlTagObject[]\n   }} assetTags\n * @param {ProcessedHtmlWebpackOptions} options\n * @returns {TemplateParameter}\n */\nfunction templateParametersGenerator (compilation, assets, assetTags, options) {\n  return {\n    compilation: compilation,\n    webpackConfig: compilation.options,\n    htmlWebpackPlugin: {\n      tags: assetTags,\n      files: assets,\n      options: options\n    }\n  };\n}\n\n// Statics:\n/**\n * The major version number of this plugin\n */\nHtmlWebpackPlugin.version = 5;\n\n/**\n * A static helper to get the hooks for this plugin\n *\n * Usage: HtmlWebpackPlugin.getHooks(compilation).HOOK_NAME.tapAsync('YourPluginName', () => { ... });\n */\nHtmlWebpackPlugin.getHooks = getHtmlWebpackPluginHooks;\nHtmlWebpackPlugin.createHtmlTagObject = createHtmlTagObject;\n\nmodule.exports = HtmlWebpackPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}