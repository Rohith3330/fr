{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    allowMutablePropsOnTags\n  } = options;\n\n  if (allowMutablePropsOnTags != null && !Array.isArray(allowMutablePropsOnTags)) {\n    throw new Error(\".allowMutablePropsOnTags must be an array, null, or undefined.\");\n  }\n\n  const HOISTED = new WeakMap();\n\n  function declares(node, scope) {\n    if (_core.types.isJSXIdentifier(node, {\n      name: \"this\"\n    }) || _core.types.isJSXIdentifier(node, {\n      name: \"arguments\"\n    }) || _core.types.isJSXIdentifier(node, {\n      name: \"super\"\n    }) || _core.types.isJSXIdentifier(node, {\n      name: \"new\"\n    })) {\n      const {\n        path\n      } = scope;\n      return path.isFunctionParent() && !path.isArrowFunctionExpression();\n    }\n\n    return scope.hasOwnBinding(node.name);\n  }\n\n  function isHoistingScope(_ref) {\n    let {\n      path\n    } = _ref;\n    return path.isFunctionParent() || path.isLoop() || path.isProgram();\n  }\n\n  function getHoistingScope(scope) {\n    while (!isHoistingScope(scope)) scope = scope.parent;\n\n    return scope;\n  }\n\n  const immutabilityVisitor = {\n    enter(path, state) {\n      const stop = () => {\n        state.isImmutable = false;\n        path.stop();\n      };\n\n      const skip = () => {\n        path.skip();\n      };\n\n      if (path.isJSXClosingElement()) return skip();\n\n      if (path.isJSXIdentifier({\n        name: \"ref\"\n      }) && path.parentPath.isJSXAttribute({\n        name: path.node\n      })) {\n        return stop();\n      }\n\n      if (path.isJSXIdentifier() || path.isJSXMemberExpression() || path.isJSXNamespacedName() || path.isImmutable()) {\n        return;\n      }\n\n      if (path.isIdentifier()) {\n        const binding = path.scope.getBinding(path.node.name);\n        if (binding && binding.constant) return;\n      }\n\n      const {\n        mutablePropsAllowed\n      } = state;\n\n      if (mutablePropsAllowed && path.isFunction()) {\n        path.traverse(targetScopeVisitor, state);\n        return skip();\n      }\n\n      if (!path.isPure()) return stop();\n      const expressionResult = path.evaluate();\n\n      if (expressionResult.confident) {\n        const {\n          value\n        } = expressionResult;\n\n        if (mutablePropsAllowed || value === null || typeof value !== \"object\" && typeof value !== \"function\") {\n          return skip();\n        }\n      } else if (_core.types.isIdentifier(expressionResult.deopt)) {\n        return;\n      }\n\n      stop();\n    }\n\n  };\n  const targetScopeVisitor = {\n    ReferencedIdentifier(path, state) {\n      const {\n        node\n      } = path;\n      let {\n        scope\n      } = path;\n\n      while (scope !== state.jsxScope) {\n        if (declares(node, scope)) return;\n        scope = scope.parent;\n      }\n\n      while (scope) {\n        if (scope === state.targetScope) return;\n        if (declares(node, scope)) break;\n        scope = scope.parent;\n      }\n\n      state.targetScope = getHoistingScope(scope);\n    }\n\n  };\n  const hoistingVisitor = Object.assign({}, immutabilityVisitor, targetScopeVisitor);\n  return {\n    name: \"transform-react-constant-elements\",\n    visitor: {\n      JSXElement(path) {\n        var _jsxScope;\n\n        if (HOISTED.has(path.node)) return;\n        const name = path.node.openingElement.name;\n        let mutablePropsAllowed = false;\n\n        if (allowMutablePropsOnTags != null) {\n          let lastSegment = name;\n\n          while (_core.types.isJSXMemberExpression(lastSegment)) {\n            lastSegment = lastSegment.property;\n          }\n\n          const elementName = lastSegment.name;\n          mutablePropsAllowed = allowMutablePropsOnTags.includes(elementName);\n        }\n\n        let jsxScope;\n        let current = path;\n\n        while (!jsxScope && current.parentPath.isJSX()) {\n          current = current.parentPath;\n          jsxScope = HOISTED.get(current.node);\n        }\n\n        (_jsxScope = jsxScope) != null ? _jsxScope : jsxScope = path.scope;\n        HOISTED.set(path.node, jsxScope);\n        const visitorState = {\n          isImmutable: true,\n          mutablePropsAllowed,\n          jsxScope,\n          targetScope: path.scope.getProgramParent()\n        };\n        path.traverse(hoistingVisitor, visitorState);\n        if (!visitorState.isImmutable) return;\n        const {\n          targetScope\n        } = visitorState;\n\n        for (let currentScope = jsxScope;;) {\n          if (targetScope === currentScope) return;\n          if (isHoistingScope(currentScope)) break;\n          currentScope = currentScope.parent;\n\n          if (!currentScope) {\n            throw new Error(\"Internal @babel/plugin-transform-react-constant-elements error: \" + \"targetScope must be an ancestor of jsxScope. \" + \"This is a Babel bug, please report it.\");\n          }\n        }\n\n        const id = path.scope.generateUidBasedOnNode(name);\n        targetScope.push({\n          id: _core.types.identifier(id)\n        });\n        HOISTED.set(path.node, targetScope);\n        let replacement = _core.template.expression.ast`\n          ${_core.types.identifier(id)} || (${_core.types.identifier(id)} = ${path.node})\n        `;\n\n        if (path.parentPath.isJSXElement() || path.parentPath.isJSXAttribute()) {\n          replacement = _core.types.jsxExpressionContainer(replacement);\n        }\n\n        path.replaceWith(replacement);\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_core","_default","declare","api","options","assertVersion","allowMutablePropsOnTags","Array","isArray","Error","HOISTED","WeakMap","declares","node","scope","types","isJSXIdentifier","name","path","isFunctionParent","isArrowFunctionExpression","hasOwnBinding","isHoistingScope","isLoop","isProgram","getHoistingScope","parent","immutabilityVisitor","enter","state","stop","isImmutable","skip","isJSXClosingElement","parentPath","isJSXAttribute","isJSXMemberExpression","isJSXNamespacedName","isIdentifier","binding","getBinding","constant","mutablePropsAllowed","isFunction","traverse","targetScopeVisitor","isPure","expressionResult","evaluate","confident","deopt","ReferencedIdentifier","jsxScope","targetScope","hoistingVisitor","assign","visitor","JSXElement","_jsxScope","has","openingElement","lastSegment","property","elementName","includes","current","isJSX","get","set","visitorState","getProgramParent","currentScope","id","generateUidBasedOnNode","push","identifier","replacement","template","expression","ast","isJSXElement","jsxExpressionContainer","replaceWith"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/plugin-transform-react-constant-elements/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    allowMutablePropsOnTags\n  } = options;\n\n  if (allowMutablePropsOnTags != null && !Array.isArray(allowMutablePropsOnTags)) {\n    throw new Error(\".allowMutablePropsOnTags must be an array, null, or undefined.\");\n  }\n\n  const HOISTED = new WeakMap();\n\n  function declares(node, scope) {\n    if (_core.types.isJSXIdentifier(node, {\n      name: \"this\"\n    }) || _core.types.isJSXIdentifier(node, {\n      name: \"arguments\"\n    }) || _core.types.isJSXIdentifier(node, {\n      name: \"super\"\n    }) || _core.types.isJSXIdentifier(node, {\n      name: \"new\"\n    })) {\n      const {\n        path\n      } = scope;\n      return path.isFunctionParent() && !path.isArrowFunctionExpression();\n    }\n\n    return scope.hasOwnBinding(node.name);\n  }\n\n  function isHoistingScope({\n    path\n  }) {\n    return path.isFunctionParent() || path.isLoop() || path.isProgram();\n  }\n\n  function getHoistingScope(scope) {\n    while (!isHoistingScope(scope)) scope = scope.parent;\n\n    return scope;\n  }\n\n  const immutabilityVisitor = {\n    enter(path, state) {\n      const stop = () => {\n        state.isImmutable = false;\n        path.stop();\n      };\n\n      const skip = () => {\n        path.skip();\n      };\n\n      if (path.isJSXClosingElement()) return skip();\n\n      if (path.isJSXIdentifier({\n        name: \"ref\"\n      }) && path.parentPath.isJSXAttribute({\n        name: path.node\n      })) {\n        return stop();\n      }\n\n      if (path.isJSXIdentifier() || path.isJSXMemberExpression() || path.isJSXNamespacedName() || path.isImmutable()) {\n        return;\n      }\n\n      if (path.isIdentifier()) {\n        const binding = path.scope.getBinding(path.node.name);\n        if (binding && binding.constant) return;\n      }\n\n      const {\n        mutablePropsAllowed\n      } = state;\n\n      if (mutablePropsAllowed && path.isFunction()) {\n        path.traverse(targetScopeVisitor, state);\n        return skip();\n      }\n\n      if (!path.isPure()) return stop();\n      const expressionResult = path.evaluate();\n\n      if (expressionResult.confident) {\n        const {\n          value\n        } = expressionResult;\n\n        if (mutablePropsAllowed || value === null || typeof value !== \"object\" && typeof value !== \"function\") {\n          return skip();\n        }\n      } else if (_core.types.isIdentifier(expressionResult.deopt)) {\n        return;\n      }\n\n      stop();\n    }\n\n  };\n  const targetScopeVisitor = {\n    ReferencedIdentifier(path, state) {\n      const {\n        node\n      } = path;\n      let {\n        scope\n      } = path;\n\n      while (scope !== state.jsxScope) {\n        if (declares(node, scope)) return;\n        scope = scope.parent;\n      }\n\n      while (scope) {\n        if (scope === state.targetScope) return;\n        if (declares(node, scope)) break;\n        scope = scope.parent;\n      }\n\n      state.targetScope = getHoistingScope(scope);\n    }\n\n  };\n  const hoistingVisitor = Object.assign({}, immutabilityVisitor, targetScopeVisitor);\n  return {\n    name: \"transform-react-constant-elements\",\n    visitor: {\n      JSXElement(path) {\n        var _jsxScope;\n\n        if (HOISTED.has(path.node)) return;\n        const name = path.node.openingElement.name;\n        let mutablePropsAllowed = false;\n\n        if (allowMutablePropsOnTags != null) {\n          let lastSegment = name;\n\n          while (_core.types.isJSXMemberExpression(lastSegment)) {\n            lastSegment = lastSegment.property;\n          }\n\n          const elementName = lastSegment.name;\n          mutablePropsAllowed = allowMutablePropsOnTags.includes(elementName);\n        }\n\n        let jsxScope;\n        let current = path;\n\n        while (!jsxScope && current.parentPath.isJSX()) {\n          current = current.parentPath;\n          jsxScope = HOISTED.get(current.node);\n        }\n\n        (_jsxScope = jsxScope) != null ? _jsxScope : jsxScope = path.scope;\n        HOISTED.set(path.node, jsxScope);\n        const visitorState = {\n          isImmutable: true,\n          mutablePropsAllowed,\n          jsxScope,\n          targetScope: path.scope.getProgramParent()\n        };\n        path.traverse(hoistingVisitor, visitorState);\n        if (!visitorState.isImmutable) return;\n        const {\n          targetScope\n        } = visitorState;\n\n        for (let currentScope = jsxScope;;) {\n          if (targetScope === currentScope) return;\n          if (isHoistingScope(currentScope)) break;\n          currentScope = currentScope.parent;\n\n          if (!currentScope) {\n            throw new Error(\"Internal @babel/plugin-transform-react-constant-elements error: \" + \"targetScope must be an ancestor of jsxScope. \" + \"This is a Babel bug, please report it.\");\n          }\n        }\n\n        const id = path.scope.generateUidBasedOnNode(name);\n        targetScope.push({\n          id: _core.types.identifier(id)\n        });\n        HOISTED.set(path.node, targetScope);\n        let replacement = _core.template.expression.ast`\n          ${_core.types.identifier(id)} || (${_core.types.identifier(id)} = ${path.node})\n        `;\n\n        if (path.parentPath.isJSXElement() || path.parentPath.isJSXAttribute()) {\n          replacement = _core.types.jsxExpressionContainer(replacement);\n        }\n\n        path.replaceWith(replacement);\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}