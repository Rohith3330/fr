{"ast":null,"code":"'use strict';\n\nvar _declaredScope = require('eslint-module-utils/declaredScope');\n\nvar _declaredScope2 = _interopRequireDefault(_declaredScope);\n\nvar _ExportMap = require('../ExportMap');\n\nvar _ExportMap2 = _interopRequireDefault(_ExportMap);\n\nvar _importDeclaration = require('../importDeclaration');\n\nvar _importDeclaration2 = _interopRequireDefault(_importDeclaration);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction processBodyStatement(context, namespaces, declaration) {\n  if (declaration.type !== 'ImportDeclaration') return;\n  if (declaration.specifiers.length === 0) return;\n\n  var imports = _ExportMap2['default'].get(declaration.source.value, context);\n\n  if (imports == null) return null;\n\n  if (imports.errors.length > 0) {\n    imports.reportErrors(context, declaration);\n    return;\n  }\n\n  declaration.specifiers.forEach(function (specifier) {\n    switch (specifier.type) {\n      case 'ImportNamespaceSpecifier':\n        if (!imports.size) {\n          context.report(specifier, 'No exported names found in module \\'' + String(declaration.source.value) + '\\'.');\n        }\n\n        namespaces.set(specifier.local.name, imports);\n        break;\n\n      case 'ImportDefaultSpecifier':\n      case 'ImportSpecifier':\n        {\n          var meta = imports.get( // default to 'default' for default https://i.imgur.com/nj6qAWy.jpg\n          specifier.imported ? specifier.imported.name || specifier.imported.value : 'default');\n\n          if (!meta || !meta.namespace) {\n            break;\n          }\n\n          namespaces.set(specifier.local.name, meta.namespace);\n          break;\n        }\n    }\n  });\n}\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      url: (0, _docsUrl2['default'])('namespace')\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowComputed: {\n          description: 'If `false`, will report computed (and thus, un-lintable) references to namespace members.',\n          type: 'boolean',\n          'default': false\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  create: function () {\n    function namespaceRule(context) {\n      // read options\n      var _ref = context.options[0] || {},\n          _ref$allowComputed = _ref.allowComputed,\n          allowComputed = _ref$allowComputed === undefined ? false : _ref$allowComputed;\n\n      var namespaces = new Map();\n\n      function makeMessage(last, namepath) {\n        return '\\'' + String(last.name) + '\\' not found in ' + (namepath.length > 1 ? 'deeply ' : '') + 'imported namespace \\'' + String(namepath.join('.')) + '\\'.';\n      }\n\n      return {\n        // pick up all imports at body entry time, to properly respect hoisting\n        Program: function () {\n          function Program(_ref2) {\n            var body = _ref2.body;\n            body.forEach(function (x) {\n              return processBodyStatement(context, namespaces, x);\n            });\n          }\n\n          return Program;\n        }(),\n        // same as above, but does not add names to local map\n        ExportNamespaceSpecifier: function () {\n          function ExportNamespaceSpecifier(namespace) {\n            var declaration = (0, _importDeclaration2['default'])(context);\n\n            var imports = _ExportMap2['default'].get(declaration.source.value, context);\n\n            if (imports == null) return null;\n\n            if (imports.errors.length) {\n              imports.reportErrors(context, declaration);\n              return;\n            }\n\n            if (!imports.size) {\n              context.report(namespace, 'No exported names found in module \\'' + String(declaration.source.value) + '\\'.');\n            }\n          }\n\n          return ExportNamespaceSpecifier;\n        }(),\n        // todo: check for possible redefinition\n        MemberExpression: function () {\n          function MemberExpression(dereference) {\n            if (dereference.object.type !== 'Identifier') return;\n            if (!namespaces.has(dereference.object.name)) return;\n            if ((0, _declaredScope2['default'])(context, dereference.object.name) !== 'module') return;\n\n            if (dereference.parent.type === 'AssignmentExpression' && dereference.parent.left === dereference) {\n              context.report(dereference.parent, 'Assignment to member of namespace \\'' + String(dereference.object.name) + '\\'.');\n            } // go deep\n\n\n            var namespace = namespaces.get(dereference.object.name);\n            var namepath = [dereference.object.name]; // while property is namespace and parent is member expression, keep validating\n\n            while (namespace instanceof _ExportMap2['default'] && dereference.type === 'MemberExpression') {\n              if (dereference.computed) {\n                if (!allowComputed) {\n                  context.report(dereference.property, 'Unable to validate computed reference to imported namespace \\'' + String(dereference.object.name) + '\\'.');\n                }\n\n                return;\n              }\n\n              if (!namespace.has(dereference.property.name)) {\n                context.report(dereference.property, makeMessage(dereference.property, namepath));\n                break;\n              }\n\n              var exported = namespace.get(dereference.property.name);\n              if (exported == null) return; // stash and pop\n\n              namepath.push(dereference.property.name);\n              namespace = exported.namespace;\n              dereference = dereference.parent;\n            }\n          }\n\n          return MemberExpression;\n        }(),\n        VariableDeclarator: function () {\n          function VariableDeclarator(_ref3) {\n            var id = _ref3.id,\n                init = _ref3.init;\n            if (init == null) return;\n            if (init.type !== 'Identifier') return;\n            if (!namespaces.has(init.name)) return; // check for redefinition in intermediate scopes\n\n            if ((0, _declaredScope2['default'])(context, init.name) !== 'module') return; // DFS traverse child namespaces\n\n            function testKey(pattern, namespace) {\n              var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [init.name];\n              if (!(namespace instanceof _ExportMap2['default'])) return;\n              if (pattern.type !== 'ObjectPattern') return;\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = pattern.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var property = _step.value;\n\n                  if (property.type === 'ExperimentalRestProperty' || property.type === 'RestElement' || !property.key) {\n                    continue;\n                  }\n\n                  if (property.key.type !== 'Identifier') {\n                    context.report({\n                      node: property,\n                      message: 'Only destructure top-level names.'\n                    });\n                    continue;\n                  }\n\n                  if (!namespace.has(property.key.name)) {\n                    context.report({\n                      node: property,\n                      message: makeMessage(property.key, path)\n                    });\n                    continue;\n                  }\n\n                  path.push(property.key.name);\n                  var dependencyExportMap = namespace.get(property.key.name); // could be null when ignored or ambiguous\n\n                  if (dependencyExportMap !== null) {\n                    testKey(property.value, dependencyExportMap.namespace, path);\n                  }\n\n                  path.pop();\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator['return']) {\n                    _iterator['return']();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n            }\n\n            testKey(id, namespaces.get(init.name));\n          }\n\n          return VariableDeclarator;\n        }(),\n        JSXMemberExpression: function () {\n          function JSXMemberExpression(_ref4) {\n            var object = _ref4.object,\n                property = _ref4.property;\n            if (!namespaces.has(object.name)) return;\n            var namespace = namespaces.get(object.name);\n\n            if (!namespace.has(property.name)) {\n              context.report({\n                node: property,\n                message: makeMessage(property, [object.name])\n              });\n            }\n          }\n\n          return JSXMemberExpression;\n        }()\n      };\n    }\n\n    return namespaceRule;\n  }()\n};","map":{"version":3,"mappings":"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","names":["processBodyStatement","context","namespaces","declaration","type","specifiers","length","imports","Exports","get","source","value","errors","reportErrors","forEach","specifier","size","report","set","local","name","meta","imported","namespace","module","exports","docs","url","schema","properties","allowComputed","description","additionalProperties","create","namespaceRule","options","Map","makeMessage","last","namepath","join","Program","body","x","ExportNamespaceSpecifier","MemberExpression","dereference","object","has","parent","left","computed","property","exported","push","VariableDeclarator","id","init","testKey","pattern","path","Symbol","key","node","message","dependencyExportMap","pop","_didIteratorError","_iteratorError","_iterator","JSXMemberExpression"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\namespace.js"],"sourcesContent":["import declaredScope from 'eslint-module-utils/declaredScope';\nimport Exports from '../ExportMap';\nimport importDeclaration from '../importDeclaration';\nimport docsUrl from '../docsUrl';\n\nfunction processBodyStatement(context, namespaces, declaration) {\n  if (declaration.type !== 'ImportDeclaration') return;\n\n  if (declaration.specifiers.length === 0) return;\n\n  const imports = Exports.get(declaration.source.value, context);\n  if (imports == null) return null;\n\n  if (imports.errors.length > 0) {\n    imports.reportErrors(context, declaration);\n    return;\n  }\n\n  declaration.specifiers.forEach((specifier) => {\n    switch (specifier.type) {\n    case 'ImportNamespaceSpecifier':\n      if (!imports.size) {\n        context.report(\n          specifier,\n          `No exported names found in module '${declaration.source.value}'.`,\n        );\n      }\n      namespaces.set(specifier.local.name, imports);\n      break;\n    case 'ImportDefaultSpecifier':\n    case 'ImportSpecifier': {\n      const meta = imports.get(\n        // default to 'default' for default https://i.imgur.com/nj6qAWy.jpg\n        specifier.imported ? (specifier.imported.name || specifier.imported.value) : 'default',\n      );\n      if (!meta || !meta.namespace) { break; }\n      namespaces.set(specifier.local.name, meta.namespace);\n      break;\n    }\n    }\n  });\n}\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      url: docsUrl('namespace'),\n    },\n\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          allowComputed: {\n            description: 'If `false`, will report computed (and thus, un-lintable) references to namespace members.',\n            type: 'boolean',\n            default: false,\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n  },\n\n  create: function namespaceRule(context) {\n\n    // read options\n    const {\n      allowComputed = false,\n    } = context.options[0] || {};\n\n    const namespaces = new Map();\n\n    function makeMessage(last, namepath) {\n      return `'${last.name}' not found in ${namepath.length > 1 ? 'deeply ' : ''}imported namespace '${namepath.join('.')}'.`;\n    }\n\n    return {\n      // pick up all imports at body entry time, to properly respect hoisting\n      Program({ body }) {\n        body.forEach(x => processBodyStatement(context, namespaces, x));\n      },\n\n      // same as above, but does not add names to local map\n      ExportNamespaceSpecifier(namespace) {\n        const declaration = importDeclaration(context);\n\n        const imports = Exports.get(declaration.source.value, context);\n        if (imports == null) return null;\n\n        if (imports.errors.length) {\n          imports.reportErrors(context, declaration);\n          return;\n        }\n\n        if (!imports.size) {\n          context.report(\n            namespace,\n            `No exported names found in module '${declaration.source.value}'.`,\n          );\n        }\n      },\n\n      // todo: check for possible redefinition\n\n      MemberExpression(dereference) {\n        if (dereference.object.type !== 'Identifier') return;\n        if (!namespaces.has(dereference.object.name)) return;\n        if (declaredScope(context, dereference.object.name) !== 'module') return;\n\n        if (dereference.parent.type === 'AssignmentExpression' && dereference.parent.left === dereference) {\n          context.report(\n            dereference.parent,\n            `Assignment to member of namespace '${dereference.object.name}'.`,\n          );\n        }\n\n        // go deep\n        let namespace = namespaces.get(dereference.object.name);\n        const namepath = [dereference.object.name];\n        // while property is namespace and parent is member expression, keep validating\n        while (namespace instanceof Exports && dereference.type === 'MemberExpression') {\n          if (dereference.computed) {\n            if (!allowComputed) {\n              context.report(\n                dereference.property,\n                `Unable to validate computed reference to imported namespace '${dereference.object.name}'.`,\n              );\n            }\n            return;\n          }\n\n          if (!namespace.has(dereference.property.name)) {\n            context.report(\n              dereference.property,\n              makeMessage(dereference.property, namepath),\n            );\n            break;\n          }\n\n          const exported = namespace.get(dereference.property.name);\n          if (exported == null) return;\n\n          // stash and pop\n          namepath.push(dereference.property.name);\n          namespace = exported.namespace;\n          dereference = dereference.parent;\n        }\n      },\n\n      VariableDeclarator({ id, init }) {\n        if (init == null) return;\n        if (init.type !== 'Identifier') return;\n        if (!namespaces.has(init.name)) return;\n\n        // check for redefinition in intermediate scopes\n        if (declaredScope(context, init.name) !== 'module') return;\n\n        // DFS traverse child namespaces\n        function testKey(pattern, namespace, path = [init.name]) {\n          if (!(namespace instanceof Exports)) return;\n\n          if (pattern.type !== 'ObjectPattern') return;\n\n          for (const property of pattern.properties) {\n            if (\n              property.type === 'ExperimentalRestProperty'\n              || property.type === 'RestElement'\n              || !property.key\n            ) {\n              continue;\n            }\n\n            if (property.key.type !== 'Identifier') {\n              context.report({\n                node: property,\n                message: 'Only destructure top-level names.',\n              });\n              continue;\n            }\n\n            if (!namespace.has(property.key.name)) {\n              context.report({\n                node: property,\n                message: makeMessage(property.key, path),\n              });\n              continue;\n            }\n\n            path.push(property.key.name);\n            const dependencyExportMap = namespace.get(property.key.name);\n            // could be null when ignored or ambiguous\n            if (dependencyExportMap !== null) {\n              testKey(property.value, dependencyExportMap.namespace, path);\n            }\n            path.pop();\n          }\n        }\n\n        testKey(id, namespaces.get(init.name));\n      },\n\n      JSXMemberExpression({ object, property }) {\n        if (!namespaces.has(object.name)) return;\n        const namespace = namespaces.get(object.name);\n        if (!namespace.has(property.name)) {\n          context.report({\n            node: property,\n            message: makeMessage(property, [object.name]),\n          });\n        }\n      },\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"script"}