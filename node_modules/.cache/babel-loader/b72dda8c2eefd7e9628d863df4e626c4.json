{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst types_1 = require(\"./types\");\n\nconst __1 = require(\"..\");\n\nconst codegen_1 = require(\"../codegen\");\n\nconst ref_error_1 = require(\"../ref_error\");\n\nconst names_1 = require(\"../names\");\n\nconst code_1 = require(\"../../vocabularies/code\");\n\nconst ref_1 = require(\"../../vocabularies/jtd/ref\");\n\nconst type_1 = require(\"../../vocabularies/jtd/type\");\n\nconst parseJson_1 = require(\"../../runtime/parseJson\");\n\nconst util_1 = require(\"../util\");\n\nconst timestamp_1 = require(\"../../runtime/timestamp\");\n\nconst genParse = {\n  elements: parseElements,\n  values: parseValues,\n  discriminator: parseDiscriminator,\n  properties: parseProperties,\n  optionalProperties: parseProperties,\n  enum: parseEnum,\n  type: parseType,\n  ref: parseRef\n};\n\nfunction compileParser(sch, definitions) {\n  const _sch = __1.getCompilingSchema.call(this, sch);\n\n  if (_sch) return _sch;\n  const {\n    es5,\n    lines\n  } = this.opts.code;\n  const {\n    ownProperties\n  } = this.opts;\n  const gen = new codegen_1.CodeGen(this.scope, {\n    es5,\n    lines,\n    ownProperties\n  });\n  const parseName = gen.scopeName(\"parse\");\n  const cxt = {\n    self: this,\n    gen,\n    schema: sch.schema,\n    schemaEnv: sch,\n    definitions,\n    data: names_1.default.data,\n    parseName,\n    char: gen.name(\"c\")\n  };\n  let sourceCode;\n\n  try {\n    this._compilations.add(sch);\n\n    sch.parseName = parseName;\n    parserFunction(cxt);\n    gen.optimize(this.opts.code.optimize);\n    const parseFuncCode = gen.toString();\n    sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;\n    const makeParse = new Function(`${names_1.default.scope}`, sourceCode);\n    const parse = makeParse(this.scope.get());\n    this.scope.value(parseName, {\n      ref: parse\n    });\n    sch.parse = parse;\n  } catch (e) {\n    if (sourceCode) this.logger.error(\"Error compiling parser, function code:\", sourceCode);\n    delete sch.parse;\n    delete sch.parseName;\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n\n  return sch;\n}\n\nexports.default = compileParser;\nconst undef = (0, codegen_1._)`undefined`;\n\nfunction parserFunction(cxt) {\n  const {\n    gen,\n    parseName,\n    char\n  } = cxt;\n  gen.func(parseName, (0, codegen_1._)`${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {\n    gen.let(names_1.default.data);\n    gen.let(char);\n    gen.assign((0, codegen_1._)`${parseName}.message`, undef);\n    gen.assign((0, codegen_1._)`${parseName}.position`, undef);\n    gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${names_1.default.jsonPos} || 0`);\n    gen.const(names_1.default.jsonLen, (0, codegen_1._)`${names_1.default.json}.length`);\n    parseCode(cxt);\n    skipWhitespace(cxt);\n    gen.if(names_1.default.jsonPart, () => {\n      gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);\n      gen.return(names_1.default.data);\n    });\n    gen.if((0, codegen_1._)`${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen.return(names_1.default.data));\n    jsonSyntaxError(cxt);\n  });\n}\n\nfunction parseCode(cxt) {\n  let form;\n\n  for (const key of types_1.jtdForms) {\n    if (key in cxt.schema) {\n      form = key;\n      break;\n    }\n  }\n\n  if (form) parseNullable(cxt, genParse[form]);else parseEmpty(cxt);\n}\n\nconst parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));\n\nfunction parseNullable(cxt, parseForm) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  if (!schema.nullable) return parseForm(cxt);\n  tryParseToken(cxt, \"null\", parseForm, () => gen.assign(data, null));\n}\n\nfunction parseElements(cxt) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  parseToken(cxt, \"[\");\n  const ix = gen.let(\"i\", 0);\n  gen.assign(data, (0, codegen_1._)`[]`);\n  parseItems(cxt, \"]\", () => {\n    const el = gen.let(\"el\");\n    parseCode({ ...cxt,\n      schema: schema.elements,\n      data: el\n    });\n    gen.assign((0, codegen_1._)`${data}[${ix}++]`, el);\n  });\n}\n\nfunction parseValues(cxt) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  parseToken(cxt, \"{\");\n  gen.assign(data, (0, codegen_1._)`{}`);\n  parseItems(cxt, \"}\", () => parseKeyValue(cxt, schema.values));\n}\n\nfunction parseItems(cxt, endToken, block) {\n  tryParseItems(cxt, endToken, block);\n  parseToken(cxt, endToken);\n}\n\nfunction tryParseItems(cxt, endToken, block) {\n  const {\n    gen\n  } = cxt;\n  gen.for((0, codegen_1._)`;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {\n    block();\n    tryParseToken(cxt, \",\", () => gen.break(), hasItem);\n  });\n\n  function hasItem() {\n    tryParseToken(cxt, endToken, () => {}, jsonSyntaxError);\n  }\n}\n\nfunction parseKeyValue(cxt, schema) {\n  const {\n    gen\n  } = cxt;\n  const key = gen.let(\"key\");\n  parseString({ ...cxt,\n    data: key\n  });\n  parseToken(cxt, \":\");\n  parsePropertyValue(cxt, key, schema);\n}\n\nfunction parseDiscriminator(cxt) {\n  const {\n    gen,\n    data,\n    schema\n  } = cxt;\n  const {\n    discriminator,\n    mapping\n  } = schema;\n  parseToken(cxt, \"{\");\n  gen.assign(data, (0, codegen_1._)`{}`);\n  const startPos = gen.const(\"pos\", names_1.default.jsonPos);\n  const value = gen.let(\"value\");\n  const tag = gen.let(\"tag\");\n  tryParseItems(cxt, \"}\", () => {\n    const key = gen.let(\"key\");\n    parseString({ ...cxt,\n      data: key\n    });\n    parseToken(cxt, \":\");\n    gen.if((0, codegen_1._)`${key} === ${discriminator}`, () => {\n      parseString({ ...cxt,\n        data: tag\n      });\n      gen.assign((0, codegen_1._)`${data}[${key}]`, tag);\n      gen.break();\n    }, () => parseEmpty({ ...cxt,\n      data: value\n    }) // can be discarded/skipped\n    );\n  });\n  gen.assign(names_1.default.jsonPos, startPos);\n  gen.if((0, codegen_1._)`${tag} === undefined`);\n  parsingError(cxt, (0, codegen_1.str)`discriminator tag not found`);\n\n  for (const tagValue in mapping) {\n    gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);\n    parseSchemaProperties({ ...cxt,\n      schema: mapping[tagValue]\n    }, discriminator);\n  }\n\n  gen.else();\n  parsingError(cxt, (0, codegen_1.str)`discriminator value not in schema`);\n  gen.endIf();\n}\n\nfunction parseProperties(cxt) {\n  const {\n    gen,\n    data\n  } = cxt;\n  parseToken(cxt, \"{\");\n  gen.assign(data, (0, codegen_1._)`{}`);\n  parseSchemaProperties(cxt);\n}\n\nfunction parseSchemaProperties(cxt, discriminator) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  const {\n    properties,\n    optionalProperties,\n    additionalProperties\n  } = schema;\n  parseItems(cxt, \"}\", () => {\n    const key = gen.let(\"key\");\n    parseString({ ...cxt,\n      data: key\n    });\n    parseToken(cxt, \":\");\n    gen.if(false);\n    parseDefinedProperty(cxt, key, properties);\n    parseDefinedProperty(cxt, key, optionalProperties);\n\n    if (discriminator) {\n      gen.elseIf((0, codegen_1._)`${key} === ${discriminator}`);\n      const tag = gen.let(\"tag\");\n      parseString({ ...cxt,\n        data: tag\n      }); // can be discarded, it is already assigned\n    }\n\n    gen.else();\n\n    if (additionalProperties) {\n      parseEmpty({ ...cxt,\n        data: (0, codegen_1._)`${data}[${key}]`\n      });\n    } else {\n      parsingError(cxt, (0, codegen_1.str)`property ${key} not allowed`);\n    }\n\n    gen.endIf();\n  });\n\n  if (properties) {\n    const hasProp = (0, code_1.hasPropFunc)(gen);\n    const allProps = (0, codegen_1.and)(...Object.keys(properties).map(p => (0, codegen_1._)`${hasProp}.call(${data}, ${p})`));\n    gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str)`missing required properties`));\n  }\n}\n\nfunction parseDefinedProperty(cxt, key) {\n  let schemas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    gen\n  } = cxt;\n\n  for (const prop in schemas) {\n    gen.elseIf((0, codegen_1._)`${key} === ${prop}`);\n    parsePropertyValue(cxt, key, schemas[prop]);\n  }\n}\n\nfunction parsePropertyValue(cxt, key, schema) {\n  parseCode({ ...cxt,\n    schema,\n    data: (0, codegen_1._)`${cxt.data}[${key}]`\n  });\n}\n\nfunction parseType(cxt) {\n  const {\n    gen,\n    schema,\n    data,\n    self\n  } = cxt;\n\n  switch (schema.type) {\n    case \"boolean\":\n      parseBoolean(cxt);\n      break;\n\n    case \"string\":\n      parseString(cxt);\n      break;\n\n    case \"timestamp\":\n      {\n        parseString(cxt);\n        const vts = (0, util_1.useFunc)(gen, timestamp_1.default);\n        const {\n          allowDate,\n          parseDate\n        } = self.opts;\n        const notValid = allowDate ? (0, codegen_1._)`!${vts}(${data}, true)` : (0, codegen_1._)`!${vts}(${data})`;\n        const fail = parseDate ? (0, codegen_1.or)(notValid, (0, codegen_1._)`(${data} = new Date(${data}), false)`, (0, codegen_1._)`isNaN(${data}.valueOf())`) : notValid;\n        gen.if(fail, () => parsingError(cxt, (0, codegen_1.str)`invalid timestamp`));\n        break;\n      }\n\n    case \"float32\":\n    case \"float64\":\n      parseNumber(cxt);\n      break;\n\n    default:\n      {\n        const t = schema.type;\n\n        if (!self.opts.int32range && (t === \"int32\" || t === \"uint32\")) {\n          parseNumber(cxt, 16); // 2 ** 53 - max safe integer\n\n          if (t === \"uint32\") {\n            gen.if((0, codegen_1._)`${data} < 0`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));\n          }\n        } else {\n          const [min, max, maxDigits] = type_1.intRange[t];\n          parseNumber(cxt, maxDigits);\n          gen.if((0, codegen_1._)`${data} < ${min} || ${data} > ${max}`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));\n        }\n      }\n  }\n}\n\nfunction parseString(cxt) {\n  parseToken(cxt, '\"');\n  parseWith(cxt, parseJson_1.parseJsonString);\n}\n\nfunction parseEnum(cxt) {\n  const {\n    gen,\n    data,\n    schema\n  } = cxt;\n  const enumSch = schema.enum;\n  parseToken(cxt, '\"'); // TODO loopEnum\n\n  gen.if(false);\n\n  for (const value of enumSch) {\n    const valueStr = JSON.stringify(value).slice(1); // remove starting quote\n\n    gen.elseIf((0, codegen_1._)`${jsonSlice(valueStr.length)} === ${valueStr}`);\n    gen.assign(data, (0, codegen_1.str)`${value}`);\n    gen.add(names_1.default.jsonPos, valueStr.length);\n  }\n\n  gen.else();\n  jsonSyntaxError(cxt);\n  gen.endIf();\n}\n\nfunction parseNumber(cxt, maxDigits) {\n  const {\n    gen\n  } = cxt;\n  skipWhitespace(cxt);\n  gen.if((0, codegen_1._)`\"-0123456789\".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));\n}\n\nfunction parseBooleanToken(bool, fail) {\n  return cxt => {\n    const {\n      gen,\n      data\n    } = cxt;\n    tryParseToken(cxt, `${bool}`, () => fail(cxt), () => gen.assign(data, bool));\n  };\n}\n\nfunction parseRef(cxt) {\n  const {\n    gen,\n    self,\n    definitions,\n    schema,\n    schemaEnv\n  } = cxt;\n  const {\n    ref\n  } = schema;\n  const refSchema = definitions[ref];\n  if (!refSchema) throw new ref_error_1.default(self.opts.uriResolver, \"\", ref, `No definition ${ref}`);\n  if (!(0, ref_1.hasRef)(refSchema)) return parseCode({ ...cxt,\n    schema: refSchema\n  });\n  const {\n    root\n  } = schemaEnv;\n  const sch = compileParser.call(self, new __1.SchemaEnv({\n    schema: refSchema,\n    root\n  }), definitions);\n  partialParse(cxt, getParser(gen, sch), true);\n}\n\nfunction getParser(gen, sch) {\n  return sch.parse ? gen.scopeValue(\"parse\", {\n    ref: sch.parse\n  }) : (0, codegen_1._)`${gen.scopeValue(\"wrapper\", {\n    ref: sch\n  })}.parse`;\n}\n\nfunction parseEmpty(cxt) {\n  parseWith(cxt, parseJson_1.parseJson);\n}\n\nfunction parseWith(cxt, parseFunc, args) {\n  partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);\n}\n\nfunction partialParse(cxt, parseFunc, args) {\n  const {\n    gen,\n    data\n  } = cxt;\n  gen.assign(data, (0, codegen_1._)`${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._)`, ${args}` : codegen_1.nil})`);\n  gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${parseFunc}.position`);\n  gen.if((0, codegen_1._)`${data} === undefined`, () => parsingError(cxt, (0, codegen_1._)`${parseFunc}.message`));\n}\n\nfunction parseToken(cxt, tok) {\n  tryParseToken(cxt, tok, jsonSyntaxError);\n}\n\nfunction tryParseToken(cxt, tok, fail, success) {\n  const {\n    gen\n  } = cxt;\n  const n = tok.length;\n  skipWhitespace(cxt);\n  gen.if((0, codegen_1._)`${jsonSlice(n)} === ${tok}`, () => {\n    gen.add(names_1.default.jsonPos, n);\n    success === null || success === void 0 ? void 0 : success(cxt);\n  }, () => fail(cxt));\n}\n\nfunction skipWhitespace(_ref) {\n  let {\n    gen,\n    char: c\n  } = _ref;\n  gen.code((0, codegen_1._)`while((${c}=${names_1.default.json}[${names_1.default.jsonPos}],${c}===\" \"||${c}===\"\\\\n\"||${c}===\"\\\\r\"||${c}===\"\\\\t\"))${names_1.default.jsonPos}++;`);\n}\n\nfunction jsonSlice(len) {\n  return len === 1 ? (0, codegen_1._)`${names_1.default.json}[${names_1.default.jsonPos}]` : (0, codegen_1._)`${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;\n}\n\nfunction jsonSyntaxError(cxt) {\n  parsingError(cxt, (0, codegen_1._)`\"unexpected token \" + ${names_1.default.json}[${names_1.default.jsonPos}]`);\n}\n\nfunction parsingError(_ref2, msg) {\n  let {\n    gen,\n    parseName\n  } = _ref2;\n  gen.assign((0, codegen_1._)`${parseName}.message`, msg);\n  gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);\n  gen.return(undef);\n}","map":{"version":3,"mappings":"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","names":["genParse","elements","parseElements","values","parseValues","discriminator","parseDiscriminator","properties","parseProperties","optionalProperties","enum","parseEnum","type","parseType","ref","parseRef","compileParser","sch","definitions","_sch","__1","call","es5","lines","opts","code","ownProperties","gen","codegen_1","scope","parseName","scopeName","cxt","self","schema","schemaEnv","data","names_1","char","name","sourceCode","_compilations","add","parserFunction","optimize","parseFuncCode","toString","scopeRefs","makeParse","Function","parse","get","value","e","logger","error","delete","exports","undef","func","json","jsonPos","jsonPart","let","assign","const","jsonLen","parseCode","skipWhitespace","if","return","jsonSyntaxError","form","key","types_1","parseNullable","parseEmpty","parseBoolean","parseBooleanToken","parseForm","nullable","tryParseToken","parseToken","ix","parseItems","el","parseKeyValue","endToken","block","tryParseItems","for","jsonSlice","break","hasItem","parseString","parsePropertyValue","mapping","startPos","tag","parsingError","tagValue","elseIf","parseSchemaProperties","else","endIf","additionalProperties","parseDefinedProperty","hasProp","allProps","Object","keys","map","p","schemas","prop","vts","timestamp_1","allowDate","parseDate","notValid","fail","parseNumber","t","int32range","min","max","maxDigits","type_1","parseWith","parseJson_1","enumSch","valueStr","JSON","stringify","slice","length","bool","refSchema","ref_error_1","uriResolver","root","partialParse","getParser","scopeValue","parseFunc","args","tok","success","n","c","len","msg"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\compile\\jtd\\parse.ts"],"sourcesContent":["import type Ajv from \"../../core\"\nimport type {SchemaObject} from \"../../types\"\nimport {jtdForms, JTDForm, SchemaObjectMap} from \"./types\"\nimport {SchemaEnv, getCompilingSchema} from \"..\"\nimport {_, str, and, or, nil, not, CodeGen, Code, Name, SafeExpr} from \"../codegen\"\nimport MissingRefError from \"../ref_error\"\nimport N from \"../names\"\nimport {hasPropFunc} from \"../../vocabularies/code\"\nimport {hasRef} from \"../../vocabularies/jtd/ref\"\nimport {intRange, IntType} from \"../../vocabularies/jtd/type\"\nimport {parseJson, parseJsonNumber, parseJsonString} from \"../../runtime/parseJson\"\nimport {useFunc} from \"../util\"\nimport validTimestamp from \"../../runtime/timestamp\"\n\ntype GenParse = (cxt: ParseCxt) => void\n\nconst genParse: {[F in JTDForm]: GenParse} = {\n  elements: parseElements,\n  values: parseValues,\n  discriminator: parseDiscriminator,\n  properties: parseProperties,\n  optionalProperties: parseProperties,\n  enum: parseEnum,\n  type: parseType,\n  ref: parseRef,\n}\n\ninterface ParseCxt {\n  readonly gen: CodeGen\n  readonly self: Ajv // current Ajv instance\n  readonly schemaEnv: SchemaEnv\n  readonly definitions: SchemaObjectMap\n  schema: SchemaObject\n  data: Code\n  parseName: Name\n  char: Name\n}\n\nexport default function compileParser(\n  this: Ajv,\n  sch: SchemaEnv,\n  definitions: SchemaObjectMap\n): SchemaEnv {\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  const parseName = gen.scopeName(\"parse\")\n  const cxt: ParseCxt = {\n    self: this,\n    gen,\n    schema: sch.schema as SchemaObject,\n    schemaEnv: sch,\n    definitions,\n    data: N.data,\n    parseName,\n    char: gen.name(\"c\"),\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    sch.parseName = parseName\n    parserFunction(cxt)\n    gen.optimize(this.opts.code.optimize)\n    const parseFuncCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${parseFuncCode}`\n    const makeParse = new Function(`${N.scope}`, sourceCode)\n    const parse: (json: string) => unknown = makeParse(this.scope.get())\n    this.scope.value(parseName, {ref: parse})\n    sch.parse = parse\n  } catch (e) {\n    if (sourceCode) this.logger.error(\"Error compiling parser, function code:\", sourceCode)\n    delete sch.parse\n    delete sch.parseName\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n  return sch\n}\n\nconst undef = _`undefined`\n\nfunction parserFunction(cxt: ParseCxt): void {\n  const {gen, parseName, char} = cxt\n  gen.func(parseName, _`${N.json}, ${N.jsonPos}, ${N.jsonPart}`, false, () => {\n    gen.let(N.data)\n    gen.let(char)\n    gen.assign(_`${parseName}.message`, undef)\n    gen.assign(_`${parseName}.position`, undef)\n    gen.assign(N.jsonPos, _`${N.jsonPos} || 0`)\n    gen.const(N.jsonLen, _`${N.json}.length`)\n    parseCode(cxt)\n    skipWhitespace(cxt)\n    gen.if(N.jsonPart, () => {\n      gen.assign(_`${parseName}.position`, N.jsonPos)\n      gen.return(N.data)\n    })\n    gen.if(_`${N.jsonPos} === ${N.jsonLen}`, () => gen.return(N.data))\n    jsonSyntaxError(cxt)\n  })\n}\n\nfunction parseCode(cxt: ParseCxt): void {\n  let form: JTDForm | undefined\n  for (const key of jtdForms) {\n    if (key in cxt.schema) {\n      form = key\n      break\n    }\n  }\n  if (form) parseNullable(cxt, genParse[form])\n  else parseEmpty(cxt)\n}\n\nconst parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError))\n\nfunction parseNullable(cxt: ParseCxt, parseForm: GenParse): void {\n  const {gen, schema, data} = cxt\n  if (!schema.nullable) return parseForm(cxt)\n  tryParseToken(cxt, \"null\", parseForm, () => gen.assign(data, null))\n}\n\nfunction parseElements(cxt: ParseCxt): void {\n  const {gen, schema, data} = cxt\n  parseToken(cxt, \"[\")\n  const ix = gen.let(\"i\", 0)\n  gen.assign(data, _`[]`)\n  parseItems(cxt, \"]\", () => {\n    const el = gen.let(\"el\")\n    parseCode({...cxt, schema: schema.elements, data: el})\n    gen.assign(_`${data}[${ix}++]`, el)\n  })\n}\n\nfunction parseValues(cxt: ParseCxt): void {\n  const {gen, schema, data} = cxt\n  parseToken(cxt, \"{\")\n  gen.assign(data, _`{}`)\n  parseItems(cxt, \"}\", () => parseKeyValue(cxt, schema.values))\n}\n\nfunction parseItems(cxt: ParseCxt, endToken: string, block: () => void): void {\n  tryParseItems(cxt, endToken, block)\n  parseToken(cxt, endToken)\n}\n\nfunction tryParseItems(cxt: ParseCxt, endToken: string, block: () => void): void {\n  const {gen} = cxt\n  gen.for(_`;${N.jsonPos}<${N.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {\n    block()\n    tryParseToken(cxt, \",\", () => gen.break(), hasItem)\n  })\n\n  function hasItem(): void {\n    tryParseToken(cxt, endToken, () => {}, jsonSyntaxError)\n  }\n}\n\nfunction parseKeyValue(cxt: ParseCxt, schema: SchemaObject): void {\n  const {gen} = cxt\n  const key = gen.let(\"key\")\n  parseString({...cxt, data: key})\n  parseToken(cxt, \":\")\n  parsePropertyValue(cxt, key, schema)\n}\n\nfunction parseDiscriminator(cxt: ParseCxt): void {\n  const {gen, data, schema} = cxt\n  const {discriminator, mapping} = schema\n  parseToken(cxt, \"{\")\n  gen.assign(data, _`{}`)\n  const startPos = gen.const(\"pos\", N.jsonPos)\n  const value = gen.let(\"value\")\n  const tag = gen.let(\"tag\")\n  tryParseItems(cxt, \"}\", () => {\n    const key = gen.let(\"key\")\n    parseString({...cxt, data: key})\n    parseToken(cxt, \":\")\n    gen.if(\n      _`${key} === ${discriminator}`,\n      () => {\n        parseString({...cxt, data: tag})\n        gen.assign(_`${data}[${key}]`, tag)\n        gen.break()\n      },\n      () => parseEmpty({...cxt, data: value}) // can be discarded/skipped\n    )\n  })\n  gen.assign(N.jsonPos, startPos)\n  gen.if(_`${tag} === undefined`)\n  parsingError(cxt, str`discriminator tag not found`)\n  for (const tagValue in mapping) {\n    gen.elseIf(_`${tag} === ${tagValue}`)\n    parseSchemaProperties({...cxt, schema: mapping[tagValue]}, discriminator)\n  }\n  gen.else()\n  parsingError(cxt, str`discriminator value not in schema`)\n  gen.endIf()\n}\n\nfunction parseProperties(cxt: ParseCxt): void {\n  const {gen, data} = cxt\n  parseToken(cxt, \"{\")\n  gen.assign(data, _`{}`)\n  parseSchemaProperties(cxt)\n}\n\nfunction parseSchemaProperties(cxt: ParseCxt, discriminator?: string): void {\n  const {gen, schema, data} = cxt\n  const {properties, optionalProperties, additionalProperties} = schema\n  parseItems(cxt, \"}\", () => {\n    const key = gen.let(\"key\")\n    parseString({...cxt, data: key})\n    parseToken(cxt, \":\")\n    gen.if(false)\n    parseDefinedProperty(cxt, key, properties)\n    parseDefinedProperty(cxt, key, optionalProperties)\n    if (discriminator) {\n      gen.elseIf(_`${key} === ${discriminator}`)\n      const tag = gen.let(\"tag\")\n      parseString({...cxt, data: tag}) // can be discarded, it is already assigned\n    }\n    gen.else()\n    if (additionalProperties) {\n      parseEmpty({...cxt, data: _`${data}[${key}]`})\n    } else {\n      parsingError(cxt, str`property ${key} not allowed`)\n    }\n    gen.endIf()\n  })\n  if (properties) {\n    const hasProp = hasPropFunc(gen)\n    const allProps: Code = and(\n      ...Object.keys(properties).map((p): Code => _`${hasProp}.call(${data}, ${p})`)\n    )\n    gen.if(not(allProps), () => parsingError(cxt, str`missing required properties`))\n  }\n}\n\nfunction parseDefinedProperty(cxt: ParseCxt, key: Name, schemas: SchemaObjectMap = {}): void {\n  const {gen} = cxt\n  for (const prop in schemas) {\n    gen.elseIf(_`${key} === ${prop}`)\n    parsePropertyValue(cxt, key, schemas[prop] as SchemaObject)\n  }\n}\n\nfunction parsePropertyValue(cxt: ParseCxt, key: Name, schema: SchemaObject): void {\n  parseCode({...cxt, schema, data: _`${cxt.data}[${key}]`})\n}\n\nfunction parseType(cxt: ParseCxt): void {\n  const {gen, schema, data, self} = cxt\n  switch (schema.type) {\n    case \"boolean\":\n      parseBoolean(cxt)\n      break\n    case \"string\":\n      parseString(cxt)\n      break\n    case \"timestamp\": {\n      parseString(cxt)\n      const vts = useFunc(gen, validTimestamp)\n      const {allowDate, parseDate} = self.opts\n      const notValid = allowDate ? _`!${vts}(${data}, true)` : _`!${vts}(${data})`\n      const fail: Code = parseDate\n        ? or(notValid, _`(${data} = new Date(${data}), false)`, _`isNaN(${data}.valueOf())`)\n        : notValid\n      gen.if(fail, () => parsingError(cxt, str`invalid timestamp`))\n      break\n    }\n    case \"float32\":\n    case \"float64\":\n      parseNumber(cxt)\n      break\n    default: {\n      const t = schema.type as IntType\n      if (!self.opts.int32range && (t === \"int32\" || t === \"uint32\")) {\n        parseNumber(cxt, 16) // 2 ** 53 - max safe integer\n        if (t === \"uint32\") {\n          gen.if(_`${data} < 0`, () => parsingError(cxt, str`integer out of range`))\n        }\n      } else {\n        const [min, max, maxDigits] = intRange[t]\n        parseNumber(cxt, maxDigits)\n        gen.if(_`${data} < ${min} || ${data} > ${max}`, () =>\n          parsingError(cxt, str`integer out of range`)\n        )\n      }\n    }\n  }\n}\n\nfunction parseString(cxt: ParseCxt): void {\n  parseToken(cxt, '\"')\n  parseWith(cxt, parseJsonString)\n}\n\nfunction parseEnum(cxt: ParseCxt): void {\n  const {gen, data, schema} = cxt\n  const enumSch = schema.enum\n  parseToken(cxt, '\"')\n  // TODO loopEnum\n  gen.if(false)\n  for (const value of enumSch) {\n    const valueStr = JSON.stringify(value).slice(1) // remove starting quote\n    gen.elseIf(_`${jsonSlice(valueStr.length)} === ${valueStr}`)\n    gen.assign(data, str`${value}`)\n    gen.add(N.jsonPos, valueStr.length)\n  }\n  gen.else()\n  jsonSyntaxError(cxt)\n  gen.endIf()\n}\n\nfunction parseNumber(cxt: ParseCxt, maxDigits?: number): void {\n  const {gen} = cxt\n  skipWhitespace(cxt)\n  gen.if(\n    _`\"-0123456789\".indexOf(${jsonSlice(1)}) < 0`,\n    () => jsonSyntaxError(cxt),\n    () => parseWith(cxt, parseJsonNumber, maxDigits)\n  )\n}\n\nfunction parseBooleanToken(bool: boolean, fail: GenParse): GenParse {\n  return (cxt) => {\n    const {gen, data} = cxt\n    tryParseToken(\n      cxt,\n      `${bool}`,\n      () => fail(cxt),\n      () => gen.assign(data, bool)\n    )\n  }\n}\n\nfunction parseRef(cxt: ParseCxt): void {\n  const {gen, self, definitions, schema, schemaEnv} = cxt\n  const {ref} = schema\n  const refSchema = definitions[ref]\n  if (!refSchema) throw new MissingRefError(self.opts.uriResolver, \"\", ref, `No definition ${ref}`)\n  if (!hasRef(refSchema)) return parseCode({...cxt, schema: refSchema})\n  const {root} = schemaEnv\n  const sch = compileParser.call(self, new SchemaEnv({schema: refSchema, root}), definitions)\n  partialParse(cxt, getParser(gen, sch), true)\n}\n\nfunction getParser(gen: CodeGen, sch: SchemaEnv): Code {\n  return sch.parse\n    ? gen.scopeValue(\"parse\", {ref: sch.parse})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.parse`\n}\n\nfunction parseEmpty(cxt: ParseCxt): void {\n  parseWith(cxt, parseJson)\n}\n\nfunction parseWith(cxt: ParseCxt, parseFunc: {code: string}, args?: SafeExpr): void {\n  partialParse(cxt, useFunc(cxt.gen, parseFunc), args)\n}\n\nfunction partialParse(cxt: ParseCxt, parseFunc: Name, args?: SafeExpr): void {\n  const {gen, data} = cxt\n  gen.assign(data, _`${parseFunc}(${N.json}, ${N.jsonPos}${args ? _`, ${args}` : nil})`)\n  gen.assign(N.jsonPos, _`${parseFunc}.position`)\n  gen.if(_`${data} === undefined`, () => parsingError(cxt, _`${parseFunc}.message`))\n}\n\nfunction parseToken(cxt: ParseCxt, tok: string): void {\n  tryParseToken(cxt, tok, jsonSyntaxError)\n}\n\nfunction tryParseToken(cxt: ParseCxt, tok: string, fail: GenParse, success?: GenParse): void {\n  const {gen} = cxt\n  const n = tok.length\n  skipWhitespace(cxt)\n  gen.if(\n    _`${jsonSlice(n)} === ${tok}`,\n    () => {\n      gen.add(N.jsonPos, n)\n      success?.(cxt)\n    },\n    () => fail(cxt)\n  )\n}\n\nfunction skipWhitespace({gen, char: c}: ParseCxt): void {\n  gen.code(\n    _`while((${c}=${N.json}[${N.jsonPos}],${c}===\" \"||${c}===\"\\\\n\"||${c}===\"\\\\r\"||${c}===\"\\\\t\"))${N.jsonPos}++;`\n  )\n}\n\nfunction jsonSlice(len: number | Name): Code {\n  return len === 1\n    ? _`${N.json}[${N.jsonPos}]`\n    : _`${N.json}.slice(${N.jsonPos}, ${N.jsonPos}+${len})`\n}\n\nfunction jsonSyntaxError(cxt: ParseCxt): void {\n  parsingError(cxt, _`\"unexpected token \" + ${N.json}[${N.jsonPos}]`)\n}\n\nfunction parsingError({gen, parseName}: ParseCxt, msg: Code): void {\n  gen.assign(_`${parseName}.message`, msg)\n  gen.assign(_`${parseName}.position`, N.jsonPos)\n  gen.return(undef)\n}\n"]},"metadata":{},"sourceType":"script"}