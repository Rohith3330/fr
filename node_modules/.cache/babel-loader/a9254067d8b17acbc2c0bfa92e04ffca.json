{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && self.key === \"consequent\" || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","map":{"version":3,"mappings":";;;;;;AAQO,MAAMA,KAAK,GAAG,CACnB,UAAUC,IAAV,EAA0BC,MAA1B,EAA4C;EAC1C,MAAMC,YAAY,GAKfF,IAAI,CAACG,GAALH,KAAa,MAAbA,KAAwBC,MAAM,CAACG,OAAPH,MAAoBA,MAAM,CAACI,YAAPJ,EAA5CD,KAGAA,IAAI,CAACG,GAALH,KAAa,aAAbA,IAA8BC,MAAM,CAACK,mBAAPL,EAH9BD,IAMAA,IAAI,CAACG,GAALH,KAAa,MAAbA,IAAuBC,MAAM,CAACM,kBAAPN,EANvBD,IASAA,IAAI,CAACQ,OAALR,KAAiB,cAAjBA,IACCC,MAAM,CAACQ,qBAAPR,EADDD,IAECC,MAAM,CAACS,IAAPT,CAAYU,YAAZV,CAAyBW,MAAzBX,KAAoC,CAXrCD,IAcAA,IAAI,CAACG,GAALH,KAAa,YAAbA,IAA6BC,MAAM,CAACY,qBAAPZ,EAnBhC;;EAqBA,IAAIC,YAAJ,EAAkB;IAChBD,MAAM,CAACa,MAAPb;IACA,OAAO,IAAP;EACD;AA1BgB,GA6BnB,UAAUD,IAAV,EAA0BC,MAA1B,EAA4C;EAC1C,IAAIA,MAAM,CAACc,oBAAPd,MAAiCA,MAAM,CAACS,IAAPT,CAAYe,WAAZf,CAAwBW,MAAxBX,KAAmC,CAAxE,EAA2E;IAIzEA,MAAM,CAACgB,WAAPhB,CAAmBA,MAAM,CAACS,IAAPT,CAAYe,WAAZf,CAAwB,CAAxBA,CAAnBA;IACA,OAAO,IAAP;EACD;AApCgB,GAuCnB,UAAUD,IAAV,EAA0BC,MAA1B,EAA4C;EAC1C,IAAIA,MAAM,CAACiB,QAAPjB,EAAJ,EAAuB;IAIrB,IAAID,IAAI,CAACG,GAALH,KAAa,MAAjB,EAAyB;MACvBC,MAAM,CAACgB,WAAPhB,CAAmBA,MAAM,CAACS,IAAPT,CAAYkB,KAA/BlB;IADF,OAEO;MAELA,MAAM,CAACgB,WAAPhB,CAAmBA,MAAM,CAACS,IAAPT,CAAYmB,IAA/BnB;IACD;;IACD,OAAO,IAAP;EACD;AAnDgB,GAsDnB,UAAUD,IAAV,EAA0BC,MAA1B,EAA4C;EAC1C,IACGA,MAAM,CAACoB,aAAPpB,MAA0BD,IAAI,CAACG,GAALH,KAAa,YAAvCC,IACAD,IAAI,CAACG,GAALH,KAAa,MAAbA,KACEC,MAAM,CAACqB,MAAPrB,MAAmBA,MAAM,CAACsB,yBAAPtB,EADrBD,CAFH,EAIE;IACAA,IAAI,CAACiB,WAALjB,CAAiB;MACfwB,IAAI,EAAE,gBADS;MAEfC,IAAI,EAAE;IAFS,CAAjBzB;IAIA,OAAO,IAAP;EACD;AAjEgB,EAAd","names":["hooks","self","parent","removeParent","key","isWhile","isSwitchCase","isExportDeclaration","isLabeledStatement","listKey","isVariableDeclaration","node","declarations","length","isExpressionStatement","remove","isSequenceExpression","expressions","replaceWith","isBinary","right","left","isIfStatement","isLoop","isArrowFunctionExpression","type","body"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\path\\lib\\removal-hooks.ts"],"sourcesContent":["// this file contains hooks that handle ancestry cleanup of parent nodes when removing children\n\nimport type NodePath from \"..\";\nimport type * as t from \"@babel/types\";\n/**\n * Pre hooks should be used for either rejecting removal or delegating removal\n */\n\nexport const hooks = [\n  function (self: NodePath, parent: NodePath) {\n    const removeParent =\n      // while (NODE);\n      // removing the test of a while/switch, we can either just remove it entirely *or* turn the\n      // `test` into `true` unlikely that the latter will ever be what's wanted so we just remove\n      // the loop to avoid infinite recursion\n      (self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase())) ||\n      // export NODE;\n      // just remove a declaration for an export as this is no longer valid\n      (self.key === \"declaration\" && parent.isExportDeclaration()) ||\n      // label: NODE\n      // stray labeled statement with no body\n      (self.key === \"body\" && parent.isLabeledStatement()) ||\n      // let NODE;\n      // remove an entire declaration if there are no declarators left\n      (self.listKey === \"declarations\" &&\n        parent.isVariableDeclaration() &&\n        parent.node.declarations.length === 1) ||\n      // NODE;\n      // remove the entire expression statement if there's no expression\n      (self.key === \"expression\" && parent.isExpressionStatement());\n\n    if (removeParent) {\n      parent.remove();\n      return true;\n    }\n  },\n\n  function (self: NodePath, parent: NodePath) {\n    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n      // (node, NODE);\n      // we've just removed the second element of a sequence expression so let's turn that sequence\n      // expression into a regular expression\n      parent.replaceWith(parent.node.expressions[0]);\n      return true;\n    }\n  },\n\n  function (self: NodePath, parent: NodePath) {\n    if (parent.isBinary()) {\n      // left + NODE;\n      // NODE + right;\n      // we're in a binary expression, better remove it and replace it with the last expression\n      if (self.key === \"left\") {\n        parent.replaceWith(parent.node.right);\n      } else {\n        // key === \"right\"\n        parent.replaceWith(parent.node.left);\n      }\n      return true;\n    }\n  },\n\n  function (self: NodePath, parent: NodePath) {\n    if (\n      (parent.isIfStatement() && self.key === \"consequent\") ||\n      (self.key === \"body\" &&\n        (parent.isLoop() || parent.isArrowFunctionExpression()))\n    ) {\n      self.replaceWith({\n        type: \"BlockStatement\",\n        body: [],\n      } as t.BlockStatement);\n      return true;\n    }\n  },\n];\n"]},"metadata":{},"sourceType":"script"}