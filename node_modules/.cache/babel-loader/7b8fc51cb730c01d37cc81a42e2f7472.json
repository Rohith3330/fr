{"ast":null,"code":"import useEventCallback from '@restart/hooks/useEventCallback';\nimport useIntersectionObserver from '@restart/hooks/useIntersectionObserver';\nimport { useMemo, useRef } from 'react';\nimport getScrollParent from 'dom-helpers/scrollParent';\nexport let Position;\n\n(function (Position) {\n  Position[Position[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  Position[Position[\"BEFORE\"] = 1] = \"BEFORE\";\n  Position[Position[\"INSIDE\"] = 2] = \"INSIDE\";\n  Position[Position[\"AFTER\"] = 3] = \"AFTER\";\n})(Position || (Position = {}));\n\nfunction toCss(margin) {\n  if (!margin || typeof margin === 'string') return margin;\n  const {\n    top = 0,\n    right = 0,\n    bottom = 0,\n    left = 0\n  } = margin;\n  return `${top}px ${right}px ${bottom}px ${left}px`;\n}\n\nconst findRoot = el => getScrollParent(el, true);\n\nfunction useWaypoint(element, callback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    rootMargin,\n    threshold,\n    scrollDirection = 'vertical'\n  } = options;\n  let {\n    root\n  } = options;\n  const handler = useEventCallback(callback);\n  const prevPositionRef = useRef(null);\n\n  if (root === 'scrollParent') {\n    root = findRoot;\n  }\n\n  const scrollParent = useMemo(() => element && typeof root === 'function' ? root(element) : null, [element, root]);\n  let realRoot = typeof root === 'function' ? scrollParent : root;\n\n  if (realRoot && realRoot.nodeType === document.DOCUMENT_NODE) {\n    // explicit undefined means \"use the viewport\", instead of `null`\n    // which means \"no root yet\". This works around a bug in safari\n    // where document is not accepted in older versions,\n    // or is accepted but doesn't work (as of v14)\n    realRoot = undefined;\n  }\n\n  useIntersectionObserver( // We change the meaning of explicit null to \"not provided yet\"\n  // this is to allow easier synchronizing between element and roots derived\n  // from it. Otherwise if the root updates later an observer will be created\n  // for the document and then for the root\n  element, (_ref, observer) => {\n    let [entry] = _ref;\n\n    var _entry$rootBounds, _entry$rootBounds2;\n\n    if (!entry) return;\n    const [start, end, point] = scrollDirection === 'vertical' ? ['top', 'bottom', 'y'] : ['left', 'right', 'x'];\n    const {\n      [point]: coord\n    } = entry.boundingClientRect;\n    const rootStart = ((_entry$rootBounds = entry.rootBounds) == null ? void 0 : _entry$rootBounds[start]) || 0;\n    const rootEnd = ((_entry$rootBounds2 = entry.rootBounds) == null ? void 0 : _entry$rootBounds2[end]) || 0; // The position may remain UNKNOWN if the root\n    // is 0 width/height or everything is hidden.\n\n    let position = Position.UNKNOWN;\n\n    if (entry.isIntersecting) {\n      position = Position.INSIDE;\n    } else if (coord > rootEnd) {\n      position = Position.AFTER;\n    } else if (coord < rootStart) {\n      position = Position.BEFORE;\n    }\n\n    const previousPosition = prevPositionRef.current;\n\n    if (previousPosition === position) {\n      return;\n    }\n\n    handler({\n      position,\n      previousPosition\n    }, entry, observer);\n    prevPositionRef.current = position;\n  }, {\n    threshold,\n    root: realRoot,\n    rootMargin: toCss(rootMargin)\n  });\n}\n\nexport default useWaypoint;","map":{"version":3,"names":["useEventCallback","useIntersectionObserver","useMemo","useRef","getScrollParent","Position","toCss","margin","top","right","bottom","left","findRoot","el","useWaypoint","element","callback","options","rootMargin","threshold","scrollDirection","root","handler","prevPositionRef","scrollParent","realRoot","nodeType","document","DOCUMENT_NODE","undefined","observer","entry","_entry$rootBounds","_entry$rootBounds2","start","end","point","coord","boundingClientRect","rootStart","rootBounds","rootEnd","position","UNKNOWN","isIntersecting","INSIDE","AFTER","BEFORE","previousPosition","current"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@restart/ui/esm/useWaypoint.js"],"sourcesContent":["import useEventCallback from '@restart/hooks/useEventCallback';\nimport useIntersectionObserver from '@restart/hooks/useIntersectionObserver';\nimport { useMemo, useRef } from 'react';\nimport getScrollParent from 'dom-helpers/scrollParent';\nexport let Position;\n\n(function (Position) {\n  Position[Position[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  Position[Position[\"BEFORE\"] = 1] = \"BEFORE\";\n  Position[Position[\"INSIDE\"] = 2] = \"INSIDE\";\n  Position[Position[\"AFTER\"] = 3] = \"AFTER\";\n})(Position || (Position = {}));\n\nfunction toCss(margin) {\n  if (!margin || typeof margin === 'string') return margin;\n  const {\n    top = 0,\n    right = 0,\n    bottom = 0,\n    left = 0\n  } = margin;\n  return `${top}px ${right}px ${bottom}px ${left}px`;\n}\n\nconst findRoot = el => getScrollParent(el, true);\n\nfunction useWaypoint(element, callback, options = {}) {\n  const {\n    rootMargin,\n    threshold,\n    scrollDirection = 'vertical'\n  } = options;\n  let {\n    root\n  } = options;\n  const handler = useEventCallback(callback);\n  const prevPositionRef = useRef(null);\n\n  if (root === 'scrollParent') {\n    root = findRoot;\n  }\n\n  const scrollParent = useMemo(() => element && typeof root === 'function' ? root(element) : null, [element, root]);\n  let realRoot = typeof root === 'function' ? scrollParent : root;\n\n  if (realRoot && realRoot.nodeType === document.DOCUMENT_NODE) {\n    // explicit undefined means \"use the viewport\", instead of `null`\n    // which means \"no root yet\". This works around a bug in safari\n    // where document is not accepted in older versions,\n    // or is accepted but doesn't work (as of v14)\n    realRoot = undefined;\n  }\n\n  useIntersectionObserver( // We change the meaning of explicit null to \"not provided yet\"\n  // this is to allow easier synchronizing between element and roots derived\n  // from it. Otherwise if the root updates later an observer will be created\n  // for the document and then for the root\n  element, ([entry], observer) => {\n    var _entry$rootBounds, _entry$rootBounds2;\n\n    if (!entry) return;\n    const [start, end, point] = scrollDirection === 'vertical' ? ['top', 'bottom', 'y'] : ['left', 'right', 'x'];\n    const {\n      [point]: coord\n    } = entry.boundingClientRect;\n    const rootStart = ((_entry$rootBounds = entry.rootBounds) == null ? void 0 : _entry$rootBounds[start]) || 0;\n    const rootEnd = ((_entry$rootBounds2 = entry.rootBounds) == null ? void 0 : _entry$rootBounds2[end]) || 0; // The position may remain UNKNOWN if the root\n    // is 0 width/height or everything is hidden.\n\n    let position = Position.UNKNOWN;\n\n    if (entry.isIntersecting) {\n      position = Position.INSIDE;\n    } else if (coord > rootEnd) {\n      position = Position.AFTER;\n    } else if (coord < rootStart) {\n      position = Position.BEFORE;\n    }\n\n    const previousPosition = prevPositionRef.current;\n\n    if (previousPosition === position) {\n      return;\n    }\n\n    handler({\n      position,\n      previousPosition\n    }, entry, observer);\n    prevPositionRef.current = position;\n  }, {\n    threshold,\n    root: realRoot,\n    rootMargin: toCss(rootMargin)\n  });\n}\n\nexport default useWaypoint;"],"mappings":"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"},"metadata":{},"sourceType":"module"}