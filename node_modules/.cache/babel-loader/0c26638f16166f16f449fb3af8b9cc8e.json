{"ast":null,"code":"const BULK_SIZE = 2000; // We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\n\nconst digestCaches = {};\n\nclass BulkUpdateDecorator {\n  /**\n   * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n   * @param {string=} hashKey key for caching\n   */\n  constructor(hashOrFactory, hashKey) {\n    this.hashKey = hashKey;\n\n    if (typeof hashOrFactory === \"function\") {\n      this.hashFactory = hashOrFactory;\n      this.hash = undefined;\n    } else {\n      this.hashFactory = undefined;\n      this.hash = hashOrFactory;\n    }\n\n    this.buffer = \"\";\n  }\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n\n\n  update(data, inputEncoding) {\n    if (inputEncoding !== undefined || typeof data !== \"string\" || data.length > BULK_SIZE) {\n      if (this.hash === undefined) {\n        this.hash = this.hashFactory();\n      }\n\n      if (this.buffer.length > 0) {\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n\n      this.hash.update(data, inputEncoding);\n    } else {\n      this.buffer += data;\n\n      if (this.buffer.length > BULK_SIZE) {\n        if (this.hash === undefined) {\n          this.hash = this.hashFactory();\n        }\n\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n   * @param {string=} encoding encoding of the return value\n   * @returns {string|Buffer} digest\n   */\n\n\n  digest(encoding) {\n    let digestCache;\n    const buffer = this.buffer;\n\n    if (this.hash === undefined) {\n      // short data for hash, we can use caching\n      const cacheKey = `${this.hashKey}-${encoding}`;\n      digestCache = digestCaches[cacheKey];\n\n      if (digestCache === undefined) {\n        digestCache = digestCaches[cacheKey] = new Map();\n      }\n\n      const cacheEntry = digestCache.get(buffer);\n\n      if (cacheEntry !== undefined) {\n        return cacheEntry;\n      }\n\n      this.hash = this.hashFactory();\n    }\n\n    if (buffer.length > 0) {\n      this.hash.update(buffer);\n    }\n\n    const digestResult = this.hash.digest(encoding);\n\n    if (digestCache !== undefined) {\n      digestCache.set(buffer, digestResult);\n    }\n\n    return digestResult;\n  }\n\n}\n\nmodule.exports = BulkUpdateDecorator;","map":{"version":3,"names":["BULK_SIZE","digestCaches","BulkUpdateDecorator","constructor","hashOrFactory","hashKey","hashFactory","hash","undefined","buffer","update","data","inputEncoding","length","digest","encoding","digestCache","cacheKey","Map","cacheEntry","get","digestResult","set","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/react-dev-utils/node_modules/loader-utils/lib/hash/BulkUpdateDecorator.js"],"sourcesContent":["const BULK_SIZE = 2000;\n\n// We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\nconst digestCaches = {};\n\nclass BulkUpdateDecorator {\n  /**\n   * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n   * @param {string=} hashKey key for caching\n   */\n  constructor(hashOrFactory, hashKey) {\n    this.hashKey = hashKey;\n\n    if (typeof hashOrFactory === \"function\") {\n      this.hashFactory = hashOrFactory;\n      this.hash = undefined;\n    } else {\n      this.hashFactory = undefined;\n      this.hash = hashOrFactory;\n    }\n\n    this.buffer = \"\";\n  }\n\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n  update(data, inputEncoding) {\n    if (\n      inputEncoding !== undefined ||\n      typeof data !== \"string\" ||\n      data.length > BULK_SIZE\n    ) {\n      if (this.hash === undefined) {\n        this.hash = this.hashFactory();\n      }\n\n      if (this.buffer.length > 0) {\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n\n      this.hash.update(data, inputEncoding);\n    } else {\n      this.buffer += data;\n\n      if (this.buffer.length > BULK_SIZE) {\n        if (this.hash === undefined) {\n          this.hash = this.hashFactory();\n        }\n\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n   * @param {string=} encoding encoding of the return value\n   * @returns {string|Buffer} digest\n   */\n  digest(encoding) {\n    let digestCache;\n\n    const buffer = this.buffer;\n\n    if (this.hash === undefined) {\n      // short data for hash, we can use caching\n      const cacheKey = `${this.hashKey}-${encoding}`;\n\n      digestCache = digestCaches[cacheKey];\n\n      if (digestCache === undefined) {\n        digestCache = digestCaches[cacheKey] = new Map();\n      }\n\n      const cacheEntry = digestCache.get(buffer);\n\n      if (cacheEntry !== undefined) {\n        return cacheEntry;\n      }\n\n      this.hash = this.hashFactory();\n    }\n\n    if (buffer.length > 0) {\n      this.hash.update(buffer);\n    }\n\n    const digestResult = this.hash.digest(encoding);\n\n    if (digestCache !== undefined) {\n      digestCache.set(buffer, digestResult);\n    }\n\n    return digestResult;\n  }\n}\n\nmodule.exports = BulkUpdateDecorator;\n"],"mappings":"AAAA,MAAMA,SAAS,GAAG,IAAlB,C,CAEA;AACA;;AACA,MAAMC,YAAY,GAAG,EAArB;;AAEA,MAAMC,mBAAN,CAA0B;EACxB;AACF;AACA;AACA;EACEC,WAAW,CAACC,aAAD,EAAgBC,OAAhB,EAAyB;IAClC,KAAKA,OAAL,GAAeA,OAAf;;IAEA,IAAI,OAAOD,aAAP,KAAyB,UAA7B,EAAyC;MACvC,KAAKE,WAAL,GAAmBF,aAAnB;MACA,KAAKG,IAAL,GAAYC,SAAZ;IACD,CAHD,MAGO;MACL,KAAKF,WAAL,GAAmBE,SAAnB;MACA,KAAKD,IAAL,GAAYH,aAAZ;IACD;;IAED,KAAKK,MAAL,GAAc,EAAd;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEC,MAAM,CAACC,IAAD,EAAOC,aAAP,EAAsB;IAC1B,IACEA,aAAa,KAAKJ,SAAlB,IACA,OAAOG,IAAP,KAAgB,QADhB,IAEAA,IAAI,CAACE,MAAL,GAAcb,SAHhB,EAIE;MACA,IAAI,KAAKO,IAAL,KAAcC,SAAlB,EAA6B;QAC3B,KAAKD,IAAL,GAAY,KAAKD,WAAL,EAAZ;MACD;;MAED,IAAI,KAAKG,MAAL,CAAYI,MAAZ,GAAqB,CAAzB,EAA4B;QAC1B,KAAKN,IAAL,CAAUG,MAAV,CAAiB,KAAKD,MAAtB;QACA,KAAKA,MAAL,GAAc,EAAd;MACD;;MAED,KAAKF,IAAL,CAAUG,MAAV,CAAiBC,IAAjB,EAAuBC,aAAvB;IACD,CAfD,MAeO;MACL,KAAKH,MAAL,IAAeE,IAAf;;MAEA,IAAI,KAAKF,MAAL,CAAYI,MAAZ,GAAqBb,SAAzB,EAAoC;QAClC,IAAI,KAAKO,IAAL,KAAcC,SAAlB,EAA6B;UAC3B,KAAKD,IAAL,GAAY,KAAKD,WAAL,EAAZ;QACD;;QAED,KAAKC,IAAL,CAAUG,MAAV,CAAiB,KAAKD,MAAtB;QACA,KAAKA,MAAL,GAAc,EAAd;MACD;IACF;;IAED,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEK,MAAM,CAACC,QAAD,EAAW;IACf,IAAIC,WAAJ;IAEA,MAAMP,MAAM,GAAG,KAAKA,MAApB;;IAEA,IAAI,KAAKF,IAAL,KAAcC,SAAlB,EAA6B;MAC3B;MACA,MAAMS,QAAQ,GAAI,GAAE,KAAKZ,OAAQ,IAAGU,QAAS,EAA7C;MAEAC,WAAW,GAAGf,YAAY,CAACgB,QAAD,CAA1B;;MAEA,IAAID,WAAW,KAAKR,SAApB,EAA+B;QAC7BQ,WAAW,GAAGf,YAAY,CAACgB,QAAD,CAAZ,GAAyB,IAAIC,GAAJ,EAAvC;MACD;;MAED,MAAMC,UAAU,GAAGH,WAAW,CAACI,GAAZ,CAAgBX,MAAhB,CAAnB;;MAEA,IAAIU,UAAU,KAAKX,SAAnB,EAA8B;QAC5B,OAAOW,UAAP;MACD;;MAED,KAAKZ,IAAL,GAAY,KAAKD,WAAL,EAAZ;IACD;;IAED,IAAIG,MAAM,CAACI,MAAP,GAAgB,CAApB,EAAuB;MACrB,KAAKN,IAAL,CAAUG,MAAV,CAAiBD,MAAjB;IACD;;IAED,MAAMY,YAAY,GAAG,KAAKd,IAAL,CAAUO,MAAV,CAAiBC,QAAjB,CAArB;;IAEA,IAAIC,WAAW,KAAKR,SAApB,EAA+B;MAC7BQ,WAAW,CAACM,GAAZ,CAAgBb,MAAhB,EAAwBY,YAAxB;IACD;;IAED,OAAOA,YAAP;EACD;;AAjGuB;;AAoG1BE,MAAM,CAACC,OAAP,GAAiBtB,mBAAjB"},"metadata":{},"sourceType":"script"}