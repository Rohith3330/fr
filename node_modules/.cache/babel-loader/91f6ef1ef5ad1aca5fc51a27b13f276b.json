{"ast":null,"code":"'use strict';\n\nconst joinGridValue = require('../lib/joinGridValue');\n/**\n * @param {import('postcss-value-parser').ParsedValue} gridAutoFlow\n * @return {import('postcss-value-parser').ParsedValue | string}\n */\n\n\nconst normalizeGridAutoFlow = gridAutoFlow => {\n  let newValue = {\n    front: '',\n    back: ''\n  };\n  let shouldNormalize = false;\n  gridAutoFlow.walk(node => {\n    if (node.value === 'dense') {\n      shouldNormalize = true;\n      newValue.back = node.value;\n    } else if (['row', 'column'].includes(node.value.trim().toLowerCase())) {\n      shouldNormalize = true;\n      newValue.front = node.value;\n    } else {\n      shouldNormalize = false;\n    }\n  });\n\n  if (shouldNormalize) {\n    return `${newValue.front.trim()} ${newValue.back.trim()}`;\n  }\n\n  return gridAutoFlow;\n};\n/**\n * @param {import('postcss-value-parser').ParsedValue} gridGap\n * @return {import('postcss-value-parser').ParsedValue | string}\n */\n\n\nconst normalizeGridColumnRowGap = gridGap => {\n  let newValue = {\n    front: '',\n    back: ''\n  };\n  let shouldNormalize = false;\n  gridGap.walk(node => {\n    // console.log(node);\n    if (node.value === 'normal') {\n      shouldNormalize = true;\n      newValue.front = node.value;\n    } else {\n      newValue.back = `${newValue.back} ${node.value}`;\n    }\n  });\n\n  if (shouldNormalize) {\n    return `${newValue.front.trim()} ${newValue.back.trim()}`;\n  }\n\n  return gridGap;\n};\n/**\n * @param {import('postcss-value-parser').ParsedValue} grid\n * @return {string | string[]}\n */\n\n\nconst normalizeGridColumnRow = grid => {\n  // cant do normalization here using node, so copy it as a string\n  let gridValue = grid.toString().split('/'); // node -> string value, split ->  \" 2 / 3 span \" ->  [' 2','3 span ']\n\n  if (gridValue.length > 1) {\n    return joinGridValue(gridValue.map(gridLine => {\n      let normalizeValue = {\n        front: '',\n        back: ''\n      };\n      gridLine = gridLine.trim(); // '3 span ' -> '3 span'\n\n      gridLine.split(' ').forEach(node => {\n        // ['3','span']\n        if (node === 'span') {\n          normalizeValue.front = node; // span _\n        } else {\n          normalizeValue.back = `${normalizeValue.back} ${node}`; // _ 3\n        }\n      });\n      return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`; // span 3\n    }) // returns \"2 / span 3\"\n    );\n  } // doing this separating if `/` is not present as while joining('/') , it will add `/` at the end\n\n\n  return gridValue.map(gridLine => {\n    let normalizeValue = {\n      front: '',\n      back: ''\n    };\n    gridLine = gridLine.trim();\n    gridLine.split(' ').forEach(node => {\n      if (node === 'span') {\n        normalizeValue.front = node;\n      } else {\n        normalizeValue.back = `${normalizeValue.back} ${node}`;\n      }\n    });\n    return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`;\n  });\n};\n\nmodule.exports = {\n  normalizeGridAutoFlow,\n  normalizeGridColumnRowGap,\n  normalizeGridColumnRow\n};","map":{"version":3,"names":["joinGridValue","require","normalizeGridAutoFlow","gridAutoFlow","newValue","front","back","shouldNormalize","walk","node","value","includes","trim","toLowerCase","normalizeGridColumnRowGap","gridGap","normalizeGridColumnRow","grid","gridValue","toString","split","length","map","gridLine","normalizeValue","forEach","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-ordered-values/src/rules/grid.js"],"sourcesContent":["'use strict';\nconst joinGridValue = require('../lib/joinGridValue');\n\n/**\n * @param {import('postcss-value-parser').ParsedValue} gridAutoFlow\n * @return {import('postcss-value-parser').ParsedValue | string}\n */\nconst normalizeGridAutoFlow = (gridAutoFlow) => {\n  let newValue = { front: '', back: '' };\n  let shouldNormalize = false;\n  gridAutoFlow.walk((node) => {\n    if (node.value === 'dense') {\n      shouldNormalize = true;\n      newValue.back = node.value;\n    } else if (['row', 'column'].includes(node.value.trim().toLowerCase())) {\n      shouldNormalize = true;\n      newValue.front = node.value;\n    } else {\n      shouldNormalize = false;\n    }\n  });\n  if (shouldNormalize) {\n    return `${newValue.front.trim()} ${newValue.back.trim()}`;\n  }\n  return gridAutoFlow;\n};\n\n/**\n * @param {import('postcss-value-parser').ParsedValue} gridGap\n * @return {import('postcss-value-parser').ParsedValue | string}\n */\nconst normalizeGridColumnRowGap = (gridGap) => {\n  let newValue = { front: '', back: '' };\n  let shouldNormalize = false;\n  gridGap.walk((node) => {\n    // console.log(node);\n    if (node.value === 'normal') {\n      shouldNormalize = true;\n      newValue.front = node.value;\n    } else {\n      newValue.back = `${newValue.back} ${node.value}`;\n    }\n  });\n  if (shouldNormalize) {\n    return `${newValue.front.trim()} ${newValue.back.trim()}`;\n  }\n  return gridGap;\n};\n\n/**\n * @param {import('postcss-value-parser').ParsedValue} grid\n * @return {string | string[]}\n */\nconst normalizeGridColumnRow = (grid) => {\n  // cant do normalization here using node, so copy it as a string\n  let gridValue = grid.toString().split('/'); // node -> string value, split ->  \" 2 / 3 span \" ->  [' 2','3 span ']\n  if (gridValue.length > 1) {\n    return joinGridValue(\n      gridValue.map((gridLine) => {\n        let normalizeValue = {\n          front: '',\n          back: '',\n        };\n        gridLine = gridLine.trim(); // '3 span ' -> '3 span'\n        gridLine.split(' ').forEach((node) => {\n          // ['3','span']\n          if (node === 'span') {\n            normalizeValue.front = node; // span _\n          } else {\n            normalizeValue.back = `${normalizeValue.back} ${node}`; // _ 3\n          }\n        });\n        return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`; // span 3\n      })\n      // returns \"2 / span 3\"\n    );\n  }\n  // doing this separating if `/` is not present as while joining('/') , it will add `/` at the end\n  return gridValue.map((gridLine) => {\n    let normalizeValue = {\n      front: '',\n      back: '',\n    };\n    gridLine = gridLine.trim();\n    gridLine.split(' ').forEach((node) => {\n      if (node === 'span') {\n        normalizeValue.front = node;\n      } else {\n        normalizeValue.back = `${normalizeValue.back} ${node}`;\n      }\n    });\n    return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`;\n  });\n};\n\nmodule.exports = {\n  normalizeGridAutoFlow,\n  normalizeGridColumnRowGap,\n  normalizeGridColumnRow,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}