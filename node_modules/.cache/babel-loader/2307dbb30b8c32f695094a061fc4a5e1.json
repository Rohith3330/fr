{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertComments = void 0;\n\nconst util_1 = require(\"tsutils/util/util\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst node_utils_1 = require(\"./node-utils\");\n\nconst ts_estree_1 = require(\"./ts-estree\");\n/**\n * Convert all comments for the given AST.\n * @param ast the AST object\n * @param code the TypeScript code\n * @returns the converted ESTreeComment\n * @private\n */\n\n\nfunction convertComments(ast, code) {\n  const comments = [];\n  (0, util_1.forEachComment)(ast, (_, comment) => {\n    const type = comment.kind == ts.SyntaxKind.SingleLineCommentTrivia ? ts_estree_1.AST_TOKEN_TYPES.Line : ts_estree_1.AST_TOKEN_TYPES.Block;\n    const range = [comment.pos, comment.end];\n    const loc = (0, node_utils_1.getLocFor)(range[0], range[1], ast); // both comments start with 2 characters - /* or //\n\n    const textStart = range[0] + 2;\n    const textEnd = comment.kind === ts.SyntaxKind.SingleLineCommentTrivia ? // single line comments end at the end\n    range[1] - textStart : // multiline comments end 2 characters early\n    range[1] - textStart - 2;\n    comments.push({\n      type,\n      value: code.slice(textStart, textStart + textEnd),\n      range,\n      loc\n    });\n  }, ast);\n  return comments;\n}\n\nexports.convertComments = convertComments;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAEA;;AAEA;AAEA;;;;;;;;;AAOA,SAAgBA,eAAhB,CACEC,GADF,EAEEC,IAFF,EAEc;EAEZ,MAAMC,QAAQ,GAAuB,EAArC;EAEA,2BACEF,GADF,EAEE,CAACG,CAAD,EAAIC,OAAJ,KAAe;IACb,MAAMC,IAAI,GACRD,OAAO,CAACE,IAAR,IAAgBC,EAAE,CAACC,UAAH,CAAcC,uBAA9B,GACIC,4BAAgBC,IADpB,GAEID,4BAAgBE,KAHtB;IAIA,MAAMC,KAAK,GAAmB,CAACT,OAAO,CAACU,GAAT,EAAcV,OAAO,CAACW,GAAtB,CAA9B;IACA,MAAMC,GAAG,GAAG,4BAAUH,KAAK,CAAC,CAAD,CAAf,EAAoBA,KAAK,CAAC,CAAD,CAAzB,EAA8Bb,GAA9B,CAAZ,CANa,CAQb;;IACA,MAAMiB,SAAS,GAAGJ,KAAK,CAAC,CAAD,CAAL,GAAW,CAA7B;IACA,MAAMK,OAAO,GACXd,OAAO,CAACE,IAAR,KAAiBC,EAAE,CAACC,UAAH,CAAcC,uBAA/B,GACI;IACAI,KAAK,CAAC,CAAD,CAAL,GAAWI,SAFf,GAGI;IACAJ,KAAK,CAAC,CAAD,CAAL,GAAWI,SAAX,GAAuB,CAL7B;IAMAf,QAAQ,CAACiB,IAAT,CAAc;MACZd,IADY;MAEZe,KAAK,EAAEnB,IAAI,CAACoB,KAAL,CAAWJ,SAAX,EAAsBA,SAAS,GAAGC,OAAlC,CAFK;MAGZL,KAHY;MAIZG;IAJY,CAAd;EAMD,CAxBH,EAyBEhB,GAzBF;EA4BA,OAAOE,QAAP;AACD;;AAnCDoB","names":["convertComments","ast","code","comments","_","comment","type","kind","ts","SyntaxKind","SingleLineCommentTrivia","ts_estree_1","Line","Block","range","pos","end","loc","textStart","textEnd","push","value","slice","exports"],"sources":["../src/convert-comments.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}