{"ast":null,"code":"/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Enforce comparing `typeof` expressions against valid strings\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/valid-typeof\"\n    },\n    hasSuggestions: true,\n    schema: [{\n      type: \"object\",\n      properties: {\n        requireStringLiterals: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      invalidValue: \"Invalid typeof comparison value.\",\n      notString: \"Typeof comparisons should be to string literals.\",\n      suggestString: 'Use `\"{{type}}\"` instead of `{{type}}`.'\n    }\n  },\n\n  create(context) {\n    const VALID_TYPES = new Set([\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"bigint\"]),\n          OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\"]);\n    const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n    let globalScope;\n    /**\n     * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n     * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n     * @param {ASTNode} node `Identifier` node to check.\n     * @returns {boolean} `true` if the node is a reference to a global variable.\n     */\n\n    function isReferenceToGlobalVariable(node) {\n      const variable = globalScope.set.get(node.name);\n      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);\n    }\n    /**\n     * Determines whether a node is a typeof expression.\n     * @param {ASTNode} node The node\n     * @returns {boolean} `true` if the node is a typeof expression\n     */\n\n\n    function isTypeofExpression(node) {\n      return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program() {\n        globalScope = context.getScope();\n      },\n\n      UnaryExpression(node) {\n        if (isTypeofExpression(node)) {\n          const parent = context.getAncestors().pop();\n\n          if (parent.type === \"BinaryExpression\" && OPERATORS.has(parent.operator)) {\n            const sibling = parent.left === node ? parent.right : parent.left;\n\n            if (sibling.type === \"Literal\" || sibling.type === \"TemplateLiteral\" && !sibling.expressions.length) {\n              const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n\n              if (!VALID_TYPES.has(value)) {\n                context.report({\n                  node: sibling,\n                  messageId: \"invalidValue\"\n                });\n              }\n            } else if (sibling.type === \"Identifier\" && sibling.name === \"undefined\" && isReferenceToGlobalVariable(sibling)) {\n              context.report({\n                node: sibling,\n                messageId: requireStringLiterals ? \"notString\" : \"invalidValue\",\n                suggest: [{\n                  messageId: \"suggestString\",\n                  data: {\n                    type: \"undefined\"\n                  },\n\n                  fix(fixer) {\n                    return fixer.replaceText(sibling, '\"undefined\"');\n                  }\n\n                }]\n              });\n            } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n              context.report({\n                node: sibling,\n                messageId: \"notString\"\n              });\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","recommended","url","hasSuggestions","schema","properties","requireStringLiterals","default","additionalProperties","messages","invalidValue","notString","suggestString","create","context","VALID_TYPES","Set","OPERATORS","options","globalScope","isReferenceToGlobalVariable","node","variable","set","get","name","defs","length","references","some","ref","identifier","isTypeofExpression","operator","Program","getScope","UnaryExpression","parent","getAncestors","pop","has","sibling","left","right","expressions","value","quasis","cooked","report","messageId","suggest","data","fix","fixer","replaceText"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/valid-typeof.js"],"sourcesContent":["/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Enforce comparing `typeof` expressions against valid strings\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/valid-typeof\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    requireStringLiterals: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            invalidValue: \"Invalid typeof comparison value.\",\n            notString: \"Typeof comparisons should be to string literals.\",\n            suggestString: 'Use `\"{{type}}\"` instead of `{{type}}`.'\n        }\n    },\n\n    create(context) {\n\n        const VALID_TYPES = new Set([\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"bigint\"]),\n            OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\"]);\n\n        const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n\n        let globalScope;\n\n        /**\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a reference to a global variable.\n         */\n        function isReferenceToGlobalVariable(node) {\n            const variable = globalScope.set.get(node.name);\n\n            return variable && variable.defs.length === 0 &&\n                variable.references.some(ref => ref.identifier === node);\n        }\n\n        /**\n         * Determines whether a node is a typeof expression.\n         * @param {ASTNode} node The node\n         * @returns {boolean} `true` if the node is a typeof expression\n         */\n        function isTypeofExpression(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program() {\n                globalScope = context.getScope();\n            },\n\n            UnaryExpression(node) {\n                if (isTypeofExpression(node)) {\n                    const parent = context.getAncestors().pop();\n\n                    if (parent.type === \"BinaryExpression\" && OPERATORS.has(parent.operator)) {\n                        const sibling = parent.left === node ? parent.right : parent.left;\n\n                        if (sibling.type === \"Literal\" || sibling.type === \"TemplateLiteral\" && !sibling.expressions.length) {\n                            const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n\n                            if (!VALID_TYPES.has(value)) {\n                                context.report({ node: sibling, messageId: \"invalidValue\" });\n                            }\n                        } else if (sibling.type === \"Identifier\" && sibling.name === \"undefined\" && isReferenceToGlobalVariable(sibling)) {\n                            context.report({\n                                node: sibling,\n                                messageId: requireStringLiterals ? \"notString\" : \"invalidValue\",\n                                suggest: [\n                                    {\n                                        messageId: \"suggestString\",\n                                        data: { type: \"undefined\" },\n                                        fix(fixer) {\n                                            return fixer.replaceText(sibling, '\"undefined\"');\n                                        }\n                                    }\n                                ]\n                            });\n                        } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n                            context.report({ node: sibling, messageId: \"notString\" });\n                        }\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}