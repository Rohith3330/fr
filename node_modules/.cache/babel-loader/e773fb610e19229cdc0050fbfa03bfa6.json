{"ast":null,"code":"function getLocator(source, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var offsetLine = options.offsetLine || 0;\n  var offsetColumn = options.offsetColumn || 0;\n  var originalLines = source.split('\\n');\n  var start = 0;\n  var lineRanges = originalLines.map(function (line, i) {\n    var end = start + line.length + 1;\n    var range = {\n      start: start,\n      end: end,\n      line: i\n    };\n    start = end;\n    return range;\n  });\n  var i = 0;\n\n  function rangeContains(range, index) {\n    return range.start <= index && index < range.end;\n  }\n\n  function getLocation(range, index) {\n    return {\n      line: offsetLine + range.line,\n      column: offsetColumn + index - range.start,\n      character: index\n    };\n  }\n\n  function locate(search, startIndex) {\n    if (typeof search === 'string') {\n      search = source.indexOf(search, startIndex || 0);\n    }\n\n    var range = lineRanges[i];\n    var d = search >= range.end ? 1 : -1;\n\n    while (range) {\n      if (rangeContains(range, search)) return getLocation(range, search);\n      i += d;\n      range = lineRanges[i];\n    }\n  }\n\n  return locate;\n}\n\nfunction locate(source, search, options) {\n  if (typeof options === 'number') {\n    throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n  }\n\n  return getLocator(source, options)(search, options && options.startIndex);\n}\n\nvar validNameCharacters = /[a-zA-Z0-9:_-]/;\nvar whitespace = /[\\s\\t\\r\\n]/;\nvar quotemark = /['\"]/;\n\nfunction repeat(str, i) {\n  var result = '';\n\n  while (i--) {\n    result += str;\n  }\n\n  return result;\n}\n\nfunction parse(source) {\n  var header = '';\n  var stack = [];\n  var state = metadata;\n  var currentElement = null;\n  var root = null;\n\n  function error(message) {\n    var ref = locate(source, i);\n    var line = ref.line;\n    var column = ref.column;\n    var before = source.slice(0, i);\n    var beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n    var after = source.slice(i);\n    var afterLine = /.*(\\n|$)/.exec(after)[0];\n    var snippet = \"\" + beforeLine + afterLine + \"\\n\" + repeat(' ', beforeLine.length) + \"^\";\n    throw new Error(message + \" (\" + line + \":\" + column + \"). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues – thanks!\\n\\n\" + snippet);\n  }\n\n  function metadata() {\n    while (i < source.length && source[i] !== '<' || !validNameCharacters.test(source[i + 1])) {\n      header += source[i++];\n    }\n\n    return neutral();\n  }\n\n  function neutral() {\n    var text = '';\n\n    while (i < source.length && source[i] !== '<') {\n      text += source[i++];\n    }\n\n    if (/\\S/.test(text)) {\n      currentElement.children.push({\n        type: 'text',\n        value: text\n      });\n    }\n\n    if (source[i] === '<') {\n      return tag;\n    }\n\n    return neutral;\n  }\n\n  function tag() {\n    var char = source[i];\n\n    if (char === '?') {\n      return neutral;\n    } // <?xml...\n\n\n    if (char === '!') {\n      if (source.slice(i + 1, i + 3) === '--') {\n        return comment;\n      }\n\n      if (source.slice(i + 1, i + 8) === '[CDATA[') {\n        return cdata;\n      }\n\n      if (/doctype/i.test(source.slice(i + 1, i + 8))) {\n        return neutral;\n      }\n    }\n\n    if (char === '/') {\n      return closingTag;\n    }\n\n    var tagName = getName();\n    var element = {\n      type: 'element',\n      tagName: tagName,\n      properties: {},\n      children: []\n    };\n\n    if (currentElement) {\n      currentElement.children.push(element);\n    } else {\n      root = element;\n    }\n\n    var attribute;\n\n    while (i < source.length && (attribute = getAttribute())) {\n      element.properties[attribute.name] = attribute.value;\n    }\n\n    var selfClosing = false;\n\n    if (source[i] === '/') {\n      i += 1;\n      selfClosing = true;\n    }\n\n    if (source[i] !== '>') {\n      error('Expected >');\n    }\n\n    if (!selfClosing) {\n      currentElement = element;\n      stack.push(element);\n    }\n\n    return neutral;\n  }\n\n  function comment() {\n    var index = source.indexOf('-->', i);\n\n    if (!~index) {\n      error('expected -->');\n    }\n\n    i = index + 2;\n    return neutral;\n  }\n\n  function cdata() {\n    var index = source.indexOf(']]>', i);\n\n    if (!~index) {\n      error('expected ]]>');\n    }\n\n    currentElement.children.push(source.slice(i + 7, index));\n    i = index + 2;\n    return neutral;\n  }\n\n  function closingTag() {\n    var tagName = getName();\n\n    if (!tagName) {\n      error('Expected tag name');\n    }\n\n    if (tagName !== currentElement.tagName) {\n      error(\"Expected closing tag </\" + tagName + \"> to match opening tag <\" + currentElement.tagName + \">\");\n    }\n\n    allowSpaces();\n\n    if (source[i] !== '>') {\n      error('Expected >');\n    }\n\n    stack.pop();\n    currentElement = stack[stack.length - 1];\n    return neutral;\n  }\n\n  function getName() {\n    var name = '';\n\n    while (i < source.length && validNameCharacters.test(source[i])) {\n      name += source[i++];\n    }\n\n    return name;\n  }\n\n  function getAttribute() {\n    if (!whitespace.test(source[i])) {\n      return null;\n    }\n\n    allowSpaces();\n    var name = getName();\n\n    if (!name) {\n      return null;\n    }\n\n    var value = true;\n    allowSpaces();\n\n    if (source[i] === '=') {\n      i += 1;\n      allowSpaces();\n      value = getAttributeValue();\n\n      if (!isNaN(value) && value.trim() !== '') {\n        value = +value;\n      } // TODO whitelist numeric attributes?\n\n    }\n\n    return {\n      name: name,\n      value: value\n    };\n  }\n\n  function getAttributeValue() {\n    return quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n  }\n\n  function getUnquotedAttributeValue() {\n    var value = '';\n\n    do {\n      var char = source[i];\n\n      if (char === ' ' || char === '>' || char === '/') {\n        return value;\n      }\n\n      value += char;\n      i += 1;\n    } while (i < source.length);\n\n    return value;\n  }\n\n  function getQuotedAttributeValue() {\n    var quotemark = source[i++];\n    var value = '';\n    var escaped = false;\n\n    while (i < source.length) {\n      var char = source[i++];\n\n      if (char === quotemark && !escaped) {\n        return value;\n      }\n\n      if (char === '\\\\' && !escaped) {\n        escaped = true;\n      }\n\n      value += escaped ? \"\\\\\" + char : char;\n      escaped = false;\n    }\n  }\n\n  function allowSpaces() {\n    while (i < source.length && whitespace.test(source[i])) {\n      i += 1;\n    }\n  }\n\n  var i = metadata.length;\n\n  while (i < source.length) {\n    if (!state) {\n      error('Unexpected character');\n    }\n\n    state = state();\n    i += 1;\n  }\n\n  if (state !== neutral) {\n    error('Unexpected end of input');\n  }\n\n  if (root.tagName === 'svg') {\n    root.metadata = header;\n  }\n\n  return {\n    type: 'root',\n    children: [root]\n  };\n}\n\nexport { parse };","map":{"version":3,"mappings":"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","names":["getLocator","source","options","offsetLine","offsetColumn","originalLines","split","start","lineRanges","map","line","i","end","length","range","rangeContains","index","getLocation","column","character","locate","search","startIndex","indexOf","d","Error","const","validNameCharacters","whitespace","quotemark","repeat","str","let","result","parse","header","stack","state","metadata","currentElement","root","error","message","before","slice","beforeLine","exec","replace","after","afterLine","snippet","test","neutral","text","children","push","type","value","tag","char","comment","cdata","closingTag","tagName","getName","element","properties","attribute","getAttribute","name","selfClosing","allowSpaces","pop","getAttributeValue","isNaN","trim","getQuotedAttributeValue","getUnquotedAttributeValue","escaped"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\svg-parser\\node_modules\\locate-character\\dist\\locate-character.es.js","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\svg-parser\\src\\index.js"],"sourcesContent":["function getLocator(source, options) {\n    if (options === void 0) { options = {}; }\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n        var end = start + line.length + 1;\n        var range = { start: start, end: end, line: i };\n        start = end;\n        return range;\n    });\n    var i = 0;\n    function rangeContains(range, index) {\n        return range.start <= index && index < range.end;\n    }\n    function getLocation(range, index) {\n        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n    }\n    function locate(search, startIndex) {\n        if (typeof search === 'string') {\n            search = source.indexOf(search, startIndex || 0);\n        }\n        var range = lineRanges[i];\n        var d = search >= range.end ? 1 : -1;\n        while (range) {\n            if (rangeContains(range, search))\n                return getLocation(range, search);\n            i += d;\n            range = lineRanges[i];\n        }\n    }\n    ;\n    return locate;\n}\nfunction locate(source, search, options) {\n    if (typeof options === 'number') {\n        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n    return getLocator(source, options)(search, options && options.startIndex);\n}\n\nexport { getLocator, locate };","import { locate } from 'locate-character';\n\nconst validNameCharacters = /[a-zA-Z0-9:_-]/;\nconst whitespace = /[\\s\\t\\r\\n]/;\nconst quotemark = /['\"]/;\n\nfunction repeat(str, i) {\n\tlet result = '';\n\twhile (i--) result += str;\n\treturn result;\n}\n\nexport function parse(source) {\n\tlet header = '';\n\tlet stack = [];\n\n\tlet state = metadata;\n\tlet currentElement = null;\n\tlet root = null;\n\n\tfunction error(message) {\n\t\tconst { line, column } = locate(source, i);\n\t\tconst before = source.slice(0, i);\n\t\tconst beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n\t\tconst after = source.slice(i);\n\t\tconst afterLine = /.*(\\n|$)/.exec(after)[0];\n\n\t\tconst snippet = `${beforeLine}${afterLine}\\n${repeat(' ', beforeLine.length)}^`;\n\n\t\tthrow new Error(\n\t\t\t`${message} (${line}:${column}). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues – thanks!\\n\\n${snippet}`\n\t\t);\n\t}\n\n\tfunction metadata() {\n\t\twhile ((i < source.length && source[i] !== '<') || !validNameCharacters.test(source[i + 1])) {\n\t\t\theader += source[i++];\n\t\t}\n\n\t\treturn neutral();\n\t}\n\n\tfunction neutral() {\n\t\tlet text = '';\n\t\twhile (i < source.length && source[i] !== '<') text += source[i++];\n\n\t\tif (/\\S/.test(text)) {\n\t\t\tcurrentElement.children.push({ type: 'text', value: text });\n\t\t}\n\n\t\tif (source[i] === '<') {\n\t\t\treturn tag;\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction tag() {\n\t\tconst char = source[i];\n\n\t\tif (char === '?') return neutral; // <?xml...\n\n\t\tif (char === '!') {\n\t\t\tif (source.slice(i + 1, i + 3) === '--') return comment;\n\t\t\tif (source.slice(i + 1, i + 8) === '[CDATA[') return cdata;\n\t\t\tif (/doctype/i.test(source.slice(i + 1, i + 8))) return neutral;\n\t\t}\n\n\t\tif (char === '/') return closingTag;\n\n\t\tconst tagName = getName();\n\n\t\tconst element = {\n\t\t\ttype: 'element',\n\t\t\ttagName,\n\t\t\tproperties: {},\n\t\t\tchildren: []\n\t\t};\n\n\t\tif (currentElement) {\n\t\t\tcurrentElement.children.push(element);\n\t\t} else {\n\t\t\troot = element;\n\t\t}\n\n\t\tlet attribute;\n\t\twhile (i < source.length && (attribute = getAttribute())) {\n\t\t\telement.properties[attribute.name] = attribute.value;\n\t\t}\n\n\t\tlet selfClosing = false;\n\n\t\tif (source[i] === '/') {\n\t\t\ti += 1;\n\t\t\tselfClosing = true;\n\t\t}\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tif (!selfClosing) {\n\t\t\tcurrentElement = element;\n\t\t\tstack.push(element);\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction comment() {\n\t\tconst index = source.indexOf('-->', i);\n\t\tif (!~index) error('expected -->');\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction cdata() {\n\t\tconst index = source.indexOf(']]>', i);\n\t\tif (!~index) error('expected ]]>');\n\n\t\tcurrentElement.children.push(source.slice(i + 7, index));\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction closingTag() {\n\t\tconst tagName = getName();\n\n\t\tif (!tagName) error('Expected tag name');\n\n\t\tif (tagName !== currentElement.tagName) {\n\t\t\terror(`Expected closing tag </${tagName}> to match opening tag <${currentElement.tagName}>`);\n\t\t}\n\n\t\tallowSpaces();\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tstack.pop();\n\t\tcurrentElement = stack[stack.length - 1];\n\n\t\treturn neutral;\n\t}\n\n\tfunction getName() {\n\t\tlet name = '';\n\t\twhile (i < source.length && validNameCharacters.test(source[i])) name += source[i++];\n\n\t\treturn name;\n\t}\n\n\tfunction getAttribute() {\n\t\tif (!whitespace.test(source[i])) return null;\n\t\tallowSpaces();\n\n\t\tconst name = getName();\n\t\tif (!name) return null;\n\n\t\tlet value = true;\n\n\t\tallowSpaces();\n\t\tif (source[i] === '=') {\n\t\t\ti += 1;\n\t\t\tallowSpaces();\n\n\t\t\tvalue = getAttributeValue();\n\t\t\tif (!isNaN(value) && value.trim() !== '') value = +value; // TODO whitelist numeric attributes?\n\t\t}\n\n\t\treturn { name, value };\n\t}\n\n\tfunction getAttributeValue() {\n\t\treturn quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n\t}\n\n\tfunction getUnquotedAttributeValue() {\n\t\tlet value = '';\n\t\tdo {\n\t\t\tconst char = source[i];\n\t\t\tif (char === ' ' || char === '>' || char === '/') {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvalue += char;\n\t\t\ti += 1;\n\t\t} while (i < source.length);\n\n\t\treturn value;\n\t}\n\n\tfunction getQuotedAttributeValue() {\n\t\tconst quotemark = source[i++];\n\n\t\tlet value = '';\n\t\tlet escaped = false;\n\n\t\twhile (i < source.length) {\n\t\t\tconst char = source[i++];\n\t\t\tif (char === quotemark && !escaped) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (char === '\\\\' && !escaped) {\n\t\t\t\tescaped = true;\n\t\t\t}\n\n\t\t\tvalue += escaped ? `\\\\${char}` : char;\n\t\t\tescaped = false;\n\t\t}\n\t}\n\n\tfunction allowSpaces() {\n\t\twhile (i < source.length && whitespace.test(source[i])) i += 1;\n\t}\n\n\tlet i = metadata.length;\n\twhile (i < source.length) {\n\t\tif (!state) error('Unexpected character');\n\t\tstate = state();\n\t\ti += 1;\n\t}\n\n\tif (state !== neutral) {\n\t\terror('Unexpected end of input');\n\t}\n\n\tif (root.tagName === 'svg') root.metadata = header;\n\treturn {\n\t\ttype: 'root',\n\t\tchildren: [root]\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}