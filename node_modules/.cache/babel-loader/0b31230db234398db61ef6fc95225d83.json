{"ast":null,"code":"/**\n * @license React\n * eslint-plugin-react-hooks.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    function _unsupportedIterableToArray(o, minLen) {\n      if (!o) return;\n      if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n      var n = Object.prototype.toString.call(o).slice(8, -1);\n      if (n === \"Object\" && o.constructor) n = o.constructor.name;\n      if (n === \"Map\" || n === \"Set\") return Array.from(o);\n      if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n    }\n\n    function _arrayLikeToArray(arr, len) {\n      if (len == null || len > arr.length) len = arr.length;\n\n      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n\n    function _createForOfIteratorHelper(o, allowArrayLike) {\n      var it;\n\n      if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n          if (it) o = it;\n          var i = 0;\n\n          var F = function () {};\n\n          return {\n            s: F,\n            n: function () {\n              if (i >= o.length) return {\n                done: true\n              };\n              return {\n                done: false,\n                value: o[i++]\n              };\n            },\n            e: function (e) {\n              throw e;\n            },\n            f: F\n          };\n        }\n\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }\n\n      var normalCompletion = true,\n          didErr = false,\n          err;\n      return {\n        s: function () {\n          it = o[Symbol.iterator]();\n        },\n        n: function () {\n          var step = it.next();\n          normalCompletion = step.done;\n          return step;\n        },\n        e: function (e) {\n          didErr = true;\n          err = e;\n        },\n        f: function () {\n          try {\n            if (!normalCompletion && it.return != null) it.return();\n          } finally {\n            if (didErr) throw err;\n          }\n        }\n      };\n    }\n    /* global BigInt */\n\n\n    function isHookName(s) {\n      return /^use[A-Z0-9].*$/.test(s);\n    }\n    /**\n     * We consider hooks to be a hook name identifier or a member expression\n     * containing a hook name.\n     */\n\n\n    function isHook(node) {\n      if (node.type === 'Identifier') {\n        return isHookName(node.name);\n      } else if (node.type === 'MemberExpression' && !node.computed && isHook(node.property)) {\n        var obj = node.object;\n        var isPascalCaseNameSpace = /^[A-Z].*/;\n        return obj.type === 'Identifier' && isPascalCaseNameSpace.test(obj.name);\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Checks if the node is a React component name. React component names must\n     * always start with a non-lowercase letter. So `MyComponent` or `_MyComponent`\n     * are valid component names for instance.\n     */\n\n\n    function isComponentName(node) {\n      if (node.type === 'Identifier') {\n        return !/^[a-z]/.test(node.name);\n      } else {\n        return false;\n      }\n    }\n\n    function isReactFunction(node, functionName) {\n      return node.name === functionName || node.type === 'MemberExpression' && node.object.name === 'React' && node.property.name === functionName;\n    }\n    /**\n     * Checks if the node is a callback argument of forwardRef. This render function\n     * should follow the rules of hooks.\n     */\n\n\n    function isForwardRefCallback(node) {\n      return !!(node.parent && node.parent.callee && isReactFunction(node.parent.callee, 'forwardRef'));\n    }\n    /**\n     * Checks if the node is a callback argument of React.memo. This anonymous\n     * functional component should follow the rules of hooks.\n     */\n\n\n    function isMemoCallback(node) {\n      return !!(node.parent && node.parent.callee && isReactFunction(node.parent.callee, 'memo'));\n    }\n\n    function isInsideComponentOrHook(node) {\n      while (node) {\n        var functionName = getFunctionName(node);\n\n        if (functionName) {\n          if (isComponentName(functionName) || isHook(functionName)) {\n            return true;\n          }\n        }\n\n        if (isForwardRefCallback(node) || isMemoCallback(node)) {\n          return true;\n        }\n\n        node = node.parent;\n      }\n\n      return false;\n    }\n\n    var RulesOfHooks = {\n      meta: {\n        type: 'problem',\n        docs: {\n          description: 'enforces the Rules of Hooks',\n          recommended: true,\n          url: 'https://reactjs.org/docs/hooks-rules.html'\n        }\n      },\n      create: function (context) {\n        var codePathReactHooksMapStack = [];\n        var codePathSegmentStack = [];\n        return {\n          // Maintain code segment path stack as we traverse.\n          onCodePathSegmentStart: function (segment) {\n            return codePathSegmentStack.push(segment);\n          },\n          onCodePathSegmentEnd: function () {\n            return codePathSegmentStack.pop();\n          },\n          // Maintain code path stack as we traverse.\n          onCodePathStart: function () {\n            return codePathReactHooksMapStack.push(new Map());\n          },\n          // Process our code path.\n          //\n          // Everything is ok if all React Hooks are both reachable from the initial\n          // segment and reachable from every final segment.\n          onCodePathEnd: function (codePath, codePathNode) {\n            var reactHooksMap = codePathReactHooksMapStack.pop();\n\n            if (reactHooksMap.size === 0) {\n              return;\n            } // All of the segments which are cyclic are recorded in this set.\n\n\n            var cyclic = new Set();\n            /**\n             * Count the number of code paths from the start of the function to this\n             * segment. For example:\n             *\n             * ```js\n             * function MyComponent() {\n             *   if (condition) {\n             *     // Segment 1\n             *   } else {\n             *     // Segment 2\n             *   }\n             *   // Segment 3\n             * }\n             * ```\n             *\n             * Segments 1 and 2 have one path to the beginning of `MyComponent` and\n             * segment 3 has two paths to the beginning of `MyComponent` since we\n             * could have either taken the path of segment 1 or segment 2.\n             *\n             * Populates `cyclic` with cyclic segments.\n             */\n\n            function countPathsFromStart(segment, pathHistory) {\n              var cache = countPathsFromStart.cache;\n              var paths = cache.get(segment.id);\n              var pathList = new Set(pathHistory); // If `pathList` includes the current segment then we've found a cycle!\n              // We need to fill `cyclic` with all segments inside cycle\n\n              if (pathList.has(segment.id)) {\n                var pathArray = [].concat(pathList);\n                var cyclicSegments = pathArray.slice(pathArray.indexOf(segment.id) + 1);\n\n                var _iterator = _createForOfIteratorHelper(cyclicSegments),\n                    _step;\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    var cyclicSegment = _step.value;\n                    cyclic.add(cyclicSegment);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                return BigInt('0');\n              } // add the current segment to pathList\n\n\n              pathList.add(segment.id); // We have a cached `paths`. Return it.\n\n              if (paths !== undefined) {\n                return paths;\n              }\n\n              if (codePath.thrownSegments.includes(segment)) {\n                paths = BigInt('0');\n              } else if (segment.prevSegments.length === 0) {\n                paths = BigInt('1');\n              } else {\n                paths = BigInt('0');\n\n                var _iterator2 = _createForOfIteratorHelper(segment.prevSegments),\n                    _step2;\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    var prevSegment = _step2.value;\n                    paths += countPathsFromStart(prevSegment, pathList);\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n              } // If our segment is reachable then there should be at least one path\n              // to it from the start of our code path.\n\n\n              if (segment.reachable && paths === BigInt('0')) {\n                cache.delete(segment.id);\n              } else {\n                cache.set(segment.id, paths);\n              }\n\n              return paths;\n            }\n            /**\n             * Count the number of code paths from this segment to the end of the\n             * function. For example:\n             *\n             * ```js\n             * function MyComponent() {\n             *   // Segment 1\n             *   if (condition) {\n             *     // Segment 2\n             *   } else {\n             *     // Segment 3\n             *   }\n             * }\n             * ```\n             *\n             * Segments 2 and 3 have one path to the end of `MyComponent` and\n             * segment 1 has two paths to the end of `MyComponent` since we could\n             * either take the path of segment 1 or segment 2.\n             *\n             * Populates `cyclic` with cyclic segments.\n             */\n\n\n            function countPathsToEnd(segment, pathHistory) {\n              var cache = countPathsToEnd.cache;\n              var paths = cache.get(segment.id);\n              var pathList = new Set(pathHistory); // If `pathList` includes the current segment then we've found a cycle!\n              // We need to fill `cyclic` with all segments inside cycle\n\n              if (pathList.has(segment.id)) {\n                var pathArray = Array.from(pathList);\n                var cyclicSegments = pathArray.slice(pathArray.indexOf(segment.id) + 1);\n\n                var _iterator3 = _createForOfIteratorHelper(cyclicSegments),\n                    _step3;\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    var cyclicSegment = _step3.value;\n                    cyclic.add(cyclicSegment);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                return BigInt('0');\n              } // add the current segment to pathList\n\n\n              pathList.add(segment.id); // We have a cached `paths`. Return it.\n\n              if (paths !== undefined) {\n                return paths;\n              }\n\n              if (codePath.thrownSegments.includes(segment)) {\n                paths = BigInt('0');\n              } else if (segment.nextSegments.length === 0) {\n                paths = BigInt('1');\n              } else {\n                paths = BigInt('0');\n\n                var _iterator4 = _createForOfIteratorHelper(segment.nextSegments),\n                    _step4;\n\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    var nextSegment = _step4.value;\n                    paths += countPathsToEnd(nextSegment, pathList);\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n              }\n\n              cache.set(segment.id, paths);\n              return paths;\n            }\n            /**\n             * Gets the shortest path length to the start of a code path.\n             * For example:\n             *\n             * ```js\n             * function MyComponent() {\n             *   if (condition) {\n             *     // Segment 1\n             *   }\n             *   // Segment 2\n             * }\n             * ```\n             *\n             * There is only one path from segment 1 to the code path start. Its\n             * length is one so that is the shortest path.\n             *\n             * There are two paths from segment 2 to the code path start. One\n             * through segment 1 with a length of two and another directly to the\n             * start with a length of one. The shortest path has a length of one\n             * so we would return that.\n             */\n\n\n            function shortestPathLengthToStart(segment) {\n              var cache = shortestPathLengthToStart.cache;\n              var length = cache.get(segment.id); // If `length` is null then we found a cycle! Return infinity since\n              // the shortest path is definitely not the one where we looped.\n\n              if (length === null) {\n                return Infinity;\n              } // We have a cached `length`. Return it.\n\n\n              if (length !== undefined) {\n                return length;\n              } // Compute `length` and cache it. Guarding against cycles.\n\n\n              cache.set(segment.id, null);\n\n              if (segment.prevSegments.length === 0) {\n                length = 1;\n              } else {\n                length = Infinity;\n\n                var _iterator5 = _createForOfIteratorHelper(segment.prevSegments),\n                    _step5;\n\n                try {\n                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                    var prevSegment = _step5.value;\n                    var prevLength = shortestPathLengthToStart(prevSegment);\n\n                    if (prevLength < length) {\n                      length = prevLength;\n                    }\n                  }\n                } catch (err) {\n                  _iterator5.e(err);\n                } finally {\n                  _iterator5.f();\n                }\n\n                length += 1;\n              }\n\n              cache.set(segment.id, length);\n              return length;\n            }\n\n            countPathsFromStart.cache = new Map();\n            countPathsToEnd.cache = new Map();\n            shortestPathLengthToStart.cache = new Map(); // Count all code paths to the end of our component/hook. Also primes\n            // the `countPathsToEnd` cache.\n\n            var allPathsFromStartToEnd = countPathsToEnd(codePath.initialSegment); // Gets the function name for our code path. If the function name is\n            // `undefined` then we know either that we have an anonymous function\n            // expression or our code path is not in a function. In both cases we\n            // will want to error since neither are React function components or\n            // hook functions - unless it is an anonymous function argument to\n            // forwardRef or memo.\n\n            var codePathFunctionName = getFunctionName(codePathNode); // This is a valid code path for React hooks if we are directly in a React\n            // function component or we are in a hook function.\n\n            var isSomewhereInsideComponentOrHook = isInsideComponentOrHook(codePathNode);\n            var isDirectlyInsideComponentOrHook = codePathFunctionName ? isComponentName(codePathFunctionName) || isHook(codePathFunctionName) : isForwardRefCallback(codePathNode) || isMemoCallback(codePathNode); // Compute the earliest finalizer level using information from the\n            // cache. We expect all reachable final segments to have a cache entry\n            // after calling `visitSegment()`.\n\n            var shortestFinalPathLength = Infinity;\n\n            var _iterator6 = _createForOfIteratorHelper(codePath.finalSegments),\n                _step6;\n\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var finalSegment = _step6.value;\n\n                if (!finalSegment.reachable) {\n                  continue;\n                }\n\n                var length = shortestPathLengthToStart(finalSegment);\n\n                if (length < shortestFinalPathLength) {\n                  shortestFinalPathLength = length;\n                }\n              } // Make sure all React Hooks pass our lint invariants. Log warnings\n              // if not.\n\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n\n            var _iterator7 = _createForOfIteratorHelper(reactHooksMap),\n                _step7;\n\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var _step7$value = _step7.value,\n                    segment = _step7$value[0],\n                    reactHooks = _step7$value[1]; // NOTE: We could report here that the hook is not reachable, but\n                // that would be redundant with more general \"no unreachable\"\n                // lint rules.\n\n                if (!segment.reachable) {\n                  continue;\n                } // If there are any final segments with a shorter path to start then\n                // we possibly have an early return.\n                //\n                // If our segment is a final segment itself then siblings could\n                // possibly be early returns.\n\n\n                var possiblyHasEarlyReturn = segment.nextSegments.length === 0 ? shortestFinalPathLength <= shortestPathLengthToStart(segment) : shortestFinalPathLength < shortestPathLengthToStart(segment); // Count all the paths from the start of our code path to the end of\n                // our code path that go _through_ this segment. The critical piece\n                // of this is _through_. If we just call `countPathsToEnd(segment)`\n                // then we neglect that we may have gone through multiple paths to get\n                // to this point! Consider:\n                //\n                // ```js\n                // function MyComponent() {\n                //   if (a) {\n                //     // Segment 1\n                //   } else {\n                //     // Segment 2\n                //   }\n                //   // Segment 3\n                //   if (b) {\n                //     // Segment 4\n                //   } else {\n                //     // Segment 5\n                //   }\n                // }\n                // ```\n                //\n                // In this component we have four code paths:\n                //\n                // 1. `a = true; b = true`\n                // 2. `a = true; b = false`\n                // 3. `a = false; b = true`\n                // 4. `a = false; b = false`\n                //\n                // From segment 3 there are two code paths to the end through segment\n                // 4 and segment 5. However, we took two paths to get here through\n                // segment 1 and segment 2.\n                //\n                // If we multiply the paths from start (two) by the paths to end (two)\n                // for segment 3 we get four. Which is our desired count.\n\n                var pathsFromStartToEnd = countPathsFromStart(segment) * countPathsToEnd(segment); // Is this hook a part of a cyclic segment?\n\n                var cycled = cyclic.has(segment.id);\n\n                var _iterator8 = _createForOfIteratorHelper(reactHooks),\n                    _step8;\n\n                try {\n                  for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                    var hook = _step8.value; // Report an error if a hook may be called more then once.\n\n                    if (cycled) {\n                      context.report({\n                        node: hook,\n                        message: \"React Hook \\\"\" + context.getSource(hook) + \"\\\" may be executed \" + 'more than once. Possibly because it is called in a loop. ' + 'React Hooks must be called in the exact same order in ' + 'every component render.'\n                      });\n                    } // If this is not a valid code path for React hooks then we need to\n                    // log a warning for every hook in this code path.\n                    //\n                    // Pick a special message depending on the scope this hook was\n                    // called in.\n\n\n                    if (isDirectlyInsideComponentOrHook) {\n                      // Report an error if a hook does not reach all finalizing code\n                      // path segments.\n                      //\n                      // Special case when we think there might be an early return.\n                      if (!cycled && pathsFromStartToEnd !== allPathsFromStartToEnd) {\n                        var message = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" is called \" + 'conditionally. React Hooks must be called in the exact ' + 'same order in every component render.' + (possiblyHasEarlyReturn ? ' Did you accidentally call a React Hook after an' + ' early return?' : '');\n                        context.report({\n                          node: hook,\n                          message: message\n                        });\n                      }\n                    } else if (codePathNode.parent && (codePathNode.parent.type === 'MethodDefinition' || codePathNode.parent.type === 'ClassProperty') && codePathNode.parent.value === codePathNode) {\n                      // Custom message for hooks inside a class\n                      var _message = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" cannot be called \" + 'in a class component. React Hooks must be called in a ' + 'React function component or a custom React Hook function.';\n\n                      context.report({\n                        node: hook,\n                        message: _message\n                      });\n                    } else if (codePathFunctionName) {\n                      // Custom message if we found an invalid function name.\n                      var _message2 = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" is called in \" + (\"function \\\"\" + context.getSource(codePathFunctionName) + \"\\\" \") + 'that is neither a React function component nor a custom ' + 'React Hook function.' + ' React component names must start with an uppercase letter.' + ' React Hook names must start with the word \"use\".';\n\n                      context.report({\n                        node: hook,\n                        message: _message2\n                      });\n                    } else if (codePathNode.type === 'Program') {\n                      // These are dangerous if you have inline requires enabled.\n                      var _message3 = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" cannot be called \" + 'at the top level. React Hooks must be called in a ' + 'React function component or a custom React Hook function.';\n\n                      context.report({\n                        node: hook,\n                        message: _message3\n                      });\n                    } else {\n                      // Assume in all other cases the user called a hook in some\n                      // random function callback. This should usually be true for\n                      // anonymous function expressions. Hopefully this is clarifying\n                      // enough in the common case that the incorrect message in\n                      // uncommon cases doesn't matter.\n                      if (isSomewhereInsideComponentOrHook) {\n                        var _message4 = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" cannot be called \" + 'inside a callback. React Hooks must be called in a ' + 'React function component or a custom React Hook function.';\n\n                        context.report({\n                          node: hook,\n                          message: _message4\n                        });\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _iterator8.e(err);\n                } finally {\n                  _iterator8.f();\n                }\n              }\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n          },\n          // Missed opportunity...We could visit all `Identifier`s instead of all\n          // `CallExpression`s and check that _every use_ of a hook name is valid.\n          // But that gets complicated and enters type-system territory, so we're\n          // only being strict about hook calls for now.\n          CallExpression: function (node) {\n            if (isHook(node.callee)) {\n              // Add the hook node to a map keyed by the code path segment. We will\n              // do full code path analysis at the end of our code path.\n              var reactHooksMap = last(codePathReactHooksMapStack);\n              var codePathSegment = last(codePathSegmentStack);\n              var reactHooks = reactHooksMap.get(codePathSegment);\n\n              if (!reactHooks) {\n                reactHooks = [];\n                reactHooksMap.set(codePathSegment, reactHooks);\n              }\n\n              reactHooks.push(node.callee);\n            }\n          }\n        };\n      }\n    };\n    /**\n     * Gets the static name of a function AST node. For function declarations it is\n     * easy. For anonymous function expressions it is much harder. If you search for\n     * `IsAnonymousFunctionDefinition()` in the ECMAScript spec you'll find places\n     * where JS gives anonymous function expressions names. We roughly detect the\n     * same AST nodes with some exceptions to better fit our use case.\n     */\n\n    function getFunctionName(node) {\n      if (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' && node.id) {\n        // function useHook() {}\n        // const whatever = function useHook() {};\n        //\n        // Function declaration or function expression names win over any\n        // assignment statements or other renames.\n        return node.id;\n      } else if (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') {\n        if (node.parent.type === 'VariableDeclarator' && node.parent.init === node) {\n          // const useHook = () => {};\n          return node.parent.id;\n        } else if (node.parent.type === 'AssignmentExpression' && node.parent.right === node && node.parent.operator === '=') {\n          // useHook = () => {};\n          return node.parent.left;\n        } else if (node.parent.type === 'Property' && node.parent.value === node && !node.parent.computed) {\n          // {useHook: () => {}}\n          // {useHook() {}}\n          return node.parent.key; // NOTE: We could also support `ClassProperty` and `MethodDefinition`\n          // here to be pedantic. However, hooks in a class are an anti-pattern. So\n          // we don't allow it to error early.\n          //\n          // class {useHook = () => {}}\n          // class {useHook() {}}\n        } else if (node.parent.type === 'AssignmentPattern' && node.parent.right === node && !node.parent.computed) {\n          // const {useHook = () => {}} = {};\n          // ({useHook = () => {}} = {});\n          //\n          // Kinda clowny, but we'd said we'd follow spec convention for\n          // `IsAnonymousFunctionDefinition()` usage.\n          return node.parent.left;\n        } else {\n          return undefined;\n        }\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Convenience function for peeking the last item in a stack.\n     */\n\n\n    function last(array) {\n      return array[array.length - 1];\n    }\n    /* eslint-disable no-for-of-loops/no-for-of-loops */\n\n\n    var ExhaustiveDeps = {\n      meta: {\n        type: 'suggestion',\n        docs: {\n          description: 'verifies the list of dependencies for Hooks like useEffect and similar',\n          recommended: true,\n          url: 'https://github.com/facebook/react/issues/14920'\n        },\n        fixable: 'code',\n        hasSuggestions: true,\n        schema: [{\n          type: 'object',\n          additionalProperties: false,\n          enableDangerousAutofixThisMayCauseInfiniteLoops: false,\n          properties: {\n            additionalHooks: {\n              type: 'string'\n            },\n            enableDangerousAutofixThisMayCauseInfiniteLoops: {\n              type: 'boolean'\n            }\n          }\n        }]\n      },\n      create: function (context) {\n        // Parse the `additionalHooks` regex.\n        var additionalHooks = context.options && context.options[0] && context.options[0].additionalHooks ? new RegExp(context.options[0].additionalHooks) : undefined;\n        var enableDangerousAutofixThisMayCauseInfiniteLoops = context.options && context.options[0] && context.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops || false;\n        var options = {\n          additionalHooks: additionalHooks,\n          enableDangerousAutofixThisMayCauseInfiniteLoops: enableDangerousAutofixThisMayCauseInfiniteLoops\n        };\n\n        function reportProblem(problem) {\n          if (enableDangerousAutofixThisMayCauseInfiniteLoops) {\n            // Used to enable legacy behavior. Dangerous.\n            // Keep this as an option until major IDEs upgrade (including VSCode FB ESLint extension).\n            if (Array.isArray(problem.suggest) && problem.suggest.length > 0) {\n              problem.fix = problem.suggest[0].fix;\n            }\n          }\n\n          context.report(problem);\n        }\n\n        var scopeManager = context.getSourceCode().scopeManager; // Should be shared between visitors.\n\n        var setStateCallSites = new WeakMap();\n        var stateVariables = new WeakSet();\n        var stableKnownValueCache = new WeakMap();\n        var functionWithoutCapturedValueCache = new WeakMap();\n\n        function memoizeWithWeakMap(fn, map) {\n          return function (arg) {\n            if (map.has(arg)) {\n              // to verify cache hits:\n              // console.log(arg.name)\n              return map.get(arg);\n            }\n\n            var result = fn(arg);\n            map.set(arg, result);\n            return result;\n          };\n        }\n        /**\n         * Visitor for both function expressions and arrow function expressions.\n         */\n\n\n        function visitFunctionWithDependencies(node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect) {\n          if (isEffect && node.async) {\n            reportProblem({\n              node: node,\n              message: \"Effect callbacks are synchronous to prevent race conditions. \" + \"Put the async function inside:\\n\\n\" + 'useEffect(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching'\n            });\n          } // Get the current scope.\n\n\n          var scope = scopeManager.acquire(node); // Find all our \"pure scopes\". On every re-render of a component these\n          // pure scopes may have changes to the variables declared within. So all\n          // variables used in our reactive hook callback but declared in a pure\n          // scope need to be listed as dependencies of our reactive hook callback.\n          //\n          // According to the rules of React you can't read a mutable value in pure\n          // scope. We can't enforce this in a lint so we trust that all variables\n          // declared outside of pure scope are indeed frozen.\n\n          var pureScopes = new Set();\n          var componentScope = null;\n          {\n            var currentScope = scope.upper;\n\n            while (currentScope) {\n              pureScopes.add(currentScope);\n\n              if (currentScope.type === 'function') {\n                break;\n              }\n\n              currentScope = currentScope.upper;\n            } // If there is no parent function scope then there are no pure scopes.\n            // The ones we've collected so far are incorrect. So don't continue with\n            // the lint.\n\n\n            if (!currentScope) {\n              return;\n            }\n\n            componentScope = currentScope;\n          }\n          var isArray = Array.isArray; // Next we'll define a few helpers that helps us\n          // tell if some values don't have to be declared as deps.\n          // Some are known to be stable based on Hook calls.\n          // const [state, setState] = useState() / React.useState()\n          //               ^^^ true for this reference\n          // const [state, dispatch] = useReducer() / React.useReducer()\n          //               ^^^ true for this reference\n          // const ref = useRef()\n          //       ^^^ true for this reference\n          // False for everything else.\n\n          function isStableKnownHookValue(resolved) {\n            if (!isArray(resolved.defs)) {\n              return false;\n            }\n\n            var def = resolved.defs[0];\n\n            if (def == null) {\n              return false;\n            } // Look for `let stuff = ...`\n\n\n            if (def.node.type !== 'VariableDeclarator') {\n              return false;\n            }\n\n            var init = def.node.init;\n\n            if (init == null) {\n              return false;\n            }\n\n            while (init.type === 'TSAsExpression') {\n              init = init.expression;\n            } // Detect primitive constants\n            // const foo = 42\n\n\n            var declaration = def.node.parent;\n\n            if (declaration == null) {\n              // This might happen if variable is declared after the callback.\n              // In that case ESLint won't set up .parent refs.\n              // So we'll set them up manually.\n              fastFindReferenceWithParent(componentScope.block, def.node.id);\n              declaration = def.node.parent;\n\n              if (declaration == null) {\n                return false;\n              }\n            }\n\n            if (declaration.kind === 'const' && init.type === 'Literal' && (typeof init.value === 'string' || typeof init.value === 'number' || init.value === null)) {\n              // Definitely stable\n              return true;\n            } // Detect known Hook calls\n            // const [_, setState] = useState()\n\n\n            if (init.type !== 'CallExpression') {\n              return false;\n            }\n\n            var callee = init.callee; // Step into `= React.something` initializer.\n\n            if (callee.type === 'MemberExpression' && callee.object.name === 'React' && callee.property != null && !callee.computed) {\n              callee = callee.property;\n            }\n\n            if (callee.type !== 'Identifier') {\n              return false;\n            }\n\n            var id = def.node.id;\n            var _callee = callee,\n                name = _callee.name;\n\n            if (name === 'useRef' && id.type === 'Identifier') {\n              // useRef() return value is stable.\n              return true;\n            } else if (name === 'useState' || name === 'useReducer') {\n              // Only consider second value in initializing tuple stable.\n              if (id.type === 'ArrayPattern' && id.elements.length === 2 && isArray(resolved.identifiers)) {\n                // Is second tuple value the same reference we're checking?\n                if (id.elements[1] === resolved.identifiers[0]) {\n                  if (name === 'useState') {\n                    var references = resolved.references;\n                    var writeCount = 0;\n\n                    for (var i = 0; i < references.length; i++) {\n                      if (references[i].isWrite()) {\n                        writeCount++;\n                      }\n\n                      if (writeCount > 1) {\n                        return false;\n                      }\n\n                      setStateCallSites.set(references[i].identifier, id.elements[0]);\n                    }\n                  } // Setter is stable.\n\n\n                  return true;\n                } else if (id.elements[0] === resolved.identifiers[0]) {\n                  if (name === 'useState') {\n                    var _references = resolved.references;\n\n                    for (var _i = 0; _i < _references.length; _i++) {\n                      stateVariables.add(_references[_i].identifier);\n                    }\n                  } // State variable itself is dynamic.\n\n\n                  return false;\n                }\n              }\n            } else if (name === 'useTransition') {\n              // Only consider second value in initializing tuple stable.\n              if (id.type === 'ArrayPattern' && id.elements.length === 2 && Array.isArray(resolved.identifiers)) {\n                // Is second tuple value the same reference we're checking?\n                if (id.elements[1] === resolved.identifiers[0]) {\n                  // Setter is stable.\n                  return true;\n                }\n              }\n            } // By default assume it's dynamic.\n\n\n            return false;\n          } // Some are just functions that don't reference anything dynamic.\n\n\n          function isFunctionWithoutCapturedValues(resolved) {\n            if (!isArray(resolved.defs)) {\n              return false;\n            }\n\n            var def = resolved.defs[0];\n\n            if (def == null) {\n              return false;\n            }\n\n            if (def.node == null || def.node.id == null) {\n              return false;\n            } // Search the direct component subscopes for\n            // top-level function definitions matching this reference.\n\n\n            var fnNode = def.node;\n            var childScopes = componentScope.childScopes;\n            var fnScope = null;\n            var i;\n\n            for (i = 0; i < childScopes.length; i++) {\n              var childScope = childScopes[i];\n              var childScopeBlock = childScope.block;\n\n              if ( // function handleChange() {}\n              fnNode.type === 'FunctionDeclaration' && childScopeBlock === fnNode || // const handleChange = () => {}\n              // const handleChange = function() {}\n              fnNode.type === 'VariableDeclarator' && childScopeBlock.parent === fnNode) {\n                // Found it!\n                fnScope = childScope;\n                break;\n              }\n            }\n\n            if (fnScope == null) {\n              return false;\n            } // Does this function capture any values\n            // that are in pure scopes (aka render)?\n\n\n            for (i = 0; i < fnScope.through.length; i++) {\n              var ref = fnScope.through[i];\n\n              if (ref.resolved == null) {\n                continue;\n              }\n\n              if (pureScopes.has(ref.resolved.scope) && // Stable values are fine though,\n              // although we won't check functions deeper.\n              !memoizedIsStableKnownHookValue(ref.resolved)) {\n                return false;\n              }\n            } // If we got here, this function doesn't capture anything\n            // from render--or everything it captures is known stable.\n\n\n            return true;\n          } // Remember such values. Avoid re-running extra checks on them.\n\n\n          var memoizedIsStableKnownHookValue = memoizeWithWeakMap(isStableKnownHookValue, stableKnownValueCache);\n          var memoizedIsFunctionWithoutCapturedValues = memoizeWithWeakMap(isFunctionWithoutCapturedValues, functionWithoutCapturedValueCache); // These are usually mistaken. Collect them.\n\n          var currentRefsInEffectCleanup = new Map(); // Is this reference inside a cleanup function for this effect node?\n          // We can check by traversing scopes upwards  from the reference, and checking\n          // if the last \"return () => \" we encounter is located directly inside the effect.\n\n          function isInsideEffectCleanup(reference) {\n            var curScope = reference.from;\n            var isInReturnedFunction = false;\n\n            while (curScope.block !== node) {\n              if (curScope.type === 'function') {\n                isInReturnedFunction = curScope.block.parent != null && curScope.block.parent.type === 'ReturnStatement';\n              }\n\n              curScope = curScope.upper;\n            }\n\n            return isInReturnedFunction;\n          } // Get dependencies from all our resolved references in pure scopes.\n          // Key is dependency string, value is whether it's stable.\n\n\n          var dependencies = new Map();\n          var optionalChains = new Map();\n          gatherDependenciesRecursively(scope);\n\n          function gatherDependenciesRecursively(currentScope) {\n            var _iterator = _createForOfIteratorHelper(currentScope.references),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var reference = _step.value; // If this reference is not resolved or it is not declared in a pure\n                // scope then we don't care about this reference.\n\n                if (!reference.resolved) {\n                  continue;\n                }\n\n                if (!pureScopes.has(reference.resolved.scope)) {\n                  continue;\n                } // Narrow the scope of a dependency if it is, say, a member expression.\n                // Then normalize the narrowed dependency.\n\n\n                var referenceNode = fastFindReferenceWithParent(node, reference.identifier);\n                var dependencyNode = getDependency(referenceNode);\n                var dependency = analyzePropertyChain(dependencyNode, optionalChains); // Accessing ref.current inside effect cleanup is bad.\n\n                if ( // We're in an effect...\n                isEffect && // ... and this look like accessing .current...\n                dependencyNode.type === 'Identifier' && (dependencyNode.parent.type === 'MemberExpression' || dependencyNode.parent.type === 'OptionalMemberExpression') && !dependencyNode.parent.computed && dependencyNode.parent.property.type === 'Identifier' && dependencyNode.parent.property.name === 'current' && // ...in a cleanup function or below...\n                isInsideEffectCleanup(reference)) {\n                  currentRefsInEffectCleanup.set(dependency, {\n                    reference: reference,\n                    dependencyNode: dependencyNode\n                  });\n                }\n\n                if (dependencyNode.parent.type === 'TSTypeQuery' || dependencyNode.parent.type === 'TSTypeReference') {\n                  continue;\n                }\n\n                var def = reference.resolved.defs[0];\n\n                if (def == null) {\n                  continue;\n                } // Ignore references to the function itself as it's not defined yet.\n\n\n                if (def.node != null && def.node.init === node.parent) {\n                  continue;\n                } // Ignore Flow type parameters\n\n\n                if (def.type === 'TypeParameter') {\n                  continue;\n                } // Add the dependency to a map so we can make sure it is referenced\n                // again in our dependencies array. Remember whether it's stable.\n\n\n                if (!dependencies.has(dependency)) {\n                  var resolved = reference.resolved;\n                  var isStable = memoizedIsStableKnownHookValue(resolved) || memoizedIsFunctionWithoutCapturedValues(resolved);\n                  dependencies.set(dependency, {\n                    isStable: isStable,\n                    references: [reference]\n                  });\n                } else {\n                  dependencies.get(dependency).references.push(reference);\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            var _iterator2 = _createForOfIteratorHelper(currentScope.childScopes),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var childScope = _step2.value;\n                gatherDependenciesRecursively(childScope);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          } // Warn about accessing .current in cleanup effects.\n\n\n          currentRefsInEffectCleanup.forEach(function (_ref, dependency) {\n            var reference = _ref.reference,\n                dependencyNode = _ref.dependencyNode;\n            var references = reference.resolved.references; // Is React managing this ref or us?\n            // Let's see if we can find a .current assignment.\n\n            var foundCurrentAssignment = false;\n\n            for (var i = 0; i < references.length; i++) {\n              var identifier = references[i].identifier;\n              var parent = identifier.parent;\n\n              if (parent != null && // ref.current\n              // Note: no need to handle OptionalMemberExpression because it can't be LHS.\n              parent.type === 'MemberExpression' && !parent.computed && parent.property.type === 'Identifier' && parent.property.name === 'current' && // ref.current = <something>\n              parent.parent.type === 'AssignmentExpression' && parent.parent.left === parent) {\n                foundCurrentAssignment = true;\n                break;\n              }\n            } // We only want to warn about React-managed refs.\n\n\n            if (foundCurrentAssignment) {\n              return;\n            }\n\n            reportProblem({\n              node: dependencyNode.parent.property,\n              message: \"The ref value '\" + dependency + \".current' will likely have \" + \"changed by the time this effect cleanup function runs. If \" + \"this ref points to a node rendered by React, copy \" + (\"'\" + dependency + \".current' to a variable inside the effect, and \") + \"use that variable in the cleanup function.\"\n            });\n          }); // Warn about assigning to variables in the outer scope.\n          // Those are usually bugs.\n\n          var staleAssignments = new Set();\n\n          function reportStaleAssignment(writeExpr, key) {\n            if (staleAssignments.has(key)) {\n              return;\n            }\n\n            staleAssignments.add(key);\n            reportProblem({\n              node: writeExpr,\n              message: \"Assignments to the '\" + key + \"' variable from inside React Hook \" + (context.getSource(reactiveHook) + \" will be lost after each \") + \"render. To preserve the value over time, store it in a useRef \" + \"Hook and keep the mutable value in the '.current' property. \" + \"Otherwise, you can move this variable directly inside \" + (context.getSource(reactiveHook) + \".\")\n            });\n          } // Remember which deps are stable and report bad usage first.\n\n\n          var stableDependencies = new Set();\n          dependencies.forEach(function (_ref2, key) {\n            var isStable = _ref2.isStable,\n                references = _ref2.references;\n\n            if (isStable) {\n              stableDependencies.add(key);\n            }\n\n            references.forEach(function (reference) {\n              if (reference.writeExpr) {\n                reportStaleAssignment(reference.writeExpr, key);\n              }\n            });\n          });\n\n          if (staleAssignments.size > 0) {\n            // The intent isn't clear so we'll wait until you fix those first.\n            return;\n          }\n\n          if (!declaredDependenciesNode) {\n            // Check if there are any top-level setState() calls.\n            // Those tend to lead to infinite loops.\n            var setStateInsideEffectWithoutDeps = null;\n            dependencies.forEach(function (_ref3, key) {\n              var isStable = _ref3.isStable,\n                  references = _ref3.references;\n\n              if (setStateInsideEffectWithoutDeps) {\n                return;\n              }\n\n              references.forEach(function (reference) {\n                if (setStateInsideEffectWithoutDeps) {\n                  return;\n                }\n\n                var id = reference.identifier;\n                var isSetState = setStateCallSites.has(id);\n\n                if (!isSetState) {\n                  return;\n                }\n\n                var fnScope = reference.from;\n\n                while (fnScope.type !== 'function') {\n                  fnScope = fnScope.upper;\n                }\n\n                var isDirectlyInsideEffect = fnScope.block === node;\n\n                if (isDirectlyInsideEffect) {\n                  // TODO: we could potentially ignore early returns.\n                  setStateInsideEffectWithoutDeps = key;\n                }\n              });\n            });\n\n            if (setStateInsideEffectWithoutDeps) {\n              var _collectRecommendatio = collectRecommendations({\n                dependencies: dependencies,\n                declaredDependencies: [],\n                stableDependencies: stableDependencies,\n                externalDependencies: new Set(),\n                isEffect: true\n              }),\n                  _suggestedDependencies = _collectRecommendatio.suggestedDependencies;\n\n              reportProblem({\n                node: reactiveHook,\n                message: \"React Hook \" + reactiveHookName + \" contains a call to '\" + setStateInsideEffectWithoutDeps + \"'. \" + \"Without a list of dependencies, this can lead to an infinite chain of updates. \" + \"To fix this, pass [\" + _suggestedDependencies.join(', ') + (\"] as a second argument to the \" + reactiveHookName + \" Hook.\"),\n                suggest: [{\n                  desc: \"Add dependencies array: [\" + _suggestedDependencies.join(', ') + \"]\",\n                  fix: function (fixer) {\n                    return fixer.insertTextAfter(node, \", [\" + _suggestedDependencies.join(', ') + \"]\");\n                  }\n                }]\n              });\n            }\n\n            return;\n          }\n\n          var declaredDependencies = [];\n          var externalDependencies = new Set();\n\n          if (declaredDependenciesNode.type !== 'ArrayExpression') {\n            // If the declared dependencies are not an array expression then we\n            // can't verify that the user provided the correct dependencies. Tell\n            // the user this in an error.\n            reportProblem({\n              node: declaredDependenciesNode,\n              message: \"React Hook \" + context.getSource(reactiveHook) + \" was passed a \" + 'dependency list that is not an array literal. This means we ' + \"can't statically verify whether you've passed the correct \" + 'dependencies.'\n            });\n          } else {\n            declaredDependenciesNode.elements.forEach(function (declaredDependencyNode) {\n              // Skip elided elements.\n              if (declaredDependencyNode === null) {\n                return;\n              } // If we see a spread element then add a special warning.\n\n\n              if (declaredDependencyNode.type === 'SpreadElement') {\n                reportProblem({\n                  node: declaredDependencyNode,\n                  message: \"React Hook \" + context.getSource(reactiveHook) + \" has a spread \" + \"element in its dependency array. This means we can't \" + \"statically verify whether you've passed the \" + 'correct dependencies.'\n                });\n                return;\n              } // Try to normalize the declared dependency. If we can't then an error\n              // will be thrown. We will catch that error and report an error.\n\n\n              var declaredDependency;\n\n              try {\n                declaredDependency = analyzePropertyChain(declaredDependencyNode, null);\n              } catch (error) {\n                if (/Unsupported node type/.test(error.message)) {\n                  if (declaredDependencyNode.type === 'Literal') {\n                    if (dependencies.has(declaredDependencyNode.value)) {\n                      reportProblem({\n                        node: declaredDependencyNode,\n                        message: \"The \" + declaredDependencyNode.raw + \" literal is not a valid dependency \" + \"because it never changes. \" + (\"Did you mean to include \" + declaredDependencyNode.value + \" in the array instead?\")\n                      });\n                    } else {\n                      reportProblem({\n                        node: declaredDependencyNode,\n                        message: \"The \" + declaredDependencyNode.raw + \" literal is not a valid dependency \" + 'because it never changes. You can safely remove it.'\n                      });\n                    }\n                  } else {\n                    reportProblem({\n                      node: declaredDependencyNode,\n                      message: \"React Hook \" + context.getSource(reactiveHook) + \" has a \" + \"complex expression in the dependency array. \" + 'Extract it to a separate variable so it can be statically checked.'\n                    });\n                  }\n\n                  return;\n                } else {\n                  throw error;\n                }\n              }\n\n              var maybeID = declaredDependencyNode;\n\n              while (maybeID.type === 'MemberExpression' || maybeID.type === 'OptionalMemberExpression' || maybeID.type === 'ChainExpression') {\n                maybeID = maybeID.object || maybeID.expression.object;\n              }\n\n              var isDeclaredInComponent = !componentScope.through.some(function (ref) {\n                return ref.identifier === maybeID;\n              }); // Add the dependency to our declared dependency map.\n\n              declaredDependencies.push({\n                key: declaredDependency,\n                node: declaredDependencyNode\n              });\n\n              if (!isDeclaredInComponent) {\n                externalDependencies.add(declaredDependency);\n              }\n            });\n          }\n\n          var _collectRecommendatio2 = collectRecommendations({\n            dependencies: dependencies,\n            declaredDependencies: declaredDependencies,\n            stableDependencies: stableDependencies,\n            externalDependencies: externalDependencies,\n            isEffect: isEffect\n          }),\n              suggestedDependencies = _collectRecommendatio2.suggestedDependencies,\n              unnecessaryDependencies = _collectRecommendatio2.unnecessaryDependencies,\n              missingDependencies = _collectRecommendatio2.missingDependencies,\n              duplicateDependencies = _collectRecommendatio2.duplicateDependencies;\n\n          var suggestedDeps = suggestedDependencies;\n          var problemCount = duplicateDependencies.size + missingDependencies.size + unnecessaryDependencies.size;\n\n          if (problemCount === 0) {\n            // If nothing else to report, check if some dependencies would\n            // invalidate on every render.\n            var constructions = scanForConstructions({\n              declaredDependencies: declaredDependencies,\n              declaredDependenciesNode: declaredDependenciesNode,\n              componentScope: componentScope,\n              scope: scope\n            });\n            constructions.forEach(function (_ref4) {\n              var construction = _ref4.construction,\n                  isUsedOutsideOfHook = _ref4.isUsedOutsideOfHook,\n                  depType = _ref4.depType;\n              var wrapperHook = depType === 'function' ? 'useCallback' : 'useMemo';\n              var constructionType = depType === 'function' ? 'definition' : 'initialization';\n              var defaultAdvice = \"wrap the \" + constructionType + \" of '\" + construction.name.name + \"' in its own \" + wrapperHook + \"() Hook.\";\n              var advice = isUsedOutsideOfHook ? \"To fix this, \" + defaultAdvice : \"Move it inside the \" + reactiveHookName + \" callback. Alternatively, \" + defaultAdvice;\n              var causation = depType === 'conditional' || depType === 'logical expression' ? 'could make' : 'makes';\n              var message = \"The '\" + construction.name.name + \"' \" + depType + \" \" + causation + \" the dependencies of \" + (reactiveHookName + \" Hook (at line \" + declaredDependenciesNode.loc.start.line + \") \") + (\"change on every render. \" + advice);\n              var suggest; // Only handle the simple case of variable assignments.\n              // Wrapping function declarations can mess up hoisting.\n\n              if (isUsedOutsideOfHook && construction.type === 'Variable' && // Objects may be mutated after construction, which would make this\n              // fix unsafe. Functions _probably_ won't be mutated, so we'll\n              // allow this fix for them.\n              depType === 'function') {\n                suggest = [{\n                  desc: \"Wrap the \" + constructionType + \" of '\" + construction.name.name + \"' in its own \" + wrapperHook + \"() Hook.\",\n                  fix: function (fixer) {\n                    var _ref5 = wrapperHook === 'useMemo' ? [\"useMemo(() => { return \", '; })'] : ['useCallback(', ')'],\n                        before = _ref5[0],\n                        after = _ref5[1];\n\n                    return [// TODO: also add an import?\n                    fixer.insertTextBefore(construction.node.init, before), // TODO: ideally we'd gather deps here but it would require\n                    // restructuring the rule code. This will cause a new lint\n                    // error to appear immediately for useCallback. Note we're\n                    // not adding [] because would that changes semantics.\n                    fixer.insertTextAfter(construction.node.init, after)];\n                  }\n                }];\n              } // TODO: What if the function needs to change on every render anyway?\n              // Should we suggest removing effect deps as an appropriate fix too?\n\n\n              reportProblem({\n                // TODO: Why not report this at the dependency site?\n                node: construction.node,\n                message: message,\n                suggest: suggest\n              });\n            });\n            return;\n          } // If we're going to report a missing dependency,\n          // we might as well recalculate the list ignoring\n          // the currently specified deps. This can result\n          // in some extra deduplication. We can't do this\n          // for effects though because those have legit\n          // use cases for over-specifying deps.\n\n\n          if (!isEffect && missingDependencies.size > 0) {\n            suggestedDeps = collectRecommendations({\n              dependencies: dependencies,\n              declaredDependencies: [],\n              // Pretend we don't know\n              stableDependencies: stableDependencies,\n              externalDependencies: externalDependencies,\n              isEffect: isEffect\n            }).suggestedDependencies;\n          } // Alphabetize the suggestions, but only if deps were already alphabetized.\n\n\n          function areDeclaredDepsAlphabetized() {\n            if (declaredDependencies.length === 0) {\n              return true;\n            }\n\n            var declaredDepKeys = declaredDependencies.map(function (dep) {\n              return dep.key;\n            });\n            var sortedDeclaredDepKeys = declaredDepKeys.slice().sort();\n            return declaredDepKeys.join(',') === sortedDeclaredDepKeys.join(',');\n          }\n\n          if (areDeclaredDepsAlphabetized()) {\n            suggestedDeps.sort();\n          } // Most of our algorithm deals with dependency paths with optional chaining stripped.\n          // This function is the last step before printing a dependency, so now is a good time to\n          // check whether any members in our path are always used as optional-only. In that case,\n          // we will use ?. instead of . to concatenate those parts of the path.\n\n\n          function formatDependency(path) {\n            var members = path.split('.');\n            var finalPath = '';\n\n            for (var i = 0; i < members.length; i++) {\n              if (i !== 0) {\n                var pathSoFar = members.slice(0, i + 1).join('.');\n                var isOptional = optionalChains.get(pathSoFar) === true;\n                finalPath += isOptional ? '?.' : '.';\n              }\n\n              finalPath += members[i];\n            }\n\n            return finalPath;\n          }\n\n          function getWarningMessage(deps, singlePrefix, label, fixVerb) {\n            if (deps.size === 0) {\n              return null;\n            }\n\n            return (deps.size > 1 ? '' : singlePrefix + ' ') + label + ' ' + (deps.size > 1 ? 'dependencies' : 'dependency') + ': ' + joinEnglish(Array.from(deps).sort().map(function (name) {\n              return \"'\" + formatDependency(name) + \"'\";\n            })) + (\". Either \" + fixVerb + \" \" + (deps.size > 1 ? 'them' : 'it') + \" or remove the dependency array.\");\n          }\n\n          var extraWarning = '';\n\n          if (unnecessaryDependencies.size > 0) {\n            var badRef = null;\n            Array.from(unnecessaryDependencies.keys()).forEach(function (key) {\n              if (badRef !== null) {\n                return;\n              }\n\n              if (key.endsWith('.current')) {\n                badRef = key;\n              }\n            });\n\n            if (badRef !== null) {\n              extraWarning = \" Mutable values like '\" + badRef + \"' aren't valid dependencies \" + \"because mutating them doesn't re-render the component.\";\n            } else if (externalDependencies.size > 0) {\n              var dep = Array.from(externalDependencies)[0]; // Don't show this warning for things that likely just got moved *inside* the callback\n              // because in that case they're clearly not referring to globals.\n\n              if (!scope.set.has(dep)) {\n                extraWarning = \" Outer scope values like '\" + dep + \"' aren't valid dependencies \" + \"because mutating them doesn't re-render the component.\";\n              }\n            }\n          } // `props.foo()` marks `props` as a dependency because it has\n          // a `this` value. This warning can be confusing.\n          // So if we're going to show it, append a clarification.\n\n\n          if (!extraWarning && missingDependencies.has('props')) {\n            var propDep = dependencies.get('props');\n\n            if (propDep == null) {\n              return;\n            }\n\n            var refs = propDep.references;\n\n            if (!Array.isArray(refs)) {\n              return;\n            }\n\n            var isPropsOnlyUsedInMembers = true;\n\n            for (var i = 0; i < refs.length; i++) {\n              var ref = refs[i];\n              var id = fastFindReferenceWithParent(componentScope.block, ref.identifier);\n\n              if (!id) {\n                isPropsOnlyUsedInMembers = false;\n                break;\n              }\n\n              var parent = id.parent;\n\n              if (parent == null) {\n                isPropsOnlyUsedInMembers = false;\n                break;\n              }\n\n              if (parent.type !== 'MemberExpression' && parent.type !== 'OptionalMemberExpression') {\n                isPropsOnlyUsedInMembers = false;\n                break;\n              }\n            }\n\n            if (isPropsOnlyUsedInMembers) {\n              extraWarning = \" However, 'props' will change when *any* prop changes, so the \" + \"preferred fix is to destructure the 'props' object outside of \" + (\"the \" + reactiveHookName + \" call and refer to those specific props \") + (\"inside \" + context.getSource(reactiveHook) + \".\");\n            }\n          }\n\n          if (!extraWarning && missingDependencies.size > 0) {\n            // See if the user is trying to avoid specifying a callable prop.\n            // This usually means they're unaware of useCallback.\n            var missingCallbackDep = null;\n            missingDependencies.forEach(function (missingDep) {\n              if (missingCallbackDep) {\n                return;\n              } // Is this a variable from top scope?\n\n\n              var topScopeRef = componentScope.set.get(missingDep);\n              var usedDep = dependencies.get(missingDep);\n\n              if (usedDep.references[0].resolved !== topScopeRef) {\n                return;\n              } // Is this a destructured prop?\n\n\n              var def = topScopeRef.defs[0];\n\n              if (def == null || def.name == null || def.type !== 'Parameter') {\n                return;\n              } // Was it called in at least one case? Then it's a function.\n\n\n              var isFunctionCall = false;\n              var id;\n\n              for (var _i2 = 0; _i2 < usedDep.references.length; _i2++) {\n                id = usedDep.references[_i2].identifier;\n\n                if (id != null && id.parent != null && (id.parent.type === 'CallExpression' || id.parent.type === 'OptionalCallExpression') && id.parent.callee === id) {\n                  isFunctionCall = true;\n                  break;\n                }\n              }\n\n              if (!isFunctionCall) {\n                return;\n              } // If it's missing (i.e. in component scope) *and* it's a parameter\n              // then it is definitely coming from props destructuring.\n              // (It could also be props itself but we wouldn't be calling it then.)\n\n\n              missingCallbackDep = missingDep;\n            });\n\n            if (missingCallbackDep !== null) {\n              extraWarning = \" If '\" + missingCallbackDep + \"' changes too often, \" + \"find the parent component that defines it \" + \"and wrap that definition in useCallback.\";\n            }\n          }\n\n          if (!extraWarning && missingDependencies.size > 0) {\n            var setStateRecommendation = null;\n            missingDependencies.forEach(function (missingDep) {\n              if (setStateRecommendation !== null) {\n                return;\n              }\n\n              var usedDep = dependencies.get(missingDep);\n              var references = usedDep.references;\n              var id;\n              var maybeCall;\n\n              for (var _i3 = 0; _i3 < references.length; _i3++) {\n                id = references[_i3].identifier;\n                maybeCall = id.parent; // Try to see if we have setState(someExpr(missingDep)).\n\n                while (maybeCall != null && maybeCall !== componentScope.block) {\n                  if (maybeCall.type === 'CallExpression') {\n                    var correspondingStateVariable = setStateCallSites.get(maybeCall.callee);\n\n                    if (correspondingStateVariable != null) {\n                      if (correspondingStateVariable.name === missingDep) {\n                        // setCount(count + 1)\n                        setStateRecommendation = {\n                          missingDep: missingDep,\n                          setter: maybeCall.callee.name,\n                          form: 'updater'\n                        };\n                      } else if (stateVariables.has(id)) {\n                        // setCount(count + increment)\n                        setStateRecommendation = {\n                          missingDep: missingDep,\n                          setter: maybeCall.callee.name,\n                          form: 'reducer'\n                        };\n                      } else {\n                        var resolved = references[_i3].resolved;\n\n                        if (resolved != null) {\n                          // If it's a parameter *and* a missing dep,\n                          // it must be a prop or something inside a prop.\n                          // Therefore, recommend an inline reducer.\n                          var def = resolved.defs[0];\n\n                          if (def != null && def.type === 'Parameter') {\n                            setStateRecommendation = {\n                              missingDep: missingDep,\n                              setter: maybeCall.callee.name,\n                              form: 'inlineReducer'\n                            };\n                          }\n                        }\n                      }\n\n                      break;\n                    }\n                  }\n\n                  maybeCall = maybeCall.parent;\n                }\n\n                if (setStateRecommendation !== null) {\n                  break;\n                }\n              }\n            });\n\n            if (setStateRecommendation !== null) {\n              switch (setStateRecommendation.form) {\n                case 'reducer':\n                  extraWarning = \" You can also replace multiple useState variables with useReducer \" + (\"if '\" + setStateRecommendation.setter + \"' needs the \") + (\"current value of '\" + setStateRecommendation.missingDep + \"'.\");\n                  break;\n\n                case 'inlineReducer':\n                  extraWarning = \" If '\" + setStateRecommendation.setter + \"' needs the \" + (\"current value of '\" + setStateRecommendation.missingDep + \"', \") + \"you can also switch to useReducer instead of useState and \" + (\"read '\" + setStateRecommendation.missingDep + \"' in the reducer.\");\n                  break;\n\n                case 'updater':\n                  extraWarning = \" You can also do a functional update '\" + setStateRecommendation.setter + \"(\" + setStateRecommendation.missingDep.substring(0, 1) + \" => ...)' if you only need '\" + setStateRecommendation.missingDep + \"'\" + (\" in the '\" + setStateRecommendation.setter + \"' call.\");\n                  break;\n\n                default:\n                  throw new Error('Unknown case.');\n              }\n            }\n          }\n\n          reportProblem({\n            node: declaredDependenciesNode,\n            message: \"React Hook \" + context.getSource(reactiveHook) + \" has \" + ( // To avoid a long message, show the next actionable item.\n            getWarningMessage(missingDependencies, 'a', 'missing', 'include') || getWarningMessage(unnecessaryDependencies, 'an', 'unnecessary', 'exclude') || getWarningMessage(duplicateDependencies, 'a', 'duplicate', 'omit')) + extraWarning,\n            suggest: [{\n              desc: \"Update the dependencies array to be: [\" + suggestedDeps.map(formatDependency).join(', ') + \"]\",\n              fix: function (fixer) {\n                // TODO: consider preserving the comments or formatting?\n                return fixer.replaceText(declaredDependenciesNode, \"[\" + suggestedDeps.map(formatDependency).join(', ') + \"]\");\n              }\n            }]\n          });\n        }\n\n        function visitCallExpression(node) {\n          var callbackIndex = getReactiveHookCallbackIndex(node.callee, options);\n\n          if (callbackIndex === -1) {\n            // Not a React Hook call that needs deps.\n            return;\n          }\n\n          var callback = node.arguments[callbackIndex];\n          var reactiveHook = node.callee;\n          var reactiveHookName = getNodeWithoutReactNamespace(reactiveHook).name;\n          var declaredDependenciesNode = node.arguments[callbackIndex + 1];\n          var isEffect = /Effect($|[^a-z])/g.test(reactiveHookName); // Check whether a callback is supplied. If there is no callback supplied\n          // then the hook will not work and React will throw a TypeError.\n          // So no need to check for dependency inclusion.\n\n          if (!callback) {\n            reportProblem({\n              node: reactiveHook,\n              message: \"React Hook \" + reactiveHookName + \" requires an effect callback. \" + \"Did you forget to pass a callback to the hook?\"\n            });\n            return;\n          } // Check the declared dependencies for this reactive hook. If there is no\n          // second argument then the reactive callback will re-run on every render.\n          // So no need to check for dependency inclusion.\n\n\n          if (!declaredDependenciesNode && !isEffect) {\n            // These are only used for optimization.\n            if (reactiveHookName === 'useMemo' || reactiveHookName === 'useCallback') {\n              // TODO: Can this have a suggestion?\n              reportProblem({\n                node: reactiveHook,\n                message: \"React Hook \" + reactiveHookName + \" does nothing when called with \" + \"only one argument. Did you forget to pass an array of \" + \"dependencies?\"\n              });\n            }\n\n            return;\n          }\n\n          switch (callback.type) {\n            case 'FunctionExpression':\n            case 'ArrowFunctionExpression':\n              visitFunctionWithDependencies(callback, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);\n              return;\n            // Handled\n\n            case 'Identifier':\n              if (!declaredDependenciesNode) {\n                // No deps, no problems.\n                return; // Handled\n              } // The function passed as a callback is not written inline.\n              // But perhaps it's in the dependencies array?\n\n\n              if (declaredDependenciesNode.elements && declaredDependenciesNode.elements.some(function (el) {\n                return el && el.type === 'Identifier' && el.name === callback.name;\n              })) {\n                // If it's already in the list of deps, we don't care because\n                // this is valid regardless.\n                return; // Handled\n              } // We'll do our best effort to find it, complain otherwise.\n\n\n              var variable = context.getScope().set.get(callback.name);\n\n              if (variable == null || variable.defs == null) {\n                // If it's not in scope, we don't care.\n                return; // Handled\n              } // The function passed as a callback is not written inline.\n              // But it's defined somewhere in the render scope.\n              // We'll do our best effort to find and check it, complain otherwise.\n\n\n              var def = variable.defs[0];\n\n              if (!def || !def.node) {\n                break; // Unhandled\n              }\n\n              if (def.type !== 'Variable' && def.type !== 'FunctionName') {\n                // Parameter or an unusual pattern. Bail out.\n                break; // Unhandled\n              }\n\n              switch (def.node.type) {\n                case 'FunctionDeclaration':\n                  // useEffect(() => { ... }, []);\n                  visitFunctionWithDependencies(def.node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);\n                  return;\n                // Handled\n\n                case 'VariableDeclarator':\n                  var init = def.node.init;\n\n                  if (!init) {\n                    break; // Unhandled\n                  }\n\n                  switch (init.type) {\n                    // const effectBody = () => {...};\n                    // useEffect(effectBody, []);\n                    case 'ArrowFunctionExpression':\n                    case 'FunctionExpression':\n                      // We can inspect this function as if it were inline.\n                      visitFunctionWithDependencies(init, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);\n                      return;\n                    // Handled\n                  }\n\n                  break;\n                // Unhandled\n              }\n\n              break;\n            // Unhandled\n\n            default:\n              // useEffect(generateEffectBody(), []);\n              reportProblem({\n                node: reactiveHook,\n                message: \"React Hook \" + reactiveHookName + \" received a function whose dependencies \" + \"are unknown. Pass an inline function instead.\"\n              });\n              return;\n            // Handled\n          } // Something unusual. Fall back to suggesting to add the body itself as a dep.\n\n\n          reportProblem({\n            node: reactiveHook,\n            message: \"React Hook \" + reactiveHookName + \" has a missing dependency: '\" + callback.name + \"'. \" + \"Either include it or remove the dependency array.\",\n            suggest: [{\n              desc: \"Update the dependencies array to be: [\" + callback.name + \"]\",\n              fix: function (fixer) {\n                return fixer.replaceText(declaredDependenciesNode, \"[\" + callback.name + \"]\");\n              }\n            }]\n          });\n        }\n\n        return {\n          CallExpression: visitCallExpression\n        };\n      }\n    }; // The meat of the logic.\n\n    function collectRecommendations(_ref6) {\n      var dependencies = _ref6.dependencies,\n          declaredDependencies = _ref6.declaredDependencies,\n          stableDependencies = _ref6.stableDependencies,\n          externalDependencies = _ref6.externalDependencies,\n          isEffect = _ref6.isEffect; // Our primary data structure.\n      // It is a logical representation of property chains:\n      // `props` -> `props.foo` -> `props.foo.bar` -> `props.foo.bar.baz`\n      //         -> `props.lol`\n      //         -> `props.huh` -> `props.huh.okay`\n      //         -> `props.wow`\n      // We'll use it to mark nodes that are *used* by the programmer,\n      // and the nodes that were *declared* as deps. Then we will\n      // traverse it to learn which deps are missing or unnecessary.\n\n      var depTree = createDepTree();\n\n      function createDepTree() {\n        return {\n          isUsed: false,\n          // True if used in code\n          isSatisfiedRecursively: false,\n          // True if specified in deps\n          isSubtreeUsed: false,\n          // True if something deeper is used by code\n          children: new Map() // Nodes for properties\n\n        };\n      } // Mark all required nodes first.\n      // Imagine exclamation marks next to each used deep property.\n\n\n      dependencies.forEach(function (_, key) {\n        var node = getOrCreateNodeByPath(depTree, key);\n        node.isUsed = true;\n        markAllParentsByPath(depTree, key, function (parent) {\n          parent.isSubtreeUsed = true;\n        });\n      }); // Mark all satisfied nodes.\n      // Imagine checkmarks next to each declared dependency.\n\n      declaredDependencies.forEach(function (_ref7) {\n        var key = _ref7.key;\n        var node = getOrCreateNodeByPath(depTree, key);\n        node.isSatisfiedRecursively = true;\n      });\n      stableDependencies.forEach(function (key) {\n        var node = getOrCreateNodeByPath(depTree, key);\n        node.isSatisfiedRecursively = true;\n      }); // Tree manipulation helpers.\n\n      function getOrCreateNodeByPath(rootNode, path) {\n        var keys = path.split('.');\n        var node = rootNode;\n\n        var _iterator3 = _createForOfIteratorHelper(keys),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var key = _step3.value;\n            var child = node.children.get(key);\n\n            if (!child) {\n              child = createDepTree();\n              node.children.set(key, child);\n            }\n\n            node = child;\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        return node;\n      }\n\n      function markAllParentsByPath(rootNode, path, fn) {\n        var keys = path.split('.');\n        var node = rootNode;\n\n        var _iterator4 = _createForOfIteratorHelper(keys),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var key = _step4.value;\n            var child = node.children.get(key);\n\n            if (!child) {\n              return;\n            }\n\n            fn(child);\n            node = child;\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } // Now we can learn which dependencies are missing or necessary.\n\n\n      var missingDependencies = new Set();\n      var satisfyingDependencies = new Set();\n      scanTreeRecursively(depTree, missingDependencies, satisfyingDependencies, function (key) {\n        return key;\n      });\n\n      function scanTreeRecursively(node, missingPaths, satisfyingPaths, keyToPath) {\n        node.children.forEach(function (child, key) {\n          var path = keyToPath(key);\n\n          if (child.isSatisfiedRecursively) {\n            if (child.isSubtreeUsed) {\n              // Remember this dep actually satisfied something.\n              satisfyingPaths.add(path);\n            } // It doesn't matter if there's something deeper.\n            // It would be transitively satisfied since we assume immutability.\n            // `props.foo` is enough if you read `props.foo.id`.\n\n\n            return;\n          }\n\n          if (child.isUsed) {\n            // Remember that no declared deps satisfied this node.\n            missingPaths.add(path); // If we got here, nothing in its subtree was satisfied.\n            // No need to search further.\n\n            return;\n          }\n\n          scanTreeRecursively(child, missingPaths, satisfyingPaths, function (childKey) {\n            return path + '.' + childKey;\n          });\n        });\n      } // Collect suggestions in the order they were originally specified.\n\n\n      var suggestedDependencies = [];\n      var unnecessaryDependencies = new Set();\n      var duplicateDependencies = new Set();\n      declaredDependencies.forEach(function (_ref8) {\n        var key = _ref8.key; // Does this declared dep satisfy a real need?\n\n        if (satisfyingDependencies.has(key)) {\n          if (suggestedDependencies.indexOf(key) === -1) {\n            // Good one.\n            suggestedDependencies.push(key);\n          } else {\n            // Duplicate.\n            duplicateDependencies.add(key);\n          }\n        } else {\n          if (isEffect && !key.endsWith('.current') && !externalDependencies.has(key)) {\n            // Effects are allowed extra \"unnecessary\" deps.\n            // Such as resetting scroll when ID changes.\n            // Consider them legit.\n            // The exception is ref.current which is always wrong.\n            if (suggestedDependencies.indexOf(key) === -1) {\n              suggestedDependencies.push(key);\n            }\n          } else {\n            // It's definitely not needed.\n            unnecessaryDependencies.add(key);\n          }\n        }\n      }); // Then add the missing ones at the end.\n\n      missingDependencies.forEach(function (key) {\n        suggestedDependencies.push(key);\n      });\n      return {\n        suggestedDependencies: suggestedDependencies,\n        unnecessaryDependencies: unnecessaryDependencies,\n        duplicateDependencies: duplicateDependencies,\n        missingDependencies: missingDependencies\n      };\n    } // If the node will result in constructing a referentially unique value, return\n    // its human readable type name, else return null.\n\n\n    function getConstructionExpressionType(node) {\n      switch (node.type) {\n        case 'ObjectExpression':\n          return 'object';\n\n        case 'ArrayExpression':\n          return 'array';\n\n        case 'ArrowFunctionExpression':\n        case 'FunctionExpression':\n          return 'function';\n\n        case 'ClassExpression':\n          return 'class';\n\n        case 'ConditionalExpression':\n          if (getConstructionExpressionType(node.consequent) != null || getConstructionExpressionType(node.alternate) != null) {\n            return 'conditional';\n          }\n\n          return null;\n\n        case 'LogicalExpression':\n          if (getConstructionExpressionType(node.left) != null || getConstructionExpressionType(node.right) != null) {\n            return 'logical expression';\n          }\n\n          return null;\n\n        case 'JSXFragment':\n          return 'JSX fragment';\n\n        case 'JSXElement':\n          return 'JSX element';\n\n        case 'AssignmentExpression':\n          if (getConstructionExpressionType(node.right) != null) {\n            return 'assignment expression';\n          }\n\n          return null;\n\n        case 'NewExpression':\n          return 'object construction';\n\n        case 'Literal':\n          if (node.value instanceof RegExp) {\n            return 'regular expression';\n          }\n\n          return null;\n\n        case 'TypeCastExpression':\n          return getConstructionExpressionType(node.expression);\n\n        case 'TSAsExpression':\n          return getConstructionExpressionType(node.expression);\n      }\n\n      return null;\n    } // Finds variables declared as dependencies\n    // that would invalidate on every render.\n\n\n    function scanForConstructions(_ref9) {\n      var declaredDependencies = _ref9.declaredDependencies,\n          declaredDependenciesNode = _ref9.declaredDependenciesNode,\n          componentScope = _ref9.componentScope,\n          scope = _ref9.scope;\n      var constructions = declaredDependencies.map(function (_ref10) {\n        var key = _ref10.key;\n        var ref = componentScope.variables.find(function (v) {\n          return v.name === key;\n        });\n\n        if (ref == null) {\n          return null;\n        }\n\n        var node = ref.defs[0];\n\n        if (node == null) {\n          return null;\n        } // const handleChange = function () {}\n        // const handleChange = () => {}\n        // const foo = {}\n        // const foo = []\n        // etc.\n\n\n        if (node.type === 'Variable' && node.node.type === 'VariableDeclarator' && node.node.id.type === 'Identifier' && // Ensure this is not destructed assignment\n        node.node.init != null) {\n          var constantExpressionType = getConstructionExpressionType(node.node.init);\n\n          if (constantExpressionType != null) {\n            return [ref, constantExpressionType];\n          }\n        } // function handleChange() {}\n\n\n        if (node.type === 'FunctionName' && node.node.type === 'FunctionDeclaration') {\n          return [ref, 'function'];\n        } // class Foo {}\n\n\n        if (node.type === 'ClassName' && node.node.type === 'ClassDeclaration') {\n          return [ref, 'class'];\n        }\n\n        return null;\n      }).filter(Boolean);\n\n      function isUsedOutsideOfHook(ref) {\n        var foundWriteExpr = false;\n\n        for (var i = 0; i < ref.references.length; i++) {\n          var reference = ref.references[i];\n\n          if (reference.writeExpr) {\n            if (foundWriteExpr) {\n              // Two writes to the same function.\n              return true;\n            } else {\n              // Ignore first write as it's not usage.\n              foundWriteExpr = true;\n              continue;\n            }\n          }\n\n          var currentScope = reference.from;\n\n          while (currentScope !== scope && currentScope != null) {\n            currentScope = currentScope.upper;\n          }\n\n          if (currentScope !== scope) {\n            // This reference is outside the Hook callback.\n            // It can only be legit if it's the deps array.\n            if (!isAncestorNodeOf(declaredDependenciesNode, reference.identifier)) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      }\n\n      return constructions.map(function (_ref11) {\n        var ref = _ref11[0],\n            depType = _ref11[1];\n        return {\n          construction: ref.defs[0],\n          depType: depType,\n          isUsedOutsideOfHook: isUsedOutsideOfHook(ref)\n        };\n      });\n    }\n    /**\n     * Assuming () means the passed/returned node:\n     * (props) => (props)\n     * props.(foo) => (props.foo)\n     * props.foo.(bar) => (props).foo.bar\n     * props.foo.bar.(baz) => (props).foo.bar.baz\n     */\n\n\n    function getDependency(node) {\n      if ((node.parent.type === 'MemberExpression' || node.parent.type === 'OptionalMemberExpression') && node.parent.object === node && node.parent.property.name !== 'current' && !node.parent.computed && !(node.parent.parent != null && (node.parent.parent.type === 'CallExpression' || node.parent.parent.type === 'OptionalCallExpression') && node.parent.parent.callee === node.parent)) {\n        return getDependency(node.parent);\n      } else if ( // Note: we don't check OptionalMemberExpression because it can't be LHS.\n      node.type === 'MemberExpression' && node.parent && node.parent.type === 'AssignmentExpression' && node.parent.left === node) {\n        return node.object;\n      } else {\n        return node;\n      }\n    }\n    /**\n     * Mark a node as either optional or required.\n     * Note: If the node argument is an OptionalMemberExpression, it doesn't necessarily mean it is optional.\n     * It just means there is an optional member somewhere inside.\n     * This particular node might still represent a required member, so check .optional field.\n     */\n\n\n    function markNode(node, optionalChains, result) {\n      if (optionalChains) {\n        if (node.optional) {\n          // We only want to consider it optional if *all* usages were optional.\n          if (!optionalChains.has(result)) {\n            // Mark as (maybe) optional. If there's a required usage, this will be overridden.\n            optionalChains.set(result, true);\n          }\n        } else {\n          // Mark as required.\n          optionalChains.set(result, false);\n        }\n      }\n    }\n    /**\n     * Assuming () means the passed node.\n     * (foo) -> 'foo'\n     * foo(.)bar -> 'foo.bar'\n     * foo.bar(.)baz -> 'foo.bar.baz'\n     * Otherwise throw.\n     */\n\n\n    function analyzePropertyChain(node, optionalChains) {\n      if (node.type === 'Identifier' || node.type === 'JSXIdentifier') {\n        var result = node.name;\n\n        if (optionalChains) {\n          // Mark as required.\n          optionalChains.set(result, false);\n        }\n\n        return result;\n      } else if (node.type === 'MemberExpression' && !node.computed) {\n        var object = analyzePropertyChain(node.object, optionalChains);\n        var property = analyzePropertyChain(node.property, null);\n\n        var _result = object + \".\" + property;\n\n        markNode(node, optionalChains, _result);\n        return _result;\n      } else if (node.type === 'OptionalMemberExpression' && !node.computed) {\n        var _object = analyzePropertyChain(node.object, optionalChains);\n\n        var _property = analyzePropertyChain(node.property, null);\n\n        var _result2 = _object + \".\" + _property;\n\n        markNode(node, optionalChains, _result2);\n        return _result2;\n      } else if (node.type === 'ChainExpression' && !node.computed) {\n        var expression = node.expression;\n\n        if (expression.type === 'CallExpression') {\n          throw new Error(\"Unsupported node type: \" + expression.type);\n        }\n\n        var _object2 = analyzePropertyChain(expression.object, optionalChains);\n\n        var _property2 = analyzePropertyChain(expression.property, null);\n\n        var _result3 = _object2 + \".\" + _property2;\n\n        markNode(expression, optionalChains, _result3);\n        return _result3;\n      } else {\n        throw new Error(\"Unsupported node type: \" + node.type);\n      }\n    }\n\n    function getNodeWithoutReactNamespace(node, options) {\n      if (node.type === 'MemberExpression' && node.object.type === 'Identifier' && node.object.name === 'React' && node.property.type === 'Identifier' && !node.computed) {\n        return node.property;\n      }\n\n      return node;\n    } // What's the index of callback that needs to be analyzed for a given Hook?\n    // -1 if it's not a Hook we care about (e.g. useState).\n    // 0 for useEffect/useMemo/useCallback(fn).\n    // 1 for useImperativeHandle(ref, fn).\n    // For additionally configured Hooks, assume that they're like useEffect (0).\n\n\n    function getReactiveHookCallbackIndex(calleeNode, options) {\n      var node = getNodeWithoutReactNamespace(calleeNode);\n\n      if (node.type !== 'Identifier') {\n        return -1;\n      }\n\n      switch (node.name) {\n        case 'useEffect':\n        case 'useLayoutEffect':\n        case 'useCallback':\n        case 'useMemo':\n          // useEffect(fn)\n          return 0;\n\n        case 'useImperativeHandle':\n          // useImperativeHandle(ref, fn)\n          return 1;\n\n        default:\n          if (node === calleeNode && options && options.additionalHooks) {\n            // Allow the user to provide a regular expression which enables the lint to\n            // target custom reactive hooks.\n            var name;\n\n            try {\n              name = analyzePropertyChain(node, null);\n            } catch (error) {\n              if (/Unsupported node type/.test(error.message)) {\n                return 0;\n              } else {\n                throw error;\n              }\n            }\n\n            return options.additionalHooks.test(name) ? 0 : -1;\n          } else {\n            return -1;\n          }\n\n      }\n    }\n    /**\n     * ESLint won't assign node.parent to references from context.getScope()\n     *\n     * So instead we search for the node from an ancestor assigning node.parent\n     * as we go. This mutates the AST.\n     *\n     * This traversal is:\n     * - optimized by only searching nodes with a range surrounding our target node\n     * - agnostic to AST node types, it looks for `{ type: string, ... }`\n     */\n\n\n    function fastFindReferenceWithParent(start, target) {\n      var queue = [start];\n      var item = null;\n\n      while (queue.length) {\n        item = queue.shift();\n\n        if (isSameIdentifier(item, target)) {\n          return item;\n        }\n\n        if (!isAncestorNodeOf(item, target)) {\n          continue;\n        }\n\n        for (var _i4 = 0, _Object$entries = Object.entries(item); _i4 < _Object$entries.length; _i4++) {\n          var _Object$entries$_i = _Object$entries[_i4],\n              key = _Object$entries$_i[0],\n              value = _Object$entries$_i[1];\n\n          if (key === 'parent') {\n            continue;\n          }\n\n          if (isNodeLike(value)) {\n            value.parent = item;\n            queue.push(value);\n          } else if (Array.isArray(value)) {\n            value.forEach(function (val) {\n              if (isNodeLike(val)) {\n                val.parent = item;\n                queue.push(val);\n              }\n            });\n          }\n        }\n      }\n\n      return null;\n    }\n\n    function joinEnglish(arr) {\n      var s = '';\n\n      for (var i = 0; i < arr.length; i++) {\n        s += arr[i];\n\n        if (i === 0 && arr.length === 2) {\n          s += ' and ';\n        } else if (i === arr.length - 2 && arr.length > 2) {\n          s += ', and ';\n        } else if (i < arr.length - 1) {\n          s += ', ';\n        }\n      }\n\n      return s;\n    }\n\n    function isNodeLike(val) {\n      return typeof val === 'object' && val !== null && !Array.isArray(val) && typeof val.type === 'string';\n    }\n\n    function isSameIdentifier(a, b) {\n      return (a.type === 'Identifier' || a.type === 'JSXIdentifier') && a.type === b.type && a.name === b.name && a.range[0] === b.range[0] && a.range[1] === b.range[1];\n    }\n\n    function isAncestorNodeOf(a, b) {\n      return a.range[0] <= b.range[0] && a.range[1] >= b.range[1];\n    }\n\n    var configs = {\n      recommended: {\n        plugins: ['react-hooks'],\n        rules: {\n          'react-hooks/rules-of-hooks': 'error',\n          'react-hooks/exhaustive-deps': 'warn'\n        }\n      }\n    };\n    var rules = {\n      'rules-of-hooks': RulesOfHooks,\n      'exhaustive-deps': ExhaustiveDeps\n    };\n    exports.configs = configs;\n    exports.rules = rules;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","_unsupportedIterableToArray","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","arr","len","length","i","arr2","_createForOfIteratorHelper","allowArrayLike","it","Symbol","iterator","isArray","F","s","done","value","e","f","TypeError","normalCompletion","didErr","err","step","next","return","isHookName","isHook","node","type","computed","property","obj","object","isPascalCaseNameSpace","isComponentName","isReactFunction","functionName","isForwardRefCallback","parent","callee","isMemoCallback","isInsideComponentOrHook","getFunctionName","RulesOfHooks","meta","docs","description","recommended","url","create","context","codePathReactHooksMapStack","codePathSegmentStack","onCodePathSegmentStart","segment","push","onCodePathSegmentEnd","pop","onCodePathStart","Map","onCodePathEnd","codePath","codePathNode","reactHooksMap","size","cyclic","Set","countPathsFromStart","pathHistory","cache","paths","get","id","pathList","has","pathArray","concat","cyclicSegments","indexOf","_iterator","_step","cyclicSegment","add","BigInt","undefined","thrownSegments","includes","prevSegments","_iterator2","_step2","prevSegment","reachable","delete","set","countPathsToEnd","_iterator3","_step3","nextSegments","_iterator4","_step4","nextSegment","shortestPathLengthToStart","Infinity","_iterator5","_step5","prevLength","allPathsFromStartToEnd","initialSegment","codePathFunctionName","isSomewhereInsideComponentOrHook","isDirectlyInsideComponentOrHook","shortestFinalPathLength","_iterator6","finalSegments","_step6","finalSegment","_iterator7","_step7","_step7$value","reactHooks","possiblyHasEarlyReturn","pathsFromStartToEnd","cycled","_iterator8","_step8","hook","report","message","getSource","_message","_message2","_message3","_message4","CallExpression","last","codePathSegment","init","right","operator","left","key","array","ExhaustiveDeps","fixable","hasSuggestions","schema","additionalProperties","enableDangerousAutofixThisMayCauseInfiniteLoops","properties","additionalHooks","options","RegExp","reportProblem","problem","suggest","fix","scopeManager","getSourceCode","setStateCallSites","WeakMap","stateVariables","WeakSet","stableKnownValueCache","functionWithoutCapturedValueCache","memoizeWithWeakMap","fn","map","arg","result","visitFunctionWithDependencies","declaredDependenciesNode","reactiveHook","reactiveHookName","isEffect","async","scope","acquire","pureScopes","componentScope","currentScope","upper","isStableKnownHookValue","resolved","defs","def","expression","declaration","fastFindReferenceWithParent","block","kind","_callee","elements","identifiers","references","writeCount","isWrite","identifier","_references","_i","isFunctionWithoutCapturedValues","fnNode","childScopes","fnScope","childScope","childScopeBlock","through","ref","memoizedIsStableKnownHookValue","memoizedIsFunctionWithoutCapturedValues","currentRefsInEffectCleanup","isInsideEffectCleanup","reference","curScope","isInReturnedFunction","dependencies","optionalChains","gatherDependenciesRecursively","referenceNode","dependencyNode","getDependency","dependency","analyzePropertyChain","isStable","forEach","_ref","foundCurrentAssignment","staleAssignments","reportStaleAssignment","writeExpr","stableDependencies","_ref2","setStateInsideEffectWithoutDeps","_ref3","isSetState","isDirectlyInsideEffect","_collectRecommendatio","collectRecommendations","declaredDependencies","externalDependencies","_suggestedDependencies","suggestedDependencies","join","desc","fixer","insertTextAfter","declaredDependencyNode","declaredDependency","error","raw","maybeID","isDeclaredInComponent","some","_collectRecommendatio2","unnecessaryDependencies","missingDependencies","duplicateDependencies","suggestedDeps","problemCount","constructions","scanForConstructions","_ref4","construction","isUsedOutsideOfHook","depType","wrapperHook","constructionType","defaultAdvice","advice","causation","loc","start","line","_ref5","before","after","insertTextBefore","areDeclaredDepsAlphabetized","declaredDepKeys","dep","sortedDeclaredDepKeys","sort","formatDependency","path","members","split","finalPath","pathSoFar","isOptional","getWarningMessage","deps","singlePrefix","label","fixVerb","joinEnglish","extraWarning","badRef","keys","endsWith","propDep","refs","isPropsOnlyUsedInMembers","missingCallbackDep","missingDep","topScopeRef","usedDep","isFunctionCall","_i2","setStateRecommendation","maybeCall","_i3","correspondingStateVariable","setter","form","substring","Error","replaceText","visitCallExpression","callbackIndex","getReactiveHookCallbackIndex","callback","arguments","getNodeWithoutReactNamespace","el","variable","getScope","_ref6","depTree","createDepTree","isUsed","isSatisfiedRecursively","isSubtreeUsed","children","_","getOrCreateNodeByPath","markAllParentsByPath","_ref7","rootNode","child","satisfyingDependencies","scanTreeRecursively","missingPaths","satisfyingPaths","keyToPath","childKey","_ref8","getConstructionExpressionType","consequent","alternate","_ref9","_ref10","variables","find","v","constantExpressionType","filter","Boolean","foundWriteExpr","isAncestorNodeOf","_ref11","markNode","optional","_result","_object","_property","_result2","_object2","_property2","_result3","calleeNode","target","queue","item","shift","isSameIdentifier","_i4","_Object$entries","entries","_Object$entries$_i","isNodeLike","val","a","b","range","configs","plugins","rules","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react-hooks/cjs/eslint-plugin-react-hooks.development.js"],"sourcesContent":["/**\n * @license React\n * eslint-plugin-react-hooks.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\n/* global BigInt */\n\nfunction isHookName(s) {\n  return /^use[A-Z0-9].*$/.test(s);\n}\n/**\n * We consider hooks to be a hook name identifier or a member expression\n * containing a hook name.\n */\n\n\nfunction isHook(node) {\n  if (node.type === 'Identifier') {\n    return isHookName(node.name);\n  } else if (node.type === 'MemberExpression' && !node.computed && isHook(node.property)) {\n    var obj = node.object;\n    var isPascalCaseNameSpace = /^[A-Z].*/;\n    return obj.type === 'Identifier' && isPascalCaseNameSpace.test(obj.name);\n  } else {\n    return false;\n  }\n}\n/**\n * Checks if the node is a React component name. React component names must\n * always start with a non-lowercase letter. So `MyComponent` or `_MyComponent`\n * are valid component names for instance.\n */\n\n\nfunction isComponentName(node) {\n  if (node.type === 'Identifier') {\n    return !/^[a-z]/.test(node.name);\n  } else {\n    return false;\n  }\n}\n\nfunction isReactFunction(node, functionName) {\n  return node.name === functionName || node.type === 'MemberExpression' && node.object.name === 'React' && node.property.name === functionName;\n}\n/**\n * Checks if the node is a callback argument of forwardRef. This render function\n * should follow the rules of hooks.\n */\n\n\nfunction isForwardRefCallback(node) {\n  return !!(node.parent && node.parent.callee && isReactFunction(node.parent.callee, 'forwardRef'));\n}\n/**\n * Checks if the node is a callback argument of React.memo. This anonymous\n * functional component should follow the rules of hooks.\n */\n\n\nfunction isMemoCallback(node) {\n  return !!(node.parent && node.parent.callee && isReactFunction(node.parent.callee, 'memo'));\n}\n\nfunction isInsideComponentOrHook(node) {\n  while (node) {\n    var functionName = getFunctionName(node);\n\n    if (functionName) {\n      if (isComponentName(functionName) || isHook(functionName)) {\n        return true;\n      }\n    }\n\n    if (isForwardRefCallback(node) || isMemoCallback(node)) {\n      return true;\n    }\n\n    node = node.parent;\n  }\n\n  return false;\n}\n\nvar RulesOfHooks = {\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'enforces the Rules of Hooks',\n      recommended: true,\n      url: 'https://reactjs.org/docs/hooks-rules.html'\n    }\n  },\n  create: function (context) {\n    var codePathReactHooksMapStack = [];\n    var codePathSegmentStack = [];\n    return {\n      // Maintain code segment path stack as we traverse.\n      onCodePathSegmentStart: function (segment) {\n        return codePathSegmentStack.push(segment);\n      },\n      onCodePathSegmentEnd: function () {\n        return codePathSegmentStack.pop();\n      },\n      // Maintain code path stack as we traverse.\n      onCodePathStart: function () {\n        return codePathReactHooksMapStack.push(new Map());\n      },\n      // Process our code path.\n      //\n      // Everything is ok if all React Hooks are both reachable from the initial\n      // segment and reachable from every final segment.\n      onCodePathEnd: function (codePath, codePathNode) {\n        var reactHooksMap = codePathReactHooksMapStack.pop();\n\n        if (reactHooksMap.size === 0) {\n          return;\n        } // All of the segments which are cyclic are recorded in this set.\n\n\n        var cyclic = new Set();\n        /**\n         * Count the number of code paths from the start of the function to this\n         * segment. For example:\n         *\n         * ```js\n         * function MyComponent() {\n         *   if (condition) {\n         *     // Segment 1\n         *   } else {\n         *     // Segment 2\n         *   }\n         *   // Segment 3\n         * }\n         * ```\n         *\n         * Segments 1 and 2 have one path to the beginning of `MyComponent` and\n         * segment 3 has two paths to the beginning of `MyComponent` since we\n         * could have either taken the path of segment 1 or segment 2.\n         *\n         * Populates `cyclic` with cyclic segments.\n         */\n\n        function countPathsFromStart(segment, pathHistory) {\n          var cache = countPathsFromStart.cache;\n          var paths = cache.get(segment.id);\n          var pathList = new Set(pathHistory); // If `pathList` includes the current segment then we've found a cycle!\n          // We need to fill `cyclic` with all segments inside cycle\n\n          if (pathList.has(segment.id)) {\n            var pathArray = [].concat(pathList);\n            var cyclicSegments = pathArray.slice(pathArray.indexOf(segment.id) + 1);\n\n            var _iterator = _createForOfIteratorHelper(cyclicSegments),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var cyclicSegment = _step.value;\n                cyclic.add(cyclicSegment);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            return BigInt('0');\n          } // add the current segment to pathList\n\n\n          pathList.add(segment.id); // We have a cached `paths`. Return it.\n\n          if (paths !== undefined) {\n            return paths;\n          }\n\n          if (codePath.thrownSegments.includes(segment)) {\n            paths = BigInt('0');\n          } else if (segment.prevSegments.length === 0) {\n            paths = BigInt('1');\n          } else {\n            paths = BigInt('0');\n\n            var _iterator2 = _createForOfIteratorHelper(segment.prevSegments),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var prevSegment = _step2.value;\n                paths += countPathsFromStart(prevSegment, pathList);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          } // If our segment is reachable then there should be at least one path\n          // to it from the start of our code path.\n\n\n          if (segment.reachable && paths === BigInt('0')) {\n            cache.delete(segment.id);\n          } else {\n            cache.set(segment.id, paths);\n          }\n\n          return paths;\n        }\n        /**\n         * Count the number of code paths from this segment to the end of the\n         * function. For example:\n         *\n         * ```js\n         * function MyComponent() {\n         *   // Segment 1\n         *   if (condition) {\n         *     // Segment 2\n         *   } else {\n         *     // Segment 3\n         *   }\n         * }\n         * ```\n         *\n         * Segments 2 and 3 have one path to the end of `MyComponent` and\n         * segment 1 has two paths to the end of `MyComponent` since we could\n         * either take the path of segment 1 or segment 2.\n         *\n         * Populates `cyclic` with cyclic segments.\n         */\n\n\n        function countPathsToEnd(segment, pathHistory) {\n          var cache = countPathsToEnd.cache;\n          var paths = cache.get(segment.id);\n          var pathList = new Set(pathHistory); // If `pathList` includes the current segment then we've found a cycle!\n          // We need to fill `cyclic` with all segments inside cycle\n\n          if (pathList.has(segment.id)) {\n            var pathArray = Array.from(pathList);\n            var cyclicSegments = pathArray.slice(pathArray.indexOf(segment.id) + 1);\n\n            var _iterator3 = _createForOfIteratorHelper(cyclicSegments),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var cyclicSegment = _step3.value;\n                cyclic.add(cyclicSegment);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n\n            return BigInt('0');\n          } // add the current segment to pathList\n\n\n          pathList.add(segment.id); // We have a cached `paths`. Return it.\n\n          if (paths !== undefined) {\n            return paths;\n          }\n\n          if (codePath.thrownSegments.includes(segment)) {\n            paths = BigInt('0');\n          } else if (segment.nextSegments.length === 0) {\n            paths = BigInt('1');\n          } else {\n            paths = BigInt('0');\n\n            var _iterator4 = _createForOfIteratorHelper(segment.nextSegments),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var nextSegment = _step4.value;\n                paths += countPathsToEnd(nextSegment, pathList);\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          }\n\n          cache.set(segment.id, paths);\n          return paths;\n        }\n        /**\n         * Gets the shortest path length to the start of a code path.\n         * For example:\n         *\n         * ```js\n         * function MyComponent() {\n         *   if (condition) {\n         *     // Segment 1\n         *   }\n         *   // Segment 2\n         * }\n         * ```\n         *\n         * There is only one path from segment 1 to the code path start. Its\n         * length is one so that is the shortest path.\n         *\n         * There are two paths from segment 2 to the code path start. One\n         * through segment 1 with a length of two and another directly to the\n         * start with a length of one. The shortest path has a length of one\n         * so we would return that.\n         */\n\n\n        function shortestPathLengthToStart(segment) {\n          var cache = shortestPathLengthToStart.cache;\n          var length = cache.get(segment.id); // If `length` is null then we found a cycle! Return infinity since\n          // the shortest path is definitely not the one where we looped.\n\n          if (length === null) {\n            return Infinity;\n          } // We have a cached `length`. Return it.\n\n\n          if (length !== undefined) {\n            return length;\n          } // Compute `length` and cache it. Guarding against cycles.\n\n\n          cache.set(segment.id, null);\n\n          if (segment.prevSegments.length === 0) {\n            length = 1;\n          } else {\n            length = Infinity;\n\n            var _iterator5 = _createForOfIteratorHelper(segment.prevSegments),\n                _step5;\n\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var prevSegment = _step5.value;\n                var prevLength = shortestPathLengthToStart(prevSegment);\n\n                if (prevLength < length) {\n                  length = prevLength;\n                }\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n\n            length += 1;\n          }\n\n          cache.set(segment.id, length);\n          return length;\n        }\n\n        countPathsFromStart.cache = new Map();\n        countPathsToEnd.cache = new Map();\n        shortestPathLengthToStart.cache = new Map(); // Count all code paths to the end of our component/hook. Also primes\n        // the `countPathsToEnd` cache.\n\n        var allPathsFromStartToEnd = countPathsToEnd(codePath.initialSegment); // Gets the function name for our code path. If the function name is\n        // `undefined` then we know either that we have an anonymous function\n        // expression or our code path is not in a function. In both cases we\n        // will want to error since neither are React function components or\n        // hook functions - unless it is an anonymous function argument to\n        // forwardRef or memo.\n\n        var codePathFunctionName = getFunctionName(codePathNode); // This is a valid code path for React hooks if we are directly in a React\n        // function component or we are in a hook function.\n\n        var isSomewhereInsideComponentOrHook = isInsideComponentOrHook(codePathNode);\n        var isDirectlyInsideComponentOrHook = codePathFunctionName ? isComponentName(codePathFunctionName) || isHook(codePathFunctionName) : isForwardRefCallback(codePathNode) || isMemoCallback(codePathNode); // Compute the earliest finalizer level using information from the\n        // cache. We expect all reachable final segments to have a cache entry\n        // after calling `visitSegment()`.\n\n        var shortestFinalPathLength = Infinity;\n\n        var _iterator6 = _createForOfIteratorHelper(codePath.finalSegments),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var finalSegment = _step6.value;\n\n            if (!finalSegment.reachable) {\n              continue;\n            }\n\n            var length = shortestPathLengthToStart(finalSegment);\n\n            if (length < shortestFinalPathLength) {\n              shortestFinalPathLength = length;\n            }\n          } // Make sure all React Hooks pass our lint invariants. Log warnings\n          // if not.\n\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        var _iterator7 = _createForOfIteratorHelper(reactHooksMap),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var _step7$value = _step7.value,\n                segment = _step7$value[0],\n                reactHooks = _step7$value[1];\n\n            // NOTE: We could report here that the hook is not reachable, but\n            // that would be redundant with more general \"no unreachable\"\n            // lint rules.\n            if (!segment.reachable) {\n              continue;\n            } // If there are any final segments with a shorter path to start then\n            // we possibly have an early return.\n            //\n            // If our segment is a final segment itself then siblings could\n            // possibly be early returns.\n\n\n            var possiblyHasEarlyReturn = segment.nextSegments.length === 0 ? shortestFinalPathLength <= shortestPathLengthToStart(segment) : shortestFinalPathLength < shortestPathLengthToStart(segment); // Count all the paths from the start of our code path to the end of\n            // our code path that go _through_ this segment. The critical piece\n            // of this is _through_. If we just call `countPathsToEnd(segment)`\n            // then we neglect that we may have gone through multiple paths to get\n            // to this point! Consider:\n            //\n            // ```js\n            // function MyComponent() {\n            //   if (a) {\n            //     // Segment 1\n            //   } else {\n            //     // Segment 2\n            //   }\n            //   // Segment 3\n            //   if (b) {\n            //     // Segment 4\n            //   } else {\n            //     // Segment 5\n            //   }\n            // }\n            // ```\n            //\n            // In this component we have four code paths:\n            //\n            // 1. `a = true; b = true`\n            // 2. `a = true; b = false`\n            // 3. `a = false; b = true`\n            // 4. `a = false; b = false`\n            //\n            // From segment 3 there are two code paths to the end through segment\n            // 4 and segment 5. However, we took two paths to get here through\n            // segment 1 and segment 2.\n            //\n            // If we multiply the paths from start (two) by the paths to end (two)\n            // for segment 3 we get four. Which is our desired count.\n\n            var pathsFromStartToEnd = countPathsFromStart(segment) * countPathsToEnd(segment); // Is this hook a part of a cyclic segment?\n\n            var cycled = cyclic.has(segment.id);\n\n            var _iterator8 = _createForOfIteratorHelper(reactHooks),\n                _step8;\n\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var hook = _step8.value;\n\n                // Report an error if a hook may be called more then once.\n                if (cycled) {\n                  context.report({\n                    node: hook,\n                    message: \"React Hook \\\"\" + context.getSource(hook) + \"\\\" may be executed \" + 'more than once. Possibly because it is called in a loop. ' + 'React Hooks must be called in the exact same order in ' + 'every component render.'\n                  });\n                } // If this is not a valid code path for React hooks then we need to\n                // log a warning for every hook in this code path.\n                //\n                // Pick a special message depending on the scope this hook was\n                // called in.\n\n\n                if (isDirectlyInsideComponentOrHook) {\n                  // Report an error if a hook does not reach all finalizing code\n                  // path segments.\n                  //\n                  // Special case when we think there might be an early return.\n                  if (!cycled && pathsFromStartToEnd !== allPathsFromStartToEnd) {\n                    var message = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" is called \" + 'conditionally. React Hooks must be called in the exact ' + 'same order in every component render.' + (possiblyHasEarlyReturn ? ' Did you accidentally call a React Hook after an' + ' early return?' : '');\n                    context.report({\n                      node: hook,\n                      message: message\n                    });\n                  }\n                } else if (codePathNode.parent && (codePathNode.parent.type === 'MethodDefinition' || codePathNode.parent.type === 'ClassProperty') && codePathNode.parent.value === codePathNode) {\n                  // Custom message for hooks inside a class\n                  var _message = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" cannot be called \" + 'in a class component. React Hooks must be called in a ' + 'React function component or a custom React Hook function.';\n\n                  context.report({\n                    node: hook,\n                    message: _message\n                  });\n                } else if (codePathFunctionName) {\n                  // Custom message if we found an invalid function name.\n                  var _message2 = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" is called in \" + (\"function \\\"\" + context.getSource(codePathFunctionName) + \"\\\" \") + 'that is neither a React function component nor a custom ' + 'React Hook function.' + ' React component names must start with an uppercase letter.' + ' React Hook names must start with the word \"use\".';\n\n                  context.report({\n                    node: hook,\n                    message: _message2\n                  });\n                } else if (codePathNode.type === 'Program') {\n                  // These are dangerous if you have inline requires enabled.\n                  var _message3 = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" cannot be called \" + 'at the top level. React Hooks must be called in a ' + 'React function component or a custom React Hook function.';\n\n                  context.report({\n                    node: hook,\n                    message: _message3\n                  });\n                } else {\n                  // Assume in all other cases the user called a hook in some\n                  // random function callback. This should usually be true for\n                  // anonymous function expressions. Hopefully this is clarifying\n                  // enough in the common case that the incorrect message in\n                  // uncommon cases doesn't matter.\n                  if (isSomewhereInsideComponentOrHook) {\n                    var _message4 = \"React Hook \\\"\" + context.getSource(hook) + \"\\\" cannot be called \" + 'inside a callback. React Hooks must be called in a ' + 'React function component or a custom React Hook function.';\n\n                    context.report({\n                      node: hook,\n                      message: _message4\n                    });\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      },\n      // Missed opportunity...We could visit all `Identifier`s instead of all\n      // `CallExpression`s and check that _every use_ of a hook name is valid.\n      // But that gets complicated and enters type-system territory, so we're\n      // only being strict about hook calls for now.\n      CallExpression: function (node) {\n        if (isHook(node.callee)) {\n          // Add the hook node to a map keyed by the code path segment. We will\n          // do full code path analysis at the end of our code path.\n          var reactHooksMap = last(codePathReactHooksMapStack);\n          var codePathSegment = last(codePathSegmentStack);\n          var reactHooks = reactHooksMap.get(codePathSegment);\n\n          if (!reactHooks) {\n            reactHooks = [];\n            reactHooksMap.set(codePathSegment, reactHooks);\n          }\n\n          reactHooks.push(node.callee);\n        }\n      }\n    };\n  }\n};\n/**\n * Gets the static name of a function AST node. For function declarations it is\n * easy. For anonymous function expressions it is much harder. If you search for\n * `IsAnonymousFunctionDefinition()` in the ECMAScript spec you'll find places\n * where JS gives anonymous function expressions names. We roughly detect the\n * same AST nodes with some exceptions to better fit our use case.\n */\n\nfunction getFunctionName(node) {\n  if (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' && node.id) {\n    // function useHook() {}\n    // const whatever = function useHook() {};\n    //\n    // Function declaration or function expression names win over any\n    // assignment statements or other renames.\n    return node.id;\n  } else if (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') {\n    if (node.parent.type === 'VariableDeclarator' && node.parent.init === node) {\n      // const useHook = () => {};\n      return node.parent.id;\n    } else if (node.parent.type === 'AssignmentExpression' && node.parent.right === node && node.parent.operator === '=') {\n      // useHook = () => {};\n      return node.parent.left;\n    } else if (node.parent.type === 'Property' && node.parent.value === node && !node.parent.computed) {\n      // {useHook: () => {}}\n      // {useHook() {}}\n      return node.parent.key; // NOTE: We could also support `ClassProperty` and `MethodDefinition`\n      // here to be pedantic. However, hooks in a class are an anti-pattern. So\n      // we don't allow it to error early.\n      //\n      // class {useHook = () => {}}\n      // class {useHook() {}}\n    } else if (node.parent.type === 'AssignmentPattern' && node.parent.right === node && !node.parent.computed) {\n      // const {useHook = () => {}} = {};\n      // ({useHook = () => {}} = {});\n      //\n      // Kinda clowny, but we'd said we'd follow spec convention for\n      // `IsAnonymousFunctionDefinition()` usage.\n      return node.parent.left;\n    } else {\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n}\n/**\n * Convenience function for peeking the last item in a stack.\n */\n\n\nfunction last(array) {\n  return array[array.length - 1];\n}\n\n/* eslint-disable no-for-of-loops/no-for-of-loops */\nvar ExhaustiveDeps = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'verifies the list of dependencies for Hooks like useEffect and similar',\n      recommended: true,\n      url: 'https://github.com/facebook/react/issues/14920'\n    },\n    fixable: 'code',\n    hasSuggestions: true,\n    schema: [{\n      type: 'object',\n      additionalProperties: false,\n      enableDangerousAutofixThisMayCauseInfiniteLoops: false,\n      properties: {\n        additionalHooks: {\n          type: 'string'\n        },\n        enableDangerousAutofixThisMayCauseInfiniteLoops: {\n          type: 'boolean'\n        }\n      }\n    }]\n  },\n  create: function (context) {\n    // Parse the `additionalHooks` regex.\n    var additionalHooks = context.options && context.options[0] && context.options[0].additionalHooks ? new RegExp(context.options[0].additionalHooks) : undefined;\n    var enableDangerousAutofixThisMayCauseInfiniteLoops = context.options && context.options[0] && context.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops || false;\n    var options = {\n      additionalHooks: additionalHooks,\n      enableDangerousAutofixThisMayCauseInfiniteLoops: enableDangerousAutofixThisMayCauseInfiniteLoops\n    };\n\n    function reportProblem(problem) {\n      if (enableDangerousAutofixThisMayCauseInfiniteLoops) {\n        // Used to enable legacy behavior. Dangerous.\n        // Keep this as an option until major IDEs upgrade (including VSCode FB ESLint extension).\n        if (Array.isArray(problem.suggest) && problem.suggest.length > 0) {\n          problem.fix = problem.suggest[0].fix;\n        }\n      }\n\n      context.report(problem);\n    }\n\n    var scopeManager = context.getSourceCode().scopeManager; // Should be shared between visitors.\n\n    var setStateCallSites = new WeakMap();\n    var stateVariables = new WeakSet();\n    var stableKnownValueCache = new WeakMap();\n    var functionWithoutCapturedValueCache = new WeakMap();\n\n    function memoizeWithWeakMap(fn, map) {\n      return function (arg) {\n        if (map.has(arg)) {\n          // to verify cache hits:\n          // console.log(arg.name)\n          return map.get(arg);\n        }\n\n        var result = fn(arg);\n        map.set(arg, result);\n        return result;\n      };\n    }\n    /**\n     * Visitor for both function expressions and arrow function expressions.\n     */\n\n\n    function visitFunctionWithDependencies(node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect) {\n      if (isEffect && node.async) {\n        reportProblem({\n          node: node,\n          message: \"Effect callbacks are synchronous to prevent race conditions. \" + \"Put the async function inside:\\n\\n\" + 'useEffect(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching'\n        });\n      } // Get the current scope.\n\n\n      var scope = scopeManager.acquire(node); // Find all our \"pure scopes\". On every re-render of a component these\n      // pure scopes may have changes to the variables declared within. So all\n      // variables used in our reactive hook callback but declared in a pure\n      // scope need to be listed as dependencies of our reactive hook callback.\n      //\n      // According to the rules of React you can't read a mutable value in pure\n      // scope. We can't enforce this in a lint so we trust that all variables\n      // declared outside of pure scope are indeed frozen.\n\n      var pureScopes = new Set();\n      var componentScope = null;\n      {\n        var currentScope = scope.upper;\n\n        while (currentScope) {\n          pureScopes.add(currentScope);\n\n          if (currentScope.type === 'function') {\n            break;\n          }\n\n          currentScope = currentScope.upper;\n        } // If there is no parent function scope then there are no pure scopes.\n        // The ones we've collected so far are incorrect. So don't continue with\n        // the lint.\n\n\n        if (!currentScope) {\n          return;\n        }\n\n        componentScope = currentScope;\n      }\n      var isArray = Array.isArray; // Next we'll define a few helpers that helps us\n      // tell if some values don't have to be declared as deps.\n      // Some are known to be stable based on Hook calls.\n      // const [state, setState] = useState() / React.useState()\n      //               ^^^ true for this reference\n      // const [state, dispatch] = useReducer() / React.useReducer()\n      //               ^^^ true for this reference\n      // const ref = useRef()\n      //       ^^^ true for this reference\n      // False for everything else.\n\n      function isStableKnownHookValue(resolved) {\n        if (!isArray(resolved.defs)) {\n          return false;\n        }\n\n        var def = resolved.defs[0];\n\n        if (def == null) {\n          return false;\n        } // Look for `let stuff = ...`\n\n\n        if (def.node.type !== 'VariableDeclarator') {\n          return false;\n        }\n\n        var init = def.node.init;\n\n        if (init == null) {\n          return false;\n        }\n\n        while (init.type === 'TSAsExpression') {\n          init = init.expression;\n        } // Detect primitive constants\n        // const foo = 42\n\n\n        var declaration = def.node.parent;\n\n        if (declaration == null) {\n          // This might happen if variable is declared after the callback.\n          // In that case ESLint won't set up .parent refs.\n          // So we'll set them up manually.\n          fastFindReferenceWithParent(componentScope.block, def.node.id);\n          declaration = def.node.parent;\n\n          if (declaration == null) {\n            return false;\n          }\n        }\n\n        if (declaration.kind === 'const' && init.type === 'Literal' && (typeof init.value === 'string' || typeof init.value === 'number' || init.value === null)) {\n          // Definitely stable\n          return true;\n        } // Detect known Hook calls\n        // const [_, setState] = useState()\n\n\n        if (init.type !== 'CallExpression') {\n          return false;\n        }\n\n        var callee = init.callee; // Step into `= React.something` initializer.\n\n        if (callee.type === 'MemberExpression' && callee.object.name === 'React' && callee.property != null && !callee.computed) {\n          callee = callee.property;\n        }\n\n        if (callee.type !== 'Identifier') {\n          return false;\n        }\n\n        var id = def.node.id;\n        var _callee = callee,\n            name = _callee.name;\n\n        if (name === 'useRef' && id.type === 'Identifier') {\n          // useRef() return value is stable.\n          return true;\n        } else if (name === 'useState' || name === 'useReducer') {\n          // Only consider second value in initializing tuple stable.\n          if (id.type === 'ArrayPattern' && id.elements.length === 2 && isArray(resolved.identifiers)) {\n            // Is second tuple value the same reference we're checking?\n            if (id.elements[1] === resolved.identifiers[0]) {\n              if (name === 'useState') {\n                var references = resolved.references;\n                var writeCount = 0;\n\n                for (var i = 0; i < references.length; i++) {\n                  if (references[i].isWrite()) {\n                    writeCount++;\n                  }\n\n                  if (writeCount > 1) {\n                    return false;\n                  }\n\n                  setStateCallSites.set(references[i].identifier, id.elements[0]);\n                }\n              } // Setter is stable.\n\n\n              return true;\n            } else if (id.elements[0] === resolved.identifiers[0]) {\n              if (name === 'useState') {\n                var _references = resolved.references;\n\n                for (var _i = 0; _i < _references.length; _i++) {\n                  stateVariables.add(_references[_i].identifier);\n                }\n              } // State variable itself is dynamic.\n\n\n              return false;\n            }\n          }\n        } else if (name === 'useTransition') {\n          // Only consider second value in initializing tuple stable.\n          if (id.type === 'ArrayPattern' && id.elements.length === 2 && Array.isArray(resolved.identifiers)) {\n            // Is second tuple value the same reference we're checking?\n            if (id.elements[1] === resolved.identifiers[0]) {\n              // Setter is stable.\n              return true;\n            }\n          }\n        } // By default assume it's dynamic.\n\n\n        return false;\n      } // Some are just functions that don't reference anything dynamic.\n\n\n      function isFunctionWithoutCapturedValues(resolved) {\n        if (!isArray(resolved.defs)) {\n          return false;\n        }\n\n        var def = resolved.defs[0];\n\n        if (def == null) {\n          return false;\n        }\n\n        if (def.node == null || def.node.id == null) {\n          return false;\n        } // Search the direct component subscopes for\n        // top-level function definitions matching this reference.\n\n\n        var fnNode = def.node;\n        var childScopes = componentScope.childScopes;\n        var fnScope = null;\n        var i;\n\n        for (i = 0; i < childScopes.length; i++) {\n          var childScope = childScopes[i];\n          var childScopeBlock = childScope.block;\n\n          if ( // function handleChange() {}\n          fnNode.type === 'FunctionDeclaration' && childScopeBlock === fnNode || // const handleChange = () => {}\n          // const handleChange = function() {}\n          fnNode.type === 'VariableDeclarator' && childScopeBlock.parent === fnNode) {\n            // Found it!\n            fnScope = childScope;\n            break;\n          }\n        }\n\n        if (fnScope == null) {\n          return false;\n        } // Does this function capture any values\n        // that are in pure scopes (aka render)?\n\n\n        for (i = 0; i < fnScope.through.length; i++) {\n          var ref = fnScope.through[i];\n\n          if (ref.resolved == null) {\n            continue;\n          }\n\n          if (pureScopes.has(ref.resolved.scope) && // Stable values are fine though,\n          // although we won't check functions deeper.\n          !memoizedIsStableKnownHookValue(ref.resolved)) {\n            return false;\n          }\n        } // If we got here, this function doesn't capture anything\n        // from render--or everything it captures is known stable.\n\n\n        return true;\n      } // Remember such values. Avoid re-running extra checks on them.\n\n\n      var memoizedIsStableKnownHookValue = memoizeWithWeakMap(isStableKnownHookValue, stableKnownValueCache);\n      var memoizedIsFunctionWithoutCapturedValues = memoizeWithWeakMap(isFunctionWithoutCapturedValues, functionWithoutCapturedValueCache); // These are usually mistaken. Collect them.\n\n      var currentRefsInEffectCleanup = new Map(); // Is this reference inside a cleanup function for this effect node?\n      // We can check by traversing scopes upwards  from the reference, and checking\n      // if the last \"return () => \" we encounter is located directly inside the effect.\n\n      function isInsideEffectCleanup(reference) {\n        var curScope = reference.from;\n        var isInReturnedFunction = false;\n\n        while (curScope.block !== node) {\n          if (curScope.type === 'function') {\n            isInReturnedFunction = curScope.block.parent != null && curScope.block.parent.type === 'ReturnStatement';\n          }\n\n          curScope = curScope.upper;\n        }\n\n        return isInReturnedFunction;\n      } // Get dependencies from all our resolved references in pure scopes.\n      // Key is dependency string, value is whether it's stable.\n\n\n      var dependencies = new Map();\n      var optionalChains = new Map();\n      gatherDependenciesRecursively(scope);\n\n      function gatherDependenciesRecursively(currentScope) {\n        var _iterator = _createForOfIteratorHelper(currentScope.references),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var reference = _step.value;\n\n            // If this reference is not resolved or it is not declared in a pure\n            // scope then we don't care about this reference.\n            if (!reference.resolved) {\n              continue;\n            }\n\n            if (!pureScopes.has(reference.resolved.scope)) {\n              continue;\n            } // Narrow the scope of a dependency if it is, say, a member expression.\n            // Then normalize the narrowed dependency.\n\n\n            var referenceNode = fastFindReferenceWithParent(node, reference.identifier);\n            var dependencyNode = getDependency(referenceNode);\n            var dependency = analyzePropertyChain(dependencyNode, optionalChains); // Accessing ref.current inside effect cleanup is bad.\n\n            if ( // We're in an effect...\n            isEffect && // ... and this look like accessing .current...\n            dependencyNode.type === 'Identifier' && (dependencyNode.parent.type === 'MemberExpression' || dependencyNode.parent.type === 'OptionalMemberExpression') && !dependencyNode.parent.computed && dependencyNode.parent.property.type === 'Identifier' && dependencyNode.parent.property.name === 'current' && // ...in a cleanup function or below...\n            isInsideEffectCleanup(reference)) {\n              currentRefsInEffectCleanup.set(dependency, {\n                reference: reference,\n                dependencyNode: dependencyNode\n              });\n            }\n\n            if (dependencyNode.parent.type === 'TSTypeQuery' || dependencyNode.parent.type === 'TSTypeReference') {\n              continue;\n            }\n\n            var def = reference.resolved.defs[0];\n\n            if (def == null) {\n              continue;\n            } // Ignore references to the function itself as it's not defined yet.\n\n\n            if (def.node != null && def.node.init === node.parent) {\n              continue;\n            } // Ignore Flow type parameters\n\n\n            if (def.type === 'TypeParameter') {\n              continue;\n            } // Add the dependency to a map so we can make sure it is referenced\n            // again in our dependencies array. Remember whether it's stable.\n\n\n            if (!dependencies.has(dependency)) {\n              var resolved = reference.resolved;\n              var isStable = memoizedIsStableKnownHookValue(resolved) || memoizedIsFunctionWithoutCapturedValues(resolved);\n              dependencies.set(dependency, {\n                isStable: isStable,\n                references: [reference]\n              });\n            } else {\n              dependencies.get(dependency).references.push(reference);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(currentScope.childScopes),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var childScope = _step2.value;\n            gatherDependenciesRecursively(childScope);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } // Warn about accessing .current in cleanup effects.\n\n\n      currentRefsInEffectCleanup.forEach(function (_ref, dependency) {\n        var reference = _ref.reference,\n            dependencyNode = _ref.dependencyNode;\n        var references = reference.resolved.references; // Is React managing this ref or us?\n        // Let's see if we can find a .current assignment.\n\n        var foundCurrentAssignment = false;\n\n        for (var i = 0; i < references.length; i++) {\n          var identifier = references[i].identifier;\n          var parent = identifier.parent;\n\n          if (parent != null && // ref.current\n          // Note: no need to handle OptionalMemberExpression because it can't be LHS.\n          parent.type === 'MemberExpression' && !parent.computed && parent.property.type === 'Identifier' && parent.property.name === 'current' && // ref.current = <something>\n          parent.parent.type === 'AssignmentExpression' && parent.parent.left === parent) {\n            foundCurrentAssignment = true;\n            break;\n          }\n        } // We only want to warn about React-managed refs.\n\n\n        if (foundCurrentAssignment) {\n          return;\n        }\n\n        reportProblem({\n          node: dependencyNode.parent.property,\n          message: \"The ref value '\" + dependency + \".current' will likely have \" + \"changed by the time this effect cleanup function runs. If \" + \"this ref points to a node rendered by React, copy \" + (\"'\" + dependency + \".current' to a variable inside the effect, and \") + \"use that variable in the cleanup function.\"\n        });\n      }); // Warn about assigning to variables in the outer scope.\n      // Those are usually bugs.\n\n      var staleAssignments = new Set();\n\n      function reportStaleAssignment(writeExpr, key) {\n        if (staleAssignments.has(key)) {\n          return;\n        }\n\n        staleAssignments.add(key);\n        reportProblem({\n          node: writeExpr,\n          message: \"Assignments to the '\" + key + \"' variable from inside React Hook \" + (context.getSource(reactiveHook) + \" will be lost after each \") + \"render. To preserve the value over time, store it in a useRef \" + \"Hook and keep the mutable value in the '.current' property. \" + \"Otherwise, you can move this variable directly inside \" + (context.getSource(reactiveHook) + \".\")\n        });\n      } // Remember which deps are stable and report bad usage first.\n\n\n      var stableDependencies = new Set();\n      dependencies.forEach(function (_ref2, key) {\n        var isStable = _ref2.isStable,\n            references = _ref2.references;\n\n        if (isStable) {\n          stableDependencies.add(key);\n        }\n\n        references.forEach(function (reference) {\n          if (reference.writeExpr) {\n            reportStaleAssignment(reference.writeExpr, key);\n          }\n        });\n      });\n\n      if (staleAssignments.size > 0) {\n        // The intent isn't clear so we'll wait until you fix those first.\n        return;\n      }\n\n      if (!declaredDependenciesNode) {\n        // Check if there are any top-level setState() calls.\n        // Those tend to lead to infinite loops.\n        var setStateInsideEffectWithoutDeps = null;\n        dependencies.forEach(function (_ref3, key) {\n          var isStable = _ref3.isStable,\n              references = _ref3.references;\n\n          if (setStateInsideEffectWithoutDeps) {\n            return;\n          }\n\n          references.forEach(function (reference) {\n            if (setStateInsideEffectWithoutDeps) {\n              return;\n            }\n\n            var id = reference.identifier;\n            var isSetState = setStateCallSites.has(id);\n\n            if (!isSetState) {\n              return;\n            }\n\n            var fnScope = reference.from;\n\n            while (fnScope.type !== 'function') {\n              fnScope = fnScope.upper;\n            }\n\n            var isDirectlyInsideEffect = fnScope.block === node;\n\n            if (isDirectlyInsideEffect) {\n              // TODO: we could potentially ignore early returns.\n              setStateInsideEffectWithoutDeps = key;\n            }\n          });\n        });\n\n        if (setStateInsideEffectWithoutDeps) {\n          var _collectRecommendatio = collectRecommendations({\n            dependencies: dependencies,\n            declaredDependencies: [],\n            stableDependencies: stableDependencies,\n            externalDependencies: new Set(),\n            isEffect: true\n          }),\n              _suggestedDependencies = _collectRecommendatio.suggestedDependencies;\n\n          reportProblem({\n            node: reactiveHook,\n            message: \"React Hook \" + reactiveHookName + \" contains a call to '\" + setStateInsideEffectWithoutDeps + \"'. \" + \"Without a list of dependencies, this can lead to an infinite chain of updates. \" + \"To fix this, pass [\" + _suggestedDependencies.join(', ') + (\"] as a second argument to the \" + reactiveHookName + \" Hook.\"),\n            suggest: [{\n              desc: \"Add dependencies array: [\" + _suggestedDependencies.join(', ') + \"]\",\n              fix: function (fixer) {\n                return fixer.insertTextAfter(node, \", [\" + _suggestedDependencies.join(', ') + \"]\");\n              }\n            }]\n          });\n        }\n\n        return;\n      }\n\n      var declaredDependencies = [];\n      var externalDependencies = new Set();\n\n      if (declaredDependenciesNode.type !== 'ArrayExpression') {\n        // If the declared dependencies are not an array expression then we\n        // can't verify that the user provided the correct dependencies. Tell\n        // the user this in an error.\n        reportProblem({\n          node: declaredDependenciesNode,\n          message: \"React Hook \" + context.getSource(reactiveHook) + \" was passed a \" + 'dependency list that is not an array literal. This means we ' + \"can't statically verify whether you've passed the correct \" + 'dependencies.'\n        });\n      } else {\n        declaredDependenciesNode.elements.forEach(function (declaredDependencyNode) {\n          // Skip elided elements.\n          if (declaredDependencyNode === null) {\n            return;\n          } // If we see a spread element then add a special warning.\n\n\n          if (declaredDependencyNode.type === 'SpreadElement') {\n            reportProblem({\n              node: declaredDependencyNode,\n              message: \"React Hook \" + context.getSource(reactiveHook) + \" has a spread \" + \"element in its dependency array. This means we can't \" + \"statically verify whether you've passed the \" + 'correct dependencies.'\n            });\n            return;\n          } // Try to normalize the declared dependency. If we can't then an error\n          // will be thrown. We will catch that error and report an error.\n\n\n          var declaredDependency;\n\n          try {\n            declaredDependency = analyzePropertyChain(declaredDependencyNode, null);\n          } catch (error) {\n            if (/Unsupported node type/.test(error.message)) {\n              if (declaredDependencyNode.type === 'Literal') {\n                if (dependencies.has(declaredDependencyNode.value)) {\n                  reportProblem({\n                    node: declaredDependencyNode,\n                    message: \"The \" + declaredDependencyNode.raw + \" literal is not a valid dependency \" + \"because it never changes. \" + (\"Did you mean to include \" + declaredDependencyNode.value + \" in the array instead?\")\n                  });\n                } else {\n                  reportProblem({\n                    node: declaredDependencyNode,\n                    message: \"The \" + declaredDependencyNode.raw + \" literal is not a valid dependency \" + 'because it never changes. You can safely remove it.'\n                  });\n                }\n              } else {\n                reportProblem({\n                  node: declaredDependencyNode,\n                  message: \"React Hook \" + context.getSource(reactiveHook) + \" has a \" + \"complex expression in the dependency array. \" + 'Extract it to a separate variable so it can be statically checked.'\n                });\n              }\n\n              return;\n            } else {\n              throw error;\n            }\n          }\n\n          var maybeID = declaredDependencyNode;\n\n          while (maybeID.type === 'MemberExpression' || maybeID.type === 'OptionalMemberExpression' || maybeID.type === 'ChainExpression') {\n            maybeID = maybeID.object || maybeID.expression.object;\n          }\n\n          var isDeclaredInComponent = !componentScope.through.some(function (ref) {\n            return ref.identifier === maybeID;\n          }); // Add the dependency to our declared dependency map.\n\n          declaredDependencies.push({\n            key: declaredDependency,\n            node: declaredDependencyNode\n          });\n\n          if (!isDeclaredInComponent) {\n            externalDependencies.add(declaredDependency);\n          }\n        });\n      }\n\n      var _collectRecommendatio2 = collectRecommendations({\n        dependencies: dependencies,\n        declaredDependencies: declaredDependencies,\n        stableDependencies: stableDependencies,\n        externalDependencies: externalDependencies,\n        isEffect: isEffect\n      }),\n          suggestedDependencies = _collectRecommendatio2.suggestedDependencies,\n          unnecessaryDependencies = _collectRecommendatio2.unnecessaryDependencies,\n          missingDependencies = _collectRecommendatio2.missingDependencies,\n          duplicateDependencies = _collectRecommendatio2.duplicateDependencies;\n\n      var suggestedDeps = suggestedDependencies;\n      var problemCount = duplicateDependencies.size + missingDependencies.size + unnecessaryDependencies.size;\n\n      if (problemCount === 0) {\n        // If nothing else to report, check if some dependencies would\n        // invalidate on every render.\n        var constructions = scanForConstructions({\n          declaredDependencies: declaredDependencies,\n          declaredDependenciesNode: declaredDependenciesNode,\n          componentScope: componentScope,\n          scope: scope\n        });\n        constructions.forEach(function (_ref4) {\n          var construction = _ref4.construction,\n              isUsedOutsideOfHook = _ref4.isUsedOutsideOfHook,\n              depType = _ref4.depType;\n          var wrapperHook = depType === 'function' ? 'useCallback' : 'useMemo';\n          var constructionType = depType === 'function' ? 'definition' : 'initialization';\n          var defaultAdvice = \"wrap the \" + constructionType + \" of '\" + construction.name.name + \"' in its own \" + wrapperHook + \"() Hook.\";\n          var advice = isUsedOutsideOfHook ? \"To fix this, \" + defaultAdvice : \"Move it inside the \" + reactiveHookName + \" callback. Alternatively, \" + defaultAdvice;\n          var causation = depType === 'conditional' || depType === 'logical expression' ? 'could make' : 'makes';\n          var message = \"The '\" + construction.name.name + \"' \" + depType + \" \" + causation + \" the dependencies of \" + (reactiveHookName + \" Hook (at line \" + declaredDependenciesNode.loc.start.line + \") \") + (\"change on every render. \" + advice);\n          var suggest; // Only handle the simple case of variable assignments.\n          // Wrapping function declarations can mess up hoisting.\n\n          if (isUsedOutsideOfHook && construction.type === 'Variable' && // Objects may be mutated after construction, which would make this\n          // fix unsafe. Functions _probably_ won't be mutated, so we'll\n          // allow this fix for them.\n          depType === 'function') {\n            suggest = [{\n              desc: \"Wrap the \" + constructionType + \" of '\" + construction.name.name + \"' in its own \" + wrapperHook + \"() Hook.\",\n              fix: function (fixer) {\n                var _ref5 = wrapperHook === 'useMemo' ? [\"useMemo(() => { return \", '; })'] : ['useCallback(', ')'],\n                    before = _ref5[0],\n                    after = _ref5[1];\n\n                return [// TODO: also add an import?\n                fixer.insertTextBefore(construction.node.init, before), // TODO: ideally we'd gather deps here but it would require\n                // restructuring the rule code. This will cause a new lint\n                // error to appear immediately for useCallback. Note we're\n                // not adding [] because would that changes semantics.\n                fixer.insertTextAfter(construction.node.init, after)];\n              }\n            }];\n          } // TODO: What if the function needs to change on every render anyway?\n          // Should we suggest removing effect deps as an appropriate fix too?\n\n\n          reportProblem({\n            // TODO: Why not report this at the dependency site?\n            node: construction.node,\n            message: message,\n            suggest: suggest\n          });\n        });\n        return;\n      } // If we're going to report a missing dependency,\n      // we might as well recalculate the list ignoring\n      // the currently specified deps. This can result\n      // in some extra deduplication. We can't do this\n      // for effects though because those have legit\n      // use cases for over-specifying deps.\n\n\n      if (!isEffect && missingDependencies.size > 0) {\n        suggestedDeps = collectRecommendations({\n          dependencies: dependencies,\n          declaredDependencies: [],\n          // Pretend we don't know\n          stableDependencies: stableDependencies,\n          externalDependencies: externalDependencies,\n          isEffect: isEffect\n        }).suggestedDependencies;\n      } // Alphabetize the suggestions, but only if deps were already alphabetized.\n\n\n      function areDeclaredDepsAlphabetized() {\n        if (declaredDependencies.length === 0) {\n          return true;\n        }\n\n        var declaredDepKeys = declaredDependencies.map(function (dep) {\n          return dep.key;\n        });\n        var sortedDeclaredDepKeys = declaredDepKeys.slice().sort();\n        return declaredDepKeys.join(',') === sortedDeclaredDepKeys.join(',');\n      }\n\n      if (areDeclaredDepsAlphabetized()) {\n        suggestedDeps.sort();\n      } // Most of our algorithm deals with dependency paths with optional chaining stripped.\n      // This function is the last step before printing a dependency, so now is a good time to\n      // check whether any members in our path are always used as optional-only. In that case,\n      // we will use ?. instead of . to concatenate those parts of the path.\n\n\n      function formatDependency(path) {\n        var members = path.split('.');\n        var finalPath = '';\n\n        for (var i = 0; i < members.length; i++) {\n          if (i !== 0) {\n            var pathSoFar = members.slice(0, i + 1).join('.');\n            var isOptional = optionalChains.get(pathSoFar) === true;\n            finalPath += isOptional ? '?.' : '.';\n          }\n\n          finalPath += members[i];\n        }\n\n        return finalPath;\n      }\n\n      function getWarningMessage(deps, singlePrefix, label, fixVerb) {\n        if (deps.size === 0) {\n          return null;\n        }\n\n        return (deps.size > 1 ? '' : singlePrefix + ' ') + label + ' ' + (deps.size > 1 ? 'dependencies' : 'dependency') + ': ' + joinEnglish(Array.from(deps).sort().map(function (name) {\n          return \"'\" + formatDependency(name) + \"'\";\n        })) + (\". Either \" + fixVerb + \" \" + (deps.size > 1 ? 'them' : 'it') + \" or remove the dependency array.\");\n      }\n\n      var extraWarning = '';\n\n      if (unnecessaryDependencies.size > 0) {\n        var badRef = null;\n        Array.from(unnecessaryDependencies.keys()).forEach(function (key) {\n          if (badRef !== null) {\n            return;\n          }\n\n          if (key.endsWith('.current')) {\n            badRef = key;\n          }\n        });\n\n        if (badRef !== null) {\n          extraWarning = \" Mutable values like '\" + badRef + \"' aren't valid dependencies \" + \"because mutating them doesn't re-render the component.\";\n        } else if (externalDependencies.size > 0) {\n          var dep = Array.from(externalDependencies)[0]; // Don't show this warning for things that likely just got moved *inside* the callback\n          // because in that case they're clearly not referring to globals.\n\n          if (!scope.set.has(dep)) {\n            extraWarning = \" Outer scope values like '\" + dep + \"' aren't valid dependencies \" + \"because mutating them doesn't re-render the component.\";\n          }\n        }\n      } // `props.foo()` marks `props` as a dependency because it has\n      // a `this` value. This warning can be confusing.\n      // So if we're going to show it, append a clarification.\n\n\n      if (!extraWarning && missingDependencies.has('props')) {\n        var propDep = dependencies.get('props');\n\n        if (propDep == null) {\n          return;\n        }\n\n        var refs = propDep.references;\n\n        if (!Array.isArray(refs)) {\n          return;\n        }\n\n        var isPropsOnlyUsedInMembers = true;\n\n        for (var i = 0; i < refs.length; i++) {\n          var ref = refs[i];\n          var id = fastFindReferenceWithParent(componentScope.block, ref.identifier);\n\n          if (!id) {\n            isPropsOnlyUsedInMembers = false;\n            break;\n          }\n\n          var parent = id.parent;\n\n          if (parent == null) {\n            isPropsOnlyUsedInMembers = false;\n            break;\n          }\n\n          if (parent.type !== 'MemberExpression' && parent.type !== 'OptionalMemberExpression') {\n            isPropsOnlyUsedInMembers = false;\n            break;\n          }\n        }\n\n        if (isPropsOnlyUsedInMembers) {\n          extraWarning = \" However, 'props' will change when *any* prop changes, so the \" + \"preferred fix is to destructure the 'props' object outside of \" + (\"the \" + reactiveHookName + \" call and refer to those specific props \") + (\"inside \" + context.getSource(reactiveHook) + \".\");\n        }\n      }\n\n      if (!extraWarning && missingDependencies.size > 0) {\n        // See if the user is trying to avoid specifying a callable prop.\n        // This usually means they're unaware of useCallback.\n        var missingCallbackDep = null;\n        missingDependencies.forEach(function (missingDep) {\n          if (missingCallbackDep) {\n            return;\n          } // Is this a variable from top scope?\n\n\n          var topScopeRef = componentScope.set.get(missingDep);\n          var usedDep = dependencies.get(missingDep);\n\n          if (usedDep.references[0].resolved !== topScopeRef) {\n            return;\n          } // Is this a destructured prop?\n\n\n          var def = topScopeRef.defs[0];\n\n          if (def == null || def.name == null || def.type !== 'Parameter') {\n            return;\n          } // Was it called in at least one case? Then it's a function.\n\n\n          var isFunctionCall = false;\n          var id;\n\n          for (var _i2 = 0; _i2 < usedDep.references.length; _i2++) {\n            id = usedDep.references[_i2].identifier;\n\n            if (id != null && id.parent != null && (id.parent.type === 'CallExpression' || id.parent.type === 'OptionalCallExpression') && id.parent.callee === id) {\n              isFunctionCall = true;\n              break;\n            }\n          }\n\n          if (!isFunctionCall) {\n            return;\n          } // If it's missing (i.e. in component scope) *and* it's a parameter\n          // then it is definitely coming from props destructuring.\n          // (It could also be props itself but we wouldn't be calling it then.)\n\n\n          missingCallbackDep = missingDep;\n        });\n\n        if (missingCallbackDep !== null) {\n          extraWarning = \" If '\" + missingCallbackDep + \"' changes too often, \" + \"find the parent component that defines it \" + \"and wrap that definition in useCallback.\";\n        }\n      }\n\n      if (!extraWarning && missingDependencies.size > 0) {\n        var setStateRecommendation = null;\n        missingDependencies.forEach(function (missingDep) {\n          if (setStateRecommendation !== null) {\n            return;\n          }\n\n          var usedDep = dependencies.get(missingDep);\n          var references = usedDep.references;\n          var id;\n          var maybeCall;\n\n          for (var _i3 = 0; _i3 < references.length; _i3++) {\n            id = references[_i3].identifier;\n            maybeCall = id.parent; // Try to see if we have setState(someExpr(missingDep)).\n\n            while (maybeCall != null && maybeCall !== componentScope.block) {\n              if (maybeCall.type === 'CallExpression') {\n                var correspondingStateVariable = setStateCallSites.get(maybeCall.callee);\n\n                if (correspondingStateVariable != null) {\n                  if (correspondingStateVariable.name === missingDep) {\n                    // setCount(count + 1)\n                    setStateRecommendation = {\n                      missingDep: missingDep,\n                      setter: maybeCall.callee.name,\n                      form: 'updater'\n                    };\n                  } else if (stateVariables.has(id)) {\n                    // setCount(count + increment)\n                    setStateRecommendation = {\n                      missingDep: missingDep,\n                      setter: maybeCall.callee.name,\n                      form: 'reducer'\n                    };\n                  } else {\n                    var resolved = references[_i3].resolved;\n\n                    if (resolved != null) {\n                      // If it's a parameter *and* a missing dep,\n                      // it must be a prop or something inside a prop.\n                      // Therefore, recommend an inline reducer.\n                      var def = resolved.defs[0];\n\n                      if (def != null && def.type === 'Parameter') {\n                        setStateRecommendation = {\n                          missingDep: missingDep,\n                          setter: maybeCall.callee.name,\n                          form: 'inlineReducer'\n                        };\n                      }\n                    }\n                  }\n\n                  break;\n                }\n              }\n\n              maybeCall = maybeCall.parent;\n            }\n\n            if (setStateRecommendation !== null) {\n              break;\n            }\n          }\n        });\n\n        if (setStateRecommendation !== null) {\n          switch (setStateRecommendation.form) {\n            case 'reducer':\n              extraWarning = \" You can also replace multiple useState variables with useReducer \" + (\"if '\" + setStateRecommendation.setter + \"' needs the \") + (\"current value of '\" + setStateRecommendation.missingDep + \"'.\");\n              break;\n\n            case 'inlineReducer':\n              extraWarning = \" If '\" + setStateRecommendation.setter + \"' needs the \" + (\"current value of '\" + setStateRecommendation.missingDep + \"', \") + \"you can also switch to useReducer instead of useState and \" + (\"read '\" + setStateRecommendation.missingDep + \"' in the reducer.\");\n              break;\n\n            case 'updater':\n              extraWarning = \" You can also do a functional update '\" + setStateRecommendation.setter + \"(\" + setStateRecommendation.missingDep.substring(0, 1) + \" => ...)' if you only need '\" + setStateRecommendation.missingDep + \"'\" + (\" in the '\" + setStateRecommendation.setter + \"' call.\");\n              break;\n\n            default:\n              throw new Error('Unknown case.');\n          }\n        }\n      }\n\n      reportProblem({\n        node: declaredDependenciesNode,\n        message: \"React Hook \" + context.getSource(reactiveHook) + \" has \" + ( // To avoid a long message, show the next actionable item.\n        getWarningMessage(missingDependencies, 'a', 'missing', 'include') || getWarningMessage(unnecessaryDependencies, 'an', 'unnecessary', 'exclude') || getWarningMessage(duplicateDependencies, 'a', 'duplicate', 'omit')) + extraWarning,\n        suggest: [{\n          desc: \"Update the dependencies array to be: [\" + suggestedDeps.map(formatDependency).join(', ') + \"]\",\n          fix: function (fixer) {\n            // TODO: consider preserving the comments or formatting?\n            return fixer.replaceText(declaredDependenciesNode, \"[\" + suggestedDeps.map(formatDependency).join(', ') + \"]\");\n          }\n        }]\n      });\n    }\n\n    function visitCallExpression(node) {\n      var callbackIndex = getReactiveHookCallbackIndex(node.callee, options);\n\n      if (callbackIndex === -1) {\n        // Not a React Hook call that needs deps.\n        return;\n      }\n\n      var callback = node.arguments[callbackIndex];\n      var reactiveHook = node.callee;\n      var reactiveHookName = getNodeWithoutReactNamespace(reactiveHook).name;\n      var declaredDependenciesNode = node.arguments[callbackIndex + 1];\n      var isEffect = /Effect($|[^a-z])/g.test(reactiveHookName); // Check whether a callback is supplied. If there is no callback supplied\n      // then the hook will not work and React will throw a TypeError.\n      // So no need to check for dependency inclusion.\n\n      if (!callback) {\n        reportProblem({\n          node: reactiveHook,\n          message: \"React Hook \" + reactiveHookName + \" requires an effect callback. \" + \"Did you forget to pass a callback to the hook?\"\n        });\n        return;\n      } // Check the declared dependencies for this reactive hook. If there is no\n      // second argument then the reactive callback will re-run on every render.\n      // So no need to check for dependency inclusion.\n\n\n      if (!declaredDependenciesNode && !isEffect) {\n        // These are only used for optimization.\n        if (reactiveHookName === 'useMemo' || reactiveHookName === 'useCallback') {\n          // TODO: Can this have a suggestion?\n          reportProblem({\n            node: reactiveHook,\n            message: \"React Hook \" + reactiveHookName + \" does nothing when called with \" + \"only one argument. Did you forget to pass an array of \" + \"dependencies?\"\n          });\n        }\n\n        return;\n      }\n\n      switch (callback.type) {\n        case 'FunctionExpression':\n        case 'ArrowFunctionExpression':\n          visitFunctionWithDependencies(callback, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);\n          return;\n        // Handled\n\n        case 'Identifier':\n          if (!declaredDependenciesNode) {\n            // No deps, no problems.\n            return; // Handled\n          } // The function passed as a callback is not written inline.\n          // But perhaps it's in the dependencies array?\n\n\n          if (declaredDependenciesNode.elements && declaredDependenciesNode.elements.some(function (el) {\n            return el && el.type === 'Identifier' && el.name === callback.name;\n          })) {\n            // If it's already in the list of deps, we don't care because\n            // this is valid regardless.\n            return; // Handled\n          } // We'll do our best effort to find it, complain otherwise.\n\n\n          var variable = context.getScope().set.get(callback.name);\n\n          if (variable == null || variable.defs == null) {\n            // If it's not in scope, we don't care.\n            return; // Handled\n          } // The function passed as a callback is not written inline.\n          // But it's defined somewhere in the render scope.\n          // We'll do our best effort to find and check it, complain otherwise.\n\n\n          var def = variable.defs[0];\n\n          if (!def || !def.node) {\n            break; // Unhandled\n          }\n\n          if (def.type !== 'Variable' && def.type !== 'FunctionName') {\n            // Parameter or an unusual pattern. Bail out.\n            break; // Unhandled\n          }\n\n          switch (def.node.type) {\n            case 'FunctionDeclaration':\n              // useEffect(() => { ... }, []);\n              visitFunctionWithDependencies(def.node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);\n              return;\n            // Handled\n\n            case 'VariableDeclarator':\n              var init = def.node.init;\n\n              if (!init) {\n                break; // Unhandled\n              }\n\n              switch (init.type) {\n                // const effectBody = () => {...};\n                // useEffect(effectBody, []);\n                case 'ArrowFunctionExpression':\n                case 'FunctionExpression':\n                  // We can inspect this function as if it were inline.\n                  visitFunctionWithDependencies(init, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);\n                  return;\n                // Handled\n              }\n\n              break;\n            // Unhandled\n          }\n\n          break;\n        // Unhandled\n\n        default:\n          // useEffect(generateEffectBody(), []);\n          reportProblem({\n            node: reactiveHook,\n            message: \"React Hook \" + reactiveHookName + \" received a function whose dependencies \" + \"are unknown. Pass an inline function instead.\"\n          });\n          return;\n        // Handled\n      } // Something unusual. Fall back to suggesting to add the body itself as a dep.\n\n\n      reportProblem({\n        node: reactiveHook,\n        message: \"React Hook \" + reactiveHookName + \" has a missing dependency: '\" + callback.name + \"'. \" + \"Either include it or remove the dependency array.\",\n        suggest: [{\n          desc: \"Update the dependencies array to be: [\" + callback.name + \"]\",\n          fix: function (fixer) {\n            return fixer.replaceText(declaredDependenciesNode, \"[\" + callback.name + \"]\");\n          }\n        }]\n      });\n    }\n\n    return {\n      CallExpression: visitCallExpression\n    };\n  }\n}; // The meat of the logic.\n\nfunction collectRecommendations(_ref6) {\n  var dependencies = _ref6.dependencies,\n      declaredDependencies = _ref6.declaredDependencies,\n      stableDependencies = _ref6.stableDependencies,\n      externalDependencies = _ref6.externalDependencies,\n      isEffect = _ref6.isEffect;\n  // Our primary data structure.\n  // It is a logical representation of property chains:\n  // `props` -> `props.foo` -> `props.foo.bar` -> `props.foo.bar.baz`\n  //         -> `props.lol`\n  //         -> `props.huh` -> `props.huh.okay`\n  //         -> `props.wow`\n  // We'll use it to mark nodes that are *used* by the programmer,\n  // and the nodes that were *declared* as deps. Then we will\n  // traverse it to learn which deps are missing or unnecessary.\n  var depTree = createDepTree();\n\n  function createDepTree() {\n    return {\n      isUsed: false,\n      // True if used in code\n      isSatisfiedRecursively: false,\n      // True if specified in deps\n      isSubtreeUsed: false,\n      // True if something deeper is used by code\n      children: new Map() // Nodes for properties\n\n    };\n  } // Mark all required nodes first.\n  // Imagine exclamation marks next to each used deep property.\n\n\n  dependencies.forEach(function (_, key) {\n    var node = getOrCreateNodeByPath(depTree, key);\n    node.isUsed = true;\n    markAllParentsByPath(depTree, key, function (parent) {\n      parent.isSubtreeUsed = true;\n    });\n  }); // Mark all satisfied nodes.\n  // Imagine checkmarks next to each declared dependency.\n\n  declaredDependencies.forEach(function (_ref7) {\n    var key = _ref7.key;\n    var node = getOrCreateNodeByPath(depTree, key);\n    node.isSatisfiedRecursively = true;\n  });\n  stableDependencies.forEach(function (key) {\n    var node = getOrCreateNodeByPath(depTree, key);\n    node.isSatisfiedRecursively = true;\n  }); // Tree manipulation helpers.\n\n  function getOrCreateNodeByPath(rootNode, path) {\n    var keys = path.split('.');\n    var node = rootNode;\n\n    var _iterator3 = _createForOfIteratorHelper(keys),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var key = _step3.value;\n        var child = node.children.get(key);\n\n        if (!child) {\n          child = createDepTree();\n          node.children.set(key, child);\n        }\n\n        node = child;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return node;\n  }\n\n  function markAllParentsByPath(rootNode, path, fn) {\n    var keys = path.split('.');\n    var node = rootNode;\n\n    var _iterator4 = _createForOfIteratorHelper(keys),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var key = _step4.value;\n        var child = node.children.get(key);\n\n        if (!child) {\n          return;\n        }\n\n        fn(child);\n        node = child;\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  } // Now we can learn which dependencies are missing or necessary.\n\n\n  var missingDependencies = new Set();\n  var satisfyingDependencies = new Set();\n  scanTreeRecursively(depTree, missingDependencies, satisfyingDependencies, function (key) {\n    return key;\n  });\n\n  function scanTreeRecursively(node, missingPaths, satisfyingPaths, keyToPath) {\n    node.children.forEach(function (child, key) {\n      var path = keyToPath(key);\n\n      if (child.isSatisfiedRecursively) {\n        if (child.isSubtreeUsed) {\n          // Remember this dep actually satisfied something.\n          satisfyingPaths.add(path);\n        } // It doesn't matter if there's something deeper.\n        // It would be transitively satisfied since we assume immutability.\n        // `props.foo` is enough if you read `props.foo.id`.\n\n\n        return;\n      }\n\n      if (child.isUsed) {\n        // Remember that no declared deps satisfied this node.\n        missingPaths.add(path); // If we got here, nothing in its subtree was satisfied.\n        // No need to search further.\n\n        return;\n      }\n\n      scanTreeRecursively(child, missingPaths, satisfyingPaths, function (childKey) {\n        return path + '.' + childKey;\n      });\n    });\n  } // Collect suggestions in the order they were originally specified.\n\n\n  var suggestedDependencies = [];\n  var unnecessaryDependencies = new Set();\n  var duplicateDependencies = new Set();\n  declaredDependencies.forEach(function (_ref8) {\n    var key = _ref8.key;\n\n    // Does this declared dep satisfy a real need?\n    if (satisfyingDependencies.has(key)) {\n      if (suggestedDependencies.indexOf(key) === -1) {\n        // Good one.\n        suggestedDependencies.push(key);\n      } else {\n        // Duplicate.\n        duplicateDependencies.add(key);\n      }\n    } else {\n      if (isEffect && !key.endsWith('.current') && !externalDependencies.has(key)) {\n        // Effects are allowed extra \"unnecessary\" deps.\n        // Such as resetting scroll when ID changes.\n        // Consider them legit.\n        // The exception is ref.current which is always wrong.\n        if (suggestedDependencies.indexOf(key) === -1) {\n          suggestedDependencies.push(key);\n        }\n      } else {\n        // It's definitely not needed.\n        unnecessaryDependencies.add(key);\n      }\n    }\n  }); // Then add the missing ones at the end.\n\n  missingDependencies.forEach(function (key) {\n    suggestedDependencies.push(key);\n  });\n  return {\n    suggestedDependencies: suggestedDependencies,\n    unnecessaryDependencies: unnecessaryDependencies,\n    duplicateDependencies: duplicateDependencies,\n    missingDependencies: missingDependencies\n  };\n} // If the node will result in constructing a referentially unique value, return\n// its human readable type name, else return null.\n\n\nfunction getConstructionExpressionType(node) {\n  switch (node.type) {\n    case 'ObjectExpression':\n      return 'object';\n\n    case 'ArrayExpression':\n      return 'array';\n\n    case 'ArrowFunctionExpression':\n    case 'FunctionExpression':\n      return 'function';\n\n    case 'ClassExpression':\n      return 'class';\n\n    case 'ConditionalExpression':\n      if (getConstructionExpressionType(node.consequent) != null || getConstructionExpressionType(node.alternate) != null) {\n        return 'conditional';\n      }\n\n      return null;\n\n    case 'LogicalExpression':\n      if (getConstructionExpressionType(node.left) != null || getConstructionExpressionType(node.right) != null) {\n        return 'logical expression';\n      }\n\n      return null;\n\n    case 'JSXFragment':\n      return 'JSX fragment';\n\n    case 'JSXElement':\n      return 'JSX element';\n\n    case 'AssignmentExpression':\n      if (getConstructionExpressionType(node.right) != null) {\n        return 'assignment expression';\n      }\n\n      return null;\n\n    case 'NewExpression':\n      return 'object construction';\n\n    case 'Literal':\n      if (node.value instanceof RegExp) {\n        return 'regular expression';\n      }\n\n      return null;\n\n    case 'TypeCastExpression':\n      return getConstructionExpressionType(node.expression);\n\n    case 'TSAsExpression':\n      return getConstructionExpressionType(node.expression);\n  }\n\n  return null;\n} // Finds variables declared as dependencies\n// that would invalidate on every render.\n\n\nfunction scanForConstructions(_ref9) {\n  var declaredDependencies = _ref9.declaredDependencies,\n      declaredDependenciesNode = _ref9.declaredDependenciesNode,\n      componentScope = _ref9.componentScope,\n      scope = _ref9.scope;\n  var constructions = declaredDependencies.map(function (_ref10) {\n    var key = _ref10.key;\n    var ref = componentScope.variables.find(function (v) {\n      return v.name === key;\n    });\n\n    if (ref == null) {\n      return null;\n    }\n\n    var node = ref.defs[0];\n\n    if (node == null) {\n      return null;\n    } // const handleChange = function () {}\n    // const handleChange = () => {}\n    // const foo = {}\n    // const foo = []\n    // etc.\n\n\n    if (node.type === 'Variable' && node.node.type === 'VariableDeclarator' && node.node.id.type === 'Identifier' && // Ensure this is not destructed assignment\n    node.node.init != null) {\n      var constantExpressionType = getConstructionExpressionType(node.node.init);\n\n      if (constantExpressionType != null) {\n        return [ref, constantExpressionType];\n      }\n    } // function handleChange() {}\n\n\n    if (node.type === 'FunctionName' && node.node.type === 'FunctionDeclaration') {\n      return [ref, 'function'];\n    } // class Foo {}\n\n\n    if (node.type === 'ClassName' && node.node.type === 'ClassDeclaration') {\n      return [ref, 'class'];\n    }\n\n    return null;\n  }).filter(Boolean);\n\n  function isUsedOutsideOfHook(ref) {\n    var foundWriteExpr = false;\n\n    for (var i = 0; i < ref.references.length; i++) {\n      var reference = ref.references[i];\n\n      if (reference.writeExpr) {\n        if (foundWriteExpr) {\n          // Two writes to the same function.\n          return true;\n        } else {\n          // Ignore first write as it's not usage.\n          foundWriteExpr = true;\n          continue;\n        }\n      }\n\n      var currentScope = reference.from;\n\n      while (currentScope !== scope && currentScope != null) {\n        currentScope = currentScope.upper;\n      }\n\n      if (currentScope !== scope) {\n        // This reference is outside the Hook callback.\n        // It can only be legit if it's the deps array.\n        if (!isAncestorNodeOf(declaredDependenciesNode, reference.identifier)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return constructions.map(function (_ref11) {\n    var ref = _ref11[0],\n        depType = _ref11[1];\n    return {\n      construction: ref.defs[0],\n      depType: depType,\n      isUsedOutsideOfHook: isUsedOutsideOfHook(ref)\n    };\n  });\n}\n/**\n * Assuming () means the passed/returned node:\n * (props) => (props)\n * props.(foo) => (props.foo)\n * props.foo.(bar) => (props).foo.bar\n * props.foo.bar.(baz) => (props).foo.bar.baz\n */\n\n\nfunction getDependency(node) {\n  if ((node.parent.type === 'MemberExpression' || node.parent.type === 'OptionalMemberExpression') && node.parent.object === node && node.parent.property.name !== 'current' && !node.parent.computed && !(node.parent.parent != null && (node.parent.parent.type === 'CallExpression' || node.parent.parent.type === 'OptionalCallExpression') && node.parent.parent.callee === node.parent)) {\n    return getDependency(node.parent);\n  } else if ( // Note: we don't check OptionalMemberExpression because it can't be LHS.\n  node.type === 'MemberExpression' && node.parent && node.parent.type === 'AssignmentExpression' && node.parent.left === node) {\n    return node.object;\n  } else {\n    return node;\n  }\n}\n/**\n * Mark a node as either optional or required.\n * Note: If the node argument is an OptionalMemberExpression, it doesn't necessarily mean it is optional.\n * It just means there is an optional member somewhere inside.\n * This particular node might still represent a required member, so check .optional field.\n */\n\n\nfunction markNode(node, optionalChains, result) {\n  if (optionalChains) {\n    if (node.optional) {\n      // We only want to consider it optional if *all* usages were optional.\n      if (!optionalChains.has(result)) {\n        // Mark as (maybe) optional. If there's a required usage, this will be overridden.\n        optionalChains.set(result, true);\n      }\n    } else {\n      // Mark as required.\n      optionalChains.set(result, false);\n    }\n  }\n}\n/**\n * Assuming () means the passed node.\n * (foo) -> 'foo'\n * foo(.)bar -> 'foo.bar'\n * foo.bar(.)baz -> 'foo.bar.baz'\n * Otherwise throw.\n */\n\n\nfunction analyzePropertyChain(node, optionalChains) {\n  if (node.type === 'Identifier' || node.type === 'JSXIdentifier') {\n    var result = node.name;\n\n    if (optionalChains) {\n      // Mark as required.\n      optionalChains.set(result, false);\n    }\n\n    return result;\n  } else if (node.type === 'MemberExpression' && !node.computed) {\n    var object = analyzePropertyChain(node.object, optionalChains);\n    var property = analyzePropertyChain(node.property, null);\n\n    var _result = object + \".\" + property;\n\n    markNode(node, optionalChains, _result);\n    return _result;\n  } else if (node.type === 'OptionalMemberExpression' && !node.computed) {\n    var _object = analyzePropertyChain(node.object, optionalChains);\n\n    var _property = analyzePropertyChain(node.property, null);\n\n    var _result2 = _object + \".\" + _property;\n\n    markNode(node, optionalChains, _result2);\n    return _result2;\n  } else if (node.type === 'ChainExpression' && !node.computed) {\n    var expression = node.expression;\n\n    if (expression.type === 'CallExpression') {\n      throw new Error(\"Unsupported node type: \" + expression.type);\n    }\n\n    var _object2 = analyzePropertyChain(expression.object, optionalChains);\n\n    var _property2 = analyzePropertyChain(expression.property, null);\n\n    var _result3 = _object2 + \".\" + _property2;\n\n    markNode(expression, optionalChains, _result3);\n    return _result3;\n  } else {\n    throw new Error(\"Unsupported node type: \" + node.type);\n  }\n}\n\nfunction getNodeWithoutReactNamespace(node, options) {\n  if (node.type === 'MemberExpression' && node.object.type === 'Identifier' && node.object.name === 'React' && node.property.type === 'Identifier' && !node.computed) {\n    return node.property;\n  }\n\n  return node;\n} // What's the index of callback that needs to be analyzed for a given Hook?\n// -1 if it's not a Hook we care about (e.g. useState).\n// 0 for useEffect/useMemo/useCallback(fn).\n// 1 for useImperativeHandle(ref, fn).\n// For additionally configured Hooks, assume that they're like useEffect (0).\n\n\nfunction getReactiveHookCallbackIndex(calleeNode, options) {\n  var node = getNodeWithoutReactNamespace(calleeNode);\n\n  if (node.type !== 'Identifier') {\n    return -1;\n  }\n\n  switch (node.name) {\n    case 'useEffect':\n    case 'useLayoutEffect':\n    case 'useCallback':\n    case 'useMemo':\n      // useEffect(fn)\n      return 0;\n\n    case 'useImperativeHandle':\n      // useImperativeHandle(ref, fn)\n      return 1;\n\n    default:\n      if (node === calleeNode && options && options.additionalHooks) {\n        // Allow the user to provide a regular expression which enables the lint to\n        // target custom reactive hooks.\n        var name;\n\n        try {\n          name = analyzePropertyChain(node, null);\n        } catch (error) {\n          if (/Unsupported node type/.test(error.message)) {\n            return 0;\n          } else {\n            throw error;\n          }\n        }\n\n        return options.additionalHooks.test(name) ? 0 : -1;\n      } else {\n        return -1;\n      }\n\n  }\n}\n/**\n * ESLint won't assign node.parent to references from context.getScope()\n *\n * So instead we search for the node from an ancestor assigning node.parent\n * as we go. This mutates the AST.\n *\n * This traversal is:\n * - optimized by only searching nodes with a range surrounding our target node\n * - agnostic to AST node types, it looks for `{ type: string, ... }`\n */\n\n\nfunction fastFindReferenceWithParent(start, target) {\n  var queue = [start];\n  var item = null;\n\n  while (queue.length) {\n    item = queue.shift();\n\n    if (isSameIdentifier(item, target)) {\n      return item;\n    }\n\n    if (!isAncestorNodeOf(item, target)) {\n      continue;\n    }\n\n    for (var _i4 = 0, _Object$entries = Object.entries(item); _i4 < _Object$entries.length; _i4++) {\n      var _Object$entries$_i = _Object$entries[_i4],\n          key = _Object$entries$_i[0],\n          value = _Object$entries$_i[1];\n\n      if (key === 'parent') {\n        continue;\n      }\n\n      if (isNodeLike(value)) {\n        value.parent = item;\n        queue.push(value);\n      } else if (Array.isArray(value)) {\n        value.forEach(function (val) {\n          if (isNodeLike(val)) {\n            val.parent = item;\n            queue.push(val);\n          }\n        });\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction joinEnglish(arr) {\n  var s = '';\n\n  for (var i = 0; i < arr.length; i++) {\n    s += arr[i];\n\n    if (i === 0 && arr.length === 2) {\n      s += ' and ';\n    } else if (i === arr.length - 2 && arr.length > 2) {\n      s += ', and ';\n    } else if (i < arr.length - 1) {\n      s += ', ';\n    }\n  }\n\n  return s;\n}\n\nfunction isNodeLike(val) {\n  return typeof val === 'object' && val !== null && !Array.isArray(val) && typeof val.type === 'string';\n}\n\nfunction isSameIdentifier(a, b) {\n  return (a.type === 'Identifier' || a.type === 'JSXIdentifier') && a.type === b.type && a.name === b.name && a.range[0] === b.range[0] && a.range[1] === b.range[1];\n}\n\nfunction isAncestorNodeOf(a, b) {\n  return a.range[0] <= b.range[0] && a.range[1] >= b.range[1];\n}\n\nvar configs = {\n  recommended: {\n    plugins: ['react-hooks'],\n    rules: {\n      'react-hooks/rules-of-hooks': 'error',\n      'react-hooks/exhaustive-deps': 'warn'\n    }\n  }\n};\nvar rules = {\n  'rules-of-hooks': RulesOfHooks,\n  'exhaustive-deps': ExhaustiveDeps\n};\n\nexports.configs = configs;\nexports.rules = rules;\n  })();\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,IAAIA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;EACzC,CAAC,YAAW;IACd;;IAEA,SAASC,2BAAT,CAAqCC,CAArC,EAAwCC,MAAxC,EAAgD;MAC9C,IAAI,CAACD,CAAL,EAAQ;MACR,IAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B,OAAOE,iBAAiB,CAACF,CAAD,EAAIC,MAAJ,CAAxB;MAC3B,IAAIE,CAAC,GAAGC,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BP,CAA/B,EAAkCQ,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAR;MACA,IAAIL,CAAC,KAAK,QAAN,IAAkBH,CAAC,CAACS,WAAxB,EAAqCN,CAAC,GAAGH,CAAC,CAACS,WAAF,CAAcC,IAAlB;MACrC,IAAIP,CAAC,KAAK,KAAN,IAAeA,CAAC,KAAK,KAAzB,EAAgC,OAAOQ,KAAK,CAACC,IAAN,CAAWZ,CAAX,CAAP;MAChC,IAAIG,CAAC,KAAK,WAAN,IAAqB,2CAA2CU,IAA3C,CAAgDV,CAAhD,CAAzB,EAA6E,OAAOD,iBAAiB,CAACF,CAAD,EAAIC,MAAJ,CAAxB;IAC9E;;IAED,SAASC,iBAAT,CAA2BY,GAA3B,EAAgCC,GAAhC,EAAqC;MACnC,IAAIA,GAAG,IAAI,IAAP,IAAeA,GAAG,GAAGD,GAAG,CAACE,MAA7B,EAAqCD,GAAG,GAAGD,GAAG,CAACE,MAAV;;MAErC,KAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAG,IAAIP,KAAJ,CAAUI,GAAV,CAAvB,EAAuCE,CAAC,GAAGF,GAA3C,EAAgDE,CAAC,EAAjD,EAAqDC,IAAI,CAACD,CAAD,CAAJ,GAAUH,GAAG,CAACG,CAAD,CAAb;;MAErD,OAAOC,IAAP;IACD;;IAED,SAASC,0BAAT,CAAoCnB,CAApC,EAAuCoB,cAAvC,EAAuD;MACrD,IAAIC,EAAJ;;MAEA,IAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiCtB,CAAC,CAACsB,MAAM,CAACC,QAAR,CAAD,IAAsB,IAA3D,EAAiE;QAC/D,IAAIZ,KAAK,CAACa,OAAN,CAAcxB,CAAd,MAAqBqB,EAAE,GAAGtB,2BAA2B,CAACC,CAAD,CAArD,KAA6DoB,cAAc,IAAIpB,CAAlB,IAAuB,OAAOA,CAAC,CAACgB,MAAT,KAAoB,QAA5G,EAAsH;UACpH,IAAIK,EAAJ,EAAQrB,CAAC,GAAGqB,EAAJ;UACR,IAAIJ,CAAC,GAAG,CAAR;;UAEA,IAAIQ,CAAC,GAAG,YAAY,CAAE,CAAtB;;UAEA,OAAO;YACLC,CAAC,EAAED,CADE;YAELtB,CAAC,EAAE,YAAY;cACb,IAAIc,CAAC,IAAIjB,CAAC,CAACgB,MAAX,EAAmB,OAAO;gBACxBW,IAAI,EAAE;cADkB,CAAP;cAGnB,OAAO;gBACLA,IAAI,EAAE,KADD;gBAELC,KAAK,EAAE5B,CAAC,CAACiB,CAAC,EAAF;cAFH,CAAP;YAID,CAVI;YAWLY,CAAC,EAAE,UAAUA,CAAV,EAAa;cACd,MAAMA,CAAN;YACD,CAbI;YAcLC,CAAC,EAAEL;UAdE,CAAP;QAgBD;;QAED,MAAM,IAAIM,SAAJ,CAAc,uIAAd,CAAN;MACD;;MAED,IAAIC,gBAAgB,GAAG,IAAvB;MAAA,IACIC,MAAM,GAAG,KADb;MAAA,IAEIC,GAFJ;MAGA,OAAO;QACLR,CAAC,EAAE,YAAY;UACbL,EAAE,GAAGrB,CAAC,CAACsB,MAAM,CAACC,QAAR,CAAD,EAAL;QACD,CAHI;QAILpB,CAAC,EAAE,YAAY;UACb,IAAIgC,IAAI,GAAGd,EAAE,CAACe,IAAH,EAAX;UACAJ,gBAAgB,GAAGG,IAAI,CAACR,IAAxB;UACA,OAAOQ,IAAP;QACD,CARI;QASLN,CAAC,EAAE,UAAUA,CAAV,EAAa;UACdI,MAAM,GAAG,IAAT;UACAC,GAAG,GAAGL,CAAN;QACD,CAZI;QAaLC,CAAC,EAAE,YAAY;UACb,IAAI;YACF,IAAI,CAACE,gBAAD,IAAqBX,EAAE,CAACgB,MAAH,IAAa,IAAtC,EAA4ChB,EAAE,CAACgB,MAAH;UAC7C,CAFD,SAEU;YACR,IAAIJ,MAAJ,EAAY,MAAMC,GAAN;UACb;QACF;MAnBI,CAAP;IAqBD;IAED;;;IAEA,SAASI,UAAT,CAAoBZ,CAApB,EAAuB;MACrB,OAAO,kBAAkBb,IAAlB,CAAuBa,CAAvB,CAAP;IACD;IACD;AACA;AACA;AACA;;;IAGA,SAASa,MAAT,CAAgBC,IAAhB,EAAsB;MACpB,IAAIA,IAAI,CAACC,IAAL,KAAc,YAAlB,EAAgC;QAC9B,OAAOH,UAAU,CAACE,IAAI,CAAC9B,IAAN,CAAjB;MACD,CAFD,MAEO,IAAI8B,IAAI,CAACC,IAAL,KAAc,kBAAd,IAAoC,CAACD,IAAI,CAACE,QAA1C,IAAsDH,MAAM,CAACC,IAAI,CAACG,QAAN,CAAhE,EAAiF;QACtF,IAAIC,GAAG,GAAGJ,IAAI,CAACK,MAAf;QACA,IAAIC,qBAAqB,GAAG,UAA5B;QACA,OAAOF,GAAG,CAACH,IAAJ,KAAa,YAAb,IAA6BK,qBAAqB,CAACjC,IAAtB,CAA2B+B,GAAG,CAAClC,IAA/B,CAApC;MACD,CAJM,MAIA;QACL,OAAO,KAAP;MACD;IACF;IACD;AACA;AACA;AACA;AACA;;;IAGA,SAASqC,eAAT,CAAyBP,IAAzB,EAA+B;MAC7B,IAAIA,IAAI,CAACC,IAAL,KAAc,YAAlB,EAAgC;QAC9B,OAAO,CAAC,SAAS5B,IAAT,CAAc2B,IAAI,CAAC9B,IAAnB,CAAR;MACD,CAFD,MAEO;QACL,OAAO,KAAP;MACD;IACF;;IAED,SAASsC,eAAT,CAAyBR,IAAzB,EAA+BS,YAA/B,EAA6C;MAC3C,OAAOT,IAAI,CAAC9B,IAAL,KAAcuC,YAAd,IAA8BT,IAAI,CAACC,IAAL,KAAc,kBAAd,IAAoCD,IAAI,CAACK,MAAL,CAAYnC,IAAZ,KAAqB,OAAzD,IAAoE8B,IAAI,CAACG,QAAL,CAAcjC,IAAd,KAAuBuC,YAAhI;IACD;IACD;AACA;AACA;AACA;;;IAGA,SAASC,oBAAT,CAA8BV,IAA9B,EAAoC;MAClC,OAAO,CAAC,EAAEA,IAAI,CAACW,MAAL,IAAeX,IAAI,CAACW,MAAL,CAAYC,MAA3B,IAAqCJ,eAAe,CAACR,IAAI,CAACW,MAAL,CAAYC,MAAb,EAAqB,YAArB,CAAtD,CAAR;IACD;IACD;AACA;AACA;AACA;;;IAGA,SAASC,cAAT,CAAwBb,IAAxB,EAA8B;MAC5B,OAAO,CAAC,EAAEA,IAAI,CAACW,MAAL,IAAeX,IAAI,CAACW,MAAL,CAAYC,MAA3B,IAAqCJ,eAAe,CAACR,IAAI,CAACW,MAAL,CAAYC,MAAb,EAAqB,MAArB,CAAtD,CAAR;IACD;;IAED,SAASE,uBAAT,CAAiCd,IAAjC,EAAuC;MACrC,OAAOA,IAAP,EAAa;QACX,IAAIS,YAAY,GAAGM,eAAe,CAACf,IAAD,CAAlC;;QAEA,IAAIS,YAAJ,EAAkB;UAChB,IAAIF,eAAe,CAACE,YAAD,CAAf,IAAiCV,MAAM,CAACU,YAAD,CAA3C,EAA2D;YACzD,OAAO,IAAP;UACD;QACF;;QAED,IAAIC,oBAAoB,CAACV,IAAD,CAApB,IAA8Ba,cAAc,CAACb,IAAD,CAAhD,EAAwD;UACtD,OAAO,IAAP;QACD;;QAEDA,IAAI,GAAGA,IAAI,CAACW,MAAZ;MACD;;MAED,OAAO,KAAP;IACD;;IAED,IAAIK,YAAY,GAAG;MACjBC,IAAI,EAAE;QACJhB,IAAI,EAAE,SADF;QAEJiB,IAAI,EAAE;UACJC,WAAW,EAAE,6BADT;UAEJC,WAAW,EAAE,IAFT;UAGJC,GAAG,EAAE;QAHD;MAFF,CADW;MASjBC,MAAM,EAAE,UAAUC,OAAV,EAAmB;QACzB,IAAIC,0BAA0B,GAAG,EAAjC;QACA,IAAIC,oBAAoB,GAAG,EAA3B;QACA,OAAO;UACL;UACAC,sBAAsB,EAAE,UAAUC,OAAV,EAAmB;YACzC,OAAOF,oBAAoB,CAACG,IAArB,CAA0BD,OAA1B,CAAP;UACD,CAJI;UAKLE,oBAAoB,EAAE,YAAY;YAChC,OAAOJ,oBAAoB,CAACK,GAArB,EAAP;UACD,CAPI;UAQL;UACAC,eAAe,EAAE,YAAY;YAC3B,OAAOP,0BAA0B,CAACI,IAA3B,CAAgC,IAAII,GAAJ,EAAhC,CAAP;UACD,CAXI;UAYL;UACA;UACA;UACA;UACAC,aAAa,EAAE,UAAUC,QAAV,EAAoBC,YAApB,EAAkC;YAC/C,IAAIC,aAAa,GAAGZ,0BAA0B,CAACM,GAA3B,EAApB;;YAEA,IAAIM,aAAa,CAACC,IAAd,KAAuB,CAA3B,EAA8B;cAC5B;YACD,CAL8C,CAK7C;;;YAGF,IAAIC,MAAM,GAAG,IAAIC,GAAJ,EAAb;YACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;YAEQ,SAASC,mBAAT,CAA6Bb,OAA7B,EAAsCc,WAAtC,EAAmD;cACjD,IAAIC,KAAK,GAAGF,mBAAmB,CAACE,KAAhC;cACA,IAAIC,KAAK,GAAGD,KAAK,CAACE,GAAN,CAAUjB,OAAO,CAACkB,EAAlB,CAAZ;cACA,IAAIC,QAAQ,GAAG,IAAIP,GAAJ,CAAQE,WAAR,CAAf,CAHiD,CAGZ;cACrC;;cAEA,IAAIK,QAAQ,CAACC,GAAT,CAAapB,OAAO,CAACkB,EAArB,CAAJ,EAA8B;gBAC5B,IAAIG,SAAS,GAAG,GAAGC,MAAH,CAAUH,QAAV,CAAhB;gBACA,IAAII,cAAc,GAAGF,SAAS,CAAChF,KAAV,CAAgBgF,SAAS,CAACG,OAAV,CAAkBxB,OAAO,CAACkB,EAA1B,IAAgC,CAAhD,CAArB;;gBAEA,IAAIO,SAAS,GAAGzE,0BAA0B,CAACuE,cAAD,CAA1C;gBAAA,IACIG,KADJ;;gBAGA,IAAI;kBACF,KAAKD,SAAS,CAAClE,CAAV,EAAL,EAAoB,CAAC,CAACmE,KAAK,GAAGD,SAAS,CAACzF,CAAV,EAAT,EAAwBwB,IAA7C,GAAoD;oBAClD,IAAImE,aAAa,GAAGD,KAAK,CAACjE,KAA1B;oBACAkD,MAAM,CAACiB,GAAP,CAAWD,aAAX;kBACD;gBACF,CALD,CAKE,OAAO5D,GAAP,EAAY;kBACZ0D,SAAS,CAAC/D,CAAV,CAAYK,GAAZ;gBACD,CAPD,SAOU;kBACR0D,SAAS,CAAC9D,CAAV;gBACD;;gBAED,OAAOkE,MAAM,CAAC,GAAD,CAAb;cACD,CAzBgD,CAyB/C;;;cAGFV,QAAQ,CAACS,GAAT,CAAa5B,OAAO,CAACkB,EAArB,EA5BiD,CA4BvB;;cAE1B,IAAIF,KAAK,KAAKc,SAAd,EAAyB;gBACvB,OAAOd,KAAP;cACD;;cAED,IAAIT,QAAQ,CAACwB,cAAT,CAAwBC,QAAxB,CAAiChC,OAAjC,CAAJ,EAA+C;gBAC7CgB,KAAK,GAAGa,MAAM,CAAC,GAAD,CAAd;cACD,CAFD,MAEO,IAAI7B,OAAO,CAACiC,YAAR,CAAqBpF,MAArB,KAAgC,CAApC,EAAuC;gBAC5CmE,KAAK,GAAGa,MAAM,CAAC,GAAD,CAAd;cACD,CAFM,MAEA;gBACLb,KAAK,GAAGa,MAAM,CAAC,GAAD,CAAd;;gBAEA,IAAIK,UAAU,GAAGlF,0BAA0B,CAACgD,OAAO,CAACiC,YAAT,CAA3C;gBAAA,IACIE,MADJ;;gBAGA,IAAI;kBACF,KAAKD,UAAU,CAAC3E,CAAX,EAAL,EAAqB,CAAC,CAAC4E,MAAM,GAAGD,UAAU,CAAClG,CAAX,EAAV,EAA0BwB,IAAhD,GAAuD;oBACrD,IAAI4E,WAAW,GAAGD,MAAM,CAAC1E,KAAzB;oBACAuD,KAAK,IAAIH,mBAAmB,CAACuB,WAAD,EAAcjB,QAAd,CAA5B;kBACD;gBACF,CALD,CAKE,OAAOpD,GAAP,EAAY;kBACZmE,UAAU,CAACxE,CAAX,CAAaK,GAAb;gBACD,CAPD,SAOU;kBACRmE,UAAU,CAACvE,CAAX;gBACD;cACF,CAtDgD,CAsD/C;cACF;;;cAGA,IAAIqC,OAAO,CAACqC,SAAR,IAAqBrB,KAAK,KAAKa,MAAM,CAAC,GAAD,CAAzC,EAAgD;gBAC9Cd,KAAK,CAACuB,MAAN,CAAatC,OAAO,CAACkB,EAArB;cACD,CAFD,MAEO;gBACLH,KAAK,CAACwB,GAAN,CAAUvC,OAAO,CAACkB,EAAlB,EAAsBF,KAAtB;cACD;;cAED,OAAOA,KAAP;YACD;YACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;YAGQ,SAASwB,eAAT,CAAyBxC,OAAzB,EAAkCc,WAAlC,EAA+C;cAC7C,IAAIC,KAAK,GAAGyB,eAAe,CAACzB,KAA5B;cACA,IAAIC,KAAK,GAAGD,KAAK,CAACE,GAAN,CAAUjB,OAAO,CAACkB,EAAlB,CAAZ;cACA,IAAIC,QAAQ,GAAG,IAAIP,GAAJ,CAAQE,WAAR,CAAf,CAH6C,CAGR;cACrC;;cAEA,IAAIK,QAAQ,CAACC,GAAT,CAAapB,OAAO,CAACkB,EAArB,CAAJ,EAA8B;gBAC5B,IAAIG,SAAS,GAAG7E,KAAK,CAACC,IAAN,CAAW0E,QAAX,CAAhB;gBACA,IAAII,cAAc,GAAGF,SAAS,CAAChF,KAAV,CAAgBgF,SAAS,CAACG,OAAV,CAAkBxB,OAAO,CAACkB,EAA1B,IAAgC,CAAhD,CAArB;;gBAEA,IAAIuB,UAAU,GAAGzF,0BAA0B,CAACuE,cAAD,CAA3C;gBAAA,IACImB,MADJ;;gBAGA,IAAI;kBACF,KAAKD,UAAU,CAAClF,CAAX,EAAL,EAAqB,CAAC,CAACmF,MAAM,GAAGD,UAAU,CAACzG,CAAX,EAAV,EAA0BwB,IAAhD,GAAuD;oBACrD,IAAImE,aAAa,GAAGe,MAAM,CAACjF,KAA3B;oBACAkD,MAAM,CAACiB,GAAP,CAAWD,aAAX;kBACD;gBACF,CALD,CAKE,OAAO5D,GAAP,EAAY;kBACZ0E,UAAU,CAAC/E,CAAX,CAAaK,GAAb;gBACD,CAPD,SAOU;kBACR0E,UAAU,CAAC9E,CAAX;gBACD;;gBAED,OAAOkE,MAAM,CAAC,GAAD,CAAb;cACD,CAzB4C,CAyB3C;;;cAGFV,QAAQ,CAACS,GAAT,CAAa5B,OAAO,CAACkB,EAArB,EA5B6C,CA4BnB;;cAE1B,IAAIF,KAAK,KAAKc,SAAd,EAAyB;gBACvB,OAAOd,KAAP;cACD;;cAED,IAAIT,QAAQ,CAACwB,cAAT,CAAwBC,QAAxB,CAAiChC,OAAjC,CAAJ,EAA+C;gBAC7CgB,KAAK,GAAGa,MAAM,CAAC,GAAD,CAAd;cACD,CAFD,MAEO,IAAI7B,OAAO,CAAC2C,YAAR,CAAqB9F,MAArB,KAAgC,CAApC,EAAuC;gBAC5CmE,KAAK,GAAGa,MAAM,CAAC,GAAD,CAAd;cACD,CAFM,MAEA;gBACLb,KAAK,GAAGa,MAAM,CAAC,GAAD,CAAd;;gBAEA,IAAIe,UAAU,GAAG5F,0BAA0B,CAACgD,OAAO,CAAC2C,YAAT,CAA3C;gBAAA,IACIE,MADJ;;gBAGA,IAAI;kBACF,KAAKD,UAAU,CAACrF,CAAX,EAAL,EAAqB,CAAC,CAACsF,MAAM,GAAGD,UAAU,CAAC5G,CAAX,EAAV,EAA0BwB,IAAhD,GAAuD;oBACrD,IAAIsF,WAAW,GAAGD,MAAM,CAACpF,KAAzB;oBACAuD,KAAK,IAAIwB,eAAe,CAACM,WAAD,EAAc3B,QAAd,CAAxB;kBACD;gBACF,CALD,CAKE,OAAOpD,GAAP,EAAY;kBACZ6E,UAAU,CAAClF,CAAX,CAAaK,GAAb;gBACD,CAPD,SAOU;kBACR6E,UAAU,CAACjF,CAAX;gBACD;cACF;;cAEDoD,KAAK,CAACwB,GAAN,CAAUvC,OAAO,CAACkB,EAAlB,EAAsBF,KAAtB;cACA,OAAOA,KAAP;YACD;YACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;YAGQ,SAAS+B,yBAAT,CAAmC/C,OAAnC,EAA4C;cAC1C,IAAIe,KAAK,GAAGgC,yBAAyB,CAAChC,KAAtC;cACA,IAAIlE,MAAM,GAAGkE,KAAK,CAACE,GAAN,CAAUjB,OAAO,CAACkB,EAAlB,CAAb,CAF0C,CAEN;cACpC;;cAEA,IAAIrE,MAAM,KAAK,IAAf,EAAqB;gBACnB,OAAOmG,QAAP;cACD,CAPyC,CAOxC;;;cAGF,IAAInG,MAAM,KAAKiF,SAAf,EAA0B;gBACxB,OAAOjF,MAAP;cACD,CAZyC,CAYxC;;;cAGFkE,KAAK,CAACwB,GAAN,CAAUvC,OAAO,CAACkB,EAAlB,EAAsB,IAAtB;;cAEA,IAAIlB,OAAO,CAACiC,YAAR,CAAqBpF,MAArB,KAAgC,CAApC,EAAuC;gBACrCA,MAAM,GAAG,CAAT;cACD,CAFD,MAEO;gBACLA,MAAM,GAAGmG,QAAT;;gBAEA,IAAIC,UAAU,GAAGjG,0BAA0B,CAACgD,OAAO,CAACiC,YAAT,CAA3C;gBAAA,IACIiB,MADJ;;gBAGA,IAAI;kBACF,KAAKD,UAAU,CAAC1F,CAAX,EAAL,EAAqB,CAAC,CAAC2F,MAAM,GAAGD,UAAU,CAACjH,CAAX,EAAV,EAA0BwB,IAAhD,GAAuD;oBACrD,IAAI4E,WAAW,GAAGc,MAAM,CAACzF,KAAzB;oBACA,IAAI0F,UAAU,GAAGJ,yBAAyB,CAACX,WAAD,CAA1C;;oBAEA,IAAIe,UAAU,GAAGtG,MAAjB,EAAyB;sBACvBA,MAAM,GAAGsG,UAAT;oBACD;kBACF;gBACF,CATD,CASE,OAAOpF,GAAP,EAAY;kBACZkF,UAAU,CAACvF,CAAX,CAAaK,GAAb;gBACD,CAXD,SAWU;kBACRkF,UAAU,CAACtF,CAAX;gBACD;;gBAEDd,MAAM,IAAI,CAAV;cACD;;cAEDkE,KAAK,CAACwB,GAAN,CAAUvC,OAAO,CAACkB,EAAlB,EAAsBrE,MAAtB;cACA,OAAOA,MAAP;YACD;;YAEDgE,mBAAmB,CAACE,KAApB,GAA4B,IAAIV,GAAJ,EAA5B;YACAmC,eAAe,CAACzB,KAAhB,GAAwB,IAAIV,GAAJ,EAAxB;YACA0C,yBAAyB,CAAChC,KAA1B,GAAkC,IAAIV,GAAJ,EAAlC,CA3P+C,CA2PF;YAC7C;;YAEA,IAAI+C,sBAAsB,GAAGZ,eAAe,CAACjC,QAAQ,CAAC8C,cAAV,CAA5C,CA9P+C,CA8PwB;YACvE;YACA;YACA;YACA;YACA;;YAEA,IAAIC,oBAAoB,GAAGlE,eAAe,CAACoB,YAAD,CAA1C,CArQ+C,CAqQW;YAC1D;;YAEA,IAAI+C,gCAAgC,GAAGpE,uBAAuB,CAACqB,YAAD,CAA9D;YACA,IAAIgD,+BAA+B,GAAGF,oBAAoB,GAAG1E,eAAe,CAAC0E,oBAAD,CAAf,IAAyClF,MAAM,CAACkF,oBAAD,CAAlD,GAA2EvE,oBAAoB,CAACyB,YAAD,CAApB,IAAsCtB,cAAc,CAACsB,YAAD,CAAzL,CAzQ+C,CAyQ0J;YACzM;YACA;;YAEA,IAAIiD,uBAAuB,GAAGT,QAA9B;;YAEA,IAAIU,UAAU,GAAG1G,0BAA0B,CAACuD,QAAQ,CAACoD,aAAV,CAA3C;YAAA,IACIC,MADJ;;YAGA,IAAI;cACF,KAAKF,UAAU,CAACnG,CAAX,EAAL,EAAqB,CAAC,CAACqG,MAAM,GAAGF,UAAU,CAAC1H,CAAX,EAAV,EAA0BwB,IAAhD,GAAuD;gBACrD,IAAIqG,YAAY,GAAGD,MAAM,CAACnG,KAA1B;;gBAEA,IAAI,CAACoG,YAAY,CAACxB,SAAlB,EAA6B;kBAC3B;gBACD;;gBAED,IAAIxF,MAAM,GAAGkG,yBAAyB,CAACc,YAAD,CAAtC;;gBAEA,IAAIhH,MAAM,GAAG4G,uBAAb,EAAsC;kBACpCA,uBAAuB,GAAG5G,MAA1B;gBACD;cACF,CAbC,CAaA;cACF;;YAED,CAhBD,CAgBE,OAAOkB,GAAP,EAAY;cACZ2F,UAAU,CAAChG,CAAX,CAAaK,GAAb;YACD,CAlBD,SAkBU;cACR2F,UAAU,CAAC/F,CAAX;YACD;;YAED,IAAImG,UAAU,GAAG9G,0BAA0B,CAACyD,aAAD,CAA3C;YAAA,IACIsD,MADJ;;YAGA,IAAI;cACF,KAAKD,UAAU,CAACvG,CAAX,EAAL,EAAqB,CAAC,CAACwG,MAAM,GAAGD,UAAU,CAAC9H,CAAX,EAAV,EAA0BwB,IAAhD,GAAuD;gBACrD,IAAIwG,YAAY,GAAGD,MAAM,CAACtG,KAA1B;gBAAA,IACIuC,OAAO,GAAGgE,YAAY,CAAC,CAAD,CAD1B;gBAAA,IAEIC,UAAU,GAAGD,YAAY,CAAC,CAAD,CAF7B,CADqD,CAKrD;gBACA;gBACA;;gBACA,IAAI,CAAChE,OAAO,CAACqC,SAAb,EAAwB;kBACtB;gBACD,CAVoD,CAUnD;gBACF;gBACA;gBACA;gBACA;;;gBAGA,IAAI6B,sBAAsB,GAAGlE,OAAO,CAAC2C,YAAR,CAAqB9F,MAArB,KAAgC,CAAhC,GAAoC4G,uBAAuB,IAAIV,yBAAyB,CAAC/C,OAAD,CAAxF,GAAoGyD,uBAAuB,GAAGV,yBAAyB,CAAC/C,OAAD,CAApL,CAjBqD,CAiB0I;gBAC/L;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;;gBAEA,IAAImE,mBAAmB,GAAGtD,mBAAmB,CAACb,OAAD,CAAnB,GAA+BwC,eAAe,CAACxC,OAAD,CAAxE,CArDqD,CAqD8B;;gBAEnF,IAAIoE,MAAM,GAAGzD,MAAM,CAACS,GAAP,CAAWpB,OAAO,CAACkB,EAAnB,CAAb;;gBAEA,IAAImD,UAAU,GAAGrH,0BAA0B,CAACiH,UAAD,CAA3C;gBAAA,IACIK,MADJ;;gBAGA,IAAI;kBACF,KAAKD,UAAU,CAAC9G,CAAX,EAAL,EAAqB,CAAC,CAAC+G,MAAM,GAAGD,UAAU,CAACrI,CAAX,EAAV,EAA0BwB,IAAhD,GAAuD;oBACrD,IAAI+G,IAAI,GAAGD,MAAM,CAAC7G,KAAlB,CADqD,CAGrD;;oBACA,IAAI2G,MAAJ,EAAY;sBACVxE,OAAO,CAAC4E,MAAR,CAAe;wBACbnG,IAAI,EAAEkG,IADO;wBAEbE,OAAO,EAAE,kBAAkB7E,OAAO,CAAC8E,SAAR,CAAkBH,IAAlB,CAAlB,GAA4C,qBAA5C,GAAoE,2DAApE,GAAkI,wDAAlI,GAA6L;sBAFzL,CAAf;oBAID,CAToD,CASnD;oBACF;oBACA;oBACA;oBACA;;;oBAGA,IAAIf,+BAAJ,EAAqC;sBACnC;sBACA;sBACA;sBACA;sBACA,IAAI,CAACY,MAAD,IAAWD,mBAAmB,KAAKf,sBAAvC,EAA+D;wBAC7D,IAAIqB,OAAO,GAAG,kBAAkB7E,OAAO,CAAC8E,SAAR,CAAkBH,IAAlB,CAAlB,GAA4C,eAA5C,GAA8D,yDAA9D,GAA0H,uCAA1H,IAAqKL,sBAAsB,GAAG,qDAAqD,gBAAxD,GAA2E,EAAtQ,CAAd;wBACAtE,OAAO,CAAC4E,MAAR,CAAe;0BACbnG,IAAI,EAAEkG,IADO;0BAEbE,OAAO,EAAEA;wBAFI,CAAf;sBAID;oBACF,CAZD,MAYO,IAAIjE,YAAY,CAACxB,MAAb,KAAwBwB,YAAY,CAACxB,MAAb,CAAoBV,IAApB,KAA6B,kBAA7B,IAAmDkC,YAAY,CAACxB,MAAb,CAAoBV,IAApB,KAA6B,eAAxG,KAA4HkC,YAAY,CAACxB,MAAb,CAAoBvB,KAApB,KAA8B+C,YAA9J,EAA4K;sBACjL;sBACA,IAAImE,QAAQ,GAAG,kBAAkB/E,OAAO,CAAC8E,SAAR,CAAkBH,IAAlB,CAAlB,GAA4C,sBAA5C,GAAqE,wDAArE,GAAgI,2DAA/I;;sBAEA3E,OAAO,CAAC4E,MAAR,CAAe;wBACbnG,IAAI,EAAEkG,IADO;wBAEbE,OAAO,EAAEE;sBAFI,CAAf;oBAID,CARM,MAQA,IAAIrB,oBAAJ,EAA0B;sBAC/B;sBACA,IAAIsB,SAAS,GAAG,kBAAkBhF,OAAO,CAAC8E,SAAR,CAAkBH,IAAlB,CAAlB,GAA4C,kBAA5C,IAAkE,gBAAgB3E,OAAO,CAAC8E,SAAR,CAAkBpB,oBAAlB,CAAhB,GAA0D,KAA5H,IAAqI,0DAArI,GAAkM,sBAAlM,GAA2N,6DAA3N,GAA2R,mDAA3S;;sBAEA1D,OAAO,CAAC4E,MAAR,CAAe;wBACbnG,IAAI,EAAEkG,IADO;wBAEbE,OAAO,EAAEG;sBAFI,CAAf;oBAID,CARM,MAQA,IAAIpE,YAAY,CAAClC,IAAb,KAAsB,SAA1B,EAAqC;sBAC1C;sBACA,IAAIuG,SAAS,GAAG,kBAAkBjF,OAAO,CAAC8E,SAAR,CAAkBH,IAAlB,CAAlB,GAA4C,sBAA5C,GAAqE,oDAArE,GAA4H,2DAA5I;;sBAEA3E,OAAO,CAAC4E,MAAR,CAAe;wBACbnG,IAAI,EAAEkG,IADO;wBAEbE,OAAO,EAAEI;sBAFI,CAAf;oBAID,CARM,MAQA;sBACL;sBACA;sBACA;sBACA;sBACA;sBACA,IAAItB,gCAAJ,EAAsC;wBACpC,IAAIuB,SAAS,GAAG,kBAAkBlF,OAAO,CAAC8E,SAAR,CAAkBH,IAAlB,CAAlB,GAA4C,sBAA5C,GAAqE,qDAArE,GAA6H,2DAA7I;;wBAEA3E,OAAO,CAAC4E,MAAR,CAAe;0BACbnG,IAAI,EAAEkG,IADO;0BAEbE,OAAO,EAAEK;wBAFI,CAAf;sBAID;oBACF;kBACF;gBACF,CArED,CAqEE,OAAO/G,GAAP,EAAY;kBACZsG,UAAU,CAAC3G,CAAX,CAAaK,GAAb;gBACD,CAvED,SAuEU;kBACRsG,UAAU,CAAC1G,CAAX;gBACD;cACF;YACF,CAxID,CAwIE,OAAOI,GAAP,EAAY;cACZ+F,UAAU,CAACpG,CAAX,CAAaK,GAAb;YACD,CA1ID,SA0IU;cACR+F,UAAU,CAACnG,CAAX;YACD;UACF,CAxcI;UAycL;UACA;UACA;UACA;UACAoH,cAAc,EAAE,UAAU1G,IAAV,EAAgB;YAC9B,IAAID,MAAM,CAACC,IAAI,CAACY,MAAN,CAAV,EAAyB;cACvB;cACA;cACA,IAAIwB,aAAa,GAAGuE,IAAI,CAACnF,0BAAD,CAAxB;cACA,IAAIoF,eAAe,GAAGD,IAAI,CAAClF,oBAAD,CAA1B;cACA,IAAImE,UAAU,GAAGxD,aAAa,CAACQ,GAAd,CAAkBgE,eAAlB,CAAjB;;cAEA,IAAI,CAAChB,UAAL,EAAiB;gBACfA,UAAU,GAAG,EAAb;gBACAxD,aAAa,CAAC8B,GAAd,CAAkB0C,eAAlB,EAAmChB,UAAnC;cACD;;cAEDA,UAAU,CAAChE,IAAX,CAAgB5B,IAAI,CAACY,MAArB;YACD;UACF;QA5dI,CAAP;MA8dD;IA1egB,CAAnB;IA4eA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEA,SAASG,eAAT,CAAyBf,IAAzB,EAA+B;MAC7B,IAAIA,IAAI,CAACC,IAAL,KAAc,qBAAd,IAAuCD,IAAI,CAACC,IAAL,KAAc,oBAAd,IAAsCD,IAAI,CAAC6C,EAAtF,EAA0F;QACxF;QACA;QACA;QACA;QACA;QACA,OAAO7C,IAAI,CAAC6C,EAAZ;MACD,CAPD,MAOO,IAAI7C,IAAI,CAACC,IAAL,KAAc,oBAAd,IAAsCD,IAAI,CAACC,IAAL,KAAc,yBAAxD,EAAmF;QACxF,IAAID,IAAI,CAACW,MAAL,CAAYV,IAAZ,KAAqB,oBAArB,IAA6CD,IAAI,CAACW,MAAL,CAAYkG,IAAZ,KAAqB7G,IAAtE,EAA4E;UAC1E;UACA,OAAOA,IAAI,CAACW,MAAL,CAAYkC,EAAnB;QACD,CAHD,MAGO,IAAI7C,IAAI,CAACW,MAAL,CAAYV,IAAZ,KAAqB,sBAArB,IAA+CD,IAAI,CAACW,MAAL,CAAYmG,KAAZ,KAAsB9G,IAArE,IAA6EA,IAAI,CAACW,MAAL,CAAYoG,QAAZ,KAAyB,GAA1G,EAA+G;UACpH;UACA,OAAO/G,IAAI,CAACW,MAAL,CAAYqG,IAAnB;QACD,CAHM,MAGA,IAAIhH,IAAI,CAACW,MAAL,CAAYV,IAAZ,KAAqB,UAArB,IAAmCD,IAAI,CAACW,MAAL,CAAYvB,KAAZ,KAAsBY,IAAzD,IAAiE,CAACA,IAAI,CAACW,MAAL,CAAYT,QAAlF,EAA4F;UACjG;UACA;UACA,OAAOF,IAAI,CAACW,MAAL,CAAYsG,GAAnB,CAHiG,CAGzE;UACxB;UACA;UACA;UACA;UACA;QACD,CATM,MASA,IAAIjH,IAAI,CAACW,MAAL,CAAYV,IAAZ,KAAqB,mBAArB,IAA4CD,IAAI,CAACW,MAAL,CAAYmG,KAAZ,KAAsB9G,IAAlE,IAA0E,CAACA,IAAI,CAACW,MAAL,CAAYT,QAA3F,EAAqG;UAC1G;UACA;UACA;UACA;UACA;UACA,OAAOF,IAAI,CAACW,MAAL,CAAYqG,IAAnB;QACD,CAPM,MAOA;UACL,OAAOvD,SAAP;QACD;MACF,CA1BM,MA0BA;QACL,OAAOA,SAAP;MACD;IACF;IACD;AACA;AACA;;;IAGA,SAASkD,IAAT,CAAcO,KAAd,EAAqB;MACnB,OAAOA,KAAK,CAACA,KAAK,CAAC1I,MAAN,GAAe,CAAhB,CAAZ;IACD;IAED;;;IACA,IAAI2I,cAAc,GAAG;MACnBlG,IAAI,EAAE;QACJhB,IAAI,EAAE,YADF;QAEJiB,IAAI,EAAE;UACJC,WAAW,EAAE,wEADT;UAEJC,WAAW,EAAE,IAFT;UAGJC,GAAG,EAAE;QAHD,CAFF;QAOJ+F,OAAO,EAAE,MAPL;QAQJC,cAAc,EAAE,IARZ;QASJC,MAAM,EAAE,CAAC;UACPrH,IAAI,EAAE,QADC;UAEPsH,oBAAoB,EAAE,KAFf;UAGPC,+CAA+C,EAAE,KAH1C;UAIPC,UAAU,EAAE;YACVC,eAAe,EAAE;cACfzH,IAAI,EAAE;YADS,CADP;YAIVuH,+CAA+C,EAAE;cAC/CvH,IAAI,EAAE;YADyC;UAJvC;QAJL,CAAD;MATJ,CADa;MAwBnBqB,MAAM,EAAE,UAAUC,OAAV,EAAmB;QACzB;QACA,IAAImG,eAAe,GAAGnG,OAAO,CAACoG,OAAR,IAAmBpG,OAAO,CAACoG,OAAR,CAAgB,CAAhB,CAAnB,IAAyCpG,OAAO,CAACoG,OAAR,CAAgB,CAAhB,EAAmBD,eAA5D,GAA8E,IAAIE,MAAJ,CAAWrG,OAAO,CAACoG,OAAR,CAAgB,CAAhB,EAAmBD,eAA9B,CAA9E,GAA+HjE,SAArJ;QACA,IAAI+D,+CAA+C,GAAGjG,OAAO,CAACoG,OAAR,IAAmBpG,OAAO,CAACoG,OAAR,CAAgB,CAAhB,CAAnB,IAAyCpG,OAAO,CAACoG,OAAR,CAAgB,CAAhB,EAAmBH,+CAA5D,IAA+G,KAArK;QACA,IAAIG,OAAO,GAAG;UACZD,eAAe,EAAEA,eADL;UAEZF,+CAA+C,EAAEA;QAFrC,CAAd;;QAKA,SAASK,aAAT,CAAuBC,OAAvB,EAAgC;UAC9B,IAAIN,+CAAJ,EAAqD;YACnD;YACA;YACA,IAAIrJ,KAAK,CAACa,OAAN,CAAc8I,OAAO,CAACC,OAAtB,KAAkCD,OAAO,CAACC,OAAR,CAAgBvJ,MAAhB,GAAyB,CAA/D,EAAkE;cAChEsJ,OAAO,CAACE,GAAR,GAAcF,OAAO,CAACC,OAAR,CAAgB,CAAhB,EAAmBC,GAAjC;YACD;UACF;;UAEDzG,OAAO,CAAC4E,MAAR,CAAe2B,OAAf;QACD;;QAED,IAAIG,YAAY,GAAG1G,OAAO,CAAC2G,aAAR,GAAwBD,YAA3C,CArByB,CAqBgC;;QAEzD,IAAIE,iBAAiB,GAAG,IAAIC,OAAJ,EAAxB;QACA,IAAIC,cAAc,GAAG,IAAIC,OAAJ,EAArB;QACA,IAAIC,qBAAqB,GAAG,IAAIH,OAAJ,EAA5B;QACA,IAAII,iCAAiC,GAAG,IAAIJ,OAAJ,EAAxC;;QAEA,SAASK,kBAAT,CAA4BC,EAA5B,EAAgCC,GAAhC,EAAqC;UACnC,OAAO,UAAUC,GAAV,EAAe;YACpB,IAAID,GAAG,CAAC5F,GAAJ,CAAQ6F,GAAR,CAAJ,EAAkB;cAChB;cACA;cACA,OAAOD,GAAG,CAAC/F,GAAJ,CAAQgG,GAAR,CAAP;YACD;;YAED,IAAIC,MAAM,GAAGH,EAAE,CAACE,GAAD,CAAf;YACAD,GAAG,CAACzE,GAAJ,CAAQ0E,GAAR,EAAaC,MAAb;YACA,OAAOA,MAAP;UACD,CAVD;QAWD;QACD;AACJ;AACA;;;QAGI,SAASC,6BAAT,CAAuC9I,IAAvC,EAA6C+I,wBAA7C,EAAuEC,YAAvE,EAAqFC,gBAArF,EAAuGC,QAAvG,EAAiH;UAC/G,IAAIA,QAAQ,IAAIlJ,IAAI,CAACmJ,KAArB,EAA4B;YAC1BtB,aAAa,CAAC;cACZ7H,IAAI,EAAEA,IADM;cAEZoG,OAAO,EAAE,kEAAkE,oCAAlE,GAAyG,qBAAzG,GAAiI,kCAAjI,GAAsK,6BAAtK,GAAsM,qDAAtM,GAA8P,cAA9P,GAA+Q,OAA/Q,GAAyR,kBAAzR,GAA8S,kEAA9S,GAAmX;YAFhX,CAAD,CAAb;UAID,CAN8G,CAM7G;;;UAGF,IAAIgD,KAAK,GAAGnB,YAAY,CAACoB,OAAb,CAAqBrJ,IAArB,CAAZ,CAT+G,CASvE;UACxC;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA,IAAIsJ,UAAU,GAAG,IAAI/G,GAAJ,EAAjB;UACA,IAAIgH,cAAc,GAAG,IAArB;UACA;YACE,IAAIC,YAAY,GAAGJ,KAAK,CAACK,KAAzB;;YAEA,OAAOD,YAAP,EAAqB;cACnBF,UAAU,CAAC/F,GAAX,CAAeiG,YAAf;;cAEA,IAAIA,YAAY,CAACvJ,IAAb,KAAsB,UAA1B,EAAsC;gBACpC;cACD;;cAEDuJ,YAAY,GAAGA,YAAY,CAACC,KAA5B;YACD,CAXH,CAWI;YACF;YACA;;;YAGA,IAAI,CAACD,YAAL,EAAmB;cACjB;YACD;;YAEDD,cAAc,GAAGC,YAAjB;UACD;UACD,IAAIxK,OAAO,GAAGb,KAAK,CAACa,OAApB,CA1C+G,CA0ClF;UAC7B;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA,SAAS0K,sBAAT,CAAgCC,QAAhC,EAA0C;YACxC,IAAI,CAAC3K,OAAO,CAAC2K,QAAQ,CAACC,IAAV,CAAZ,EAA6B;cAC3B,OAAO,KAAP;YACD;;YAED,IAAIC,GAAG,GAAGF,QAAQ,CAACC,IAAT,CAAc,CAAd,CAAV;;YAEA,IAAIC,GAAG,IAAI,IAAX,EAAiB;cACf,OAAO,KAAP;YACD,CATuC,CAStC;;;YAGF,IAAIA,GAAG,CAAC7J,IAAJ,CAASC,IAAT,KAAkB,oBAAtB,EAA4C;cAC1C,OAAO,KAAP;YACD;;YAED,IAAI4G,IAAI,GAAGgD,GAAG,CAAC7J,IAAJ,CAAS6G,IAApB;;YAEA,IAAIA,IAAI,IAAI,IAAZ,EAAkB;cAChB,OAAO,KAAP;YACD;;YAED,OAAOA,IAAI,CAAC5G,IAAL,KAAc,gBAArB,EAAuC;cACrC4G,IAAI,GAAGA,IAAI,CAACiD,UAAZ;YACD,CAxBuC,CAwBtC;YACF;;;YAGA,IAAIC,WAAW,GAAGF,GAAG,CAAC7J,IAAJ,CAASW,MAA3B;;YAEA,IAAIoJ,WAAW,IAAI,IAAnB,EAAyB;cACvB;cACA;cACA;cACAC,2BAA2B,CAACT,cAAc,CAACU,KAAhB,EAAuBJ,GAAG,CAAC7J,IAAJ,CAAS6C,EAAhC,CAA3B;cACAkH,WAAW,GAAGF,GAAG,CAAC7J,IAAJ,CAASW,MAAvB;;cAEA,IAAIoJ,WAAW,IAAI,IAAnB,EAAyB;gBACvB,OAAO,KAAP;cACD;YACF;;YAED,IAAIA,WAAW,CAACG,IAAZ,KAAqB,OAArB,IAAgCrD,IAAI,CAAC5G,IAAL,KAAc,SAA9C,KAA4D,OAAO4G,IAAI,CAACzH,KAAZ,KAAsB,QAAtB,IAAkC,OAAOyH,IAAI,CAACzH,KAAZ,KAAsB,QAAxD,IAAoEyH,IAAI,CAACzH,KAAL,KAAe,IAA/I,CAAJ,EAA0J;cACxJ;cACA,OAAO,IAAP;YACD,CA7CuC,CA6CtC;YACF;;;YAGA,IAAIyH,IAAI,CAAC5G,IAAL,KAAc,gBAAlB,EAAoC;cAClC,OAAO,KAAP;YACD;;YAED,IAAIW,MAAM,GAAGiG,IAAI,CAACjG,MAAlB,CArDwC,CAqDd;;YAE1B,IAAIA,MAAM,CAACX,IAAP,KAAgB,kBAAhB,IAAsCW,MAAM,CAACP,MAAP,CAAcnC,IAAd,KAAuB,OAA7D,IAAwE0C,MAAM,CAACT,QAAP,IAAmB,IAA3F,IAAmG,CAACS,MAAM,CAACV,QAA/G,EAAyH;cACvHU,MAAM,GAAGA,MAAM,CAACT,QAAhB;YACD;;YAED,IAAIS,MAAM,CAACX,IAAP,KAAgB,YAApB,EAAkC;cAChC,OAAO,KAAP;YACD;;YAED,IAAI4C,EAAE,GAAGgH,GAAG,CAAC7J,IAAJ,CAAS6C,EAAlB;YACA,IAAIsH,OAAO,GAAGvJ,MAAd;YAAA,IACI1C,IAAI,GAAGiM,OAAO,CAACjM,IADnB;;YAGA,IAAIA,IAAI,KAAK,QAAT,IAAqB2E,EAAE,CAAC5C,IAAH,KAAY,YAArC,EAAmD;cACjD;cACA,OAAO,IAAP;YACD,CAHD,MAGO,IAAI/B,IAAI,KAAK,UAAT,IAAuBA,IAAI,KAAK,YAApC,EAAkD;cACvD;cACA,IAAI2E,EAAE,CAAC5C,IAAH,KAAY,cAAZ,IAA8B4C,EAAE,CAACuH,QAAH,CAAY5L,MAAZ,KAAuB,CAArD,IAA0DQ,OAAO,CAAC2K,QAAQ,CAACU,WAAV,CAArE,EAA6F;gBAC3F;gBACA,IAAIxH,EAAE,CAACuH,QAAH,CAAY,CAAZ,MAAmBT,QAAQ,CAACU,WAAT,CAAqB,CAArB,CAAvB,EAAgD;kBAC9C,IAAInM,IAAI,KAAK,UAAb,EAAyB;oBACvB,IAAIoM,UAAU,GAAGX,QAAQ,CAACW,UAA1B;oBACA,IAAIC,UAAU,GAAG,CAAjB;;oBAEA,KAAK,IAAI9L,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6L,UAAU,CAAC9L,MAA/B,EAAuCC,CAAC,EAAxC,EAA4C;sBAC1C,IAAI6L,UAAU,CAAC7L,CAAD,CAAV,CAAc+L,OAAd,EAAJ,EAA6B;wBAC3BD,UAAU;sBACX;;sBAED,IAAIA,UAAU,GAAG,CAAjB,EAAoB;wBAClB,OAAO,KAAP;sBACD;;sBAEDpC,iBAAiB,CAACjE,GAAlB,CAAsBoG,UAAU,CAAC7L,CAAD,CAAV,CAAcgM,UAApC,EAAgD5H,EAAE,CAACuH,QAAH,CAAY,CAAZ,CAAhD;oBACD;kBACF,CAhB6C,CAgB5C;;;kBAGF,OAAO,IAAP;gBACD,CApBD,MAoBO,IAAIvH,EAAE,CAACuH,QAAH,CAAY,CAAZ,MAAmBT,QAAQ,CAACU,WAAT,CAAqB,CAArB,CAAvB,EAAgD;kBACrD,IAAInM,IAAI,KAAK,UAAb,EAAyB;oBACvB,IAAIwM,WAAW,GAAGf,QAAQ,CAACW,UAA3B;;oBAEA,KAAK,IAAIK,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGD,WAAW,CAAClM,MAAlC,EAA0CmM,EAAE,EAA5C,EAAgD;sBAC9CtC,cAAc,CAAC9E,GAAf,CAAmBmH,WAAW,CAACC,EAAD,CAAX,CAAgBF,UAAnC;oBACD;kBACF,CAPoD,CAOnD;;;kBAGF,OAAO,KAAP;gBACD;cACF;YACF,CArCM,MAqCA,IAAIvM,IAAI,KAAK,eAAb,EAA8B;cACnC;cACA,IAAI2E,EAAE,CAAC5C,IAAH,KAAY,cAAZ,IAA8B4C,EAAE,CAACuH,QAAH,CAAY5L,MAAZ,KAAuB,CAArD,IAA0DL,KAAK,CAACa,OAAN,CAAc2K,QAAQ,CAACU,WAAvB,CAA9D,EAAmG;gBACjG;gBACA,IAAIxH,EAAE,CAACuH,QAAH,CAAY,CAAZ,MAAmBT,QAAQ,CAACU,WAAT,CAAqB,CAArB,CAAvB,EAAgD;kBAC9C;kBACA,OAAO,IAAP;gBACD;cACF;YACF,CApHuC,CAoHtC;;;YAGF,OAAO,KAAP;UACD,CA7K8G,CA6K7G;;;UAGF,SAASO,+BAAT,CAAyCjB,QAAzC,EAAmD;YACjD,IAAI,CAAC3K,OAAO,CAAC2K,QAAQ,CAACC,IAAV,CAAZ,EAA6B;cAC3B,OAAO,KAAP;YACD;;YAED,IAAIC,GAAG,GAAGF,QAAQ,CAACC,IAAT,CAAc,CAAd,CAAV;;YAEA,IAAIC,GAAG,IAAI,IAAX,EAAiB;cACf,OAAO,KAAP;YACD;;YAED,IAAIA,GAAG,CAAC7J,IAAJ,IAAY,IAAZ,IAAoB6J,GAAG,CAAC7J,IAAJ,CAAS6C,EAAT,IAAe,IAAvC,EAA6C;cAC3C,OAAO,KAAP;YACD,CAbgD,CAa/C;YACF;;;YAGA,IAAIgI,MAAM,GAAGhB,GAAG,CAAC7J,IAAjB;YACA,IAAI8K,WAAW,GAAGvB,cAAc,CAACuB,WAAjC;YACA,IAAIC,OAAO,GAAG,IAAd;YACA,IAAItM,CAAJ;;YAEA,KAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGqM,WAAW,CAACtM,MAA5B,EAAoCC,CAAC,EAArC,EAAyC;cACvC,IAAIuM,UAAU,GAAGF,WAAW,CAACrM,CAAD,CAA5B;cACA,IAAIwM,eAAe,GAAGD,UAAU,CAACf,KAAjC;;cAEA,KAAK;cACLY,MAAM,CAAC5K,IAAP,KAAgB,qBAAhB,IAAyCgL,eAAe,KAAKJ,MAA7D,IAAuE;cACvE;cACAA,MAAM,CAAC5K,IAAP,KAAgB,oBAAhB,IAAwCgL,eAAe,CAACtK,MAAhB,KAA2BkK,MAHnE,EAG2E;gBACzE;gBACAE,OAAO,GAAGC,UAAV;gBACA;cACD;YACF;;YAED,IAAID,OAAO,IAAI,IAAf,EAAqB;cACnB,OAAO,KAAP;YACD,CAtCgD,CAsC/C;YACF;;;YAGA,KAAKtM,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGsM,OAAO,CAACG,OAAR,CAAgB1M,MAAhC,EAAwCC,CAAC,EAAzC,EAA6C;cAC3C,IAAI0M,GAAG,GAAGJ,OAAO,CAACG,OAAR,CAAgBzM,CAAhB,CAAV;;cAEA,IAAI0M,GAAG,CAACxB,QAAJ,IAAgB,IAApB,EAA0B;gBACxB;cACD;;cAED,IAAIL,UAAU,CAACvG,GAAX,CAAeoI,GAAG,CAACxB,QAAJ,CAAaP,KAA5B,KAAsC;cAC1C;cACA,CAACgC,8BAA8B,CAACD,GAAG,CAACxB,QAAL,CAF/B,EAE+C;gBAC7C,OAAO,KAAP;cACD;YACF,CAtDgD,CAsD/C;YACF;;;YAGA,OAAO,IAAP;UACD,CA3O8G,CA2O7G;;;UAGF,IAAIyB,8BAA8B,GAAG3C,kBAAkB,CAACiB,sBAAD,EAAyBnB,qBAAzB,CAAvD;UACA,IAAI8C,uCAAuC,GAAG5C,kBAAkB,CAACmC,+BAAD,EAAkCpC,iCAAlC,CAAhE,CA/O+G,CA+OuB;;UAEtI,IAAI8C,0BAA0B,GAAG,IAAItJ,GAAJ,EAAjC,CAjP+G,CAiPnE;UAC5C;UACA;;UAEA,SAASuJ,qBAAT,CAA+BC,SAA/B,EAA0C;YACxC,IAAIC,QAAQ,GAAGD,SAAS,CAACpN,IAAzB;YACA,IAAIsN,oBAAoB,GAAG,KAA3B;;YAEA,OAAOD,QAAQ,CAACxB,KAAT,KAAmBjK,IAA1B,EAAgC;cAC9B,IAAIyL,QAAQ,CAACxL,IAAT,KAAkB,UAAtB,EAAkC;gBAChCyL,oBAAoB,GAAGD,QAAQ,CAACxB,KAAT,CAAetJ,MAAf,IAAyB,IAAzB,IAAiC8K,QAAQ,CAACxB,KAAT,CAAetJ,MAAf,CAAsBV,IAAtB,KAA+B,iBAAvF;cACD;;cAEDwL,QAAQ,GAAGA,QAAQ,CAAChC,KAApB;YACD;;YAED,OAAOiC,oBAAP;UACD,CAlQ8G,CAkQ7G;UACF;;;UAGA,IAAIC,YAAY,GAAG,IAAI3J,GAAJ,EAAnB;UACA,IAAI4J,cAAc,GAAG,IAAI5J,GAAJ,EAArB;UACA6J,6BAA6B,CAACzC,KAAD,CAA7B;;UAEA,SAASyC,6BAAT,CAAuCrC,YAAvC,EAAqD;YACnD,IAAIpG,SAAS,GAAGzE,0BAA0B,CAAC6K,YAAY,CAACc,UAAd,CAA1C;YAAA,IACIjH,KADJ;;YAGA,IAAI;cACF,KAAKD,SAAS,CAAClE,CAAV,EAAL,EAAoB,CAAC,CAACmE,KAAK,GAAGD,SAAS,CAACzF,CAAV,EAAT,EAAwBwB,IAA7C,GAAoD;gBAClD,IAAIqM,SAAS,GAAGnI,KAAK,CAACjE,KAAtB,CADkD,CAGlD;gBACA;;gBACA,IAAI,CAACoM,SAAS,CAAC7B,QAAf,EAAyB;kBACvB;gBACD;;gBAED,IAAI,CAACL,UAAU,CAACvG,GAAX,CAAeyI,SAAS,CAAC7B,QAAV,CAAmBP,KAAlC,CAAL,EAA+C;kBAC7C;gBACD,CAXiD,CAWhD;gBACF;;;gBAGA,IAAI0C,aAAa,GAAG9B,2BAA2B,CAAChK,IAAD,EAAOwL,SAAS,CAACf,UAAjB,CAA/C;gBACA,IAAIsB,cAAc,GAAGC,aAAa,CAACF,aAAD,CAAlC;gBACA,IAAIG,UAAU,GAAGC,oBAAoB,CAACH,cAAD,EAAiBH,cAAjB,CAArC,CAjBkD,CAiBqB;;gBAEvE,KAAK;gBACL1C,QAAQ,IAAI;gBACZ6C,cAAc,CAAC9L,IAAf,KAAwB,YADxB,KACyC8L,cAAc,CAACpL,MAAf,CAAsBV,IAAtB,KAA+B,kBAA/B,IAAqD8L,cAAc,CAACpL,MAAf,CAAsBV,IAAtB,KAA+B,0BAD7H,KAC4J,CAAC8L,cAAc,CAACpL,MAAf,CAAsBT,QADnL,IAC+L6L,cAAc,CAACpL,MAAf,CAAsBR,QAAtB,CAA+BF,IAA/B,KAAwC,YADvO,IACuP8L,cAAc,CAACpL,MAAf,CAAsBR,QAAtB,CAA+BjC,IAA/B,KAAwC,SAD/R,IAC4S;gBAC5SqN,qBAAqB,CAACC,SAAD,CAHrB,EAGkC;kBAChCF,0BAA0B,CAACpH,GAA3B,CAA+B+H,UAA/B,EAA2C;oBACzCT,SAAS,EAAEA,SAD8B;oBAEzCO,cAAc,EAAEA;kBAFyB,CAA3C;gBAID;;gBAED,IAAIA,cAAc,CAACpL,MAAf,CAAsBV,IAAtB,KAA+B,aAA/B,IAAgD8L,cAAc,CAACpL,MAAf,CAAsBV,IAAtB,KAA+B,iBAAnF,EAAsG;kBACpG;gBACD;;gBAED,IAAI4J,GAAG,GAAG2B,SAAS,CAAC7B,QAAV,CAAmBC,IAAnB,CAAwB,CAAxB,CAAV;;gBAEA,IAAIC,GAAG,IAAI,IAAX,EAAiB;kBACf;gBACD,CArCiD,CAqChD;;;gBAGF,IAAIA,GAAG,CAAC7J,IAAJ,IAAY,IAAZ,IAAoB6J,GAAG,CAAC7J,IAAJ,CAAS6G,IAAT,KAAkB7G,IAAI,CAACW,MAA/C,EAAuD;kBACrD;gBACD,CA1CiD,CA0ChD;;;gBAGF,IAAIkJ,GAAG,CAAC5J,IAAJ,KAAa,eAAjB,EAAkC;kBAChC;gBACD,CA/CiD,CA+ChD;gBACF;;;gBAGA,IAAI,CAAC0L,YAAY,CAAC5I,GAAb,CAAiBkJ,UAAjB,CAAL,EAAmC;kBACjC,IAAItC,QAAQ,GAAG6B,SAAS,CAAC7B,QAAzB;kBACA,IAAIwC,QAAQ,GAAGf,8BAA8B,CAACzB,QAAD,CAA9B,IAA4C0B,uCAAuC,CAAC1B,QAAD,CAAlG;kBACAgC,YAAY,CAACzH,GAAb,CAAiB+H,UAAjB,EAA6B;oBAC3BE,QAAQ,EAAEA,QADiB;oBAE3B7B,UAAU,EAAE,CAACkB,SAAD;kBAFe,CAA7B;gBAID,CAPD,MAOO;kBACLG,YAAY,CAAC/I,GAAb,CAAiBqJ,UAAjB,EAA6B3B,UAA7B,CAAwC1I,IAAxC,CAA6C4J,SAA7C;gBACD;cACF;YACF,CA/DD,CA+DE,OAAO9L,GAAP,EAAY;cACZ0D,SAAS,CAAC/D,CAAV,CAAYK,GAAZ;YACD,CAjED,SAiEU;cACR0D,SAAS,CAAC9D,CAAV;YACD;;YAED,IAAIuE,UAAU,GAAGlF,0BAA0B,CAAC6K,YAAY,CAACsB,WAAd,CAA3C;YAAA,IACIhH,MADJ;;YAGA,IAAI;cACF,KAAKD,UAAU,CAAC3E,CAAX,EAAL,EAAqB,CAAC,CAAC4E,MAAM,GAAGD,UAAU,CAAClG,CAAX,EAAV,EAA0BwB,IAAhD,GAAuD;gBACrD,IAAI6L,UAAU,GAAGlH,MAAM,CAAC1E,KAAxB;gBACAyM,6BAA6B,CAACb,UAAD,CAA7B;cACD;YACF,CALD,CAKE,OAAOtL,GAAP,EAAY;cACZmE,UAAU,CAACxE,CAAX,CAAaK,GAAb;YACD,CAPD,SAOU;cACRmE,UAAU,CAACvE,CAAX;YACD;UACF,CAhW8G,CAgW7G;;;UAGFgM,0BAA0B,CAACc,OAA3B,CAAmC,UAAUC,IAAV,EAAgBJ,UAAhB,EAA4B;YAC7D,IAAIT,SAAS,GAAGa,IAAI,CAACb,SAArB;YAAA,IACIO,cAAc,GAAGM,IAAI,CAACN,cAD1B;YAEA,IAAIzB,UAAU,GAAGkB,SAAS,CAAC7B,QAAV,CAAmBW,UAApC,CAH6D,CAGb;YAChD;;YAEA,IAAIgC,sBAAsB,GAAG,KAA7B;;YAEA,KAAK,IAAI7N,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6L,UAAU,CAAC9L,MAA/B,EAAuCC,CAAC,EAAxC,EAA4C;cAC1C,IAAIgM,UAAU,GAAGH,UAAU,CAAC7L,CAAD,CAAV,CAAcgM,UAA/B;cACA,IAAI9J,MAAM,GAAG8J,UAAU,CAAC9J,MAAxB;;cAEA,IAAIA,MAAM,IAAI,IAAV,IAAkB;cACtB;cACAA,MAAM,CAACV,IAAP,KAAgB,kBAFZ,IAEkC,CAACU,MAAM,CAACT,QAF1C,IAEsDS,MAAM,CAACR,QAAP,CAAgBF,IAAhB,KAAyB,YAF/E,IAE+FU,MAAM,CAACR,QAAP,CAAgBjC,IAAhB,KAAyB,SAFxH,IAEqI;cACzIyC,MAAM,CAACA,MAAP,CAAcV,IAAd,KAAuB,sBAHnB,IAG6CU,MAAM,CAACA,MAAP,CAAcqG,IAAd,KAAuBrG,MAHxE,EAGgF;gBAC9E2L,sBAAsB,GAAG,IAAzB;gBACA;cACD;YACF,CAnB4D,CAmB3D;;;YAGF,IAAIA,sBAAJ,EAA4B;cAC1B;YACD;;YAEDzE,aAAa,CAAC;cACZ7H,IAAI,EAAE+L,cAAc,CAACpL,MAAf,CAAsBR,QADhB;cAEZiG,OAAO,EAAE,oBAAoB6F,UAApB,GAAiC,6BAAjC,GAAiE,4DAAjE,GAAgI,oDAAhI,IAAwL,MAAMA,UAAN,GAAmB,iDAA3M,IAAgQ;YAF7P,CAAD,CAAb;UAID,CA9BD,EAnW+G,CAiY3G;UACJ;;UAEA,IAAIM,gBAAgB,GAAG,IAAIhK,GAAJ,EAAvB;;UAEA,SAASiK,qBAAT,CAA+BC,SAA/B,EAA0CxF,GAA1C,EAA+C;YAC7C,IAAIsF,gBAAgB,CAACxJ,GAAjB,CAAqBkE,GAArB,CAAJ,EAA+B;cAC7B;YACD;;YAEDsF,gBAAgB,CAAChJ,GAAjB,CAAqB0D,GAArB;YACAY,aAAa,CAAC;cACZ7H,IAAI,EAAEyM,SADM;cAEZrG,OAAO,EAAE,yBAAyBa,GAAzB,GAA+B,oCAA/B,IAAuE1F,OAAO,CAAC8E,SAAR,CAAkB2C,YAAlB,IAAkC,2BAAzG,IAAwI,gEAAxI,GAA2M,8DAA3M,GAA4Q,wDAA5Q,IAAwUzH,OAAO,CAAC8E,SAAR,CAAkB2C,YAAlB,IAAkC,GAA1W;YAFG,CAAD,CAAb;UAID,CAhZ8G,CAgZ7G;;;UAGF,IAAI0D,kBAAkB,GAAG,IAAInK,GAAJ,EAAzB;UACAoJ,YAAY,CAACS,OAAb,CAAqB,UAAUO,KAAV,EAAiB1F,GAAjB,EAAsB;YACzC,IAAIkF,QAAQ,GAAGQ,KAAK,CAACR,QAArB;YAAA,IACI7B,UAAU,GAAGqC,KAAK,CAACrC,UADvB;;YAGA,IAAI6B,QAAJ,EAAc;cACZO,kBAAkB,CAACnJ,GAAnB,CAAuB0D,GAAvB;YACD;;YAEDqD,UAAU,CAAC8B,OAAX,CAAmB,UAAUZ,SAAV,EAAqB;cACtC,IAAIA,SAAS,CAACiB,SAAd,EAAyB;gBACvBD,qBAAqB,CAAChB,SAAS,CAACiB,SAAX,EAAsBxF,GAAtB,CAArB;cACD;YACF,CAJD;UAKD,CAbD;;UAeA,IAAIsF,gBAAgB,CAAClK,IAAjB,GAAwB,CAA5B,EAA+B;YAC7B;YACA;UACD;;UAED,IAAI,CAAC0G,wBAAL,EAA+B;YAC7B;YACA;YACA,IAAI6D,+BAA+B,GAAG,IAAtC;YACAjB,YAAY,CAACS,OAAb,CAAqB,UAAUS,KAAV,EAAiB5F,GAAjB,EAAsB;cACzC,IAAIkF,QAAQ,GAAGU,KAAK,CAACV,QAArB;cAAA,IACI7B,UAAU,GAAGuC,KAAK,CAACvC,UADvB;;cAGA,IAAIsC,+BAAJ,EAAqC;gBACnC;cACD;;cAEDtC,UAAU,CAAC8B,OAAX,CAAmB,UAAUZ,SAAV,EAAqB;gBACtC,IAAIoB,+BAAJ,EAAqC;kBACnC;gBACD;;gBAED,IAAI/J,EAAE,GAAG2I,SAAS,CAACf,UAAnB;gBACA,IAAIqC,UAAU,GAAG3E,iBAAiB,CAACpF,GAAlB,CAAsBF,EAAtB,CAAjB;;gBAEA,IAAI,CAACiK,UAAL,EAAiB;kBACf;gBACD;;gBAED,IAAI/B,OAAO,GAAGS,SAAS,CAACpN,IAAxB;;gBAEA,OAAO2M,OAAO,CAAC9K,IAAR,KAAiB,UAAxB,EAAoC;kBAClC8K,OAAO,GAAGA,OAAO,CAACtB,KAAlB;gBACD;;gBAED,IAAIsD,sBAAsB,GAAGhC,OAAO,CAACd,KAAR,KAAkBjK,IAA/C;;gBAEA,IAAI+M,sBAAJ,EAA4B;kBAC1B;kBACAH,+BAA+B,GAAG3F,GAAlC;gBACD;cACF,CAxBD;YAyBD,CAjCD;;YAmCA,IAAI2F,+BAAJ,EAAqC;cACnC,IAAII,qBAAqB,GAAGC,sBAAsB,CAAC;gBACjDtB,YAAY,EAAEA,YADmC;gBAEjDuB,oBAAoB,EAAE,EAF2B;gBAGjDR,kBAAkB,EAAEA,kBAH6B;gBAIjDS,oBAAoB,EAAE,IAAI5K,GAAJ,EAJ2B;gBAKjD2G,QAAQ,EAAE;cALuC,CAAD,CAAlD;cAAA,IAOIkE,sBAAsB,GAAGJ,qBAAqB,CAACK,qBAPnD;;cASAxF,aAAa,CAAC;gBACZ7H,IAAI,EAAEgJ,YADM;gBAEZ5C,OAAO,EAAE,gBAAgB6C,gBAAhB,GAAmC,uBAAnC,GAA6D2D,+BAA7D,GAA+F,KAA/F,GAAuG,iFAAvG,GAA2L,qBAA3L,GAAmNQ,sBAAsB,CAACE,IAAvB,CAA4B,IAA5B,CAAnN,IAAwP,mCAAmCrE,gBAAnC,GAAsD,QAA9S,CAFG;gBAGZlB,OAAO,EAAE,CAAC;kBACRwF,IAAI,EAAE,8BAA8BH,sBAAsB,CAACE,IAAvB,CAA4B,IAA5B,CAA9B,GAAkE,GADhE;kBAERtF,GAAG,EAAE,UAAUwF,KAAV,EAAiB;oBACpB,OAAOA,KAAK,CAACC,eAAN,CAAsBzN,IAAtB,EAA4B,QAAQoN,sBAAsB,CAACE,IAAvB,CAA4B,IAA5B,CAAR,GAA4C,GAAxE,CAAP;kBACD;gBAJO,CAAD;cAHG,CAAD,CAAb;YAUD;;YAED;UACD;;UAED,IAAIJ,oBAAoB,GAAG,EAA3B;UACA,IAAIC,oBAAoB,GAAG,IAAI5K,GAAJ,EAA3B;;UAEA,IAAIwG,wBAAwB,CAAC9I,IAAzB,KAAkC,iBAAtC,EAAyD;YACvD;YACA;YACA;YACA4H,aAAa,CAAC;cACZ7H,IAAI,EAAE+I,wBADM;cAEZ3C,OAAO,EAAE,gBAAgB7E,OAAO,CAAC8E,SAAR,CAAkB2C,YAAlB,CAAhB,GAAkD,gBAAlD,GAAqE,8DAArE,GAAsI,4DAAtI,GAAqM;YAFlM,CAAD,CAAb;UAID,CARD,MAQO;YACLD,wBAAwB,CAACqB,QAAzB,CAAkCgC,OAAlC,CAA0C,UAAUsB,sBAAV,EAAkC;cAC1E;cACA,IAAIA,sBAAsB,KAAK,IAA/B,EAAqC;gBACnC;cACD,CAJyE,CAIxE;;;cAGF,IAAIA,sBAAsB,CAACzN,IAAvB,KAAgC,eAApC,EAAqD;gBACnD4H,aAAa,CAAC;kBACZ7H,IAAI,EAAE0N,sBADM;kBAEZtH,OAAO,EAAE,gBAAgB7E,OAAO,CAAC8E,SAAR,CAAkB2C,YAAlB,CAAhB,GAAkD,gBAAlD,GAAqE,uDAArE,GAA+H,8CAA/H,GAAgL;gBAF7K,CAAD,CAAb;gBAIA;cACD,CAbyE,CAaxE;cACF;;;cAGA,IAAI2E,kBAAJ;;cAEA,IAAI;gBACFA,kBAAkB,GAAGzB,oBAAoB,CAACwB,sBAAD,EAAyB,IAAzB,CAAzC;cACD,CAFD,CAEE,OAAOE,KAAP,EAAc;gBACd,IAAI,wBAAwBvP,IAAxB,CAA6BuP,KAAK,CAACxH,OAAnC,CAAJ,EAAiD;kBAC/C,IAAIsH,sBAAsB,CAACzN,IAAvB,KAAgC,SAApC,EAA+C;oBAC7C,IAAI0L,YAAY,CAAC5I,GAAb,CAAiB2K,sBAAsB,CAACtO,KAAxC,CAAJ,EAAoD;sBAClDyI,aAAa,CAAC;wBACZ7H,IAAI,EAAE0N,sBADM;wBAEZtH,OAAO,EAAE,SAASsH,sBAAsB,CAACG,GAAhC,GAAsC,qCAAtC,GAA8E,4BAA9E,IAA8G,6BAA6BH,sBAAsB,CAACtO,KAApD,GAA4D,wBAA1K;sBAFG,CAAD,CAAb;oBAID,CALD,MAKO;sBACLyI,aAAa,CAAC;wBACZ7H,IAAI,EAAE0N,sBADM;wBAEZtH,OAAO,EAAE,SAASsH,sBAAsB,CAACG,GAAhC,GAAsC,qCAAtC,GAA8E;sBAF3E,CAAD,CAAb;oBAID;kBACF,CAZD,MAYO;oBACLhG,aAAa,CAAC;sBACZ7H,IAAI,EAAE0N,sBADM;sBAEZtH,OAAO,EAAE,gBAAgB7E,OAAO,CAAC8E,SAAR,CAAkB2C,YAAlB,CAAhB,GAAkD,SAAlD,GAA8D,8CAA9D,GAA+G;oBAF5G,CAAD,CAAb;kBAID;;kBAED;gBACD,CArBD,MAqBO;kBACL,MAAM4E,KAAN;gBACD;cACF;;cAED,IAAIE,OAAO,GAAGJ,sBAAd;;cAEA,OAAOI,OAAO,CAAC7N,IAAR,KAAiB,kBAAjB,IAAuC6N,OAAO,CAAC7N,IAAR,KAAiB,0BAAxD,IAAsF6N,OAAO,CAAC7N,IAAR,KAAiB,iBAA9G,EAAiI;gBAC/H6N,OAAO,GAAGA,OAAO,CAACzN,MAAR,IAAkByN,OAAO,CAAChE,UAAR,CAAmBzJ,MAA/C;cACD;;cAED,IAAI0N,qBAAqB,GAAG,CAACxE,cAAc,CAAC2B,OAAf,CAAuB8C,IAAvB,CAA4B,UAAU7C,GAAV,EAAe;gBACtE,OAAOA,GAAG,CAACV,UAAJ,KAAmBqD,OAA1B;cACD,CAF4B,CAA7B,CAtD0E,CAwDtE;;cAEJZ,oBAAoB,CAACtL,IAArB,CAA0B;gBACxBqF,GAAG,EAAE0G,kBADmB;gBAExB3N,IAAI,EAAE0N;cAFkB,CAA1B;;cAKA,IAAI,CAACK,qBAAL,EAA4B;gBAC1BZ,oBAAoB,CAAC5J,GAArB,CAAyBoK,kBAAzB;cACD;YACF,CAlED;UAmED;;UAED,IAAIM,sBAAsB,GAAGhB,sBAAsB,CAAC;YAClDtB,YAAY,EAAEA,YADoC;YAElDuB,oBAAoB,EAAEA,oBAF4B;YAGlDR,kBAAkB,EAAEA,kBAH8B;YAIlDS,oBAAoB,EAAEA,oBAJ4B;YAKlDjE,QAAQ,EAAEA;UALwC,CAAD,CAAnD;UAAA,IAOImE,qBAAqB,GAAGY,sBAAsB,CAACZ,qBAPnD;UAAA,IAQIa,uBAAuB,GAAGD,sBAAsB,CAACC,uBARrD;UAAA,IASIC,mBAAmB,GAAGF,sBAAsB,CAACE,mBATjD;UAAA,IAUIC,qBAAqB,GAAGH,sBAAsB,CAACG,qBAVnD;;UAYA,IAAIC,aAAa,GAAGhB,qBAApB;UACA,IAAIiB,YAAY,GAAGF,qBAAqB,CAAC/L,IAAtB,GAA6B8L,mBAAmB,CAAC9L,IAAjD,GAAwD6L,uBAAuB,CAAC7L,IAAnG;;UAEA,IAAIiM,YAAY,KAAK,CAArB,EAAwB;YACtB;YACA;YACA,IAAIC,aAAa,GAAGC,oBAAoB,CAAC;cACvCtB,oBAAoB,EAAEA,oBADiB;cAEvCnE,wBAAwB,EAAEA,wBAFa;cAGvCQ,cAAc,EAAEA,cAHuB;cAIvCH,KAAK,EAAEA;YAJgC,CAAD,CAAxC;YAMAmF,aAAa,CAACnC,OAAd,CAAsB,UAAUqC,KAAV,EAAiB;cACrC,IAAIC,YAAY,GAAGD,KAAK,CAACC,YAAzB;cAAA,IACIC,mBAAmB,GAAGF,KAAK,CAACE,mBADhC;cAAA,IAEIC,OAAO,GAAGH,KAAK,CAACG,OAFpB;cAGA,IAAIC,WAAW,GAAGD,OAAO,KAAK,UAAZ,GAAyB,aAAzB,GAAyC,SAA3D;cACA,IAAIE,gBAAgB,GAAGF,OAAO,KAAK,UAAZ,GAAyB,YAAzB,GAAwC,gBAA/D;cACA,IAAIG,aAAa,GAAG,cAAcD,gBAAd,GAAiC,OAAjC,GAA2CJ,YAAY,CAACxQ,IAAb,CAAkBA,IAA7D,GAAoE,eAApE,GAAsF2Q,WAAtF,GAAoG,UAAxH;cACA,IAAIG,MAAM,GAAGL,mBAAmB,GAAG,kBAAkBI,aAArB,GAAqC,wBAAwB9F,gBAAxB,GAA2C,4BAA3C,GAA0E8F,aAA/I;cACA,IAAIE,SAAS,GAAGL,OAAO,KAAK,aAAZ,IAA6BA,OAAO,KAAK,oBAAzC,GAAgE,YAAhE,GAA+E,OAA/F;cACA,IAAIxI,OAAO,GAAG,UAAUsI,YAAY,CAACxQ,IAAb,CAAkBA,IAA5B,GAAmC,IAAnC,GAA0C0Q,OAA1C,GAAoD,GAApD,GAA0DK,SAA1D,GAAsE,uBAAtE,IAAiGhG,gBAAgB,GAAG,iBAAnB,GAAuCF,wBAAwB,CAACmG,GAAzB,CAA6BC,KAA7B,CAAmCC,IAA1E,GAAiF,IAAlL,KAA2L,6BAA6BJ,MAAxN,CAAd;cACA,IAAIjH,OAAJ,CAVqC,CAUxB;cACb;;cAEA,IAAI4G,mBAAmB,IAAID,YAAY,CAACzO,IAAb,KAAsB,UAA7C,IAA2D;cAC/D;cACA;cACA2O,OAAO,KAAK,UAHZ,EAGwB;gBACtB7G,OAAO,GAAG,CAAC;kBACTwF,IAAI,EAAE,cAAcuB,gBAAd,GAAiC,OAAjC,GAA2CJ,YAAY,CAACxQ,IAAb,CAAkBA,IAA7D,GAAoE,eAApE,GAAsF2Q,WAAtF,GAAoG,UADjG;kBAET7G,GAAG,EAAE,UAAUwF,KAAV,EAAiB;oBACpB,IAAI6B,KAAK,GAAGR,WAAW,KAAK,SAAhB,GAA4B,CAAC,yBAAD,EAA4B,MAA5B,CAA5B,GAAkE,CAAC,cAAD,EAAiB,GAAjB,CAA9E;oBAAA,IACIS,MAAM,GAAGD,KAAK,CAAC,CAAD,CADlB;oBAAA,IAEIE,KAAK,GAAGF,KAAK,CAAC,CAAD,CAFjB;;oBAIA,OAAO,CAAC;oBACR7B,KAAK,CAACgC,gBAAN,CAAuBd,YAAY,CAAC1O,IAAb,CAAkB6G,IAAzC,EAA+CyI,MAA/C,CADO,EACiD;oBACxD;oBACA;oBACA;oBACA9B,KAAK,CAACC,eAAN,CAAsBiB,YAAY,CAAC1O,IAAb,CAAkB6G,IAAxC,EAA8C0I,KAA9C,CALO,CAAP;kBAMD;gBAbQ,CAAD,CAAV;cAeD,CAhCoC,CAgCnC;cACF;;;cAGA1H,aAAa,CAAC;gBACZ;gBACA7H,IAAI,EAAE0O,YAAY,CAAC1O,IAFP;gBAGZoG,OAAO,EAAEA,OAHG;gBAIZ2B,OAAO,EAAEA;cAJG,CAAD,CAAb;YAMD,CA1CD;YA2CA;UACD,CA7nB8G,CA6nB7G;UACF;UACA;UACA;UACA;UACA;;;UAGA,IAAI,CAACmB,QAAD,IAAaiF,mBAAmB,CAAC9L,IAApB,GAA2B,CAA5C,EAA+C;YAC7CgM,aAAa,GAAGpB,sBAAsB,CAAC;cACrCtB,YAAY,EAAEA,YADuB;cAErCuB,oBAAoB,EAAE,EAFe;cAGrC;cACAR,kBAAkB,EAAEA,kBAJiB;cAKrCS,oBAAoB,EAAEA,oBALe;cAMrCjE,QAAQ,EAAEA;YAN2B,CAAD,CAAtB,CAObmE,qBAPH;UAQD,CA9oB8G,CA8oB7G;;;UAGF,SAASoC,2BAAT,GAAuC;YACrC,IAAIvC,oBAAoB,CAAC1O,MAArB,KAAgC,CAApC,EAAuC;cACrC,OAAO,IAAP;YACD;;YAED,IAAIkR,eAAe,GAAGxC,oBAAoB,CAACvE,GAArB,CAAyB,UAAUgH,GAAV,EAAe;cAC5D,OAAOA,GAAG,CAAC1I,GAAX;YACD,CAFqB,CAAtB;YAGA,IAAI2I,qBAAqB,GAAGF,eAAe,CAAC1R,KAAhB,GAAwB6R,IAAxB,EAA5B;YACA,OAAOH,eAAe,CAACpC,IAAhB,CAAqB,GAArB,MAA8BsC,qBAAqB,CAACtC,IAAtB,CAA2B,GAA3B,CAArC;UACD;;UAED,IAAImC,2BAA2B,EAA/B,EAAmC;YACjCpB,aAAa,CAACwB,IAAd;UACD,CA/pB8G,CA+pB7G;UACF;UACA;UACA;;;UAGA,SAASC,gBAAT,CAA0BC,IAA1B,EAAgC;YAC9B,IAAIC,OAAO,GAAGD,IAAI,CAACE,KAAL,CAAW,GAAX,CAAd;YACA,IAAIC,SAAS,GAAG,EAAhB;;YAEA,KAAK,IAAIzR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuR,OAAO,CAACxR,MAA5B,EAAoCC,CAAC,EAArC,EAAyC;cACvC,IAAIA,CAAC,KAAK,CAAV,EAAa;gBACX,IAAI0R,SAAS,GAAGH,OAAO,CAAChS,KAAR,CAAc,CAAd,EAAiBS,CAAC,GAAG,CAArB,EAAwB6O,IAAxB,CAA6B,GAA7B,CAAhB;gBACA,IAAI8C,UAAU,GAAGxE,cAAc,CAAChJ,GAAf,CAAmBuN,SAAnB,MAAkC,IAAnD;gBACAD,SAAS,IAAIE,UAAU,GAAG,IAAH,GAAU,GAAjC;cACD;;cAEDF,SAAS,IAAIF,OAAO,CAACvR,CAAD,CAApB;YACD;;YAED,OAAOyR,SAAP;UACD;;UAED,SAASG,iBAAT,CAA2BC,IAA3B,EAAiCC,YAAjC,EAA+CC,KAA/C,EAAsDC,OAAtD,EAA+D;YAC7D,IAAIH,IAAI,CAACjO,IAAL,KAAc,CAAlB,EAAqB;cACnB,OAAO,IAAP;YACD;;YAED,OAAO,CAACiO,IAAI,CAACjO,IAAL,GAAY,CAAZ,GAAgB,EAAhB,GAAqBkO,YAAY,GAAG,GAArC,IAA4CC,KAA5C,GAAoD,GAApD,IAA2DF,IAAI,CAACjO,IAAL,GAAY,CAAZ,GAAgB,cAAhB,GAAiC,YAA5F,IAA4G,IAA5G,GAAmHqO,WAAW,CAACvS,KAAK,CAACC,IAAN,CAAWkS,IAAX,EAAiBT,IAAjB,GAAwBlH,GAAxB,CAA4B,UAAUzK,IAAV,EAAgB;cAChL,OAAO,MAAM4R,gBAAgB,CAAC5R,IAAD,CAAtB,GAA+B,GAAtC;YACD,CAFqI,CAAD,CAA9H,IAEA,cAAcuS,OAAd,GAAwB,GAAxB,IAA+BH,IAAI,CAACjO,IAAL,GAAY,CAAZ,GAAgB,MAAhB,GAAyB,IAAxD,IAAgE,kCAFhE,CAAP;UAGD;;UAED,IAAIsO,YAAY,GAAG,EAAnB;;UAEA,IAAIzC,uBAAuB,CAAC7L,IAAxB,GAA+B,CAAnC,EAAsC;YACpC,IAAIuO,MAAM,GAAG,IAAb;YACAzS,KAAK,CAACC,IAAN,CAAW8P,uBAAuB,CAAC2C,IAAxB,EAAX,EAA2CzE,OAA3C,CAAmD,UAAUnF,GAAV,EAAe;cAChE,IAAI2J,MAAM,KAAK,IAAf,EAAqB;gBACnB;cACD;;cAED,IAAI3J,GAAG,CAAC6J,QAAJ,CAAa,UAAb,CAAJ,EAA8B;gBAC5BF,MAAM,GAAG3J,GAAT;cACD;YACF,CARD;;YAUA,IAAI2J,MAAM,KAAK,IAAf,EAAqB;cACnBD,YAAY,GAAG,2BAA2BC,MAA3B,GAAoC,8BAApC,GAAqE,wDAApF;YACD,CAFD,MAEO,IAAIzD,oBAAoB,CAAC9K,IAArB,GAA4B,CAAhC,EAAmC;cACxC,IAAIsN,GAAG,GAAGxR,KAAK,CAACC,IAAN,CAAW+O,oBAAX,EAAiC,CAAjC,CAAV,CADwC,CACO;cAC/C;;cAEA,IAAI,CAAC/D,KAAK,CAAClF,GAAN,CAAUnB,GAAV,CAAc4M,GAAd,CAAL,EAAyB;gBACvBgB,YAAY,GAAG,+BAA+BhB,GAA/B,GAAqC,8BAArC,GAAsE,wDAArF;cACD;YACF;UACF,CAxtB8G,CAwtB7G;UACF;UACA;;;UAGA,IAAI,CAACgB,YAAD,IAAiBxC,mBAAmB,CAACpL,GAApB,CAAwB,OAAxB,CAArB,EAAuD;YACrD,IAAIgO,OAAO,GAAGpF,YAAY,CAAC/I,GAAb,CAAiB,OAAjB,CAAd;;YAEA,IAAImO,OAAO,IAAI,IAAf,EAAqB;cACnB;YACD;;YAED,IAAIC,IAAI,GAAGD,OAAO,CAACzG,UAAnB;;YAEA,IAAI,CAACnM,KAAK,CAACa,OAAN,CAAcgS,IAAd,CAAL,EAA0B;cACxB;YACD;;YAED,IAAIC,wBAAwB,GAAG,IAA/B;;YAEA,KAAK,IAAIxS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuS,IAAI,CAACxS,MAAzB,EAAiCC,CAAC,EAAlC,EAAsC;cACpC,IAAI0M,GAAG,GAAG6F,IAAI,CAACvS,CAAD,CAAd;cACA,IAAIoE,EAAE,GAAGmH,2BAA2B,CAACT,cAAc,CAACU,KAAhB,EAAuBkB,GAAG,CAACV,UAA3B,CAApC;;cAEA,IAAI,CAAC5H,EAAL,EAAS;gBACPoO,wBAAwB,GAAG,KAA3B;gBACA;cACD;;cAED,IAAItQ,MAAM,GAAGkC,EAAE,CAAClC,MAAhB;;cAEA,IAAIA,MAAM,IAAI,IAAd,EAAoB;gBAClBsQ,wBAAwB,GAAG,KAA3B;gBACA;cACD;;cAED,IAAItQ,MAAM,CAACV,IAAP,KAAgB,kBAAhB,IAAsCU,MAAM,CAACV,IAAP,KAAgB,0BAA1D,EAAsF;gBACpFgR,wBAAwB,GAAG,KAA3B;gBACA;cACD;YACF;;YAED,IAAIA,wBAAJ,EAA8B;cAC5BN,YAAY,GAAG,mEAAmE,gEAAnE,IAAuI,SAAS1H,gBAAT,GAA4B,0CAAnK,KAAkN,YAAY1H,OAAO,CAAC8E,SAAR,CAAkB2C,YAAlB,CAAZ,GAA8C,GAAhQ,CAAf;YACD;UACF;;UAED,IAAI,CAAC2H,YAAD,IAAiBxC,mBAAmB,CAAC9L,IAApB,GAA2B,CAAhD,EAAmD;YACjD;YACA;YACA,IAAI6O,kBAAkB,GAAG,IAAzB;YACA/C,mBAAmB,CAAC/B,OAApB,CAA4B,UAAU+E,UAAV,EAAsB;cAChD,IAAID,kBAAJ,EAAwB;gBACtB;cACD,CAH+C,CAG9C;;;cAGF,IAAIE,WAAW,GAAG7H,cAAc,CAACrF,GAAf,CAAmBtB,GAAnB,CAAuBuO,UAAvB,CAAlB;cACA,IAAIE,OAAO,GAAG1F,YAAY,CAAC/I,GAAb,CAAiBuO,UAAjB,CAAd;;cAEA,IAAIE,OAAO,CAAC/G,UAAR,CAAmB,CAAnB,EAAsBX,QAAtB,KAAmCyH,WAAvC,EAAoD;gBAClD;cACD,CAX+C,CAW9C;;;cAGF,IAAIvH,GAAG,GAAGuH,WAAW,CAACxH,IAAZ,CAAiB,CAAjB,CAAV;;cAEA,IAAIC,GAAG,IAAI,IAAP,IAAeA,GAAG,CAAC3L,IAAJ,IAAY,IAA3B,IAAmC2L,GAAG,CAAC5J,IAAJ,KAAa,WAApD,EAAiE;gBAC/D;cACD,CAlB+C,CAkB9C;;;cAGF,IAAIqR,cAAc,GAAG,KAArB;cACA,IAAIzO,EAAJ;;cAEA,KAAK,IAAI0O,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,OAAO,CAAC/G,UAAR,CAAmB9L,MAA3C,EAAmD+S,GAAG,EAAtD,EAA0D;gBACxD1O,EAAE,GAAGwO,OAAO,CAAC/G,UAAR,CAAmBiH,GAAnB,EAAwB9G,UAA7B;;gBAEA,IAAI5H,EAAE,IAAI,IAAN,IAAcA,EAAE,CAAClC,MAAH,IAAa,IAA3B,KAAoCkC,EAAE,CAAClC,MAAH,CAAUV,IAAV,KAAmB,gBAAnB,IAAuC4C,EAAE,CAAClC,MAAH,CAAUV,IAAV,KAAmB,wBAA9F,KAA2H4C,EAAE,CAAClC,MAAH,CAAUC,MAAV,KAAqBiC,EAApJ,EAAwJ;kBACtJyO,cAAc,GAAG,IAAjB;kBACA;gBACD;cACF;;cAED,IAAI,CAACA,cAAL,EAAqB;gBACnB;cACD,CAnC+C,CAmC9C;cACF;cACA;;;cAGAJ,kBAAkB,GAAGC,UAArB;YACD,CAzCD;;YA2CA,IAAID,kBAAkB,KAAK,IAA3B,EAAiC;cAC/BP,YAAY,GAAG,UAAUO,kBAAV,GAA+B,uBAA/B,GAAyD,4CAAzD,GAAwG,0CAAvH;YACD;UACF;;UAED,IAAI,CAACP,YAAD,IAAiBxC,mBAAmB,CAAC9L,IAApB,GAA2B,CAAhD,EAAmD;YACjD,IAAImP,sBAAsB,GAAG,IAA7B;YACArD,mBAAmB,CAAC/B,OAApB,CAA4B,UAAU+E,UAAV,EAAsB;cAChD,IAAIK,sBAAsB,KAAK,IAA/B,EAAqC;gBACnC;cACD;;cAED,IAAIH,OAAO,GAAG1F,YAAY,CAAC/I,GAAb,CAAiBuO,UAAjB,CAAd;cACA,IAAI7G,UAAU,GAAG+G,OAAO,CAAC/G,UAAzB;cACA,IAAIzH,EAAJ;cACA,IAAI4O,SAAJ;;cAEA,KAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGpH,UAAU,CAAC9L,MAAnC,EAA2CkT,GAAG,EAA9C,EAAkD;gBAChD7O,EAAE,GAAGyH,UAAU,CAACoH,GAAD,CAAV,CAAgBjH,UAArB;gBACAgH,SAAS,GAAG5O,EAAE,CAAClC,MAAf,CAFgD,CAEzB;;gBAEvB,OAAO8Q,SAAS,IAAI,IAAb,IAAqBA,SAAS,KAAKlI,cAAc,CAACU,KAAzD,EAAgE;kBAC9D,IAAIwH,SAAS,CAACxR,IAAV,KAAmB,gBAAvB,EAAyC;oBACvC,IAAI0R,0BAA0B,GAAGxJ,iBAAiB,CAACvF,GAAlB,CAAsB6O,SAAS,CAAC7Q,MAAhC,CAAjC;;oBAEA,IAAI+Q,0BAA0B,IAAI,IAAlC,EAAwC;sBACtC,IAAIA,0BAA0B,CAACzT,IAA3B,KAAoCiT,UAAxC,EAAoD;wBAClD;wBACAK,sBAAsB,GAAG;0BACvBL,UAAU,EAAEA,UADW;0BAEvBS,MAAM,EAAEH,SAAS,CAAC7Q,MAAV,CAAiB1C,IAFF;0BAGvB2T,IAAI,EAAE;wBAHiB,CAAzB;sBAKD,CAPD,MAOO,IAAIxJ,cAAc,CAACtF,GAAf,CAAmBF,EAAnB,CAAJ,EAA4B;wBACjC;wBACA2O,sBAAsB,GAAG;0BACvBL,UAAU,EAAEA,UADW;0BAEvBS,MAAM,EAAEH,SAAS,CAAC7Q,MAAV,CAAiB1C,IAFF;0BAGvB2T,IAAI,EAAE;wBAHiB,CAAzB;sBAKD,CAPM,MAOA;wBACL,IAAIlI,QAAQ,GAAGW,UAAU,CAACoH,GAAD,CAAV,CAAgB/H,QAA/B;;wBAEA,IAAIA,QAAQ,IAAI,IAAhB,EAAsB;0BACpB;0BACA;0BACA;0BACA,IAAIE,GAAG,GAAGF,QAAQ,CAACC,IAAT,CAAc,CAAd,CAAV;;0BAEA,IAAIC,GAAG,IAAI,IAAP,IAAeA,GAAG,CAAC5J,IAAJ,KAAa,WAAhC,EAA6C;4BAC3CuR,sBAAsB,GAAG;8BACvBL,UAAU,EAAEA,UADW;8BAEvBS,MAAM,EAAEH,SAAS,CAAC7Q,MAAV,CAAiB1C,IAFF;8BAGvB2T,IAAI,EAAE;4BAHiB,CAAzB;0BAKD;wBACF;sBACF;;sBAED;oBACD;kBACF;;kBAEDJ,SAAS,GAAGA,SAAS,CAAC9Q,MAAtB;gBACD;;gBAED,IAAI6Q,sBAAsB,KAAK,IAA/B,EAAqC;kBACnC;gBACD;cACF;YACF,CA/DD;;YAiEA,IAAIA,sBAAsB,KAAK,IAA/B,EAAqC;cACnC,QAAQA,sBAAsB,CAACK,IAA/B;gBACE,KAAK,SAAL;kBACElB,YAAY,GAAG,wEAAwE,SAASa,sBAAsB,CAACI,MAAhC,GAAyC,cAAjH,KAAoI,uBAAuBJ,sBAAsB,CAACL,UAA9C,GAA2D,IAA/L,CAAf;kBACA;;gBAEF,KAAK,eAAL;kBACER,YAAY,GAAG,UAAUa,sBAAsB,CAACI,MAAjC,GAA0C,cAA1C,IAA4D,uBAAuBJ,sBAAsB,CAACL,UAA9C,GAA2D,KAAvH,IAAgI,4DAAhI,IAAgM,WAAWK,sBAAsB,CAACL,UAAlC,GAA+C,mBAA/O,CAAf;kBACA;;gBAEF,KAAK,SAAL;kBACER,YAAY,GAAG,2CAA2Ca,sBAAsB,CAACI,MAAlE,GAA2E,GAA3E,GAAiFJ,sBAAsB,CAACL,UAAvB,CAAkCW,SAAlC,CAA4C,CAA5C,EAA+C,CAA/C,CAAjF,GAAqI,8BAArI,GAAsKN,sBAAsB,CAACL,UAA7L,GAA0M,GAA1M,IAAiN,cAAcK,sBAAsB,CAACI,MAArC,GAA8C,SAA/P,CAAf;kBACA;;gBAEF;kBACE,MAAM,IAAIG,KAAJ,CAAU,eAAV,CAAN;cAdJ;YAgBD;UACF;;UAEDlK,aAAa,CAAC;YACZ7H,IAAI,EAAE+I,wBADM;YAEZ3C,OAAO,EAAE,gBAAgB7E,OAAO,CAAC8E,SAAR,CAAkB2C,YAAlB,CAAhB,GAAkD,OAAlD,KAA8D;YACvEqH,iBAAiB,CAAClC,mBAAD,EAAsB,GAAtB,EAA2B,SAA3B,EAAsC,SAAtC,CAAjB,IAAqEkC,iBAAiB,CAACnC,uBAAD,EAA0B,IAA1B,EAAgC,aAAhC,EAA+C,SAA/C,CAAtF,IAAmJmC,iBAAiB,CAACjC,qBAAD,EAAwB,GAAxB,EAA6B,WAA7B,EAA0C,MAA1C,CAD3J,IACgNuC,YAH7M;YAIZ5I,OAAO,EAAE,CAAC;cACRwF,IAAI,EAAE,2CAA2Cc,aAAa,CAAC1F,GAAd,CAAkBmH,gBAAlB,EAAoCxC,IAApC,CAAyC,IAAzC,CAA3C,GAA4F,GAD1F;cAERtF,GAAG,EAAE,UAAUwF,KAAV,EAAiB;gBACpB;gBACA,OAAOA,KAAK,CAACwE,WAAN,CAAkBjJ,wBAAlB,EAA4C,MAAMsF,aAAa,CAAC1F,GAAd,CAAkBmH,gBAAlB,EAAoCxC,IAApC,CAAyC,IAAzC,CAAN,GAAuD,GAAnG,CAAP;cACD;YALO,CAAD;UAJG,CAAD,CAAb;QAYD;;QAED,SAAS2E,mBAAT,CAA6BjS,IAA7B,EAAmC;UACjC,IAAIkS,aAAa,GAAGC,4BAA4B,CAACnS,IAAI,CAACY,MAAN,EAAc+G,OAAd,CAAhD;;UAEA,IAAIuK,aAAa,KAAK,CAAC,CAAvB,EAA0B;YACxB;YACA;UACD;;UAED,IAAIE,QAAQ,GAAGpS,IAAI,CAACqS,SAAL,CAAeH,aAAf,CAAf;UACA,IAAIlJ,YAAY,GAAGhJ,IAAI,CAACY,MAAxB;UACA,IAAIqI,gBAAgB,GAAGqJ,4BAA4B,CAACtJ,YAAD,CAA5B,CAA2C9K,IAAlE;UACA,IAAI6K,wBAAwB,GAAG/I,IAAI,CAACqS,SAAL,CAAeH,aAAa,GAAG,CAA/B,CAA/B;UACA,IAAIhJ,QAAQ,GAAG,oBAAoB7K,IAApB,CAAyB4K,gBAAzB,CAAf,CAZiC,CAY0B;UAC3D;UACA;;UAEA,IAAI,CAACmJ,QAAL,EAAe;YACbvK,aAAa,CAAC;cACZ7H,IAAI,EAAEgJ,YADM;cAEZ5C,OAAO,EAAE,gBAAgB6C,gBAAhB,GAAmC,gCAAnC,GAAsE;YAFnE,CAAD,CAAb;YAIA;UACD,CAtBgC,CAsB/B;UACF;UACA;;;UAGA,IAAI,CAACF,wBAAD,IAA6B,CAACG,QAAlC,EAA4C;YAC1C;YACA,IAAID,gBAAgB,KAAK,SAArB,IAAkCA,gBAAgB,KAAK,aAA3D,EAA0E;cACxE;cACApB,aAAa,CAAC;gBACZ7H,IAAI,EAAEgJ,YADM;gBAEZ5C,OAAO,EAAE,gBAAgB6C,gBAAhB,GAAmC,iCAAnC,GAAuE,wDAAvE,GAAkI;cAF/H,CAAD,CAAb;YAID;;YAED;UACD;;UAED,QAAQmJ,QAAQ,CAACnS,IAAjB;YACE,KAAK,oBAAL;YACA,KAAK,yBAAL;cACE6I,6BAA6B,CAACsJ,QAAD,EAAWrJ,wBAAX,EAAqCC,YAArC,EAAmDC,gBAAnD,EAAqEC,QAArE,CAA7B;cACA;YACF;;YAEA,KAAK,YAAL;cACE,IAAI,CAACH,wBAAL,EAA+B;gBAC7B;gBACA,OAF6B,CAErB;cACT,CAJH,CAII;cACF;;;cAGA,IAAIA,wBAAwB,CAACqB,QAAzB,IAAqCrB,wBAAwB,CAACqB,QAAzB,CAAkC4D,IAAlC,CAAuC,UAAUuE,EAAV,EAAc;gBAC5F,OAAOA,EAAE,IAAIA,EAAE,CAACtS,IAAH,KAAY,YAAlB,IAAkCsS,EAAE,CAACrU,IAAH,KAAYkU,QAAQ,CAAClU,IAA9D;cACD,CAFwC,CAAzC,EAEI;gBACF;gBACA;gBACA,OAHE,CAGM;cACT,CAdH,CAcI;;;cAGF,IAAIsU,QAAQ,GAAGjR,OAAO,CAACkR,QAAR,GAAmBvO,GAAnB,CAAuBtB,GAAvB,CAA2BwP,QAAQ,CAAClU,IAApC,CAAf;;cAEA,IAAIsU,QAAQ,IAAI,IAAZ,IAAoBA,QAAQ,CAAC5I,IAAT,IAAiB,IAAzC,EAA+C;gBAC7C;gBACA,OAF6C,CAErC;cACT,CAtBH,CAsBI;cACF;cACA;;;cAGA,IAAIC,GAAG,GAAG2I,QAAQ,CAAC5I,IAAT,CAAc,CAAd,CAAV;;cAEA,IAAI,CAACC,GAAD,IAAQ,CAACA,GAAG,CAAC7J,IAAjB,EAAuB;gBACrB,MADqB,CACd;cACR;;cAED,IAAI6J,GAAG,CAAC5J,IAAJ,KAAa,UAAb,IAA2B4J,GAAG,CAAC5J,IAAJ,KAAa,cAA5C,EAA4D;gBAC1D;gBACA,MAF0D,CAEnD;cACR;;cAED,QAAQ4J,GAAG,CAAC7J,IAAJ,CAASC,IAAjB;gBACE,KAAK,qBAAL;kBACE;kBACA6I,6BAA6B,CAACe,GAAG,CAAC7J,IAAL,EAAW+I,wBAAX,EAAqCC,YAArC,EAAmDC,gBAAnD,EAAqEC,QAArE,CAA7B;kBACA;gBACF;;gBAEA,KAAK,oBAAL;kBACE,IAAIrC,IAAI,GAAGgD,GAAG,CAAC7J,IAAJ,CAAS6G,IAApB;;kBAEA,IAAI,CAACA,IAAL,EAAW;oBACT,MADS,CACF;kBACR;;kBAED,QAAQA,IAAI,CAAC5G,IAAb;oBACE;oBACA;oBACA,KAAK,yBAAL;oBACA,KAAK,oBAAL;sBACE;sBACA6I,6BAA6B,CAACjC,IAAD,EAAOkC,wBAAP,EAAiCC,YAAjC,EAA+CC,gBAA/C,EAAiEC,QAAjE,CAA7B;sBACA;oBACF;kBARF;;kBAWA;gBACF;cA1BF;;cA6BA;YACF;;YAEA;cACE;cACArB,aAAa,CAAC;gBACZ7H,IAAI,EAAEgJ,YADM;gBAEZ5C,OAAO,EAAE,gBAAgB6C,gBAAhB,GAAmC,0CAAnC,GAAgF;cAF7E,CAAD,CAAb;cAIA;YACF;UApFF,CAxCiC,CA6H/B;;;UAGFpB,aAAa,CAAC;YACZ7H,IAAI,EAAEgJ,YADM;YAEZ5C,OAAO,EAAE,gBAAgB6C,gBAAhB,GAAmC,8BAAnC,GAAoEmJ,QAAQ,CAAClU,IAA7E,GAAoF,KAApF,GAA4F,mDAFzF;YAGZ6J,OAAO,EAAE,CAAC;cACRwF,IAAI,EAAE,2CAA2C6E,QAAQ,CAAClU,IAApD,GAA2D,GADzD;cAER8J,GAAG,EAAE,UAAUwF,KAAV,EAAiB;gBACpB,OAAOA,KAAK,CAACwE,WAAN,CAAkBjJ,wBAAlB,EAA4C,MAAMqJ,QAAQ,CAAClU,IAAf,GAAsB,GAAlE,CAAP;cACD;YAJO,CAAD;UAHG,CAAD,CAAb;QAUD;;QAED,OAAO;UACLwI,cAAc,EAAEuL;QADX,CAAP;MAGD;IArnCkB,CAArB,CAhsBc,CAszDX;;IAEH,SAAShF,sBAAT,CAAgCyF,KAAhC,EAAuC;MACrC,IAAI/G,YAAY,GAAG+G,KAAK,CAAC/G,YAAzB;MAAA,IACIuB,oBAAoB,GAAGwF,KAAK,CAACxF,oBADjC;MAAA,IAEIR,kBAAkB,GAAGgG,KAAK,CAAChG,kBAF/B;MAAA,IAGIS,oBAAoB,GAAGuF,KAAK,CAACvF,oBAHjC;MAAA,IAIIjE,QAAQ,GAAGwJ,KAAK,CAACxJ,QAJrB,CADqC,CAMrC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MACA,IAAIyJ,OAAO,GAAGC,aAAa,EAA3B;;MAEA,SAASA,aAAT,GAAyB;QACvB,OAAO;UACLC,MAAM,EAAE,KADH;UAEL;UACAC,sBAAsB,EAAE,KAHnB;UAIL;UACAC,aAAa,EAAE,KALV;UAML;UACAC,QAAQ,EAAE,IAAIhR,GAAJ,EAPL,CAOe;;QAPf,CAAP;MAUD,CA5BoC,CA4BnC;MACF;;;MAGA2J,YAAY,CAACS,OAAb,CAAqB,UAAU6G,CAAV,EAAahM,GAAb,EAAkB;QACrC,IAAIjH,IAAI,GAAGkT,qBAAqB,CAACP,OAAD,EAAU1L,GAAV,CAAhC;QACAjH,IAAI,CAAC6S,MAAL,GAAc,IAAd;QACAM,oBAAoB,CAACR,OAAD,EAAU1L,GAAV,EAAe,UAAUtG,MAAV,EAAkB;UACnDA,MAAM,CAACoS,aAAP,GAAuB,IAAvB;QACD,CAFmB,CAApB;MAGD,CAND,EAhCqC,CAsCjC;MACJ;;MAEA7F,oBAAoB,CAACd,OAArB,CAA6B,UAAUgH,KAAV,EAAiB;QAC5C,IAAInM,GAAG,GAAGmM,KAAK,CAACnM,GAAhB;QACA,IAAIjH,IAAI,GAAGkT,qBAAqB,CAACP,OAAD,EAAU1L,GAAV,CAAhC;QACAjH,IAAI,CAAC8S,sBAAL,GAA8B,IAA9B;MACD,CAJD;MAKApG,kBAAkB,CAACN,OAAnB,CAA2B,UAAUnF,GAAV,EAAe;QACxC,IAAIjH,IAAI,GAAGkT,qBAAqB,CAACP,OAAD,EAAU1L,GAAV,CAAhC;QACAjH,IAAI,CAAC8S,sBAAL,GAA8B,IAA9B;MACD,CAHD,EA9CqC,CAiDjC;;MAEJ,SAASI,qBAAT,CAA+BG,QAA/B,EAAyCtD,IAAzC,EAA+C;QAC7C,IAAIc,IAAI,GAAGd,IAAI,CAACE,KAAL,CAAW,GAAX,CAAX;QACA,IAAIjQ,IAAI,GAAGqT,QAAX;;QAEA,IAAIjP,UAAU,GAAGzF,0BAA0B,CAACkS,IAAD,CAA3C;QAAA,IACIxM,MADJ;;QAGA,IAAI;UACF,KAAKD,UAAU,CAAClF,CAAX,EAAL,EAAqB,CAAC,CAACmF,MAAM,GAAGD,UAAU,CAACzG,CAAX,EAAV,EAA0BwB,IAAhD,GAAuD;YACrD,IAAI8H,GAAG,GAAG5C,MAAM,CAACjF,KAAjB;YACA,IAAIkU,KAAK,GAAGtT,IAAI,CAACgT,QAAL,CAAcpQ,GAAd,CAAkBqE,GAAlB,CAAZ;;YAEA,IAAI,CAACqM,KAAL,EAAY;cACVA,KAAK,GAAGV,aAAa,EAArB;cACA5S,IAAI,CAACgT,QAAL,CAAc9O,GAAd,CAAkB+C,GAAlB,EAAuBqM,KAAvB;YACD;;YAEDtT,IAAI,GAAGsT,KAAP;UACD;QACF,CAZD,CAYE,OAAO5T,GAAP,EAAY;UACZ0E,UAAU,CAAC/E,CAAX,CAAaK,GAAb;QACD,CAdD,SAcU;UACR0E,UAAU,CAAC9E,CAAX;QACD;;QAED,OAAOU,IAAP;MACD;;MAED,SAASmT,oBAAT,CAA8BE,QAA9B,EAAwCtD,IAAxC,EAA8CrH,EAA9C,EAAkD;QAChD,IAAImI,IAAI,GAAGd,IAAI,CAACE,KAAL,CAAW,GAAX,CAAX;QACA,IAAIjQ,IAAI,GAAGqT,QAAX;;QAEA,IAAI9O,UAAU,GAAG5F,0BAA0B,CAACkS,IAAD,CAA3C;QAAA,IACIrM,MADJ;;QAGA,IAAI;UACF,KAAKD,UAAU,CAACrF,CAAX,EAAL,EAAqB,CAAC,CAACsF,MAAM,GAAGD,UAAU,CAAC5G,CAAX,EAAV,EAA0BwB,IAAhD,GAAuD;YACrD,IAAI8H,GAAG,GAAGzC,MAAM,CAACpF,KAAjB;YACA,IAAIkU,KAAK,GAAGtT,IAAI,CAACgT,QAAL,CAAcpQ,GAAd,CAAkBqE,GAAlB,CAAZ;;YAEA,IAAI,CAACqM,KAAL,EAAY;cACV;YACD;;YAED5K,EAAE,CAAC4K,KAAD,CAAF;YACAtT,IAAI,GAAGsT,KAAP;UACD;QACF,CAZD,CAYE,OAAO5T,GAAP,EAAY;UACZ6E,UAAU,CAAClF,CAAX,CAAaK,GAAb;QACD,CAdD,SAcU;UACR6E,UAAU,CAACjF,CAAX;QACD;MACF,CAvGoC,CAuGnC;;;MAGF,IAAI6O,mBAAmB,GAAG,IAAI5L,GAAJ,EAA1B;MACA,IAAIgR,sBAAsB,GAAG,IAAIhR,GAAJ,EAA7B;MACAiR,mBAAmB,CAACb,OAAD,EAAUxE,mBAAV,EAA+BoF,sBAA/B,EAAuD,UAAUtM,GAAV,EAAe;QACvF,OAAOA,GAAP;MACD,CAFkB,CAAnB;;MAIA,SAASuM,mBAAT,CAA6BxT,IAA7B,EAAmCyT,YAAnC,EAAiDC,eAAjD,EAAkEC,SAAlE,EAA6E;QAC3E3T,IAAI,CAACgT,QAAL,CAAc5G,OAAd,CAAsB,UAAUkH,KAAV,EAAiBrM,GAAjB,EAAsB;UAC1C,IAAI8I,IAAI,GAAG4D,SAAS,CAAC1M,GAAD,CAApB;;UAEA,IAAIqM,KAAK,CAACR,sBAAV,EAAkC;YAChC,IAAIQ,KAAK,CAACP,aAAV,EAAyB;cACvB;cACAW,eAAe,CAACnQ,GAAhB,CAAoBwM,IAApB;YACD,CAJ+B,CAI9B;YACF;YACA;;;YAGA;UACD;;UAED,IAAIuD,KAAK,CAACT,MAAV,EAAkB;YAChB;YACAY,YAAY,CAAClQ,GAAb,CAAiBwM,IAAjB,EAFgB,CAEQ;YACxB;;YAEA;UACD;;UAEDyD,mBAAmB,CAACF,KAAD,EAAQG,YAAR,EAAsBC,eAAtB,EAAuC,UAAUE,QAAV,EAAoB;YAC5E,OAAO7D,IAAI,GAAG,GAAP,GAAa6D,QAApB;UACD,CAFkB,CAAnB;QAGD,CA1BD;MA2BD,CA5IoC,CA4InC;;;MAGF,IAAIvG,qBAAqB,GAAG,EAA5B;MACA,IAAIa,uBAAuB,GAAG,IAAI3L,GAAJ,EAA9B;MACA,IAAI6L,qBAAqB,GAAG,IAAI7L,GAAJ,EAA5B;MACA2K,oBAAoB,CAACd,OAArB,CAA6B,UAAUyH,KAAV,EAAiB;QAC5C,IAAI5M,GAAG,GAAG4M,KAAK,CAAC5M,GAAhB,CAD4C,CAG5C;;QACA,IAAIsM,sBAAsB,CAACxQ,GAAvB,CAA2BkE,GAA3B,CAAJ,EAAqC;UACnC,IAAIoG,qBAAqB,CAAClK,OAAtB,CAA8B8D,GAA9B,MAAuC,CAAC,CAA5C,EAA+C;YAC7C;YACAoG,qBAAqB,CAACzL,IAAtB,CAA2BqF,GAA3B;UACD,CAHD,MAGO;YACL;YACAmH,qBAAqB,CAAC7K,GAAtB,CAA0B0D,GAA1B;UACD;QACF,CARD,MAQO;UACL,IAAIiC,QAAQ,IAAI,CAACjC,GAAG,CAAC6J,QAAJ,CAAa,UAAb,CAAb,IAAyC,CAAC3D,oBAAoB,CAACpK,GAArB,CAAyBkE,GAAzB,CAA9C,EAA6E;YAC3E;YACA;YACA;YACA;YACA,IAAIoG,qBAAqB,CAAClK,OAAtB,CAA8B8D,GAA9B,MAAuC,CAAC,CAA5C,EAA+C;cAC7CoG,qBAAqB,CAACzL,IAAtB,CAA2BqF,GAA3B;YACD;UACF,CARD,MAQO;YACL;YACAiH,uBAAuB,CAAC3K,GAAxB,CAA4B0D,GAA5B;UACD;QACF;MACF,CA1BD,EAlJqC,CA4KjC;;MAEJkH,mBAAmB,CAAC/B,OAApB,CAA4B,UAAUnF,GAAV,EAAe;QACzCoG,qBAAqB,CAACzL,IAAtB,CAA2BqF,GAA3B;MACD,CAFD;MAGA,OAAO;QACLoG,qBAAqB,EAAEA,qBADlB;QAELa,uBAAuB,EAAEA,uBAFpB;QAGLE,qBAAqB,EAAEA,qBAHlB;QAILD,mBAAmB,EAAEA;MAJhB,CAAP;IAMD,CA/+Da,CA++DZ;IACF;;;IAGA,SAAS2F,6BAAT,CAAuC9T,IAAvC,EAA6C;MAC3C,QAAQA,IAAI,CAACC,IAAb;QACE,KAAK,kBAAL;UACE,OAAO,QAAP;;QAEF,KAAK,iBAAL;UACE,OAAO,OAAP;;QAEF,KAAK,yBAAL;QACA,KAAK,oBAAL;UACE,OAAO,UAAP;;QAEF,KAAK,iBAAL;UACE,OAAO,OAAP;;QAEF,KAAK,uBAAL;UACE,IAAI6T,6BAA6B,CAAC9T,IAAI,CAAC+T,UAAN,CAA7B,IAAkD,IAAlD,IAA0DD,6BAA6B,CAAC9T,IAAI,CAACgU,SAAN,CAA7B,IAAiD,IAA/G,EAAqH;YACnH,OAAO,aAAP;UACD;;UAED,OAAO,IAAP;;QAEF,KAAK,mBAAL;UACE,IAAIF,6BAA6B,CAAC9T,IAAI,CAACgH,IAAN,CAA7B,IAA4C,IAA5C,IAAoD8M,6BAA6B,CAAC9T,IAAI,CAAC8G,KAAN,CAA7B,IAA6C,IAArG,EAA2G;YACzG,OAAO,oBAAP;UACD;;UAED,OAAO,IAAP;;QAEF,KAAK,aAAL;UACE,OAAO,cAAP;;QAEF,KAAK,YAAL;UACE,OAAO,aAAP;;QAEF,KAAK,sBAAL;UACE,IAAIgN,6BAA6B,CAAC9T,IAAI,CAAC8G,KAAN,CAA7B,IAA6C,IAAjD,EAAuD;YACrD,OAAO,uBAAP;UACD;;UAED,OAAO,IAAP;;QAEF,KAAK,eAAL;UACE,OAAO,qBAAP;;QAEF,KAAK,SAAL;UACE,IAAI9G,IAAI,CAACZ,KAAL,YAAsBwI,MAA1B,EAAkC;YAChC,OAAO,oBAAP;UACD;;UAED,OAAO,IAAP;;QAEF,KAAK,oBAAL;UACE,OAAOkM,6BAA6B,CAAC9T,IAAI,CAAC8J,UAAN,CAApC;;QAEF,KAAK,gBAAL;UACE,OAAOgK,6BAA6B,CAAC9T,IAAI,CAAC8J,UAAN,CAApC;MAvDJ;;MA0DA,OAAO,IAAP;IACD,CA/iEa,CA+iEZ;IACF;;;IAGA,SAAS0E,oBAAT,CAA8ByF,KAA9B,EAAqC;MACnC,IAAI/G,oBAAoB,GAAG+G,KAAK,CAAC/G,oBAAjC;MAAA,IACInE,wBAAwB,GAAGkL,KAAK,CAAClL,wBADrC;MAAA,IAEIQ,cAAc,GAAG0K,KAAK,CAAC1K,cAF3B;MAAA,IAGIH,KAAK,GAAG6K,KAAK,CAAC7K,KAHlB;MAIA,IAAImF,aAAa,GAAGrB,oBAAoB,CAACvE,GAArB,CAAyB,UAAUuL,MAAV,EAAkB;QAC7D,IAAIjN,GAAG,GAAGiN,MAAM,CAACjN,GAAjB;QACA,IAAIkE,GAAG,GAAG5B,cAAc,CAAC4K,SAAf,CAAyBC,IAAzB,CAA8B,UAAUC,CAAV,EAAa;UACnD,OAAOA,CAAC,CAACnW,IAAF,KAAW+I,GAAlB;QACD,CAFS,CAAV;;QAIA,IAAIkE,GAAG,IAAI,IAAX,EAAiB;UACf,OAAO,IAAP;QACD;;QAED,IAAInL,IAAI,GAAGmL,GAAG,CAACvB,IAAJ,CAAS,CAAT,CAAX;;QAEA,IAAI5J,IAAI,IAAI,IAAZ,EAAkB;UAChB,OAAO,IAAP;QACD,CAd4D,CAc3D;QACF;QACA;QACA;QACA;;;QAGA,IAAIA,IAAI,CAACC,IAAL,KAAc,UAAd,IAA4BD,IAAI,CAACA,IAAL,CAAUC,IAAV,KAAmB,oBAA/C,IAAuED,IAAI,CAACA,IAAL,CAAU6C,EAAV,CAAa5C,IAAb,KAAsB,YAA7F,IAA6G;QACjHD,IAAI,CAACA,IAAL,CAAU6G,IAAV,IAAkB,IADlB,EACwB;UACtB,IAAIyN,sBAAsB,GAAGR,6BAA6B,CAAC9T,IAAI,CAACA,IAAL,CAAU6G,IAAX,CAA1D;;UAEA,IAAIyN,sBAAsB,IAAI,IAA9B,EAAoC;YAClC,OAAO,CAACnJ,GAAD,EAAMmJ,sBAAN,CAAP;UACD;QACF,CA5B4D,CA4B3D;;;QAGF,IAAItU,IAAI,CAACC,IAAL,KAAc,cAAd,IAAgCD,IAAI,CAACA,IAAL,CAAUC,IAAV,KAAmB,qBAAvD,EAA8E;UAC5E,OAAO,CAACkL,GAAD,EAAM,UAAN,CAAP;QACD,CAjC4D,CAiC3D;;;QAGF,IAAInL,IAAI,CAACC,IAAL,KAAc,WAAd,IAA6BD,IAAI,CAACA,IAAL,CAAUC,IAAV,KAAmB,kBAApD,EAAwE;UACtE,OAAO,CAACkL,GAAD,EAAM,OAAN,CAAP;QACD;;QAED,OAAO,IAAP;MACD,CAzCmB,EAyCjBoJ,MAzCiB,CAyCVC,OAzCU,CAApB;;MA2CA,SAAS7F,mBAAT,CAA6BxD,GAA7B,EAAkC;QAChC,IAAIsJ,cAAc,GAAG,KAArB;;QAEA,KAAK,IAAIhW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0M,GAAG,CAACb,UAAJ,CAAe9L,MAAnC,EAA2CC,CAAC,EAA5C,EAAgD;UAC9C,IAAI+M,SAAS,GAAGL,GAAG,CAACb,UAAJ,CAAe7L,CAAf,CAAhB;;UAEA,IAAI+M,SAAS,CAACiB,SAAd,EAAyB;YACvB,IAAIgI,cAAJ,EAAoB;cAClB;cACA,OAAO,IAAP;YACD,CAHD,MAGO;cACL;cACAA,cAAc,GAAG,IAAjB;cACA;YACD;UACF;;UAED,IAAIjL,YAAY,GAAGgC,SAAS,CAACpN,IAA7B;;UAEA,OAAOoL,YAAY,KAAKJ,KAAjB,IAA0BI,YAAY,IAAI,IAAjD,EAAuD;YACrDA,YAAY,GAAGA,YAAY,CAACC,KAA5B;UACD;;UAED,IAAID,YAAY,KAAKJ,KAArB,EAA4B;YAC1B;YACA;YACA,IAAI,CAACsL,gBAAgB,CAAC3L,wBAAD,EAA2ByC,SAAS,CAACf,UAArC,CAArB,EAAuE;cACrE,OAAO,IAAP;YACD;UACF;QACF;;QAED,OAAO,KAAP;MACD;;MAED,OAAO8D,aAAa,CAAC5F,GAAd,CAAkB,UAAUgM,MAAV,EAAkB;QACzC,IAAIxJ,GAAG,GAAGwJ,MAAM,CAAC,CAAD,CAAhB;QAAA,IACI/F,OAAO,GAAG+F,MAAM,CAAC,CAAD,CADpB;QAEA,OAAO;UACLjG,YAAY,EAAEvD,GAAG,CAACvB,IAAJ,CAAS,CAAT,CADT;UAELgF,OAAO,EAAEA,OAFJ;UAGLD,mBAAmB,EAAEA,mBAAmB,CAACxD,GAAD;QAHnC,CAAP;MAKD,CARM,CAAP;IASD;IACD;AACA;AACA;AACA;AACA;AACA;AACA;;;IAGA,SAASa,aAAT,CAAuBhM,IAAvB,EAA6B;MAC3B,IAAI,CAACA,IAAI,CAACW,MAAL,CAAYV,IAAZ,KAAqB,kBAArB,IAA2CD,IAAI,CAACW,MAAL,CAAYV,IAAZ,KAAqB,0BAAjE,KAAgGD,IAAI,CAACW,MAAL,CAAYN,MAAZ,KAAuBL,IAAvH,IAA+HA,IAAI,CAACW,MAAL,CAAYR,QAAZ,CAAqBjC,IAArB,KAA8B,SAA7J,IAA0K,CAAC8B,IAAI,CAACW,MAAL,CAAYT,QAAvL,IAAmM,EAAEF,IAAI,CAACW,MAAL,CAAYA,MAAZ,IAAsB,IAAtB,KAA+BX,IAAI,CAACW,MAAL,CAAYA,MAAZ,CAAmBV,IAAnB,KAA4B,gBAA5B,IAAgDD,IAAI,CAACW,MAAL,CAAYA,MAAZ,CAAmBV,IAAnB,KAA4B,wBAA3G,KAAwID,IAAI,CAACW,MAAL,CAAYA,MAAZ,CAAmBC,MAAnB,KAA8BZ,IAAI,CAACW,MAA7K,CAAvM,EAA6X;QAC3X,OAAOqL,aAAa,CAAChM,IAAI,CAACW,MAAN,CAApB;MACD,CAFD,MAEO,KAAK;MACZX,IAAI,CAACC,IAAL,KAAc,kBAAd,IAAoCD,IAAI,CAACW,MAAzC,IAAmDX,IAAI,CAACW,MAAL,CAAYV,IAAZ,KAAqB,sBAAxE,IAAkGD,IAAI,CAACW,MAAL,CAAYqG,IAAZ,KAAqBhH,IADhH,EACsH;QAC3H,OAAOA,IAAI,CAACK,MAAZ;MACD,CAHM,MAGA;QACL,OAAOL,IAAP;MACD;IACF;IACD;AACA;AACA;AACA;AACA;AACA;;;IAGA,SAAS4U,QAAT,CAAkB5U,IAAlB,EAAwB4L,cAAxB,EAAwC/C,MAAxC,EAAgD;MAC9C,IAAI+C,cAAJ,EAAoB;QAClB,IAAI5L,IAAI,CAAC6U,QAAT,EAAmB;UACjB;UACA,IAAI,CAACjJ,cAAc,CAAC7I,GAAf,CAAmB8F,MAAnB,CAAL,EAAiC;YAC/B;YACA+C,cAAc,CAAC1H,GAAf,CAAmB2E,MAAnB,EAA2B,IAA3B;UACD;QACF,CAND,MAMO;UACL;UACA+C,cAAc,CAAC1H,GAAf,CAAmB2E,MAAnB,EAA2B,KAA3B;QACD;MACF;IACF;IACD;AACA;AACA;AACA;AACA;AACA;AACA;;;IAGA,SAASqD,oBAAT,CAA8BlM,IAA9B,EAAoC4L,cAApC,EAAoD;MAClD,IAAI5L,IAAI,CAACC,IAAL,KAAc,YAAd,IAA8BD,IAAI,CAACC,IAAL,KAAc,eAAhD,EAAiE;QAC/D,IAAI4I,MAAM,GAAG7I,IAAI,CAAC9B,IAAlB;;QAEA,IAAI0N,cAAJ,EAAoB;UAClB;UACAA,cAAc,CAAC1H,GAAf,CAAmB2E,MAAnB,EAA2B,KAA3B;QACD;;QAED,OAAOA,MAAP;MACD,CATD,MASO,IAAI7I,IAAI,CAACC,IAAL,KAAc,kBAAd,IAAoC,CAACD,IAAI,CAACE,QAA9C,EAAwD;QAC7D,IAAIG,MAAM,GAAG6L,oBAAoB,CAAClM,IAAI,CAACK,MAAN,EAAcuL,cAAd,CAAjC;QACA,IAAIzL,QAAQ,GAAG+L,oBAAoB,CAAClM,IAAI,CAACG,QAAN,EAAgB,IAAhB,CAAnC;;QAEA,IAAI2U,OAAO,GAAGzU,MAAM,GAAG,GAAT,GAAeF,QAA7B;;QAEAyU,QAAQ,CAAC5U,IAAD,EAAO4L,cAAP,EAAuBkJ,OAAvB,CAAR;QACA,OAAOA,OAAP;MACD,CARM,MAQA,IAAI9U,IAAI,CAACC,IAAL,KAAc,0BAAd,IAA4C,CAACD,IAAI,CAACE,QAAtD,EAAgE;QACrE,IAAI6U,OAAO,GAAG7I,oBAAoB,CAAClM,IAAI,CAACK,MAAN,EAAcuL,cAAd,CAAlC;;QAEA,IAAIoJ,SAAS,GAAG9I,oBAAoB,CAAClM,IAAI,CAACG,QAAN,EAAgB,IAAhB,CAApC;;QAEA,IAAI8U,QAAQ,GAAGF,OAAO,GAAG,GAAV,GAAgBC,SAA/B;;QAEAJ,QAAQ,CAAC5U,IAAD,EAAO4L,cAAP,EAAuBqJ,QAAvB,CAAR;QACA,OAAOA,QAAP;MACD,CATM,MASA,IAAIjV,IAAI,CAACC,IAAL,KAAc,iBAAd,IAAmC,CAACD,IAAI,CAACE,QAA7C,EAAuD;QAC5D,IAAI4J,UAAU,GAAG9J,IAAI,CAAC8J,UAAtB;;QAEA,IAAIA,UAAU,CAAC7J,IAAX,KAAoB,gBAAxB,EAA0C;UACxC,MAAM,IAAI8R,KAAJ,CAAU,4BAA4BjI,UAAU,CAAC7J,IAAjD,CAAN;QACD;;QAED,IAAIiV,QAAQ,GAAGhJ,oBAAoB,CAACpC,UAAU,CAACzJ,MAAZ,EAAoBuL,cAApB,CAAnC;;QAEA,IAAIuJ,UAAU,GAAGjJ,oBAAoB,CAACpC,UAAU,CAAC3J,QAAZ,EAAsB,IAAtB,CAArC;;QAEA,IAAIiV,QAAQ,GAAGF,QAAQ,GAAG,GAAX,GAAiBC,UAAhC;;QAEAP,QAAQ,CAAC9K,UAAD,EAAa8B,cAAb,EAA6BwJ,QAA7B,CAAR;QACA,OAAOA,QAAP;MACD,CAfM,MAeA;QACL,MAAM,IAAIrD,KAAJ,CAAU,4BAA4B/R,IAAI,CAACC,IAA3C,CAAN;MACD;IACF;;IAED,SAASqS,4BAAT,CAAsCtS,IAAtC,EAA4C2H,OAA5C,EAAqD;MACnD,IAAI3H,IAAI,CAACC,IAAL,KAAc,kBAAd,IAAoCD,IAAI,CAACK,MAAL,CAAYJ,IAAZ,KAAqB,YAAzD,IAAyED,IAAI,CAACK,MAAL,CAAYnC,IAAZ,KAAqB,OAA9F,IAAyG8B,IAAI,CAACG,QAAL,CAAcF,IAAd,KAAuB,YAAhI,IAAgJ,CAACD,IAAI,CAACE,QAA1J,EAAoK;QAClK,OAAOF,IAAI,CAACG,QAAZ;MACD;;MAED,OAAOH,IAAP;IACD,CAvvEa,CAuvEZ;IACF;IACA;IACA;IACA;;;IAGA,SAASmS,4BAAT,CAAsCkD,UAAtC,EAAkD1N,OAAlD,EAA2D;MACzD,IAAI3H,IAAI,GAAGsS,4BAA4B,CAAC+C,UAAD,CAAvC;;MAEA,IAAIrV,IAAI,CAACC,IAAL,KAAc,YAAlB,EAAgC;QAC9B,OAAO,CAAC,CAAR;MACD;;MAED,QAAQD,IAAI,CAAC9B,IAAb;QACE,KAAK,WAAL;QACA,KAAK,iBAAL;QACA,KAAK,aAAL;QACA,KAAK,SAAL;UACE;UACA,OAAO,CAAP;;QAEF,KAAK,qBAAL;UACE;UACA,OAAO,CAAP;;QAEF;UACE,IAAI8B,IAAI,KAAKqV,UAAT,IAAuB1N,OAAvB,IAAkCA,OAAO,CAACD,eAA9C,EAA+D;YAC7D;YACA;YACA,IAAIxJ,IAAJ;;YAEA,IAAI;cACFA,IAAI,GAAGgO,oBAAoB,CAAClM,IAAD,EAAO,IAAP,CAA3B;YACD,CAFD,CAEE,OAAO4N,KAAP,EAAc;cACd,IAAI,wBAAwBvP,IAAxB,CAA6BuP,KAAK,CAACxH,OAAnC,CAAJ,EAAiD;gBAC/C,OAAO,CAAP;cACD,CAFD,MAEO;gBACL,MAAMwH,KAAN;cACD;YACF;;YAED,OAAOjG,OAAO,CAACD,eAAR,CAAwBrJ,IAAxB,CAA6BH,IAA7B,IAAqC,CAArC,GAAyC,CAAC,CAAjD;UACD,CAhBD,MAgBO;YACL,OAAO,CAAC,CAAR;UACD;;MA/BL;IAkCD;IACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IAGA,SAAS8L,2BAAT,CAAqCmF,KAArC,EAA4CmG,MAA5C,EAAoD;MAClD,IAAIC,KAAK,GAAG,CAACpG,KAAD,CAAZ;MACA,IAAIqG,IAAI,GAAG,IAAX;;MAEA,OAAOD,KAAK,CAAC/W,MAAb,EAAqB;QACnBgX,IAAI,GAAGD,KAAK,CAACE,KAAN,EAAP;;QAEA,IAAIC,gBAAgB,CAACF,IAAD,EAAOF,MAAP,CAApB,EAAoC;UAClC,OAAOE,IAAP;QACD;;QAED,IAAI,CAACd,gBAAgB,CAACc,IAAD,EAAOF,MAAP,CAArB,EAAqC;UACnC;QACD;;QAED,KAAK,IAAIK,GAAG,GAAG,CAAV,EAAaC,eAAe,GAAGhY,MAAM,CAACiY,OAAP,CAAeL,IAAf,CAApC,EAA0DG,GAAG,GAAGC,eAAe,CAACpX,MAAhF,EAAwFmX,GAAG,EAA3F,EAA+F;UAC7F,IAAIG,kBAAkB,GAAGF,eAAe,CAACD,GAAD,CAAxC;UAAA,IACI1O,GAAG,GAAG6O,kBAAkB,CAAC,CAAD,CAD5B;UAAA,IAEI1W,KAAK,GAAG0W,kBAAkB,CAAC,CAAD,CAF9B;;UAIA,IAAI7O,GAAG,KAAK,QAAZ,EAAsB;YACpB;UACD;;UAED,IAAI8O,UAAU,CAAC3W,KAAD,CAAd,EAAuB;YACrBA,KAAK,CAACuB,MAAN,GAAe6U,IAAf;YACAD,KAAK,CAAC3T,IAAN,CAAWxC,KAAX;UACD,CAHD,MAGO,IAAIjB,KAAK,CAACa,OAAN,CAAcI,KAAd,CAAJ,EAA0B;YAC/BA,KAAK,CAACgN,OAAN,CAAc,UAAU4J,GAAV,EAAe;cAC3B,IAAID,UAAU,CAACC,GAAD,CAAd,EAAqB;gBACnBA,GAAG,CAACrV,MAAJ,GAAa6U,IAAb;gBACAD,KAAK,CAAC3T,IAAN,CAAWoU,GAAX;cACD;YACF,CALD;UAMD;QACF;MACF;;MAED,OAAO,IAAP;IACD;;IAED,SAAStF,WAAT,CAAqBpS,GAArB,EAA0B;MACxB,IAAIY,CAAC,GAAG,EAAR;;MAEA,KAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAAG,CAACE,MAAxB,EAAgCC,CAAC,EAAjC,EAAqC;QACnCS,CAAC,IAAIZ,GAAG,CAACG,CAAD,CAAR;;QAEA,IAAIA,CAAC,KAAK,CAAN,IAAWH,GAAG,CAACE,MAAJ,KAAe,CAA9B,EAAiC;UAC/BU,CAAC,IAAI,OAAL;QACD,CAFD,MAEO,IAAIT,CAAC,KAAKH,GAAG,CAACE,MAAJ,GAAa,CAAnB,IAAwBF,GAAG,CAACE,MAAJ,GAAa,CAAzC,EAA4C;UACjDU,CAAC,IAAI,QAAL;QACD,CAFM,MAEA,IAAIT,CAAC,GAAGH,GAAG,CAACE,MAAJ,GAAa,CAArB,EAAwB;UAC7BU,CAAC,IAAI,IAAL;QACD;MACF;;MAED,OAAOA,CAAP;IACD;;IAED,SAAS6W,UAAT,CAAoBC,GAApB,EAAyB;MACvB,OAAO,OAAOA,GAAP,KAAe,QAAf,IAA2BA,GAAG,KAAK,IAAnC,IAA2C,CAAC7X,KAAK,CAACa,OAAN,CAAcgX,GAAd,CAA5C,IAAkE,OAAOA,GAAG,CAAC/V,IAAX,KAAoB,QAA7F;IACD;;IAED,SAASyV,gBAAT,CAA0BO,CAA1B,EAA6BC,CAA7B,EAAgC;MAC9B,OAAO,CAACD,CAAC,CAAChW,IAAF,KAAW,YAAX,IAA2BgW,CAAC,CAAChW,IAAF,KAAW,eAAvC,KAA2DgW,CAAC,CAAChW,IAAF,KAAWiW,CAAC,CAACjW,IAAxE,IAAgFgW,CAAC,CAAC/X,IAAF,KAAWgY,CAAC,CAAChY,IAA7F,IAAqG+X,CAAC,CAACE,KAAF,CAAQ,CAAR,MAAeD,CAAC,CAACC,KAAF,CAAQ,CAAR,CAApH,IAAkIF,CAAC,CAACE,KAAF,CAAQ,CAAR,MAAeD,CAAC,CAACC,KAAF,CAAQ,CAAR,CAAxJ;IACD;;IAED,SAASzB,gBAAT,CAA0BuB,CAA1B,EAA6BC,CAA7B,EAAgC;MAC9B,OAAOD,CAAC,CAACE,KAAF,CAAQ,CAAR,KAAcD,CAAC,CAACC,KAAF,CAAQ,CAAR,CAAd,IAA4BF,CAAC,CAACE,KAAF,CAAQ,CAAR,KAAcD,CAAC,CAACC,KAAF,CAAQ,CAAR,CAAjD;IACD;;IAED,IAAIC,OAAO,GAAG;MACZhV,WAAW,EAAE;QACXiV,OAAO,EAAE,CAAC,aAAD,CADE;QAEXC,KAAK,EAAE;UACL,8BAA8B,OADzB;UAEL,+BAA+B;QAF1B;MAFI;IADD,CAAd;IASA,IAAIA,KAAK,GAAG;MACV,kBAAkBtV,YADR;MAEV,mBAAmBmG;IAFT,CAAZ;IAKAoP,OAAO,CAACH,OAAR,GAAkBA,OAAlB;IACAG,OAAO,CAACD,KAAR,GAAgBA,KAAhB;EACG,CA34ED;AA44ED"},"metadata":{},"sourceType":"script"}