{"ast":null,"code":"/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nconst path = require('path');\n\nconst {\n  createDebugLogger,\n  formatJoinMessage\n} = require('./debug');\n\nconst fsUtils = require('./fs-utils');\n\nconst ITERATION_SAFETY_LIMIT = 100e3;\n/**\n * Wrap a function such that it always returns a generator of tuple elements.\n *\n * @param {function({uri:string},...):(Array|Iterator)<[string,string]|string>} fn The function to wrap\n * @returns {function({uri:string},...):(Array|Iterator)<[string,string]>} A function that always returns tuple elements\n */\n\nconst asGenerator = fn => {\n  const toTuple = defaults => value => {\n    const partial = [].concat(value);\n    return [...partial, ...defaults.slice(partial.length)];\n  };\n\n  const isTupleUnique = (v, i, a) => {\n    const required = v.join(',');\n    return a.findIndex(vv => vv.join(',') === required) === i;\n  };\n\n  return function (item) {\n    const {\n      uri\n    } = item;\n    const mapTuple = toTuple([null, uri]);\n\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n\n    const pending = fn(item, ...rest);\n\n    if (Array.isArray(pending)) {\n      return pending.map(mapTuple).filter(isTupleUnique)[Symbol.iterator]();\n    } else if (pending && typeof pending === 'object' && typeof pending.next === 'function' && pending.next.length === 0) {\n      return pending;\n    } else {\n      throw new TypeError(`in \"join\" function expected \"generator\" to return Array|Iterator`);\n    }\n  };\n};\n\nexports.asGenerator = asGenerator;\n/**\n * A high-level utility to create a join function.\n *\n * The `generator` is responsible for ordering possible base paths. The `operation` is responsible for joining a single\n * `base` path with the given `uri`. The `predicate` is responsible for reporting whether the single joined value is\n * successful as the overall result.\n *\n * Both the `generator` and `operation` may be `function*()` or simply `function(...):Array<string>`.\n *\n * @param {function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}, {filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (Array<string>|Iterator<string>)} generator A function that takes the hash of base paths from the `engine` and\n *  returns ordered iterable of paths to consider\n * @returns {function({filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}):string)} join implementation\n */\n\nconst createJoinImplementation = generator => (item, options, loader) => {\n  const {\n    isAbsolute\n  } = item;\n  const {\n    root\n  } = options;\n  const {\n    fs\n  } = loader; // generate the iterator\n\n  const iterator = generator(item, options, loader);\n  const isValidIterator = iterator && typeof iterator === 'object' && typeof iterator.next === 'function';\n\n  if (!isValidIterator) {\n    throw new Error('expected generator to return Iterator');\n  } // run the iterator lazily and record attempts\n\n\n  const {\n    isFileSync,\n    isDirectorySync\n  } = fsUtils(fs);\n  const attempts = [];\n\n  for (let i = 0; i < ITERATION_SAFETY_LIMIT; i++) {\n    const {\n      value,\n      done\n    } = iterator.next();\n\n    if (done) {\n      break;\n    } else if (value) {\n      const tuple = Array.isArray(value) && value.length === 2 ? value : null;\n\n      if (!tuple) {\n        throw new Error('expected Iterator values to be tuple of [string,string], do you need asGenerator utility?');\n      } // skip elements where base or uri is non-string\n      // noting that we need to support base=\"\" when root=\"\"\n\n\n      const [base, uri] = value;\n\n      if (typeof base === 'string' && typeof uri === 'string') {\n        // validate\n        const isValidBase = isAbsolute && base === root || path.isAbsolute(base) && isDirectorySync(base);\n\n        if (!isValidBase) {\n          throw new Error(`expected \"base\" to be absolute path to a valid directory, got \"${base}\"`);\n        } // make the attempt\n\n\n        const joined = path.normalize(path.join(base, uri));\n        const isFallback = true;\n        const isSuccess = isFileSync(joined);\n        attempts.push({\n          base,\n          uri,\n          joined,\n          isFallback,\n          isSuccess\n        });\n\n        if (isSuccess) {\n          break;\n        } // validate any non-strings are falsey\n\n      } else {\n        const isValidTuple = value.every(v => typeof v === 'string' || !v);\n\n        if (!isValidTuple) {\n          throw new Error('expected Iterator values to be tuple of [string,string]');\n        }\n      }\n    }\n  }\n\n  return attempts;\n};\n\nexports.createJoinImplementation = createJoinImplementation;\n/**\n * A low-level utility to create a join function.\n *\n * The `implementation` function processes an individual `item` and returns an Array of attempts. Each attempt consists\n * of a `base` and a `joined` value with `isSuccessful` and `isFallback` flags.\n *\n * In the case that any attempt `isSuccessful` then its `joined` value is the outcome. Otherwise the first `isFallback`\n * attempt is used. If there is no successful or fallback attempts then `null` is returned indicating no change to the\n * original URI in the CSS.\n *\n * The `attempts` Array is logged to console when in `debug` mode.\n *\n * @param {string} name Name for the resulting join function\n * @param {function({uri:string, query:string, isAbsolute:boolean, bases:{subString:string, value:string,\n *  property:string, selector:string}}, {filename:string, fs:Object, debug:function|boolean, root:string}):\n *  Array<{base:string,joined:string,fallback?:string,result?:string}>} implementation A function accepts an item and\n *  returns a list of attempts\n * @returns {function({filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}):string)} join function\n */\n\nconst createJoinFunction = (name, implementation) => {\n  const assertAttempts = value => {\n    const isValid = Array.isArray(value) && value.every(v => v && typeof v === 'object' && typeof v.base === 'string' && typeof v.uri === 'string' && typeof v.joined === 'string' && typeof v.isSuccess === 'boolean' && typeof v.isFallback === 'boolean');\n\n    if (!isValid) {\n      throw new Error(`expected implementation to return Array of {base, uri, joined, isSuccess, isFallback}`);\n    } else {\n      return value;\n    }\n  };\n\n  const assertJoined = value => {\n    const isValid = value && typeof value === 'string' && path.isAbsolute(value) || value === null;\n\n    if (!isValid) {\n      throw new Error(`expected \"joined\" to be absolute path, got \"${value}\"`);\n    } else {\n      return value;\n    }\n  };\n\n  const join = (options, loader) => {\n    const {\n      debug\n    } = options;\n    const {\n      resourcePath\n    } = loader;\n    const log = createDebugLogger(debug);\n    return item => {\n      const {\n        uri\n      } = item;\n      const attempts = implementation(item, options, loader);\n      assertAttempts(attempts, !!debug);\n      const {\n        joined: fallback\n      } = attempts.find(_ref => {\n        let {\n          isFallback\n        } = _ref;\n        return isFallback;\n      }) || {};\n      const {\n        joined: result\n      } = attempts.find(_ref2 => {\n        let {\n          isSuccess\n        } = _ref2;\n        return isSuccess;\n      }) || {};\n      log(formatJoinMessage, [resourcePath, uri, attempts]);\n      return assertJoined(result || fallback || null);\n    };\n  };\n\n  const toString = () => '[Function ' + name + ']';\n\n  return Object.assign(join, !!name && {\n    toString,\n    toJSON: toString\n  });\n};\n\nexports.createJoinFunction = createJoinFunction;\n/**\n * The default iterable factory will order `subString` then `value` then `property` then `selector`.\n *\n * @param {string} uri The uri given in the file webpack is processing\n * @param {boolean} isAbsolute True for absolute URIs, false for relative URIs\n * @param {string} subString A possible base path\n * @param {string} value A possible base path\n * @param {string} property A possible base path\n * @param {string} selector A possible base path\n * @param {string} root The loader options.root value where given\n * @returns {Array<string>} An iterable of possible base paths in preference order\n */\n\nconst defaultJoinGenerator = asGenerator((_ref3, _ref4) => {\n  let {\n    uri,\n    isAbsolute,\n    bases: {\n      subString,\n      value,\n      property,\n      selector\n    }\n  } = _ref3;\n  let {\n    root\n  } = _ref4;\n  return isAbsolute ? [root] : [subString, value, property, selector];\n});\nexports.defaultJoinGenerator = defaultJoinGenerator;\n/**\n * @type {function({filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}):string)} join function\n */\n\nexports.defaultJoin = createJoinFunction('defaultJoin', createJoinImplementation(defaultJoinGenerator));","map":{"version":3,"names":["path","require","createDebugLogger","formatJoinMessage","fsUtils","ITERATION_SAFETY_LIMIT","asGenerator","fn","toTuple","defaults","value","partial","concat","slice","length","isTupleUnique","v","i","a","required","join","findIndex","vv","item","uri","mapTuple","rest","pending","Array","isArray","map","filter","Symbol","iterator","next","TypeError","exports","createJoinImplementation","generator","options","loader","isAbsolute","root","fs","isValidIterator","Error","isFileSync","isDirectorySync","attempts","done","tuple","base","isValidBase","joined","normalize","isFallback","isSuccess","push","isValidTuple","every","createJoinFunction","name","implementation","assertAttempts","isValid","assertJoined","debug","resourcePath","log","fallback","find","result","toString","Object","assign","toJSON","defaultJoinGenerator","bases","subString","property","selector","defaultJoin"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/resolve-url-loader/lib/join-function/index.js"],"sourcesContent":["/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nconst path = require('path');\n\nconst { createDebugLogger, formatJoinMessage } = require('./debug');\nconst fsUtils = require('./fs-utils');\n\nconst ITERATION_SAFETY_LIMIT = 100e3;\n\n/**\n * Wrap a function such that it always returns a generator of tuple elements.\n *\n * @param {function({uri:string},...):(Array|Iterator)<[string,string]|string>} fn The function to wrap\n * @returns {function({uri:string},...):(Array|Iterator)<[string,string]>} A function that always returns tuple elements\n */\nconst asGenerator = (fn) => {\n  const toTuple = (defaults) => (value) => {\n    const partial = [].concat(value);\n    return [...partial, ...defaults.slice(partial.length)];\n  };\n\n  const isTupleUnique = (v, i, a) => {\n    const required = v.join(',');\n    return a.findIndex((vv) => vv.join(',') === required) === i;\n  };\n\n  return (item, ...rest) => {\n    const {uri} = item;\n    const mapTuple = toTuple([null, uri]);\n    const pending = fn(item, ...rest);\n    if (Array.isArray(pending)) {\n      return pending.map(mapTuple).filter(isTupleUnique)[Symbol.iterator]();\n    } else if (\n      pending &&\n      (typeof pending === 'object') &&\n      (typeof pending.next === 'function') &&\n      (pending.next.length === 0)\n    ) {\n      return pending;\n    } else {\n      throw new TypeError(`in \"join\" function expected \"generator\" to return Array|Iterator`);\n    }\n  };\n};\n\nexports.asGenerator = asGenerator;\n\n/**\n * A high-level utility to create a join function.\n *\n * The `generator` is responsible for ordering possible base paths. The `operation` is responsible for joining a single\n * `base` path with the given `uri`. The `predicate` is responsible for reporting whether the single joined value is\n * successful as the overall result.\n *\n * Both the `generator` and `operation` may be `function*()` or simply `function(...):Array<string>`.\n *\n * @param {function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}, {filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (Array<string>|Iterator<string>)} generator A function that takes the hash of base paths from the `engine` and\n *  returns ordered iterable of paths to consider\n * @returns {function({filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}):string)} join implementation\n */\nconst createJoinImplementation = (generator) => (item, options, loader) => {\n  const { isAbsolute } = item;\n  const { root } = options;\n  const { fs } = loader;\n\n  // generate the iterator\n  const iterator = generator(item, options, loader);\n  const isValidIterator = iterator && typeof iterator === 'object' && typeof iterator.next === 'function';\n  if (!isValidIterator) {\n    throw new Error('expected generator to return Iterator');\n  }\n\n  // run the iterator lazily and record attempts\n  const { isFileSync, isDirectorySync } = fsUtils(fs);\n  const attempts = [];\n  for (let i = 0; i < ITERATION_SAFETY_LIMIT; i++) {\n    const { value, done } = iterator.next();\n    if (done) {\n      break;\n    } else if (value) {\n      const tuple = Array.isArray(value) && value.length === 2 ? value : null;\n      if (!tuple) {\n        throw new Error('expected Iterator values to be tuple of [string,string], do you need asGenerator utility?');\n      }\n\n      // skip elements where base or uri is non-string\n      // noting that we need to support base=\"\" when root=\"\"\n      const [base, uri] = value;\n      if ((typeof base === 'string') && (typeof uri === 'string')) {\n\n        // validate\n        const isValidBase = (isAbsolute && base === root) || (path.isAbsolute(base) && isDirectorySync(base));\n        if (!isValidBase) {\n          throw new Error(`expected \"base\" to be absolute path to a valid directory, got \"${base}\"`);\n        }\n\n        // make the attempt\n        const joined = path.normalize(path.join(base, uri));\n        const isFallback = true;\n        const isSuccess = isFileSync(joined);\n        attempts.push({base, uri, joined, isFallback, isSuccess});\n\n        if (isSuccess) {\n          break;\n        }\n\n      // validate any non-strings are falsey\n      } else {\n        const isValidTuple = value.every((v) => (typeof v === 'string') || !v);\n        if (!isValidTuple) {\n          throw new Error('expected Iterator values to be tuple of [string,string]');\n        }\n      }\n    }\n  }\n\n  return attempts;\n};\n\nexports.createJoinImplementation = createJoinImplementation;\n\n/**\n * A low-level utility to create a join function.\n *\n * The `implementation` function processes an individual `item` and returns an Array of attempts. Each attempt consists\n * of a `base` and a `joined` value with `isSuccessful` and `isFallback` flags.\n *\n * In the case that any attempt `isSuccessful` then its `joined` value is the outcome. Otherwise the first `isFallback`\n * attempt is used. If there is no successful or fallback attempts then `null` is returned indicating no change to the\n * original URI in the CSS.\n *\n * The `attempts` Array is logged to console when in `debug` mode.\n *\n * @param {string} name Name for the resulting join function\n * @param {function({uri:string, query:string, isAbsolute:boolean, bases:{subString:string, value:string,\n *  property:string, selector:string}}, {filename:string, fs:Object, debug:function|boolean, root:string}):\n *  Array<{base:string,joined:string,fallback?:string,result?:string}>} implementation A function accepts an item and\n *  returns a list of attempts\n * @returns {function({filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}):string)} join function\n */\nconst createJoinFunction = (name, implementation) => {\n  const assertAttempts = (value) => {\n    const isValid =\n      Array.isArray(value) && value.every((v) =>\n        v &&\n        (typeof v === 'object') &&\n        (typeof v.base === 'string') &&\n        (typeof v.uri === 'string') &&\n        (typeof v.joined === 'string') &&\n        (typeof v.isSuccess === 'boolean') &&\n        (typeof v.isFallback === 'boolean')\n      );\n    if (!isValid) {\n      throw new Error(`expected implementation to return Array of {base, uri, joined, isSuccess, isFallback}`);\n    } else {\n      return value;\n    }\n  };\n\n  const assertJoined = (value) => {\n    const isValid = value && (typeof value === 'string') && path.isAbsolute(value) || (value === null);\n    if (!isValid) {\n      throw new Error(`expected \"joined\" to be absolute path, got \"${value}\"`);\n    } else {\n      return value;\n    }\n  };\n\n  const join = (options, loader) => {\n    const { debug } = options;\n    const { resourcePath } = loader;\n    const log = createDebugLogger(debug);\n\n    return (item) => {\n      const { uri } = item;\n      const attempts = implementation(item, options, loader);\n      assertAttempts(attempts, !!debug);\n\n      const { joined: fallback } = attempts.find(({ isFallback }) => isFallback) || {};\n      const { joined: result } = attempts.find(({ isSuccess }) => isSuccess) || {};\n\n      log(formatJoinMessage, [resourcePath, uri, attempts]);\n\n      return assertJoined(result || fallback || null);\n    };\n  };\n\n  const toString = () => '[Function ' + name + ']';\n\n  return Object.assign(join, !!name && {\n    toString,\n    toJSON: toString\n  });\n};\n\nexports.createJoinFunction = createJoinFunction;\n\n/**\n * The default iterable factory will order `subString` then `value` then `property` then `selector`.\n *\n * @param {string} uri The uri given in the file webpack is processing\n * @param {boolean} isAbsolute True for absolute URIs, false for relative URIs\n * @param {string} subString A possible base path\n * @param {string} value A possible base path\n * @param {string} property A possible base path\n * @param {string} selector A possible base path\n * @param {string} root The loader options.root value where given\n * @returns {Array<string>} An iterable of possible base paths in preference order\n */\nconst defaultJoinGenerator = asGenerator(\n  ({ uri, isAbsolute, bases: { subString, value, property, selector } }, { root }) =>\n    isAbsolute ? [root] : [subString, value, property, selector]\n);\n\nexports.defaultJoinGenerator = defaultJoinGenerator;\n\n/**\n * @type {function({filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}):string)} join function\n */\nexports.defaultJoin = createJoinFunction(\n  'defaultJoin',\n  createJoinImplementation(defaultJoinGenerator)\n);\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AAEA,MAAM;EAAEC,iBAAF;EAAqBC;AAArB,IAA2CF,OAAO,CAAC,SAAD,CAAxD;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,YAAD,CAAvB;;AAEA,MAAMI,sBAAsB,GAAG,KAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,WAAW,GAAIC,EAAD,IAAQ;EAC1B,MAAMC,OAAO,GAAIC,QAAD,IAAeC,KAAD,IAAW;IACvC,MAAMC,OAAO,GAAG,GAAGC,MAAH,CAAUF,KAAV,CAAhB;IACA,OAAO,CAAC,GAAGC,OAAJ,EAAa,GAAGF,QAAQ,CAACI,KAAT,CAAeF,OAAO,CAACG,MAAvB,CAAhB,CAAP;EACD,CAHD;;EAKA,MAAMC,aAAa,GAAG,CAACC,CAAD,EAAIC,CAAJ,EAAOC,CAAP,KAAa;IACjC,MAAMC,QAAQ,GAAGH,CAAC,CAACI,IAAF,CAAO,GAAP,CAAjB;IACA,OAAOF,CAAC,CAACG,SAAF,CAAaC,EAAD,IAAQA,EAAE,CAACF,IAAH,CAAQ,GAAR,MAAiBD,QAArC,MAAmDF,CAA1D;EACD,CAHD;;EAKA,OAAO,UAACM,IAAD,EAAmB;IACxB,MAAM;MAACC;IAAD,IAAQD,IAAd;IACA,MAAME,QAAQ,GAAGjB,OAAO,CAAC,CAAC,IAAD,EAAOgB,GAAP,CAAD,CAAxB;;IAFwB,kCAATE,IAAS;MAATA,IAAS;IAAA;;IAGxB,MAAMC,OAAO,GAAGpB,EAAE,CAACgB,IAAD,EAAO,GAAGG,IAAV,CAAlB;;IACA,IAAIE,KAAK,CAACC,OAAN,CAAcF,OAAd,CAAJ,EAA4B;MAC1B,OAAOA,OAAO,CAACG,GAAR,CAAYL,QAAZ,EAAsBM,MAAtB,CAA6BhB,aAA7B,EAA4CiB,MAAM,CAACC,QAAnD,GAAP;IACD,CAFD,MAEO,IACLN,OAAO,IACN,OAAOA,OAAP,KAAmB,QADpB,IAEC,OAAOA,OAAO,CAACO,IAAf,KAAwB,UAFzB,IAGCP,OAAO,CAACO,IAAR,CAAapB,MAAb,KAAwB,CAJpB,EAKL;MACA,OAAOa,OAAP;IACD,CAPM,MAOA;MACL,MAAM,IAAIQ,SAAJ,CAAe,kEAAf,CAAN;IACD;EACF,CAhBD;AAiBD,CA5BD;;AA8BAC,OAAO,CAAC9B,WAAR,GAAsBA,WAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAM+B,wBAAwB,GAAIC,SAAD,IAAe,CAACf,IAAD,EAAOgB,OAAP,EAAgBC,MAAhB,KAA2B;EACzE,MAAM;IAAEC;EAAF,IAAiBlB,IAAvB;EACA,MAAM;IAAEmB;EAAF,IAAWH,OAAjB;EACA,MAAM;IAAEI;EAAF,IAASH,MAAf,CAHyE,CAKzE;;EACA,MAAMP,QAAQ,GAAGK,SAAS,CAACf,IAAD,EAAOgB,OAAP,EAAgBC,MAAhB,CAA1B;EACA,MAAMI,eAAe,GAAGX,QAAQ,IAAI,OAAOA,QAAP,KAAoB,QAAhC,IAA4C,OAAOA,QAAQ,CAACC,IAAhB,KAAyB,UAA7F;;EACA,IAAI,CAACU,eAAL,EAAsB;IACpB,MAAM,IAAIC,KAAJ,CAAU,uCAAV,CAAN;EACD,CAVwE,CAYzE;;;EACA,MAAM;IAAEC,UAAF;IAAcC;EAAd,IAAkC3C,OAAO,CAACuC,EAAD,CAA/C;EACA,MAAMK,QAAQ,GAAG,EAAjB;;EACA,KAAK,IAAI/B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,sBAApB,EAA4CY,CAAC,EAA7C,EAAiD;IAC/C,MAAM;MAAEP,KAAF;MAASuC;IAAT,IAAkBhB,QAAQ,CAACC,IAAT,EAAxB;;IACA,IAAIe,IAAJ,EAAU;MACR;IACD,CAFD,MAEO,IAAIvC,KAAJ,EAAW;MAChB,MAAMwC,KAAK,GAAGtB,KAAK,CAACC,OAAN,CAAcnB,KAAd,KAAwBA,KAAK,CAACI,MAAN,KAAiB,CAAzC,GAA6CJ,KAA7C,GAAqD,IAAnE;;MACA,IAAI,CAACwC,KAAL,EAAY;QACV,MAAM,IAAIL,KAAJ,CAAU,2FAAV,CAAN;MACD,CAJe,CAMhB;MACA;;;MACA,MAAM,CAACM,IAAD,EAAO3B,GAAP,IAAcd,KAApB;;MACA,IAAK,OAAOyC,IAAP,KAAgB,QAAjB,IAA+B,OAAO3B,GAAP,KAAe,QAAlD,EAA6D;QAE3D;QACA,MAAM4B,WAAW,GAAIX,UAAU,IAAIU,IAAI,KAAKT,IAAxB,IAAkC1C,IAAI,CAACyC,UAAL,CAAgBU,IAAhB,KAAyBJ,eAAe,CAACI,IAAD,CAA9F;;QACA,IAAI,CAACC,WAAL,EAAkB;UAChB,MAAM,IAAIP,KAAJ,CAAW,kEAAiEM,IAAK,GAAjF,CAAN;QACD,CAN0D,CAQ3D;;;QACA,MAAME,MAAM,GAAGrD,IAAI,CAACsD,SAAL,CAAetD,IAAI,CAACoB,IAAL,CAAU+B,IAAV,EAAgB3B,GAAhB,CAAf,CAAf;QACA,MAAM+B,UAAU,GAAG,IAAnB;QACA,MAAMC,SAAS,GAAGV,UAAU,CAACO,MAAD,CAA5B;QACAL,QAAQ,CAACS,IAAT,CAAc;UAACN,IAAD;UAAO3B,GAAP;UAAY6B,MAAZ;UAAoBE,UAApB;UAAgCC;QAAhC,CAAd;;QAEA,IAAIA,SAAJ,EAAe;UACb;QACD,CAhB0D,CAkB7D;;MACC,CAnBD,MAmBO;QACL,MAAME,YAAY,GAAGhD,KAAK,CAACiD,KAAN,CAAa3C,CAAD,IAAQ,OAAOA,CAAP,KAAa,QAAd,IAA2B,CAACA,CAA/C,CAArB;;QACA,IAAI,CAAC0C,YAAL,EAAmB;UACjB,MAAM,IAAIb,KAAJ,CAAU,yDAAV,CAAN;QACD;MACF;IACF;EACF;;EAED,OAAOG,QAAP;AACD,CAzDD;;AA2DAZ,OAAO,CAACC,wBAAR,GAAmCA,wBAAnC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMuB,kBAAkB,GAAG,CAACC,IAAD,EAAOC,cAAP,KAA0B;EACnD,MAAMC,cAAc,GAAIrD,KAAD,IAAW;IAChC,MAAMsD,OAAO,GACXpC,KAAK,CAACC,OAAN,CAAcnB,KAAd,KAAwBA,KAAK,CAACiD,KAAN,CAAa3C,CAAD,IAClCA,CAAC,IACA,OAAOA,CAAP,KAAa,QADd,IAEC,OAAOA,CAAC,CAACmC,IAAT,KAAkB,QAFnB,IAGC,OAAOnC,CAAC,CAACQ,GAAT,KAAiB,QAHlB,IAIC,OAAOR,CAAC,CAACqC,MAAT,KAAoB,QAJrB,IAKC,OAAOrC,CAAC,CAACwC,SAAT,KAAuB,SALxB,IAMC,OAAOxC,CAAC,CAACuC,UAAT,KAAwB,SAPH,CAD1B;;IAUA,IAAI,CAACS,OAAL,EAAc;MACZ,MAAM,IAAInB,KAAJ,CAAW,uFAAX,CAAN;IACD,CAFD,MAEO;MACL,OAAOnC,KAAP;IACD;EACF,CAhBD;;EAkBA,MAAMuD,YAAY,GAAIvD,KAAD,IAAW;IAC9B,MAAMsD,OAAO,GAAGtD,KAAK,IAAK,OAAOA,KAAP,KAAiB,QAA3B,IAAwCV,IAAI,CAACyC,UAAL,CAAgB/B,KAAhB,CAAxC,IAAmEA,KAAK,KAAK,IAA7F;;IACA,IAAI,CAACsD,OAAL,EAAc;MACZ,MAAM,IAAInB,KAAJ,CAAW,+CAA8CnC,KAAM,GAA/D,CAAN;IACD,CAFD,MAEO;MACL,OAAOA,KAAP;IACD;EACF,CAPD;;EASA,MAAMU,IAAI,GAAG,CAACmB,OAAD,EAAUC,MAAV,KAAqB;IAChC,MAAM;MAAE0B;IAAF,IAAY3B,OAAlB;IACA,MAAM;MAAE4B;IAAF,IAAmB3B,MAAzB;IACA,MAAM4B,GAAG,GAAGlE,iBAAiB,CAACgE,KAAD,CAA7B;IAEA,OAAQ3C,IAAD,IAAU;MACf,MAAM;QAAEC;MAAF,IAAUD,IAAhB;MACA,MAAMyB,QAAQ,GAAGc,cAAc,CAACvC,IAAD,EAAOgB,OAAP,EAAgBC,MAAhB,CAA/B;MACAuB,cAAc,CAACf,QAAD,EAAW,CAAC,CAACkB,KAAb,CAAd;MAEA,MAAM;QAAEb,MAAM,EAAEgB;MAAV,IAAuBrB,QAAQ,CAACsB,IAAT,CAAc;QAAA,IAAC;UAAEf;QAAF,CAAD;QAAA,OAAoBA,UAApB;MAAA,CAAd,KAAiD,EAA9E;MACA,MAAM;QAAEF,MAAM,EAAEkB;MAAV,IAAqBvB,QAAQ,CAACsB,IAAT,CAAc;QAAA,IAAC;UAAEd;QAAF,CAAD;QAAA,OAAmBA,SAAnB;MAAA,CAAd,KAA+C,EAA1E;MAEAY,GAAG,CAACjE,iBAAD,EAAoB,CAACgE,YAAD,EAAe3C,GAAf,EAAoBwB,QAApB,CAApB,CAAH;MAEA,OAAOiB,YAAY,CAACM,MAAM,IAAIF,QAAV,IAAsB,IAAvB,CAAnB;IACD,CAXD;EAYD,CAjBD;;EAmBA,MAAMG,QAAQ,GAAG,MAAM,eAAeX,IAAf,GAAsB,GAA7C;;EAEA,OAAOY,MAAM,CAACC,MAAP,CAActD,IAAd,EAAoB,CAAC,CAACyC,IAAF,IAAU;IACnCW,QADmC;IAEnCG,MAAM,EAAEH;EAF2B,CAA9B,CAAP;AAID,CArDD;;AAuDApC,OAAO,CAACwB,kBAAR,GAA6BA,kBAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMgB,oBAAoB,GAAGtE,WAAW,CACtC;EAAA,IAAC;IAAEkB,GAAF;IAAOiB,UAAP;IAAmBoC,KAAK,EAAE;MAAEC,SAAF;MAAapE,KAAb;MAAoBqE,QAApB;MAA8BC;IAA9B;EAA1B,CAAD;EAAA,IAAuE;IAAEtC;EAAF,CAAvE;EAAA,OACED,UAAU,GAAG,CAACC,IAAD,CAAH,GAAY,CAACoC,SAAD,EAAYpE,KAAZ,EAAmBqE,QAAnB,EAA6BC,QAA7B,CADxB;AAAA,CADsC,CAAxC;AAKA5C,OAAO,CAACwC,oBAAR,GAA+BA,oBAA/B;AAEA;AACA;AACA;AACA;AACA;;AACAxC,OAAO,CAAC6C,WAAR,GAAsBrB,kBAAkB,CACtC,aADsC,EAEtCvB,wBAAwB,CAACuC,oBAAD,CAFc,CAAxC"},"metadata":{},"sourceType":"script"}