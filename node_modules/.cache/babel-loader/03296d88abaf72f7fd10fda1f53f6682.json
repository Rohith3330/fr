{"ast":null,"code":"/**\n * @fileoverview  Attempts to discover all state fields in a React component and\n * warn if any of them are never read.\n *\n * State field definitions are collected from `this.state = {}` assignments in\n * the constructor, objects passed to `this.setState()`, and `state = {}` class\n * property assignments.\n */\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\n\nconst ast = require('../util/ast');\n\nconst componentUtil = require('../util/componentUtil');\n\nconst report = require('../util/report'); // Descend through all wrapping TypeCastExpressions and return the expression\n// that was cast.\n\n\nfunction uncast(node) {\n  while (node.type === 'TypeCastExpression') {\n    node = node.expression;\n  }\n\n  return node;\n} // Return the name of an identifier or the string value of a literal. Useful\n// anywhere that a literal may be used as a key (e.g., member expressions,\n// method definitions, ObjectExpression property keys).\n\n\nfunction getName(node) {\n  node = uncast(node);\n  const type = node.type;\n\n  if (type === 'Identifier') {\n    return node.name;\n  }\n\n  if (type === 'Literal') {\n    return String(node.value);\n  }\n\n  if (type === 'TemplateLiteral' && node.expressions.length === 0) {\n    return node.quasis[0].value.raw;\n  }\n\n  return null;\n}\n\nfunction isThisExpression(node) {\n  return ast.unwrapTSAsExpression(uncast(node)).type === 'ThisExpression';\n}\n\nfunction getInitialClassInfo() {\n  return {\n    // Set of nodes where state fields were defined.\n    stateFields: new Set(),\n    // Set of names of state fields that we've seen used.\n    usedStateFields: new Set(),\n    // Names of local variables that may be pointing to this.state. To\n    // track this properly, we would need to keep track of all locals,\n    // shadowing, assignments, etc. To keep things simple, we only\n    // maintain one set of aliases per method and accept that it will\n    // produce some false negatives.\n    aliases: null\n  };\n}\n\nfunction isSetStateCall(node) {\n  const unwrappedCalleeNode = ast.unwrapTSAsExpression(node.callee);\n  return unwrappedCalleeNode.type === 'MemberExpression' && isThisExpression(unwrappedCalleeNode.object) && getName(unwrappedCalleeNode.property) === 'setState';\n}\n\nconst messages = {\n  unusedStateField: 'Unused state field: \\'{{name}}\\''\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow definitions of unused state',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('no-unused-state')\n    },\n    messages,\n    schema: []\n  },\n\n  create(context) {\n    // Non-null when we are inside a React component ClassDeclaration and we have\n    // not yet encountered any use of this.state which we have chosen not to\n    // analyze. If we encounter any such usage (like this.state being spread as\n    // JSX attributes), then this is again set to null.\n    let classInfo = null;\n\n    function isStateParameterReference(node) {\n      const classMethods = ['shouldComponentUpdate', 'componentWillUpdate', 'UNSAFE_componentWillUpdate', 'getSnapshotBeforeUpdate', 'componentDidUpdate'];\n      let scope = context.getScope();\n\n      while (scope) {\n        const parent = scope.block && scope.block.parent;\n\n        if (parent && parent.type === 'MethodDefinition' && (parent.static && parent.key.name === 'getDerivedStateFromProps' || classMethods.indexOf(parent.key.name) !== -1) && parent.value.type === 'FunctionExpression' && parent.value.params[1] && parent.value.params[1].name === node.name) {\n          return true;\n        }\n\n        scope = scope.upper;\n      }\n\n      return false;\n    } // Returns true if the given node is possibly a reference to `this.state` or the state parameter of\n    // a lifecycle method.\n\n\n    function isStateReference(node) {\n      node = uncast(node);\n      const isDirectStateReference = node.type === 'MemberExpression' && isThisExpression(node.object) && node.property.name === 'state';\n      const isAliasedStateReference = node.type === 'Identifier' && classInfo.aliases && classInfo.aliases.has(node.name);\n      return isDirectStateReference || isAliasedStateReference || isStateParameterReference(node);\n    } // Takes an ObjectExpression node and adds all named Property nodes to the\n    // current set of state fields.\n\n\n    function addStateFields(node) {\n      node.properties.filter(prop => prop.type === 'Property' && (prop.key.type === 'Literal' || prop.key.type === 'TemplateLiteral' && prop.key.expressions.length === 0 || prop.computed === false && prop.key.type === 'Identifier') && getName(prop.key) !== null).forEach(prop => {\n        classInfo.stateFields.add(prop);\n      });\n    } // Adds the name of the given node as a used state field if the node is an\n    // Identifier or a Literal. Other node types are ignored.\n\n\n    function addUsedStateField(node) {\n      if (!classInfo) {\n        return;\n      }\n\n      const name = getName(node);\n\n      if (name) {\n        classInfo.usedStateFields.add(name);\n      }\n    } // Records used state fields and new aliases for an ObjectPattern which\n    // destructures `this.state`.\n\n\n    function handleStateDestructuring(node) {\n      for (const prop of node.properties) {\n        if (prop.type === 'Property') {\n          addUsedStateField(prop.key);\n        } else if ((prop.type === 'ExperimentalRestProperty' || prop.type === 'RestElement') && classInfo.aliases) {\n          classInfo.aliases.add(getName(prop.argument));\n        }\n      }\n    } // Used to record used state fields and new aliases for both\n    // AssignmentExpressions and VariableDeclarators.\n\n\n    function handleAssignment(left, right) {\n      const unwrappedRight = ast.unwrapTSAsExpression(right);\n\n      switch (left.type) {\n        case 'Identifier':\n          if (isStateReference(unwrappedRight) && classInfo.aliases) {\n            classInfo.aliases.add(left.name);\n          }\n\n          break;\n\n        case 'ObjectPattern':\n          if (isStateReference(unwrappedRight)) {\n            handleStateDestructuring(left);\n          } else if (isThisExpression(unwrappedRight) && classInfo.aliases) {\n            for (const prop of left.properties) {\n              if (prop.type === 'Property' && getName(prop.key) === 'state') {\n                const name = getName(prop.value);\n\n                if (name) {\n                  classInfo.aliases.add(name);\n                } else if (prop.value.type === 'ObjectPattern') {\n                  handleStateDestructuring(prop.value);\n                }\n              }\n            }\n          }\n\n          break;\n\n        default: // pass\n\n      }\n    }\n\n    function reportUnusedFields() {\n      // Report all unused state fields.\n      for (const node of classInfo.stateFields) {\n        const name = getName(node.key);\n\n        if (!classInfo.usedStateFields.has(name)) {\n          report(context, messages.unusedStateField, 'unusedStateField', {\n            node,\n            data: {\n              name\n            }\n          });\n        }\n      }\n    }\n\n    function handleES6ComponentEnter(node) {\n      if (componentUtil.isES6Component(node, context)) {\n        classInfo = getInitialClassInfo();\n      }\n    }\n\n    function handleES6ComponentExit() {\n      if (!classInfo) {\n        return;\n      }\n\n      reportUnusedFields();\n      classInfo = null;\n    }\n\n    function isGDSFP(node) {\n      const name = getName(node.key);\n\n      if (!node.static || name !== 'getDerivedStateFromProps' || !node.value || !node.value.params || node.value.params.length < 2 // no `state` argument\n      ) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return {\n      ClassDeclaration: handleES6ComponentEnter,\n      'ClassDeclaration:exit': handleES6ComponentExit,\n      ClassExpression: handleES6ComponentEnter,\n      'ClassExpression:exit': handleES6ComponentExit,\n\n      ObjectExpression(node) {\n        if (componentUtil.isES5Component(node, context)) {\n          classInfo = getInitialClassInfo();\n        }\n      },\n\n      'ObjectExpression:exit'(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        if (componentUtil.isES5Component(node, context)) {\n          reportUnusedFields();\n          classInfo = null;\n        }\n      },\n\n      CallExpression(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        const unwrappedNode = ast.unwrapTSAsExpression(node);\n        const unwrappedArgumentNode = ast.unwrapTSAsExpression(unwrappedNode.arguments[0]); // If we're looking at a `this.setState({})` invocation, record all the\n        // properties as state fields.\n\n        if (isSetStateCall(unwrappedNode) && unwrappedNode.arguments.length > 0 && unwrappedArgumentNode.type === 'ObjectExpression') {\n          addStateFields(unwrappedArgumentNode);\n        } else if (isSetStateCall(unwrappedNode) && unwrappedNode.arguments.length > 0 && unwrappedArgumentNode.type === 'ArrowFunctionExpression') {\n          const unwrappedBodyNode = ast.unwrapTSAsExpression(unwrappedArgumentNode.body);\n\n          if (unwrappedBodyNode.type === 'ObjectExpression') {\n            addStateFields(unwrappedBodyNode);\n          }\n\n          if (unwrappedArgumentNode.params.length > 0 && classInfo.aliases) {\n            const firstParam = unwrappedArgumentNode.params[0];\n\n            if (firstParam.type === 'ObjectPattern') {\n              handleStateDestructuring(firstParam);\n            } else {\n              classInfo.aliases.add(getName(firstParam));\n            }\n          }\n        }\n      },\n\n      'ClassProperty, PropertyDefinition'(node) {\n        if (!classInfo) {\n          return;\n        } // If we see state being assigned as a class property using an object\n        // expression, record all the fields of that object as state fields.\n\n\n        const unwrappedValueNode = ast.unwrapTSAsExpression(node.value);\n        const name = getName(node.key);\n\n        if (name === 'state' && !node.static && unwrappedValueNode && unwrappedValueNode.type === 'ObjectExpression') {\n          addStateFields(unwrappedValueNode);\n        }\n\n        if (!node.static && unwrappedValueNode && unwrappedValueNode.type === 'ArrowFunctionExpression') {\n          // Create a new set for this.state aliases local to this method.\n          classInfo.aliases = new Set();\n        }\n      },\n\n      'ClassProperty:exit'(node) {\n        if (classInfo && !node.static && node.value && node.value.type === 'ArrowFunctionExpression') {\n          // Forget our set of local aliases.\n          classInfo.aliases = null;\n        }\n      },\n\n      'PropertyDefinition, ClassProperty'(node) {\n        if (!isGDSFP(node)) {\n          return;\n        }\n\n        const childScope = context.getScope().childScopes.find(x => x.block === node.value);\n\n        if (!childScope) {\n          return;\n        }\n\n        const scope = childScope.variableScope.childScopes.find(x => x.block === node.value);\n        const stateArg = node.value.params[1]; // probably \"state\"\n\n        if (!scope || !scope.variables) {\n          return;\n        }\n\n        const argVar = scope.variables.find(x => x.name === stateArg.name);\n        const stateRefs = argVar.references;\n        stateRefs.forEach(ref => {\n          const identifier = ref.identifier;\n\n          if (identifier && identifier.parent && identifier.parent.type === 'MemberExpression') {\n            addUsedStateField(identifier.parent.property);\n          }\n        });\n      },\n\n      'PropertyDefinition:exit'(node) {\n        if (classInfo && !node.static && node.value && node.value.type === 'ArrowFunctionExpression' && !isGDSFP(node)) {\n          // Forget our set of local aliases.\n          classInfo.aliases = null;\n        }\n      },\n\n      MethodDefinition() {\n        if (!classInfo) {\n          return;\n        } // Create a new set for this.state aliases local to this method.\n\n\n        classInfo.aliases = new Set();\n      },\n\n      'MethodDefinition:exit'() {\n        if (!classInfo) {\n          return;\n        } // Forget our set of local aliases.\n\n\n        classInfo.aliases = null;\n      },\n\n      FunctionExpression(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        const parent = node.parent;\n\n        if (!componentUtil.isES5Component(parent.parent, context)) {\n          return;\n        }\n\n        if (parent.key.name === 'getInitialState') {\n          const body = node.body.body;\n          const lastBodyNode = body[body.length - 1];\n\n          if (lastBodyNode.type === 'ReturnStatement' && lastBodyNode.argument.type === 'ObjectExpression') {\n            addStateFields(lastBodyNode.argument);\n          }\n        } else {\n          // Create a new set for this.state aliases local to this method.\n          classInfo.aliases = new Set();\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        const unwrappedLeft = ast.unwrapTSAsExpression(node.left);\n        const unwrappedRight = ast.unwrapTSAsExpression(node.right); // Check for assignments like `this.state = {}`\n\n        if (unwrappedLeft.type === 'MemberExpression' && isThisExpression(unwrappedLeft.object) && getName(unwrappedLeft.property) === 'state' && unwrappedRight.type === 'ObjectExpression') {\n          // Find the nearest function expression containing this assignment.\n          let fn = node;\n\n          while (fn.type !== 'FunctionExpression' && fn.parent) {\n            fn = fn.parent;\n          } // If the nearest containing function is the constructor, then we want\n          // to record all the assigned properties as state fields.\n\n\n          if (fn.parent && fn.parent.type === 'MethodDefinition' && fn.parent.kind === 'constructor') {\n            addStateFields(unwrappedRight);\n          }\n        } else {\n          // Check for assignments like `alias = this.state` and record the alias.\n          handleAssignment(unwrappedLeft, unwrappedRight);\n        }\n      },\n\n      VariableDeclarator(node) {\n        if (!classInfo || !node.init) {\n          return;\n        }\n\n        handleAssignment(node.id, node.init);\n      },\n\n      'MemberExpression, OptionalMemberExpression'(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        if (isStateReference(ast.unwrapTSAsExpression(node.object))) {\n          // If we see this.state[foo] access, give up.\n          if (node.computed && node.property.type !== 'Literal') {\n            classInfo = null;\n            return;\n          } // Otherwise, record that we saw this property being accessed.\n\n\n          addUsedStateField(node.property); // If we see a `this.state` access in a CallExpression, give up.\n        } else if (isStateReference(node) && node.parent.type === 'CallExpression') {\n          classInfo = null;\n        }\n      },\n\n      JSXSpreadAttribute(node) {\n        if (classInfo && isStateReference(node.argument)) {\n          classInfo = null;\n        }\n      },\n\n      'ExperimentalSpreadProperty, SpreadElement'(node) {\n        if (classInfo && isStateReference(node.argument)) {\n          classInfo = null;\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["docsUrl","require","ast","componentUtil","report","uncast","node","type","expression","getName","name","String","value","expressions","length","quasis","raw","isThisExpression","unwrapTSAsExpression","getInitialClassInfo","stateFields","Set","usedStateFields","aliases","isSetStateCall","unwrappedCalleeNode","callee","object","property","messages","unusedStateField","module","exports","meta","docs","description","category","recommended","url","schema","create","context","classInfo","isStateParameterReference","classMethods","scope","getScope","parent","block","static","key","indexOf","params","upper","isStateReference","isDirectStateReference","isAliasedStateReference","has","addStateFields","properties","filter","prop","computed","forEach","add","addUsedStateField","handleStateDestructuring","argument","handleAssignment","left","right","unwrappedRight","reportUnusedFields","data","handleES6ComponentEnter","isES6Component","handleES6ComponentExit","isGDSFP","ClassDeclaration","ClassExpression","ObjectExpression","isES5Component","CallExpression","unwrappedNode","unwrappedArgumentNode","arguments","unwrappedBodyNode","body","firstParam","unwrappedValueNode","childScope","childScopes","find","x","variableScope","stateArg","variables","argVar","stateRefs","references","ref","identifier","MethodDefinition","FunctionExpression","lastBodyNode","AssignmentExpression","unwrappedLeft","fn","kind","VariableDeclarator","init","id","JSXSpreadAttribute"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/no-unused-state.js"],"sourcesContent":["/**\n * @fileoverview  Attempts to discover all state fields in a React component and\n * warn if any of them are never read.\n *\n * State field definitions are collected from `this.state = {}` assignments in\n * the constructor, objects passed to `this.setState()`, and `state = {}` class\n * property assignments.\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst ast = require('../util/ast');\nconst componentUtil = require('../util/componentUtil');\nconst report = require('../util/report');\n\n// Descend through all wrapping TypeCastExpressions and return the expression\n// that was cast.\nfunction uncast(node) {\n  while (node.type === 'TypeCastExpression') {\n    node = node.expression;\n  }\n  return node;\n}\n\n// Return the name of an identifier or the string value of a literal. Useful\n// anywhere that a literal may be used as a key (e.g., member expressions,\n// method definitions, ObjectExpression property keys).\nfunction getName(node) {\n  node = uncast(node);\n  const type = node.type;\n\n  if (type === 'Identifier') {\n    return node.name;\n  }\n  if (type === 'Literal') {\n    return String(node.value);\n  }\n  if (type === 'TemplateLiteral' && node.expressions.length === 0) {\n    return node.quasis[0].value.raw;\n  }\n  return null;\n}\n\nfunction isThisExpression(node) {\n  return ast.unwrapTSAsExpression(uncast(node)).type === 'ThisExpression';\n}\n\nfunction getInitialClassInfo() {\n  return {\n    // Set of nodes where state fields were defined.\n    stateFields: new Set(),\n\n    // Set of names of state fields that we've seen used.\n    usedStateFields: new Set(),\n\n    // Names of local variables that may be pointing to this.state. To\n    // track this properly, we would need to keep track of all locals,\n    // shadowing, assignments, etc. To keep things simple, we only\n    // maintain one set of aliases per method and accept that it will\n    // produce some false negatives.\n    aliases: null,\n  };\n}\n\nfunction isSetStateCall(node) {\n  const unwrappedCalleeNode = ast.unwrapTSAsExpression(node.callee);\n\n  return (\n    unwrappedCalleeNode.type === 'MemberExpression'\n    && isThisExpression(unwrappedCalleeNode.object)\n    && getName(unwrappedCalleeNode.property) === 'setState'\n  );\n}\n\nconst messages = {\n  unusedStateField: 'Unused state field: \\'{{name}}\\'',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow definitions of unused state',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('no-unused-state'),\n    },\n\n    messages,\n\n    schema: [],\n  },\n\n  create(context) {\n    // Non-null when we are inside a React component ClassDeclaration and we have\n    // not yet encountered any use of this.state which we have chosen not to\n    // analyze. If we encounter any such usage (like this.state being spread as\n    // JSX attributes), then this is again set to null.\n    let classInfo = null;\n\n    function isStateParameterReference(node) {\n      const classMethods = [\n        'shouldComponentUpdate',\n        'componentWillUpdate',\n        'UNSAFE_componentWillUpdate',\n        'getSnapshotBeforeUpdate',\n        'componentDidUpdate',\n      ];\n\n      let scope = context.getScope();\n      while (scope) {\n        const parent = scope.block && scope.block.parent;\n        if (\n          parent\n          && parent.type === 'MethodDefinition' && (\n            (parent.static && parent.key.name === 'getDerivedStateFromProps')\n            || classMethods.indexOf(parent.key.name) !== -1\n          )\n          && parent.value.type === 'FunctionExpression'\n          && parent.value.params[1]\n          && parent.value.params[1].name === node.name\n        ) {\n          return true;\n        }\n        scope = scope.upper;\n      }\n\n      return false;\n    }\n\n    // Returns true if the given node is possibly a reference to `this.state` or the state parameter of\n    // a lifecycle method.\n    function isStateReference(node) {\n      node = uncast(node);\n\n      const isDirectStateReference = node.type === 'MemberExpression'\n        && isThisExpression(node.object)\n        && node.property.name === 'state';\n\n      const isAliasedStateReference = node.type === 'Identifier'\n        && classInfo.aliases\n        && classInfo.aliases.has(node.name);\n\n      return isDirectStateReference || isAliasedStateReference || isStateParameterReference(node);\n    }\n\n    // Takes an ObjectExpression node and adds all named Property nodes to the\n    // current set of state fields.\n    function addStateFields(node) {\n      node.properties.filter((prop) => (\n        prop.type === 'Property'\n          && (prop.key.type === 'Literal'\n          || (prop.key.type === 'TemplateLiteral' && prop.key.expressions.length === 0)\n          || (prop.computed === false && prop.key.type === 'Identifier'))\n          && getName(prop.key) !== null\n      )).forEach((prop) => {\n        classInfo.stateFields.add(prop);\n      });\n    }\n\n    // Adds the name of the given node as a used state field if the node is an\n    // Identifier or a Literal. Other node types are ignored.\n    function addUsedStateField(node) {\n      if (!classInfo) {\n        return;\n      }\n      const name = getName(node);\n      if (name) {\n        classInfo.usedStateFields.add(name);\n      }\n    }\n\n    // Records used state fields and new aliases for an ObjectPattern which\n    // destructures `this.state`.\n    function handleStateDestructuring(node) {\n      for (const prop of node.properties) {\n        if (prop.type === 'Property') {\n          addUsedStateField(prop.key);\n        } else if (\n          (prop.type === 'ExperimentalRestProperty' || prop.type === 'RestElement')\n          && classInfo.aliases\n        ) {\n          classInfo.aliases.add(getName(prop.argument));\n        }\n      }\n    }\n\n    // Used to record used state fields and new aliases for both\n    // AssignmentExpressions and VariableDeclarators.\n    function handleAssignment(left, right) {\n      const unwrappedRight = ast.unwrapTSAsExpression(right);\n\n      switch (left.type) {\n        case 'Identifier':\n          if (isStateReference(unwrappedRight) && classInfo.aliases) {\n            classInfo.aliases.add(left.name);\n          }\n          break;\n        case 'ObjectPattern':\n          if (isStateReference(unwrappedRight)) {\n            handleStateDestructuring(left);\n          } else if (isThisExpression(unwrappedRight) && classInfo.aliases) {\n            for (const prop of left.properties) {\n              if (prop.type === 'Property' && getName(prop.key) === 'state') {\n                const name = getName(prop.value);\n                if (name) {\n                  classInfo.aliases.add(name);\n                } else if (prop.value.type === 'ObjectPattern') {\n                  handleStateDestructuring(prop.value);\n                }\n              }\n            }\n          }\n          break;\n        default:\n        // pass\n      }\n    }\n\n    function reportUnusedFields() {\n      // Report all unused state fields.\n      for (const node of classInfo.stateFields) {\n        const name = getName(node.key);\n        if (!classInfo.usedStateFields.has(name)) {\n          report(context, messages.unusedStateField, 'unusedStateField', {\n            node,\n            data: {\n              name,\n            },\n          });\n        }\n      }\n    }\n\n    function handleES6ComponentEnter(node) {\n      if (componentUtil.isES6Component(node, context)) {\n        classInfo = getInitialClassInfo();\n      }\n    }\n\n    function handleES6ComponentExit() {\n      if (!classInfo) {\n        return;\n      }\n      reportUnusedFields();\n      classInfo = null;\n    }\n\n    function isGDSFP(node) {\n      const name = getName(node.key);\n      if (\n        !node.static\n        || name !== 'getDerivedStateFromProps'\n        || !node.value\n        || !node.value.params\n        || node.value.params.length < 2 // no `state` argument\n      ) {\n        return false;\n      }\n      return true;\n    }\n\n    return {\n      ClassDeclaration: handleES6ComponentEnter,\n\n      'ClassDeclaration:exit': handleES6ComponentExit,\n\n      ClassExpression: handleES6ComponentEnter,\n\n      'ClassExpression:exit': handleES6ComponentExit,\n\n      ObjectExpression(node) {\n        if (componentUtil.isES5Component(node, context)) {\n          classInfo = getInitialClassInfo();\n        }\n      },\n\n      'ObjectExpression:exit'(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        if (componentUtil.isES5Component(node, context)) {\n          reportUnusedFields();\n          classInfo = null;\n        }\n      },\n\n      CallExpression(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        const unwrappedNode = ast.unwrapTSAsExpression(node);\n        const unwrappedArgumentNode = ast.unwrapTSAsExpression(unwrappedNode.arguments[0]);\n\n        // If we're looking at a `this.setState({})` invocation, record all the\n        // properties as state fields.\n        if (\n          isSetStateCall(unwrappedNode)\n          && unwrappedNode.arguments.length > 0\n          && unwrappedArgumentNode.type === 'ObjectExpression'\n        ) {\n          addStateFields(unwrappedArgumentNode);\n        } else if (\n          isSetStateCall(unwrappedNode)\n          && unwrappedNode.arguments.length > 0\n          && unwrappedArgumentNode.type === 'ArrowFunctionExpression'\n        ) {\n          const unwrappedBodyNode = ast.unwrapTSAsExpression(unwrappedArgumentNode.body);\n\n          if (unwrappedBodyNode.type === 'ObjectExpression') {\n            addStateFields(unwrappedBodyNode);\n          }\n          if (unwrappedArgumentNode.params.length > 0 && classInfo.aliases) {\n            const firstParam = unwrappedArgumentNode.params[0];\n            if (firstParam.type === 'ObjectPattern') {\n              handleStateDestructuring(firstParam);\n            } else {\n              classInfo.aliases.add(getName(firstParam));\n            }\n          }\n        }\n      },\n\n      'ClassProperty, PropertyDefinition'(node) {\n        if (!classInfo) {\n          return;\n        }\n        // If we see state being assigned as a class property using an object\n        // expression, record all the fields of that object as state fields.\n        const unwrappedValueNode = ast.unwrapTSAsExpression(node.value);\n\n        const name = getName(node.key);\n        if (\n          name === 'state'\n          && !node.static\n          && unwrappedValueNode\n          && unwrappedValueNode.type === 'ObjectExpression'\n        ) {\n          addStateFields(unwrappedValueNode);\n        }\n\n        if (\n          !node.static\n          && unwrappedValueNode\n          && unwrappedValueNode.type === 'ArrowFunctionExpression'\n        ) {\n          // Create a new set for this.state aliases local to this method.\n          classInfo.aliases = new Set();\n        }\n      },\n\n      'ClassProperty:exit'(node) {\n        if (\n          classInfo\n          && !node.static\n          && node.value\n          && node.value.type === 'ArrowFunctionExpression'\n        ) {\n          // Forget our set of local aliases.\n          classInfo.aliases = null;\n        }\n      },\n\n      'PropertyDefinition, ClassProperty'(node) {\n        if (!isGDSFP(node)) {\n          return;\n        }\n\n        const childScope = context.getScope().childScopes.find((x) => x.block === node.value);\n        if (!childScope) {\n          return;\n        }\n        const scope = childScope.variableScope.childScopes.find((x) => x.block === node.value);\n        const stateArg = node.value.params[1]; // probably \"state\"\n        if (!scope || !scope.variables) {\n          return;\n        }\n        const argVar = scope.variables.find((x) => x.name === stateArg.name);\n\n        const stateRefs = argVar.references;\n\n        stateRefs.forEach((ref) => {\n          const identifier = ref.identifier;\n          if (identifier && identifier.parent && identifier.parent.type === 'MemberExpression') {\n            addUsedStateField(identifier.parent.property);\n          }\n        });\n      },\n\n      'PropertyDefinition:exit'(node) {\n        if (\n          classInfo\n          && !node.static\n          && node.value\n          && node.value.type === 'ArrowFunctionExpression'\n          && !isGDSFP(node)\n        ) {\n          // Forget our set of local aliases.\n          classInfo.aliases = null;\n        }\n      },\n\n      MethodDefinition() {\n        if (!classInfo) {\n          return;\n        }\n        // Create a new set for this.state aliases local to this method.\n        classInfo.aliases = new Set();\n      },\n\n      'MethodDefinition:exit'() {\n        if (!classInfo) {\n          return;\n        }\n        // Forget our set of local aliases.\n        classInfo.aliases = null;\n      },\n\n      FunctionExpression(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        const parent = node.parent;\n        if (!componentUtil.isES5Component(parent.parent, context)) {\n          return;\n        }\n\n        if (parent.key.name === 'getInitialState') {\n          const body = node.body.body;\n          const lastBodyNode = body[body.length - 1];\n\n          if (\n            lastBodyNode.type === 'ReturnStatement'\n            && lastBodyNode.argument.type === 'ObjectExpression'\n          ) {\n            addStateFields(lastBodyNode.argument);\n          }\n        } else {\n          // Create a new set for this.state aliases local to this method.\n          classInfo.aliases = new Set();\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        const unwrappedLeft = ast.unwrapTSAsExpression(node.left);\n        const unwrappedRight = ast.unwrapTSAsExpression(node.right);\n\n        // Check for assignments like `this.state = {}`\n        if (\n          unwrappedLeft.type === 'MemberExpression'\n          && isThisExpression(unwrappedLeft.object)\n          && getName(unwrappedLeft.property) === 'state'\n          && unwrappedRight.type === 'ObjectExpression'\n        ) {\n          // Find the nearest function expression containing this assignment.\n          let fn = node;\n          while (fn.type !== 'FunctionExpression' && fn.parent) {\n            fn = fn.parent;\n          }\n          // If the nearest containing function is the constructor, then we want\n          // to record all the assigned properties as state fields.\n          if (\n            fn.parent\n            && fn.parent.type === 'MethodDefinition'\n            && fn.parent.kind === 'constructor'\n          ) {\n            addStateFields(unwrappedRight);\n          }\n        } else {\n          // Check for assignments like `alias = this.state` and record the alias.\n          handleAssignment(unwrappedLeft, unwrappedRight);\n        }\n      },\n\n      VariableDeclarator(node) {\n        if (!classInfo || !node.init) {\n          return;\n        }\n        handleAssignment(node.id, node.init);\n      },\n\n      'MemberExpression, OptionalMemberExpression'(node) {\n        if (!classInfo) {\n          return;\n        }\n        if (isStateReference(ast.unwrapTSAsExpression(node.object))) {\n          // If we see this.state[foo] access, give up.\n          if (node.computed && node.property.type !== 'Literal') {\n            classInfo = null;\n            return;\n          }\n          // Otherwise, record that we saw this property being accessed.\n          addUsedStateField(node.property);\n        // If we see a `this.state` access in a CallExpression, give up.\n        } else if (isStateReference(node) && node.parent.type === 'CallExpression') {\n          classInfo = null;\n        }\n      },\n\n      JSXSpreadAttribute(node) {\n        if (classInfo && isStateReference(node.argument)) {\n          classInfo = null;\n        }\n      },\n\n      'ExperimentalSpreadProperty, SpreadElement'(node) {\n        if (classInfo && isStateReference(node.argument)) {\n          classInfo = null;\n        }\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}