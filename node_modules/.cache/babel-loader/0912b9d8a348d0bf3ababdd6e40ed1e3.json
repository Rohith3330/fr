{"ast":null,"code":"let source, pos, end, openTokenDepth, lastTokenPos, openTokenPosStack, openClassPosStack, curDynamicImport, templateStackDepth, facade, lastSlashWasDivision, nextBraceIsClass, templateDepth, templateStack, imports, exports, name;\n\nfunction addImport(ss, s, e, d) {\n  const impt = {\n    ss,\n    se: d === -2 ? e : d === -1 ? e + 1 : 0,\n    s,\n    e,\n    d,\n    a: -1,\n    n: undefined\n  };\n  imports.push(impt);\n  return impt;\n}\n\nfunction readName(impt) {\n  let {\n    d,\n    s\n  } = impt;\n  if (d !== -1) s++;\n  impt.n = readString(s, source.charCodeAt(s - 1));\n} // Note: parsing is based on the _assumption_ that the source is already valid\n\n\nexport function parse(_source, _name) {\n  openTokenDepth = 0;\n  curDynamicImport = null;\n  templateDepth = -1;\n  lastTokenPos = -1;\n  lastSlashWasDivision = false;\n  templateStack = Array(1024);\n  templateStackDepth = 0;\n  openTokenPosStack = Array(1024);\n  openClassPosStack = Array(1024);\n  nextBraceIsClass = false;\n  facade = true;\n  name = _name || '@';\n  imports = [];\n  exports = new Set();\n  source = _source;\n  pos = -1;\n  end = source.length - 1;\n  let ch = 0; // start with a pure \"module-only\" parser\n\n  m: while (pos++ < end) {\n    ch = source.charCodeAt(pos);\n    if (ch === 32 || ch < 14 && ch > 8) continue;\n\n    switch (ch) {\n      case 101\n      /*e*/\n      :\n        if (openTokenDepth === 0 && keywordStart(pos) && source.startsWith('xport', pos + 1)) {\n          tryParseExportStatement(); // export might have been a non-pure declaration\n\n          if (!facade) {\n            lastTokenPos = pos;\n            break m;\n          }\n        }\n\n        break;\n\n      case 105\n      /*i*/\n      :\n        if (keywordStart(pos) && source.startsWith('mport', pos + 1)) tryParseImportStatement();\n        break;\n\n      case 59\n      /*;*/\n      :\n        break;\n\n      case 47\n      /*/*/\n      :\n        {\n          const next_ch = source.charCodeAt(pos + 1);\n\n          if (next_ch === 47\n          /*/*/\n          ) {\n            lineComment(); // dont update lastToken\n\n            continue;\n          } else if (next_ch === 42\n          /***/\n          ) {\n            blockComment(true); // dont update lastToken\n\n            continue;\n          } // fallthrough\n\n        }\n\n      default:\n        // as soon as we hit a non-module token, we go to main parser\n        facade = false;\n        pos--;\n        break m;\n    }\n\n    lastTokenPos = pos;\n  }\n\n  while (pos++ < end) {\n    ch = source.charCodeAt(pos);\n    if (ch === 32 || ch < 14 && ch > 8) continue;\n\n    switch (ch) {\n      case 101\n      /*e*/\n      :\n        if (openTokenDepth === 0 && keywordStart(pos) && source.startsWith('xport', pos + 1)) tryParseExportStatement();\n        break;\n\n      case 105\n      /*i*/\n      :\n        if (keywordStart(pos) && source.startsWith('mport', pos + 1)) tryParseImportStatement();\n        break;\n\n      case 99\n      /*c*/\n      :\n        if (keywordStart(pos) && source.startsWith('lass', pos + 1) && isBrOrWs(source.charCodeAt(pos + 5))) nextBraceIsClass = true;\n        break;\n\n      case 40\n      /*(*/\n      :\n        openTokenPosStack[openTokenDepth++] = lastTokenPos;\n        break;\n\n      case 41\n      /*)*/\n      :\n        if (openTokenDepth === 0) syntaxError();\n        openTokenDepth--;\n\n        if (curDynamicImport && curDynamicImport.d === openTokenPosStack[openTokenDepth]) {\n          if (curDynamicImport.e === 0) curDynamicImport.e = pos;\n          curDynamicImport.se = pos;\n          curDynamicImport = null;\n        }\n\n        break;\n\n      case 123\n      /*{*/\n      :\n        // dynamic import followed by { is not a dynamic import (so remove)\n        // this is a sneaky way to get around { import () {} } v { import () }\n        // block / object ambiguity without a parser (assuming source is valid)\n        if (source.charCodeAt(lastTokenPos) === 41\n        /*)*/\n        && imports.length && imports[imports.length - 1].e === lastTokenPos) {\n          imports.pop();\n        }\n\n        openClassPosStack[openTokenDepth] = nextBraceIsClass;\n        nextBraceIsClass = false;\n        openTokenPosStack[openTokenDepth++] = lastTokenPos;\n        break;\n\n      case 125\n      /*}*/\n      :\n        if (openTokenDepth === 0) syntaxError();\n\n        if (openTokenDepth-- === templateDepth) {\n          templateDepth = templateStack[--templateStackDepth];\n          templateString();\n        } else {\n          if (templateDepth !== -1 && openTokenDepth < templateDepth) syntaxError();\n        }\n\n        break;\n\n      case 39\n      /*'*/\n      :\n      case 34\n      /*\"*/\n      :\n        stringLiteral(ch);\n        break;\n\n      case 47\n      /*/*/\n      :\n        {\n          const next_ch = source.charCodeAt(pos + 1);\n\n          if (next_ch === 47\n          /*/*/\n          ) {\n            lineComment(); // dont update lastToken\n\n            continue;\n          } else if (next_ch === 42\n          /***/\n          ) {\n            blockComment(true); // dont update lastToken\n\n            continue;\n          } else {\n            // Division / regex ambiguity handling based on checking backtrack analysis of:\n            // - what token came previously (lastToken)\n            // - if a closing brace or paren, what token came before the corresponding\n            //   opening brace or paren (lastOpenTokenIndex)\n            const lastToken = source.charCodeAt(lastTokenPos);\n\n            if (isExpressionPunctuator(lastToken) && !(lastToken === 46\n            /*.*/\n            && source.charCodeAt(lastTokenPos - 1) >= 48\n            /*0*/\n            && source.charCodeAt(lastTokenPos - 1) <= 57\n            /*9*/\n            ) && !(lastToken === 43\n            /*+*/\n            && source.charCodeAt(lastTokenPos - 1) === 43\n            /*+*/\n            ) && !(lastToken === 45\n            /*-*/\n            && source.charCodeAt(lastTokenPos - 1) === 45\n            /*-*/\n            ) || lastToken === 41\n            /*)*/\n            && isParenKeyword(openTokenPosStack[openTokenDepth]) || lastToken === 125\n            /*}*/\n            && (isExpressionTerminator(openTokenPosStack[openTokenDepth]) || openClassPosStack[openTokenDepth]) || lastToken === 47\n            /*/*/\n            && lastSlashWasDivision || isExpressionKeyword(lastTokenPos) || !lastToken) {\n              regularExpression();\n              lastSlashWasDivision = false;\n            } else {\n              lastSlashWasDivision = true;\n            }\n          }\n\n          break;\n        }\n\n      case 96\n      /*`*/\n      :\n        templateString();\n        break;\n    }\n\n    lastTokenPos = pos;\n  }\n\n  if (templateDepth !== -1 || openTokenDepth) syntaxError();\n  return [imports, [...exports], facade];\n}\n\nfunction tryParseImportStatement() {\n  const startPos = pos;\n  pos += 6;\n  let ch = commentWhitespace(true);\n\n  switch (ch) {\n    // dynamic import\n    case 40\n    /*(*/\n    :\n      openTokenPosStack[openTokenDepth++] = startPos;\n      if (source.charCodeAt(lastTokenPos) === 46\n      /*.*/\n      ) return; // dynamic import indicated by positive d\n\n      const impt = addImport(startPos, pos + 1, 0, startPos);\n      curDynamicImport = impt; // try parse a string, to record a safe dynamic import string\n\n      pos++;\n      ch = commentWhitespace(true);\n\n      if (ch === 39\n      /*'*/\n      || ch === 34\n      /*\"*/\n      ) {\n        stringLiteral(ch);\n      } else {\n        pos--;\n        return;\n      }\n\n      pos++;\n      ch = commentWhitespace(true);\n\n      if (ch === 44\n      /*,*/\n      ) {\n        impt.e = pos;\n        pos++;\n        ch = commentWhitespace(true);\n        impt.a = pos;\n        readName(impt);\n        pos--;\n      } else if (ch === 41\n      /*)*/\n      ) {\n        openTokenDepth--;\n        impt.e = pos;\n        impt.se = pos;\n        readName(impt);\n      } else {\n        pos--;\n      }\n\n      return;\n    // import.meta\n\n    case 46\n    /*.*/\n    :\n      pos++;\n      ch = commentWhitespace(true); // import.meta indicated by d === -2\n\n      if (ch === 109\n      /*m*/\n      && source.startsWith('eta', pos + 1) && source.charCodeAt(lastTokenPos) !== 46\n      /*.*/\n      ) addImport(startPos, startPos, pos + 4, -2);\n      return;\n\n    default:\n      // no space after \"import\" -> not an import keyword\n      if (pos === startPos + 6) break;\n\n    case 34\n    /*\"*/\n    :\n    case 39\n    /*'*/\n    :\n    case 123\n    /*{*/\n    :\n    case 42\n    /***/\n    :\n      // import statement only permitted at base-level\n      if (openTokenDepth !== 0) {\n        pos--;\n        return;\n      }\n\n      while (pos < end) {\n        ch = source.charCodeAt(pos);\n\n        if (ch === 39\n        /*'*/\n        || ch === 34\n        /*\"*/\n        ) {\n          readImportString(startPos, ch);\n          return;\n        }\n\n        pos++;\n      }\n\n      syntaxError();\n  }\n}\n\nfunction tryParseExportStatement() {\n  const sStartPos = pos;\n  pos += 6;\n  const curPos = pos;\n  let ch = commentWhitespace(true);\n  if (pos === curPos && !isPunctuator(ch)) return;\n\n  switch (ch) {\n    // export default ...\n    case 100\n    /*d*/\n    :\n      exports.add(source.slice(pos, pos + 7));\n      return;\n    // export async? function*? name () {\n\n    case 97\n    /*a*/\n    :\n      pos += 5;\n      commentWhitespace(true);\n    // fallthrough\n\n    case 102\n    /*f*/\n    :\n      pos += 8;\n      ch = commentWhitespace(true);\n\n      if (ch === 42\n      /***/\n      ) {\n        pos++;\n        ch = commentWhitespace(true);\n      }\n\n      const startPos = pos;\n      ch = readToWsOrPunctuator(ch);\n      exports.add(source.slice(startPos, pos));\n      pos--;\n      return;\n\n    case 99\n    /*c*/\n    :\n      if (source.startsWith('lass', pos + 1) && isBrOrWsOrPunctuatorNotDot(source.charCodeAt(pos + 5))) {\n        pos += 5;\n        ch = commentWhitespace(true);\n        const startPos = pos;\n        ch = readToWsOrPunctuator(ch);\n        exports.add(source.slice(startPos, pos));\n        pos--;\n        return;\n      }\n\n      pos += 2;\n    // fallthrough\n    // export var/let/const name = ...(, name = ...)+\n\n    case 118\n    /*v*/\n    :\n    case 109\n    /*l*/\n    :\n      // destructured initializations not currently supported (skipped for { or [)\n      // also, lexing names after variable equals is skipped (export var p = function () { ... }, q = 5 skips \"q\")\n      pos += 2;\n      facade = false;\n\n      do {\n        pos++;\n        ch = commentWhitespace(true);\n        const startPos = pos;\n        ch = readToWsOrPunctuator(ch); // dont yet handle [ { destructurings\n\n        if (ch === 123\n        /*{*/\n        || ch === 91\n        /*[*/\n        ) {\n          pos--;\n          return;\n        }\n\n        if (pos === startPos) return;\n        exports.add(source.slice(startPos, pos));\n        ch = commentWhitespace(true);\n\n        if (ch === 61\n        /*=*/\n        ) {\n          pos--;\n          return;\n        }\n      } while (ch === 44\n      /*,*/\n      );\n\n      pos--;\n      return;\n    // export {...}\n\n    case 123\n    /*{*/\n    :\n      pos++;\n      ch = commentWhitespace(true);\n\n      while (true) {\n        const startPos = pos;\n        readToWsOrPunctuator(ch);\n        const endPos = pos;\n        commentWhitespace(true);\n        ch = readExportAs(startPos, endPos); // ,\n\n        if (ch === 44\n        /*,*/\n        ) {\n          pos++;\n          ch = commentWhitespace(true);\n        }\n\n        if (ch === 125\n        /*}*/\n        ) break;\n        if (pos === startPos) return syntaxError();\n        if (pos > end) return syntaxError();\n      }\n\n      pos++;\n      ch = commentWhitespace(true);\n      break;\n    // export *\n    // export * as X\n\n    case 42\n    /***/\n    :\n      pos++;\n      commentWhitespace(true);\n      ch = readExportAs(pos, pos);\n      ch = commentWhitespace(true);\n      break;\n  } // from ...\n\n\n  if (ch === 102\n  /*f*/\n  && source.startsWith('rom', pos + 1)) {\n    pos += 4;\n    readImportString(sStartPos, commentWhitespace(true));\n  } else {\n    pos--;\n  }\n}\n/*\r\n * Ported from Acorn\r\n *   \r\n * MIT License\r\n\r\n * Copyright (C) 2012-2020 by various contributors (see AUTHORS)\r\n\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\n\n\nlet acornPos;\n\nfunction readString(start, quote) {\n  acornPos = start;\n  let out = '',\n      chunkStart = acornPos;\n\n  for (;;) {\n    if (acornPos >= source.length) syntaxError();\n    const ch = source.charCodeAt(acornPos);\n    if (ch === quote) break;\n\n    if (ch === 92) {\n      // '\\'\n      out += source.slice(chunkStart, acornPos);\n      out += readEscapedChar();\n      chunkStart = acornPos;\n    } else if (ch === 0x2028 || ch === 0x2029) {\n      ++acornPos;\n    } else {\n      if (isBr(ch)) syntaxError();\n      ++acornPos;\n    }\n  }\n\n  out += source.slice(chunkStart, acornPos++);\n  return out;\n} // Used to read escaped characters\n\n\nfunction readEscapedChar() {\n  let ch = source.charCodeAt(++acornPos);\n  ++acornPos;\n\n  switch (ch) {\n    case 110:\n      return '\\n';\n    // 'n' -> '\\n'\n\n    case 114:\n      return '\\r';\n    // 'r' -> '\\r'\n\n    case 120:\n      return String.fromCharCode(readHexChar(2));\n    // 'x'\n\n    case 117:\n      return readCodePointToString();\n    // 'u'\n\n    case 116:\n      return '\\t';\n    // 't' -> '\\t'\n\n    case 98:\n      return '\\b';\n    // 'b' -> '\\b'\n\n    case 118:\n      return '\\u000b';\n    // 'v' -> '\\u000b'\n\n    case 102:\n      return '\\f';\n    // 'f' -> '\\f'\n\n    case 13:\n      if (source.charCodeAt(acornPos) === 10) ++acornPos;\n    // '\\r\\n'\n\n    case 10:\n      // ' \\n'\n      return '';\n\n    case 56:\n    case 57:\n      syntaxError();\n\n    default:\n      if (ch >= 48 && ch <= 55) {\n        let octalStr = source.substr(acornPos - 1, 3).match(/^[0-7]+/)[0];\n        let octal = parseInt(octalStr, 8);\n\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n\n        acornPos += octalStr.length - 1;\n        ch = source.charCodeAt(acornPos);\n        if (octalStr !== '0' || ch === 56 || ch === 57) syntaxError();\n        return String.fromCharCode(octal);\n      }\n\n      if (isBr(ch)) {\n        // Unicode new line characters after \\ get removed from output in both\n        // template literals and strings\n        return '';\n      }\n\n      return String.fromCharCode(ch);\n  }\n} // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n\nfunction readHexChar(len) {\n  const start = acornPos;\n  let total = 0,\n      lastCode = 0;\n\n  for (let i = 0; i < len; ++i, ++acornPos) {\n    let code = source.charCodeAt(acornPos),\n        val;\n\n    if (code === 95) {\n      if (lastCode === 95 || i === 0) syntaxError();\n      lastCode = code;\n      continue;\n    }\n\n    if (code >= 97) val = code - 97 + 10; // a\n    else if (code >= 65) val = code - 65 + 10; // A\n    else if (code >= 48 && code <= 57) val = code - 48; // 0-9\n    else break;\n    if (val >= 16) break;\n    lastCode = code;\n    total = total * 16 + val;\n  }\n\n  if (lastCode === 95 || acornPos - start !== len) syntaxError();\n  return total;\n} // Read a string value, interpreting backslash-escapes.\n\n\nfunction readCodePointToString() {\n  const ch = source.charCodeAt(acornPos);\n  let code;\n\n  if (ch === 123) {\n    // '{'\n    ++acornPos;\n    code = readHexChar(source.indexOf('}', acornPos) - acornPos);\n    ++acornPos;\n    if (code > 0x10FFFF) syntaxError();\n  } else {\n    code = readHexChar(4);\n  } // UTF-16 Decoding\n\n\n  if (code <= 0xFFFF) return String.fromCharCode(code);\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n}\n/*\r\n * </ Acorn Port>\r\n */\n\n\nfunction readExportAs(startPos, endPos) {\n  let ch = source.charCodeAt(pos);\n\n  if (ch === 97\n  /*a*/\n  ) {\n    pos += 2;\n    ch = commentWhitespace(true);\n    startPos = pos;\n    readToWsOrPunctuator(ch);\n    endPos = pos;\n    ch = commentWhitespace(true);\n  }\n\n  if (pos !== startPos) exports.add(source.slice(startPos, endPos));\n  return ch;\n}\n\nfunction readImportString(ss, ch) {\n  const startPos = pos + 1;\n\n  if (ch === 39\n  /*'*/\n  || ch === 34\n  /*\"*/\n  ) {\n    stringLiteral(ch);\n  } else {\n    syntaxError();\n    return;\n  }\n\n  const impt = addImport(ss, startPos, pos, -1);\n  readName(impt);\n  pos++;\n  ch = commentWhitespace(false);\n\n  if (ch !== 97\n  /*a*/\n  || !source.startsWith('ssert', pos + 1)) {\n    pos--;\n    return;\n  }\n\n  const assertIndex = pos;\n  pos += 6;\n  ch = commentWhitespace(true);\n\n  if (ch !== 123\n  /*{*/\n  ) {\n    pos = assertIndex;\n    return;\n  }\n\n  const assertStart = pos;\n\n  do {\n    pos++;\n    ch = commentWhitespace(true);\n\n    if (ch === 39\n    /*'*/\n    || ch === 34\n    /*\"*/\n    ) {\n      stringLiteral(ch);\n      pos++;\n      ch = commentWhitespace(true);\n    } else {\n      ch = readToWsOrPunctuator(ch);\n    }\n\n    if (ch !== 58\n    /*:*/\n    ) {\n      pos = assertIndex;\n      return;\n    }\n\n    pos++;\n    ch = commentWhitespace(true);\n\n    if (ch === 39\n    /*'*/\n    || ch === 34\n    /*\"*/\n    ) {\n      stringLiteral(ch);\n    } else {\n      pos = assertIndex;\n      return;\n    }\n\n    pos++;\n    ch = commentWhitespace(true);\n\n    if (ch === 44\n    /*,*/\n    ) {\n      pos++;\n      ch = commentWhitespace(true);\n      if (ch === 125\n      /*}*/\n      ) break;\n      continue;\n    }\n\n    if (ch === 125\n    /*}*/\n    ) break;\n    pos = assertIndex;\n    return;\n  } while (true);\n\n  impt.a = assertStart;\n  impt.se = pos + 1;\n}\n\nfunction commentWhitespace(br) {\n  let ch;\n\n  do {\n    ch = source.charCodeAt(pos);\n\n    if (ch === 47\n    /*/*/\n    ) {\n      const next_ch = source.charCodeAt(pos + 1);\n      if (next_ch === 47\n      /*/*/\n      ) lineComment();else if (next_ch === 42\n      /***/\n      ) blockComment(br);else return ch;\n    } else if (br ? !isBrOrWs(ch) : !isWsNotBr(ch)) {\n      return ch;\n    }\n  } while (pos++ < end);\n\n  return ch;\n}\n\nfunction templateString() {\n  while (pos++ < end) {\n    const ch = source.charCodeAt(pos);\n\n    if (ch === 36\n    /*$*/\n    && source.charCodeAt(pos + 1) === 123\n    /*{*/\n    ) {\n      pos++;\n      templateStack[templateStackDepth++] = templateDepth;\n      templateDepth = ++openTokenDepth;\n      return;\n    }\n\n    if (ch === 96\n    /*`*/\n    ) return;\n    if (ch === 92\n    /*\\*/\n    ) pos++;\n  }\n\n  syntaxError();\n}\n\nfunction blockComment(br) {\n  pos++;\n\n  while (pos++ < end) {\n    const ch = source.charCodeAt(pos);\n    if (!br && isBr(ch)) return;\n\n    if (ch === 42\n    /***/\n    && source.charCodeAt(pos + 1) === 47\n    /*/*/\n    ) {\n      pos++;\n      return;\n    }\n  }\n}\n\nfunction lineComment() {\n  while (pos++ < end) {\n    const ch = source.charCodeAt(pos);\n    if (ch === 10\n    /*\\n*/\n    || ch === 13\n    /*\\r*/\n    ) return;\n  }\n}\n\nfunction stringLiteral(quote) {\n  while (pos++ < end) {\n    let ch = source.charCodeAt(pos);\n    if (ch === quote) return;\n\n    if (ch === 92\n    /*\\*/\n    ) {\n      ch = source.charCodeAt(++pos);\n      if (ch === 13\n      /*\\r*/\n      && source.charCodeAt(pos + 1) === 10\n      /*\\n*/\n      ) pos++;\n    } else if (isBr(ch)) break;\n  }\n\n  syntaxError();\n}\n\nfunction regexCharacterClass() {\n  while (pos++ < end) {\n    let ch = source.charCodeAt(pos);\n    if (ch === 93\n    /*]*/\n    ) return ch;\n    if (ch === 92\n    /*\\*/\n    ) pos++;else if (ch === 10\n    /*\\n*/\n    || ch === 13\n    /*\\r*/\n    ) break;\n  }\n\n  syntaxError();\n}\n\nfunction regularExpression() {\n  while (pos++ < end) {\n    let ch = source.charCodeAt(pos);\n    if (ch === 47\n    /*/*/\n    ) return;\n    if (ch === 91\n    /*[*/\n    ) ch = regexCharacterClass();else if (ch === 92\n    /*\\*/\n    ) pos++;else if (ch === 10\n    /*\\n*/\n    || ch === 13\n    /*\\r*/\n    ) break;\n  }\n\n  syntaxError();\n}\n\nfunction readToWsOrPunctuator(ch) {\n  do {\n    if (isBrOrWs(ch) || isPunctuator(ch)) return ch;\n  } while (ch = source.charCodeAt(++pos));\n\n  return ch;\n} // Note: non-asii BR and whitespace checks omitted for perf / footprint\n// if there is a significant user need this can be reconsidered\n\n\nfunction isBr(c) {\n  return c === 13\n  /*\\r*/\n  || c === 10\n  /*\\n*/\n  ;\n}\n\nfunction isWsNotBr(c) {\n  return c === 9 || c === 11 || c === 12 || c === 32 || c === 160;\n}\n\nfunction isBrOrWs(c) {\n  return c > 8 && c < 14 || c === 32 || c === 160;\n}\n\nfunction isBrOrWsOrPunctuatorNotDot(c) {\n  return c > 8 && c < 14 || c === 32 || c === 160 || isPunctuator(c) && c !== 46\n  /*.*/\n  ;\n}\n\nfunction keywordStart(pos) {\n  return pos === 0 || isBrOrWsOrPunctuatorNotDot(source.charCodeAt(pos - 1));\n}\n\nfunction readPrecedingKeyword(pos, match) {\n  if (pos < match.length - 1) return false;\n  return source.startsWith(match, pos - match.length + 1) && (pos === 0 || isBrOrWsOrPunctuatorNotDot(source.charCodeAt(pos - match.length)));\n}\n\nfunction readPrecedingKeyword1(pos, ch) {\n  return source.charCodeAt(pos) === ch && (pos === 0 || isBrOrWsOrPunctuatorNotDot(source.charCodeAt(pos - 1)));\n} // Detects one of case, debugger, delete, do, else, in, instanceof, new,\n//   return, throw, typeof, void, yield, await\n\n\nfunction isExpressionKeyword(pos) {\n  switch (source.charCodeAt(pos)) {\n    case 100\n    /*d*/\n    :\n      switch (source.charCodeAt(pos - 1)) {\n        case 105\n        /*i*/\n        :\n          // void\n          return readPrecedingKeyword(pos - 2, 'vo');\n\n        case 108\n        /*l*/\n        :\n          // yield\n          return readPrecedingKeyword(pos - 2, 'yie');\n\n        default:\n          return false;\n      }\n\n    case 101\n    /*e*/\n    :\n      switch (source.charCodeAt(pos - 1)) {\n        case 115\n        /*s*/\n        :\n          switch (source.charCodeAt(pos - 2)) {\n            case 108\n            /*l*/\n            :\n              // else\n              return readPrecedingKeyword1(pos - 3, 101\n              /*e*/\n              );\n\n            case 97\n            /*a*/\n            :\n              // case\n              return readPrecedingKeyword1(pos - 3, 99\n              /*c*/\n              );\n\n            default:\n              return false;\n          }\n\n        case 116\n        /*t*/\n        :\n          // delete\n          return readPrecedingKeyword(pos - 2, 'dele');\n\n        default:\n          return false;\n      }\n\n    case 102\n    /*f*/\n    :\n      if (source.charCodeAt(pos - 1) !== 111\n      /*o*/\n      || source.charCodeAt(pos - 2) !== 101\n      /*e*/\n      ) return false;\n\n      switch (source.charCodeAt(pos - 3)) {\n        case 99\n        /*c*/\n        :\n          // instanceof\n          return readPrecedingKeyword(pos - 4, 'instan');\n\n        case 112\n        /*p*/\n        :\n          // typeof\n          return readPrecedingKeyword(pos - 4, 'ty');\n\n        default:\n          return false;\n      }\n\n    case 110\n    /*n*/\n    :\n      // in, return\n      return readPrecedingKeyword1(pos - 1, 105\n      /*i*/\n      ) || readPrecedingKeyword(pos - 1, 'retur');\n\n    case 111\n    /*o*/\n    :\n      // do\n      return readPrecedingKeyword1(pos - 1, 100\n      /*d*/\n      );\n\n    case 114\n    /*r*/\n    :\n      // debugger\n      return readPrecedingKeyword(pos - 1, 'debugge');\n\n    case 116\n    /*t*/\n    :\n      // await\n      return readPrecedingKeyword(pos - 1, 'awai');\n\n    case 119\n    /*w*/\n    :\n      switch (source.charCodeAt(pos - 1)) {\n        case 101\n        /*e*/\n        :\n          // new\n          return readPrecedingKeyword1(pos - 2, 110\n          /*n*/\n          );\n\n        case 111\n        /*o*/\n        :\n          // throw\n          return readPrecedingKeyword(pos - 2, 'thr');\n\n        default:\n          return false;\n      }\n\n  }\n\n  return false;\n}\n\nfunction isParenKeyword(curPos) {\n  return source.charCodeAt(curPos) === 101\n  /*e*/\n  && source.startsWith('whil', curPos - 4) || source.charCodeAt(curPos) === 114\n  /*r*/\n  && source.startsWith('fo', curPos - 2) || source.charCodeAt(curPos - 1) === 105\n  /*i*/\n  && source.charCodeAt(curPos) === 102\n  /*f*/\n  ;\n}\n\nfunction isPunctuator(ch) {\n  // 23 possible punctuator endings: !%&()*+,-./:;<=>?[]^{}|~\n  return ch === 33\n  /*!*/\n  || ch === 37\n  /*%*/\n  || ch === 38\n  /*&*/\n  || ch > 39 && ch < 48 || ch > 57 && ch < 64 || ch === 91\n  /*[*/\n  || ch === 93\n  /*]*/\n  || ch === 94\n  /*^*/\n  || ch > 122 && ch < 127;\n}\n\nfunction isExpressionPunctuator(ch) {\n  // 20 possible expression endings: !%&(*+,-.:;<=>?[^{|~\n  return ch === 33\n  /*!*/\n  || ch === 37\n  /*%*/\n  || ch === 38\n  /*&*/\n  || ch > 39 && ch < 47 && ch !== 41 || ch > 57 && ch < 64 || ch === 91\n  /*[*/\n  || ch === 94\n  /*^*/\n  || ch > 122 && ch < 127 && ch !== 125\n  /*}*/\n  ;\n}\n\nfunction isExpressionTerminator(curPos) {\n  // detects:\n  // => ; ) finally catch else\n  // as all of these followed by a { will indicate a statement brace\n  switch (source.charCodeAt(curPos)) {\n    case 62\n    /*>*/\n    :\n      return source.charCodeAt(curPos - 1) === 61\n      /*=*/\n      ;\n\n    case 59\n    /*;*/\n    :\n    case 41\n    /*)*/\n    :\n      return true;\n\n    case 104\n    /*h*/\n    :\n      return source.startsWith('catc', curPos - 4);\n\n    case 121\n    /*y*/\n    :\n      return source.startsWith('finall', curPos - 6);\n\n    case 101\n    /*e*/\n    :\n      return source.startsWith('els', curPos - 3);\n  }\n\n  return false;\n}\n\nfunction syntaxError() {\n  throw Object.assign(new Error(`Parse error ${name}:${source.slice(0, pos).split('\\n').length}:${pos - source.lastIndexOf('\\n', pos - 1)}`), {\n    idx: pos\n  });\n}","map":{"version":3,"names":["source","pos","end","openTokenDepth","lastTokenPos","openTokenPosStack","openClassPosStack","curDynamicImport","templateStackDepth","facade","lastSlashWasDivision","nextBraceIsClass","templateDepth","templateStack","imports","exports","name","addImport","ss","s","e","d","impt","se","a","n","undefined","push","readName","readString","charCodeAt","parse","_source","_name","Array","Set","length","ch","m","keywordStart","startsWith","tryParseExportStatement","tryParseImportStatement","next_ch","lineComment","blockComment","isBrOrWs","syntaxError","pop","templateString","stringLiteral","lastToken","isExpressionPunctuator","isParenKeyword","isExpressionTerminator","isExpressionKeyword","regularExpression","startPos","commentWhitespace","readImportString","sStartPos","curPos","isPunctuator","add","slice","readToWsOrPunctuator","isBrOrWsOrPunctuatorNotDot","endPos","readExportAs","acornPos","start","quote","out","chunkStart","readEscapedChar","isBr","String","fromCharCode","readHexChar","readCodePointToString","octalStr","substr","match","octal","parseInt","len","total","lastCode","i","code","val","indexOf","assertIndex","assertStart","br","isWsNotBr","regexCharacterClass","c","readPrecedingKeyword","readPrecedingKeyword1","Object","assign","Error","split","lastIndexOf","idx"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/es-module-lexer/lexer.js"],"sourcesContent":["let source, pos, end,\r\n  openTokenDepth,\r\n  lastTokenPos,\r\n  openTokenPosStack,\r\n  openClassPosStack,\r\n  curDynamicImport,\r\n  templateStackDepth,\r\n  facade,\r\n  lastSlashWasDivision,\r\n  nextBraceIsClass,\r\n  templateDepth,\r\n  templateStack,\r\n  imports,\r\n  exports,\r\n  name;\r\n\r\nfunction addImport (ss, s, e, d) {\r\n  const impt = { ss, se: d === -2 ? e : d === -1 ? e + 1 : 0, s, e, d, a: -1, n: undefined };\r\n  imports.push(impt);\r\n  return impt;\r\n}\r\n\r\nfunction readName (impt) {\r\n  let { d, s } = impt;\r\n  if (d !== -1)\r\n    s++;\r\n  impt.n = readString(s, source.charCodeAt(s - 1));\r\n}\r\n\r\n// Note: parsing is based on the _assumption_ that the source is already valid\r\nexport function parse (_source, _name) {\r\n  openTokenDepth = 0;\r\n  curDynamicImport = null;\r\n  templateDepth = -1;\r\n  lastTokenPos = -1;\r\n  lastSlashWasDivision = false;\r\n  templateStack = Array(1024);\r\n  templateStackDepth = 0;\r\n  openTokenPosStack = Array(1024);\r\n  openClassPosStack = Array(1024);\r\n  nextBraceIsClass = false;\r\n  facade = true;\r\n  name = _name || '@';\r\n\r\n  imports = [];\r\n  exports = new Set();\r\n\r\n  source = _source;\r\n  pos = -1;\r\n  end = source.length - 1;\r\n  let ch = 0;\r\n\r\n  // start with a pure \"module-only\" parser\r\n  m: while (pos++ < end) {\r\n    ch = source.charCodeAt(pos);\r\n\r\n    if (ch === 32 || ch < 14 && ch > 8)\r\n      continue;\r\n\r\n    switch (ch) {\r\n      case 101/*e*/:\r\n        if (openTokenDepth === 0 && keywordStart(pos) && source.startsWith('xport', pos + 1)) {\r\n          tryParseExportStatement();\r\n          // export might have been a non-pure declaration\r\n          if (!facade) {\r\n            lastTokenPos = pos;\r\n            break m;\r\n          }\r\n        }\r\n        break;\r\n      case 105/*i*/:\r\n        if (keywordStart(pos) && source.startsWith('mport', pos + 1))\r\n          tryParseImportStatement();\r\n        break;\r\n      case 59/*;*/:\r\n        break;\r\n      case 47/*/*/: {\r\n        const next_ch = source.charCodeAt(pos + 1);\r\n        if (next_ch === 47/*/*/) {\r\n          lineComment();\r\n          // dont update lastToken\r\n          continue;\r\n        }\r\n        else if (next_ch === 42/***/) {\r\n          blockComment(true);\r\n          // dont update lastToken\r\n          continue;\r\n        }\r\n        // fallthrough\r\n      }\r\n      default:\r\n        // as soon as we hit a non-module token, we go to main parser\r\n        facade = false;\r\n        pos--;\r\n        break m;\r\n    }\r\n    lastTokenPos = pos;\r\n  }\r\n\r\n  while (pos++ < end) {\r\n    ch = source.charCodeAt(pos);\r\n\r\n    if (ch === 32 || ch < 14 && ch > 8)\r\n      continue;\r\n\r\n    switch (ch) {\r\n      case 101/*e*/:\r\n        if (openTokenDepth === 0 && keywordStart(pos) && source.startsWith('xport', pos + 1))\r\n          tryParseExportStatement();\r\n        break;\r\n      case 105/*i*/:\r\n        if (keywordStart(pos) && source.startsWith('mport', pos + 1))\r\n          tryParseImportStatement();\r\n        break;\r\n      case 99/*c*/:\r\n        if (keywordStart(pos) && source.startsWith('lass', pos + 1) && isBrOrWs(source.charCodeAt(pos + 5)))\r\n          nextBraceIsClass = true;\r\n        break;\r\n      case 40/*(*/:\r\n        openTokenPosStack[openTokenDepth++] = lastTokenPos;\r\n        break;\r\n      case 41/*)*/:\r\n        if (openTokenDepth === 0)\r\n          syntaxError();\r\n        openTokenDepth--;\r\n        if (curDynamicImport && curDynamicImport.d === openTokenPosStack[openTokenDepth]) {\r\n          if (curDynamicImport.e === 0)\r\n            curDynamicImport.e = pos;\r\n          curDynamicImport.se = pos;\r\n          curDynamicImport = null;\r\n        }\r\n        break;\r\n      case 123/*{*/:\r\n        // dynamic import followed by { is not a dynamic import (so remove)\r\n        // this is a sneaky way to get around { import () {} } v { import () }\r\n        // block / object ambiguity without a parser (assuming source is valid)\r\n        if (source.charCodeAt(lastTokenPos) === 41/*)*/ && imports.length && imports[imports.length - 1].e === lastTokenPos) {\r\n          imports.pop();\r\n        }\r\n        openClassPosStack[openTokenDepth] = nextBraceIsClass;\r\n        nextBraceIsClass = false;\r\n        openTokenPosStack[openTokenDepth++] = lastTokenPos;\r\n        break;\r\n      case 125/*}*/:\r\n        if (openTokenDepth === 0)\r\n          syntaxError();\r\n        if (openTokenDepth-- === templateDepth) {\r\n          templateDepth = templateStack[--templateStackDepth];\r\n          templateString();\r\n        }\r\n        else {\r\n          if (templateDepth !== -1 && openTokenDepth < templateDepth)\r\n            syntaxError();\r\n        }\r\n        break;\r\n      case 39/*'*/:\r\n      case 34/*\"*/:\r\n        stringLiteral(ch);\r\n        break;\r\n      case 47/*/*/: {\r\n        const next_ch = source.charCodeAt(pos + 1);\r\n        if (next_ch === 47/*/*/) {\r\n          lineComment();\r\n          // dont update lastToken\r\n          continue;\r\n        }\r\n        else if (next_ch === 42/***/) {\r\n          blockComment(true);\r\n          // dont update lastToken\r\n          continue;\r\n        }\r\n        else {\r\n          // Division / regex ambiguity handling based on checking backtrack analysis of:\r\n          // - what token came previously (lastToken)\r\n          // - if a closing brace or paren, what token came before the corresponding\r\n          //   opening brace or paren (lastOpenTokenIndex)\r\n          const lastToken = source.charCodeAt(lastTokenPos);\r\n          if (isExpressionPunctuator(lastToken) &&\r\n              !(lastToken === 46/*.*/ && (source.charCodeAt(lastTokenPos - 1) >= 48/*0*/ && source.charCodeAt(lastTokenPos - 1) <= 57/*9*/)) &&\r\n              !(lastToken === 43/*+*/ && source.charCodeAt(lastTokenPos - 1) === 43/*+*/) && !(lastToken === 45/*-*/ && source.charCodeAt(lastTokenPos - 1) === 45/*-*/) ||\r\n              lastToken === 41/*)*/ && isParenKeyword(openTokenPosStack[openTokenDepth]) ||\r\n              lastToken === 125/*}*/ && (isExpressionTerminator(openTokenPosStack[openTokenDepth]) || openClassPosStack[openTokenDepth]) ||\r\n              lastToken === 47/*/*/ && lastSlashWasDivision ||\r\n              isExpressionKeyword(lastTokenPos) ||\r\n              !lastToken) {\r\n            regularExpression();\r\n            lastSlashWasDivision = false;\r\n          }\r\n          else {\r\n            lastSlashWasDivision = true;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case 96/*`*/:\r\n        templateString();\r\n        break;\r\n    }\r\n    lastTokenPos = pos;\r\n  }\r\n\r\n  if (templateDepth !== -1 || openTokenDepth)\r\n    syntaxError();\r\n\r\n  return [imports, [...exports], facade];\r\n}\r\n\r\nfunction tryParseImportStatement () {\r\n  const startPos = pos;\r\n\r\n  pos += 6;\r\n\r\n  let ch = commentWhitespace(true);\r\n  \r\n  switch (ch) {\r\n    // dynamic import\r\n    case 40/*(*/:\r\n      openTokenPosStack[openTokenDepth++] = startPos;\r\n      if (source.charCodeAt(lastTokenPos) === 46/*.*/)\r\n        return;\r\n      // dynamic import indicated by positive d\r\n      const impt = addImport(startPos, pos + 1, 0, startPos);\r\n      curDynamicImport = impt;\r\n      // try parse a string, to record a safe dynamic import string\r\n      pos++;\r\n      ch = commentWhitespace(true);\r\n      if (ch === 39/*'*/ || ch === 34/*\"*/) {\r\n        stringLiteral(ch);\r\n      }\r\n      else {\r\n        pos--;\r\n        return;\r\n      }\r\n      pos++;\r\n      ch = commentWhitespace(true);\r\n      if (ch === 44/*,*/) {\r\n        impt.e = pos;\r\n        pos++;\r\n        ch = commentWhitespace(true);\r\n        impt.a = pos;\r\n        readName(impt);\r\n        pos--;\r\n      }\r\n      else if (ch === 41/*)*/) {\r\n        openTokenDepth--;\r\n        impt.e = pos;\r\n        impt.se = pos;\r\n        readName(impt);\r\n      }\r\n      else {\r\n        pos--;\r\n      }\r\n      return;\r\n    // import.meta\r\n    case 46/*.*/:\r\n      pos++;\r\n      ch = commentWhitespace(true);\r\n      // import.meta indicated by d === -2\r\n      if (ch === 109/*m*/ && source.startsWith('eta', pos + 1) && source.charCodeAt(lastTokenPos) !== 46/*.*/)\r\n        addImport(startPos, startPos, pos + 4, -2);\r\n      return;\r\n    \r\n    default:\r\n      // no space after \"import\" -> not an import keyword\r\n      if (pos === startPos + 6)\r\n        break;\r\n    case 34/*\"*/:\r\n    case 39/*'*/:\r\n    case 123/*{*/:\r\n    case 42/***/:\r\n      // import statement only permitted at base-level\r\n      if (openTokenDepth !== 0) {\r\n        pos--;\r\n        return;\r\n      }\r\n      while (pos < end) {\r\n        ch = source.charCodeAt(pos);\r\n        if (ch === 39/*'*/ || ch === 34/*\"*/) {\r\n          readImportString(startPos, ch);\r\n          return;\r\n        }\r\n        pos++;\r\n      }\r\n      syntaxError();\r\n  }\r\n}\r\n\r\nfunction tryParseExportStatement () {\r\n  const sStartPos = pos;\r\n\r\n  pos += 6;\r\n\r\n  const curPos = pos;\r\n\r\n  let ch = commentWhitespace(true);\r\n\r\n  if (pos === curPos && !isPunctuator(ch))\r\n    return;\r\n\r\n  switch (ch) {\r\n    // export default ...\r\n    case 100/*d*/:\r\n      exports.add(source.slice(pos, pos + 7));\r\n      return;\r\n\r\n    // export async? function*? name () {\r\n    case 97/*a*/:\r\n      pos += 5;\r\n      commentWhitespace(true);\r\n    // fallthrough\r\n    case 102/*f*/:\r\n      pos += 8;\r\n      ch = commentWhitespace(true);\r\n      if (ch === 42/***/) {\r\n        pos++;\r\n        ch = commentWhitespace(true);\r\n      }\r\n      const startPos = pos;\r\n      ch = readToWsOrPunctuator(ch);\r\n      exports.add(source.slice(startPos, pos));\r\n      pos--;\r\n      return;\r\n\r\n    case 99/*c*/:\r\n      if (source.startsWith('lass', pos + 1) && isBrOrWsOrPunctuatorNotDot(source.charCodeAt(pos + 5))) {\r\n        pos += 5;\r\n        ch = commentWhitespace(true);\r\n        const startPos = pos;\r\n        ch = readToWsOrPunctuator(ch);\r\n        exports.add(source.slice(startPos, pos));\r\n        pos--;\r\n        return;\r\n      }\r\n      pos += 2;\r\n    // fallthrough\r\n\r\n    // export var/let/const name = ...(, name = ...)+\r\n    case 118/*v*/:\r\n    case 109/*l*/:\r\n      // destructured initializations not currently supported (skipped for { or [)\r\n      // also, lexing names after variable equals is skipped (export var p = function () { ... }, q = 5 skips \"q\")\r\n      pos += 2;\r\n      facade = false;\r\n      do {\r\n        pos++;\r\n        ch = commentWhitespace(true);\r\n        const startPos = pos;\r\n        ch = readToWsOrPunctuator(ch);\r\n        // dont yet handle [ { destructurings\r\n        if (ch === 123/*{*/ || ch === 91/*[*/) {\r\n          pos--;\r\n          return;\r\n        }\r\n        if (pos === startPos)\r\n          return;\r\n        exports.add(source.slice(startPos, pos));\r\n        ch = commentWhitespace(true);\r\n        if (ch === 61/*=*/) {\r\n          pos--;\r\n          return;\r\n        }\r\n      } while (ch === 44/*,*/);\r\n      pos--;\r\n      return;\r\n\r\n\r\n    // export {...}\r\n    case 123/*{*/:\r\n      pos++;\r\n      ch = commentWhitespace(true);\r\n      while (true) {\r\n        const startPos = pos;\r\n        readToWsOrPunctuator(ch);\r\n        const endPos = pos;\r\n        commentWhitespace(true);\r\n        ch = readExportAs(startPos, endPos);\r\n        // ,\r\n        if (ch === 44/*,*/) {\r\n          pos++;\r\n          ch = commentWhitespace(true);\r\n        }\r\n        if (ch === 125/*}*/)\r\n          break;\r\n        if (pos === startPos)\r\n          return syntaxError(); \r\n        if (pos > end)\r\n          return syntaxError();\r\n      }\r\n      pos++;\r\n      ch = commentWhitespace(true);\r\n    break;\r\n    \r\n    // export *\r\n    // export * as X\r\n    case 42/***/:\r\n      pos++;\r\n      commentWhitespace(true);\r\n      ch = readExportAs(pos, pos);\r\n      ch = commentWhitespace(true);\r\n    break;\r\n  }\r\n\r\n  // from ...\r\n  if (ch === 102/*f*/ && source.startsWith('rom', pos + 1)) {\r\n    pos += 4;\r\n    readImportString(sStartPos, commentWhitespace(true));\r\n  }\r\n  else {\r\n    pos--;\r\n  }\r\n}\r\n\r\n/*\r\n * Ported from Acorn\r\n *   \r\n * MIT License\r\n\r\n * Copyright (C) 2012-2020 by various contributors (see AUTHORS)\r\n\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\nlet acornPos;\r\nfunction readString (start, quote) {\r\n  acornPos = start;\r\n  let out = '', chunkStart = acornPos;\r\n  for (;;) {\r\n    if (acornPos >= source.length) syntaxError();\r\n    const ch = source.charCodeAt(acornPos);\r\n    if (ch === quote) break;\r\n    if (ch === 92) { // '\\'\r\n      out += source.slice(chunkStart, acornPos);\r\n      out += readEscapedChar();\r\n      chunkStart = acornPos;\r\n    }\r\n    else if (ch === 0x2028 || ch === 0x2029) {\r\n      ++acornPos;\r\n    }\r\n    else {\r\n      if (isBr(ch)) syntaxError();\r\n      ++acornPos;\r\n    }\r\n  }\r\n  out += source.slice(chunkStart, acornPos++);\r\n  return out;\r\n}\r\n\r\n// Used to read escaped characters\r\n\r\nfunction readEscapedChar () {\r\n  let ch = source.charCodeAt(++acornPos);\r\n  ++acornPos;\r\n  switch (ch) {\r\n    case 110: return '\\n'; // 'n' -> '\\n'\r\n    case 114: return '\\r'; // 'r' -> '\\r'\r\n    case 120: return String.fromCharCode(readHexChar(2)); // 'x'\r\n    case 117: return readCodePointToString(); // 'u'\r\n    case 116: return '\\t'; // 't' -> '\\t'\r\n    case 98: return '\\b'; // 'b' -> '\\b'\r\n    case 118: return '\\u000b'; // 'v' -> '\\u000b'\r\n    case 102: return '\\f'; // 'f' -> '\\f'\r\n    case 13: if (source.charCodeAt(acornPos) === 10) ++acornPos; // '\\r\\n'\r\n    case 10: // ' \\n'\r\n      return '';\r\n    case 56:\r\n    case 57:\r\n      syntaxError();\r\n    default:\r\n      if (ch >= 48 && ch <= 55) {\r\n        let octalStr = source.substr(acornPos - 1, 3).match(/^[0-7]+/)[0];\r\n        let octal = parseInt(octalStr, 8);\r\n        if (octal > 255) {\r\n          octalStr = octalStr.slice(0, -1);\r\n          octal = parseInt(octalStr, 8);\r\n        }\r\n        acornPos += octalStr.length - 1;\r\n        ch = source.charCodeAt(acornPos);\r\n        if (octalStr !== '0' || ch === 56 || ch === 57)\r\n          syntaxError();\r\n        return String.fromCharCode(octal);\r\n      }\r\n      if (isBr(ch)) {\r\n        // Unicode new line characters after \\ get removed from output in both\r\n        // template literals and strings\r\n        return '';\r\n      }\r\n      return String.fromCharCode(ch);\r\n  }\r\n}\r\n\r\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\r\n\r\nfunction readHexChar (len) {\r\n  const start = acornPos;\r\n  let total = 0, lastCode = 0;\r\n  for (let i = 0; i < len; ++i, ++acornPos) {\r\n    let code = source.charCodeAt(acornPos), val;\r\n\r\n    if (code === 95) {\r\n      if (lastCode === 95 || i === 0) syntaxError();\r\n      lastCode = code;\r\n      continue;\r\n    }\r\n\r\n    if (code >= 97) val = code - 97 + 10; // a\r\n    else if (code >= 65) val = code - 65 + 10; // A\r\n    else if (code >= 48 && code <= 57) val = code - 48; // 0-9\r\n    else break;\r\n    if (val >= 16) break;\r\n    lastCode = code;\r\n    total = total * 16 + val;\r\n  }\r\n\r\n  if (lastCode === 95 || acornPos - start !== len) syntaxError();\r\n\r\n  return total;\r\n}\r\n\r\n// Read a string value, interpreting backslash-escapes.\r\n\r\nfunction readCodePointToString () {\r\n  const ch = source.charCodeAt(acornPos);\r\n  let code;\r\n  if (ch === 123) { // '{'\r\n    ++acornPos;\r\n    code = readHexChar(source.indexOf('}', acornPos) - acornPos);\r\n    ++acornPos;\r\n    if (code > 0x10FFFF) syntaxError();\r\n  } else {\r\n    code = readHexChar(4);\r\n  }\r\n  // UTF-16 Decoding\r\n  if (code <= 0xFFFF) return String.fromCharCode(code);\r\n  code -= 0x10000;\r\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\r\n}\r\n\r\n/*\r\n * </ Acorn Port>\r\n */\r\n\r\nfunction readExportAs (startPos, endPos) {\r\n  let ch = source.charCodeAt(pos);\r\n  if (ch === 97 /*a*/) {\r\n    pos += 2;\r\n    ch = commentWhitespace(true);\r\n    startPos = pos;\r\n    readToWsOrPunctuator(ch);\r\n    endPos = pos;\r\n    ch = commentWhitespace(true);\r\n  }\r\n  if (pos !== startPos)\r\n    exports.add(source.slice(startPos, endPos));\r\n  return ch;\r\n}\r\n\r\nfunction readImportString (ss, ch) {\r\n  const startPos = pos + 1;\r\n  if (ch === 39/*'*/ || ch === 34/*\"*/) {\r\n    stringLiteral(ch);\r\n  }\r\n  else {\r\n    syntaxError();\r\n    return;\r\n  }\r\n  const impt = addImport(ss, startPos, pos, -1);\r\n  readName(impt);\r\n  pos++;\r\n  ch = commentWhitespace(false);\r\n  if (ch !== 97/*a*/ || !source.startsWith('ssert', pos + 1)) {\r\n    pos--;\r\n    return;\r\n  }\r\n  const assertIndex = pos;\r\n\r\n  pos += 6;\r\n  ch = commentWhitespace(true);\r\n  if (ch !== 123/*{*/) {\r\n    pos = assertIndex;\r\n    return;\r\n  }\r\n  const assertStart = pos;\r\n  do {\r\n    pos++;\r\n    ch = commentWhitespace(true);\r\n    if (ch === 39/*'*/ || ch === 34/*\"*/) {\r\n      stringLiteral(ch);\r\n      pos++;\r\n      ch = commentWhitespace(true);\r\n    }\r\n    else {\r\n      ch = readToWsOrPunctuator(ch);\r\n    }\r\n    if (ch !== 58/*:*/) {\r\n      pos = assertIndex;\r\n      return;\r\n    }\r\n    pos++;\r\n    ch = commentWhitespace(true);\r\n    if (ch === 39/*'*/ || ch === 34/*\"*/) {\r\n      stringLiteral(ch);\r\n    }\r\n    else {\r\n      pos = assertIndex;\r\n      return;\r\n    }\r\n    pos++;\r\n    ch = commentWhitespace(true);\r\n    if (ch === 44/*,*/) {\r\n      pos++;\r\n      ch = commentWhitespace(true);\r\n      if (ch === 125/*}*/)\r\n        break;\r\n      continue;\r\n    }\r\n    if (ch === 125/*}*/)\r\n      break;\r\n    pos = assertIndex;\r\n    return;\r\n  } while (true);\r\n  impt.a = assertStart;\r\n  impt.se = pos + 1;\r\n}\r\n\r\nfunction commentWhitespace (br) {\r\n  let ch;\r\n  do {\r\n    ch = source.charCodeAt(pos);\r\n    if (ch === 47/*/*/) {\r\n      const next_ch = source.charCodeAt(pos + 1);\r\n      if (next_ch === 47/*/*/)\r\n        lineComment();\r\n      else if (next_ch === 42/***/)\r\n        blockComment(br);\r\n      else\r\n        return ch;\r\n    }\r\n    else if (br ? !isBrOrWs(ch): !isWsNotBr(ch)) {\r\n      return ch;\r\n    }\r\n  } while (pos++ < end);\r\n  return ch;\r\n}\r\n\r\nfunction templateString () {\r\n  while (pos++ < end) {\r\n    const ch = source.charCodeAt(pos);\r\n    if (ch === 36/*$*/ && source.charCodeAt(pos + 1) === 123/*{*/) {\r\n      pos++;\r\n      templateStack[templateStackDepth++] = templateDepth;\r\n      templateDepth = ++openTokenDepth;\r\n      return;\r\n    }\r\n    if (ch === 96/*`*/)\r\n      return;\r\n    if (ch === 92/*\\*/)\r\n      pos++;\r\n  }\r\n  syntaxError();\r\n}\r\n\r\nfunction blockComment (br) {\r\n  pos++;\r\n  while (pos++ < end) {\r\n    const ch = source.charCodeAt(pos);\r\n    if (!br && isBr(ch))\r\n      return;\r\n    if (ch === 42/***/ && source.charCodeAt(pos + 1) === 47/*/*/) {\r\n      pos++;\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\nfunction lineComment () {\r\n  while (pos++ < end) {\r\n    const ch = source.charCodeAt(pos);\r\n    if (ch === 10/*\\n*/ || ch === 13/*\\r*/)\r\n      return;\r\n  }\r\n}\r\n\r\nfunction stringLiteral (quote) {\r\n  while (pos++ < end) {\r\n    let ch = source.charCodeAt(pos);\r\n    if (ch === quote)\r\n      return;\r\n    if (ch === 92/*\\*/) {\r\n      ch = source.charCodeAt(++pos);\r\n      if (ch === 13/*\\r*/ && source.charCodeAt(pos + 1) === 10/*\\n*/)\r\n        pos++;\r\n    }\r\n    else if (isBr(ch))\r\n      break;\r\n  }\r\n  syntaxError();\r\n}\r\n\r\nfunction regexCharacterClass () {\r\n  while (pos++ < end) {\r\n    let ch = source.charCodeAt(pos);\r\n    if (ch === 93/*]*/)\r\n      return ch;\r\n    if (ch === 92/*\\*/)\r\n      pos++;\r\n    else if (ch === 10/*\\n*/ || ch === 13/*\\r*/)\r\n      break;\r\n  }\r\n  syntaxError();\r\n}\r\n\r\nfunction regularExpression () {\r\n  while (pos++ < end) {\r\n    let ch = source.charCodeAt(pos);\r\n    if (ch === 47/*/*/)\r\n      return;\r\n    if (ch === 91/*[*/)\r\n      ch = regexCharacterClass();\r\n    else if (ch === 92/*\\*/)\r\n      pos++;\r\n    else if (ch === 10/*\\n*/ || ch === 13/*\\r*/)\r\n      break;\r\n  }\r\n  syntaxError();\r\n}\r\n\r\nfunction readToWsOrPunctuator (ch) {\r\n  do {\r\n    if (isBrOrWs(ch) || isPunctuator(ch))\r\n      return ch;\r\n  } while (ch = source.charCodeAt(++pos));\r\n  return ch;\r\n}\r\n\r\n// Note: non-asii BR and whitespace checks omitted for perf / footprint\r\n// if there is a significant user need this can be reconsidered\r\nfunction isBr (c) {\r\n  return c === 13/*\\r*/ || c === 10/*\\n*/;\r\n}\r\n\r\nfunction isWsNotBr (c) {\r\n  return c === 9 || c === 11 || c === 12 || c === 32 || c === 160;\r\n}\r\n\r\nfunction isBrOrWs (c) {\r\n  return c > 8 && c < 14 || c === 32 || c === 160;\r\n}\r\n\r\nfunction isBrOrWsOrPunctuatorNotDot (c) {\r\n  return c > 8 && c < 14 || c === 32 || c === 160 || isPunctuator(c) && c !== 46/*.*/;\r\n}\r\n\r\nfunction keywordStart (pos) {\r\n  return pos === 0 || isBrOrWsOrPunctuatorNotDot(source.charCodeAt(pos - 1));\r\n}\r\n\r\nfunction readPrecedingKeyword (pos, match) {\r\n  if (pos < match.length - 1)\r\n    return false;\r\n  return source.startsWith(match, pos - match.length + 1) && (pos === 0 || isBrOrWsOrPunctuatorNotDot(source.charCodeAt(pos - match.length)));\r\n}\r\n\r\nfunction readPrecedingKeyword1 (pos, ch) {\r\n  return source.charCodeAt(pos) === ch && (pos === 0 || isBrOrWsOrPunctuatorNotDot(source.charCodeAt(pos - 1)));\r\n}\r\n\r\n// Detects one of case, debugger, delete, do, else, in, instanceof, new,\r\n//   return, throw, typeof, void, yield, await\r\nfunction isExpressionKeyword (pos) {\r\n  switch (source.charCodeAt(pos)) {\r\n    case 100/*d*/:\r\n      switch (source.charCodeAt(pos - 1)) {\r\n        case 105/*i*/:\r\n          // void\r\n          return readPrecedingKeyword(pos - 2, 'vo');\r\n        case 108/*l*/:\r\n          // yield\r\n          return readPrecedingKeyword(pos - 2, 'yie');\r\n        default:\r\n          return false;\r\n      }\r\n    case 101/*e*/:\r\n      switch (source.charCodeAt(pos - 1)) {\r\n        case 115/*s*/:\r\n          switch (source.charCodeAt(pos - 2)) {\r\n            case 108/*l*/:\r\n              // else\r\n              return readPrecedingKeyword1(pos - 3, 101/*e*/);\r\n            case 97/*a*/:\r\n              // case\r\n              return readPrecedingKeyword1(pos - 3, 99/*c*/);\r\n            default:\r\n              return false;\r\n          }\r\n        case 116/*t*/:\r\n          // delete\r\n          return readPrecedingKeyword(pos - 2, 'dele');\r\n        default:\r\n          return false;\r\n      }\r\n    case 102/*f*/:\r\n      if (source.charCodeAt(pos - 1) !== 111/*o*/ || source.charCodeAt(pos - 2) !== 101/*e*/)\r\n        return false;\r\n      switch (source.charCodeAt(pos - 3)) {\r\n        case 99/*c*/:\r\n          // instanceof\r\n          return readPrecedingKeyword(pos - 4, 'instan');\r\n        case 112/*p*/:\r\n          // typeof\r\n          return readPrecedingKeyword(pos - 4, 'ty');\r\n        default:\r\n          return false;\r\n      }\r\n    case 110/*n*/:\r\n      // in, return\r\n      return readPrecedingKeyword1(pos - 1, 105/*i*/) || readPrecedingKeyword(pos - 1, 'retur');\r\n    case 111/*o*/:\r\n      // do\r\n      return readPrecedingKeyword1(pos - 1, 100/*d*/);\r\n    case 114/*r*/:\r\n      // debugger\r\n      return readPrecedingKeyword(pos - 1, 'debugge');\r\n    case 116/*t*/:\r\n      // await\r\n      return readPrecedingKeyword(pos - 1, 'awai');\r\n    case 119/*w*/:\r\n      switch (source.charCodeAt(pos - 1)) {\r\n        case 101/*e*/:\r\n          // new\r\n          return readPrecedingKeyword1(pos - 2, 110/*n*/);\r\n        case 111/*o*/:\r\n          // throw\r\n          return readPrecedingKeyword(pos - 2, 'thr');\r\n        default:\r\n          return false;\r\n      }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction isParenKeyword (curPos) {\r\n  return source.charCodeAt(curPos) === 101/*e*/ && source.startsWith('whil', curPos - 4) ||\r\n      source.charCodeAt(curPos) === 114/*r*/ && source.startsWith('fo', curPos - 2) ||\r\n      source.charCodeAt(curPos - 1) === 105/*i*/ && source.charCodeAt(curPos) === 102/*f*/;\r\n}\r\n\r\nfunction isPunctuator (ch) {\r\n  // 23 possible punctuator endings: !%&()*+,-./:;<=>?[]^{}|~\r\n  return ch === 33/*!*/ || ch === 37/*%*/ || ch === 38/*&*/ ||\r\n    ch > 39 && ch < 48 || ch > 57 && ch < 64 ||\r\n    ch === 91/*[*/ || ch === 93/*]*/ || ch === 94/*^*/ ||\r\n    ch > 122 && ch < 127;\r\n}\r\n\r\nfunction isExpressionPunctuator (ch) {\r\n  // 20 possible expression endings: !%&(*+,-.:;<=>?[^{|~\r\n  return ch === 33/*!*/ || ch === 37/*%*/ || ch === 38/*&*/ ||\r\n    ch > 39 && ch < 47 && ch !== 41 || ch > 57 && ch < 64 ||\r\n    ch === 91/*[*/ || ch === 94/*^*/ || ch > 122 && ch < 127 && ch !== 125/*}*/;\r\n}\r\n\r\nfunction isExpressionTerminator (curPos) {\r\n  // detects:\r\n  // => ; ) finally catch else\r\n  // as all of these followed by a { will indicate a statement brace\r\n  switch (source.charCodeAt(curPos)) {\r\n    case 62/*>*/:\r\n      return source.charCodeAt(curPos - 1) === 61/*=*/;\r\n    case 59/*;*/:\r\n    case 41/*)*/:\r\n      return true;\r\n    case 104/*h*/:\r\n      return source.startsWith('catc', curPos - 4);\r\n    case 121/*y*/:\r\n      return source.startsWith('finall', curPos - 6);\r\n    case 101/*e*/:\r\n      return source.startsWith('els', curPos - 3);\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction syntaxError () {\r\n  throw Object.assign(new Error(`Parse error ${name}:${source.slice(0, pos).split('\\n').length}:${pos - source.lastIndexOf('\\n', pos - 1)}`), { idx: pos });\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}