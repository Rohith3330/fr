{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBaseClassMemberOfClassElement = exports.getIteratorYieldResultFromIteratorResult = exports.getInstanceTypeOfClassLikeDeclaration = exports.getConstructorTypeOfClassLikeDeclaration = exports.getSymbolOfClassLikeDeclaration = exports.getPropertyNameFromType = exports.symbolHasReadonlyDeclaration = exports.isPropertyReadonlyInType = exports.getWellKnownSymbolPropertyOfType = exports.getPropertyOfType = exports.isBooleanLiteralType = exports.isFalsyType = exports.isThenableType = exports.someTypePart = exports.intersectionTypeParts = exports.unionTypeParts = exports.getCallSignaturesOfType = exports.isTypeAssignableToString = exports.isTypeAssignableToNumber = exports.isOptionalChainingUndefinedMarkerType = exports.removeOptionalChainingUndefinedMarkerType = exports.removeOptionalityFromType = exports.isEmptyObjectType = void 0;\n\nconst ts = require(\"typescript\");\n\nconst type_1 = require(\"../typeguard/type\");\n\nconst util_1 = require(\"./util\");\n\nconst node_1 = require(\"../typeguard/node\");\n\nfunction isEmptyObjectType(type) {\n  if (type_1.isObjectType(type) && type.objectFlags & ts.ObjectFlags.Anonymous && type.getProperties().length === 0 && type.getCallSignatures().length === 0 && type.getConstructSignatures().length === 0 && type.getStringIndexType() === undefined && type.getNumberIndexType() === undefined) {\n    const baseTypes = type.getBaseTypes();\n    return baseTypes === undefined || baseTypes.every(isEmptyObjectType);\n  }\n\n  return false;\n}\n\nexports.isEmptyObjectType = isEmptyObjectType;\n\nfunction removeOptionalityFromType(checker, type) {\n  if (!containsTypeWithFlag(type, ts.TypeFlags.Undefined)) return type;\n  const allowsNull = containsTypeWithFlag(type, ts.TypeFlags.Null);\n  type = checker.getNonNullableType(type);\n  return allowsNull ? checker.getNullableType(type, ts.TypeFlags.Null) : type;\n}\n\nexports.removeOptionalityFromType = removeOptionalityFromType;\n\nfunction containsTypeWithFlag(type, flag) {\n  for (const t of unionTypeParts(type)) if (util_1.isTypeFlagSet(t, flag)) return true;\n\n  return false;\n}\n\nfunction removeOptionalChainingUndefinedMarkerType(checker, type) {\n  if (!type_1.isUnionType(type)) return isOptionalChainingUndefinedMarkerType(checker, type) ? type.getNonNullableType() : type;\n  let flags = 0;\n  let containsUndefinedMarker = false;\n\n  for (const t of type.types) {\n    if (isOptionalChainingUndefinedMarkerType(checker, t)) {\n      containsUndefinedMarker = true;\n    } else {\n      flags |= t.flags;\n    }\n  }\n\n  return containsUndefinedMarker ? checker.getNullableType(type.getNonNullableType(), flags) : type;\n}\n\nexports.removeOptionalChainingUndefinedMarkerType = removeOptionalChainingUndefinedMarkerType;\n\nfunction isOptionalChainingUndefinedMarkerType(checker, t) {\n  return util_1.isTypeFlagSet(t, ts.TypeFlags.Undefined) && checker.getNullableType(t.getNonNullableType(), ts.TypeFlags.Undefined) !== t;\n}\n\nexports.isOptionalChainingUndefinedMarkerType = isOptionalChainingUndefinedMarkerType;\n\nfunction isTypeAssignableToNumber(checker, type) {\n  return isTypeAssignableTo(checker, type, ts.TypeFlags.NumberLike);\n}\n\nexports.isTypeAssignableToNumber = isTypeAssignableToNumber;\n\nfunction isTypeAssignableToString(checker, type) {\n  return isTypeAssignableTo(checker, type, ts.TypeFlags.StringLike);\n}\n\nexports.isTypeAssignableToString = isTypeAssignableToString;\n\nfunction isTypeAssignableTo(checker, type, flags) {\n  flags |= ts.TypeFlags.Any;\n  let typeParametersSeen;\n  return function check(t) {\n    if (type_1.isTypeParameter(t) && t.symbol !== undefined && t.symbol.declarations !== undefined) {\n      if (typeParametersSeen === undefined) {\n        typeParametersSeen = new Set([t]);\n      } else if (!typeParametersSeen.has(t)) {\n        typeParametersSeen.add(t);\n      } else {\n        return false;\n      }\n\n      const declaration = t.symbol.declarations[0];\n      if (declaration.constraint === undefined) return true; // TODO really?\n\n      return check(checker.getTypeFromTypeNode(declaration.constraint));\n    }\n\n    if (type_1.isUnionType(t)) return t.types.every(check);\n    if (type_1.isIntersectionType(t)) return t.types.some(check);\n    return util_1.isTypeFlagSet(t, flags);\n  }(type);\n}\n\nfunction getCallSignaturesOfType(type) {\n  if (type_1.isUnionType(type)) {\n    const signatures = [];\n\n    for (const t of type.types) signatures.push(...getCallSignaturesOfType(t));\n\n    return signatures;\n  }\n\n  if (type_1.isIntersectionType(type)) {\n    let signatures;\n\n    for (const t of type.types) {\n      const sig = getCallSignaturesOfType(t);\n\n      if (sig.length !== 0) {\n        if (signatures !== undefined) return []; // if more than one type of the intersection has call signatures, none of them is useful for inference\n\n        signatures = sig;\n      }\n    }\n\n    return signatures === undefined ? [] : signatures;\n  }\n\n  return type.getCallSignatures();\n}\n\nexports.getCallSignaturesOfType = getCallSignaturesOfType;\n/** Returns all types of a union type or an array containing `type` itself if it's no union type. */\n\nfunction unionTypeParts(type) {\n  return type_1.isUnionType(type) ? type.types : [type];\n}\n\nexports.unionTypeParts = unionTypeParts;\n/** Returns all types of a intersection type or an array containing `type` itself if it's no intersection type. */\n\nfunction intersectionTypeParts(type) {\n  return type_1.isIntersectionType(type) ? type.types : [type];\n}\n\nexports.intersectionTypeParts = intersectionTypeParts;\n\nfunction someTypePart(type, predicate, cb) {\n  return predicate(type) ? type.types.some(cb) : cb(type);\n}\n\nexports.someTypePart = someTypePart;\n\nfunction isThenableType(checker, node) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : checker.getTypeAtLocation(node);\n\n  for (const ty of unionTypeParts(checker.getApparentType(type))) {\n    const then = ty.getProperty('then');\n    if (then === undefined) continue;\n    const thenType = checker.getTypeOfSymbolAtLocation(then, node);\n\n    for (const t of unionTypeParts(thenType)) for (const signature of t.getCallSignatures()) if (signature.parameters.length !== 0 && isCallback(checker, signature.parameters[0], node)) return true;\n  }\n\n  return false;\n}\n\nexports.isThenableType = isThenableType;\n\nfunction isCallback(checker, param, node) {\n  let type = checker.getApparentType(checker.getTypeOfSymbolAtLocation(param, node));\n\n  if (param.valueDeclaration.dotDotDotToken) {\n    // unwrap array type of rest parameter\n    type = type.getNumberIndexType();\n    if (type === undefined) return false;\n  }\n\n  for (const t of unionTypeParts(type)) if (t.getCallSignatures().length !== 0) return true;\n\n  return false;\n}\n/** Determine if a type is definitely falsy. This function doesn't unwrap union types. */\n\n\nfunction isFalsyType(type) {\n  if (type.flags & (ts.TypeFlags.Undefined | ts.TypeFlags.Null | ts.TypeFlags.Void)) return true;\n  if (type_1.isLiteralType(type)) return !type.value;\n  return isBooleanLiteralType(type, false);\n}\n\nexports.isFalsyType = isFalsyType;\n/** Determines whether the given type is a boolean literal type and matches the given boolean literal (true or false). */\n\nfunction isBooleanLiteralType(type, literal) {\n  return util_1.isTypeFlagSet(type, ts.TypeFlags.BooleanLiteral) && type.intrinsicName === (literal ? 'true' : 'false');\n}\n\nexports.isBooleanLiteralType = isBooleanLiteralType;\n\nfunction getPropertyOfType(type, name) {\n  if (!name.startsWith('__')) return type.getProperty(name);\n  return type.getProperties().find(s => s.escapedName === name);\n}\n\nexports.getPropertyOfType = getPropertyOfType;\n\nfunction getWellKnownSymbolPropertyOfType(type, wellKnownSymbolName, checker) {\n  const prefix = '__@' + wellKnownSymbolName;\n\n  for (const prop of type.getProperties()) {\n    if (!prop.name.startsWith(prefix)) continue;\n    const globalSymbol = checker.getApparentType(checker.getTypeAtLocation(prop.valueDeclaration.name.expression)).symbol;\n    if (prop.escapedName === getPropertyNameOfWellKnownSymbol(checker, globalSymbol, wellKnownSymbolName)) return prop;\n  }\n\n  return;\n}\n\nexports.getWellKnownSymbolPropertyOfType = getWellKnownSymbolPropertyOfType;\n\nfunction getPropertyNameOfWellKnownSymbol(checker, symbolConstructor, symbolName) {\n  const knownSymbol = symbolConstructor && checker.getTypeOfSymbolAtLocation(symbolConstructor, symbolConstructor.valueDeclaration).getProperty(symbolName);\n  const knownSymbolType = knownSymbol && checker.getTypeOfSymbolAtLocation(knownSymbol, knownSymbol.valueDeclaration);\n  if (knownSymbolType && type_1.isUniqueESSymbolType(knownSymbolType)) return knownSymbolType.escapedName;\n  return '__@' + symbolName;\n}\n/** Determines if writing to a certain property of a given type is allowed. */\n\n\nfunction isPropertyReadonlyInType(type, name, checker) {\n  let seenProperty = false;\n  let seenReadonlySignature = false;\n\n  for (const t of unionTypeParts(type)) {\n    if (getPropertyOfType(t, name) === undefined) {\n      // property is not present in this part of the union -> check for readonly index signature\n      const index = (util_1.isNumericPropertyName(name) ? checker.getIndexInfoOfType(t, ts.IndexKind.Number) : undefined) || checker.getIndexInfoOfType(t, ts.IndexKind.String);\n\n      if (index !== undefined && index.isReadonly) {\n        if (seenProperty) return true;\n        seenReadonlySignature = true;\n      }\n    } else if (seenReadonlySignature || isReadonlyPropertyIntersection(t, name, checker)) {\n      return true;\n    } else {\n      seenProperty = true;\n    }\n  }\n\n  return false;\n}\n\nexports.isPropertyReadonlyInType = isPropertyReadonlyInType;\n\nfunction isReadonlyPropertyIntersection(type, name, checker) {\n  return someTypePart(type, type_1.isIntersectionType, t => {\n    const prop = getPropertyOfType(t, name);\n    if (prop === undefined) return false;\n\n    if (prop.flags & ts.SymbolFlags.Transient) {\n      if (/^(?:[1-9]\\d*|0)$/.test(name) && type_1.isTupleTypeReference(t)) return t.target.readonly;\n\n      switch (isReadonlyPropertyFromMappedType(t, name, checker)) {\n        case true:\n          return true;\n\n        case false:\n          return false;\n\n        default: // `undefined` falls through\n\n      }\n    }\n\n    return (// members of namespace import\n      util_1.isSymbolFlagSet(prop, ts.SymbolFlags.ValueModule) || // we unwrapped every mapped type, now we can check the actual declarations\n      symbolHasReadonlyDeclaration(prop, checker)\n    );\n  });\n}\n\nfunction isReadonlyPropertyFromMappedType(type, name, checker) {\n  if (!type_1.isObjectType(type) || !util_1.isObjectFlagSet(type, ts.ObjectFlags.Mapped)) return;\n  const declaration = type.symbol.declarations[0]; // well-known symbols are not affected by mapped types\n\n  if (declaration.readonlyToken !== undefined && !/^__@[^@]+$/.test(name)) return declaration.readonlyToken.kind !== ts.SyntaxKind.MinusToken;\n  return isPropertyReadonlyInType(type.modifiersType, name, checker);\n}\n\nfunction symbolHasReadonlyDeclaration(symbol, checker) {\n  return (symbol.flags & ts.SymbolFlags.Accessor) === ts.SymbolFlags.GetAccessor || symbol.declarations !== undefined && symbol.declarations.some(node => util_1.isModifierFlagSet(node, ts.ModifierFlags.Readonly) || node_1.isVariableDeclaration(node) && util_1.isNodeFlagSet(node.parent, ts.NodeFlags.Const) || node_1.isCallExpression(node) && util_1.isReadonlyAssignmentDeclaration(node, checker) || node_1.isEnumMember(node) || (node_1.isPropertyAssignment(node) || node_1.isShorthandPropertyAssignment(node)) && util_1.isInConstContext(node.parent));\n}\n\nexports.symbolHasReadonlyDeclaration = symbolHasReadonlyDeclaration;\n/** Returns the the literal name or unique symbol name from a given type. Doesn't unwrap union types. */\n\nfunction getPropertyNameFromType(type) {\n  // string or number literal. bigint is intentionally excluded\n  if (type.flags & (ts.TypeFlags.StringLiteral | ts.TypeFlags.NumberLiteral)) {\n    const value = String(type.value);\n    return {\n      displayName: value,\n      symbolName: ts.escapeLeadingUnderscores(value)\n    };\n  }\n\n  if (type_1.isUniqueESSymbolType(type)) return {\n    displayName: `[${type.symbol ? `${isKnownSymbol(type.symbol) ? 'Symbol.' : ''}${type.symbol.name}` : type.escapedName.replace(/^__@|@\\d+$/g, '')}]`,\n    symbolName: type.escapedName\n  };\n}\n\nexports.getPropertyNameFromType = getPropertyNameFromType;\n\nfunction isKnownSymbol(symbol) {\n  return util_1.isSymbolFlagSet(symbol, ts.SymbolFlags.Property) && symbol.valueDeclaration !== undefined && node_1.isInterfaceDeclaration(symbol.valueDeclaration.parent) && symbol.valueDeclaration.parent.name.text === 'SymbolConstructor' && isGlobalDeclaration(symbol.valueDeclaration.parent);\n}\n\nfunction isGlobalDeclaration(node) {\n  return util_1.isNodeFlagSet(node.parent, ts.NodeFlags.GlobalAugmentation) || node_1.isSourceFile(node.parent) && !ts.isExternalModule(node.parent);\n}\n\nfunction getSymbolOfClassLikeDeclaration(node, checker) {\n  var _a;\n\n  return checker.getSymbolAtLocation((_a = node.name) !== null && _a !== void 0 ? _a : util_1.getChildOfKind(node, ts.SyntaxKind.ClassKeyword));\n}\n\nexports.getSymbolOfClassLikeDeclaration = getSymbolOfClassLikeDeclaration;\n\nfunction getConstructorTypeOfClassLikeDeclaration(node, checker) {\n  return node.kind === ts.SyntaxKind.ClassExpression ? checker.getTypeAtLocation(node) : checker.getTypeOfSymbolAtLocation(getSymbolOfClassLikeDeclaration(node, checker), node);\n}\n\nexports.getConstructorTypeOfClassLikeDeclaration = getConstructorTypeOfClassLikeDeclaration;\n\nfunction getInstanceTypeOfClassLikeDeclaration(node, checker) {\n  return node.kind === ts.SyntaxKind.ClassDeclaration ? checker.getTypeAtLocation(node) : checker.getDeclaredTypeOfSymbol(getSymbolOfClassLikeDeclaration(node, checker));\n}\n\nexports.getInstanceTypeOfClassLikeDeclaration = getInstanceTypeOfClassLikeDeclaration;\n\nfunction getIteratorYieldResultFromIteratorResult(type, node, checker) {\n  return type_1.isUnionType(type) && type.types.find(t => {\n    const done = t.getProperty('done');\n    return done !== undefined && isBooleanLiteralType(removeOptionalityFromType(checker, checker.getTypeOfSymbolAtLocation(done, node)), false);\n  }) || type;\n}\n\nexports.getIteratorYieldResultFromIteratorResult = getIteratorYieldResultFromIteratorResult;\n/** Lookup the declaration of a class member in the super class. */\n\nfunction getBaseClassMemberOfClassElement(node, checker) {\n  if (!node_1.isClassLikeDeclaration(node.parent)) return;\n  const base = util_1.getBaseOfClassLikeExpression(node.parent);\n  if (base === undefined) return;\n  const name = util_1.getSingleLateBoundPropertyNameOfPropertyName(node.name, checker);\n  if (name === undefined) return;\n  const baseType = checker.getTypeAtLocation(util_1.hasModifier(node.modifiers, ts.SyntaxKind.StaticKeyword) ? base.expression : base);\n  return getPropertyOfType(baseType, name.symbolName);\n}\n\nexports.getBaseClassMemberOfClassElement = getBaseClassMemberOfClassElement;","map":{"version":3,"mappings":"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","names":["isEmptyObjectType","type","type_1","objectFlags","ts","ObjectFlags","Anonymous","getProperties","length","getCallSignatures","getConstructSignatures","getStringIndexType","undefined","getNumberIndexType","baseTypes","getBaseTypes","every","exports","removeOptionalityFromType","checker","containsTypeWithFlag","TypeFlags","Undefined","allowsNull","Null","getNonNullableType","getNullableType","flag","t","unionTypeParts","util_1","removeOptionalChainingUndefinedMarkerType","isOptionalChainingUndefinedMarkerType","flags","containsUndefinedMarker","types","isTypeAssignableToNumber","isTypeAssignableTo","NumberLike","isTypeAssignableToString","StringLike","Any","typeParametersSeen","check","symbol","declarations","Set","has","add","declaration","constraint","getTypeFromTypeNode","some","getCallSignaturesOfType","signatures","push","sig","intersectionTypeParts","someTypePart","predicate","cb","isThenableType","node","getTypeAtLocation","ty","getApparentType","then","getProperty","thenType","getTypeOfSymbolAtLocation","signature","parameters","isCallback","param","valueDeclaration","dotDotDotToken","isFalsyType","Void","value","isBooleanLiteralType","literal","BooleanLiteral","intrinsicName","getPropertyOfType","name","startsWith","find","s","escapedName","getWellKnownSymbolPropertyOfType","wellKnownSymbolName","prefix","prop","globalSymbol","expression","getPropertyNameOfWellKnownSymbol","symbolConstructor","symbolName","knownSymbol","knownSymbolType","isPropertyReadonlyInType","seenProperty","seenReadonlySignature","index","getIndexInfoOfType","IndexKind","Number","String","isReadonly","isReadonlyPropertyIntersection","SymbolFlags","Transient","test","target","readonly","isReadonlyPropertyFromMappedType","ValueModule","symbolHasReadonlyDeclaration","Mapped","readonlyToken","kind","SyntaxKind","MinusToken","modifiersType","Accessor","GetAccessor","ModifierFlags","Readonly","node_1","parent","NodeFlags","Const","getPropertyNameFromType","StringLiteral","NumberLiteral","displayName","escapeLeadingUnderscores","isKnownSymbol","replace","Property","text","isGlobalDeclaration","GlobalAugmentation","isExternalModule","getSymbolOfClassLikeDeclaration","getSymbolAtLocation","_a","ClassKeyword","getConstructorTypeOfClassLikeDeclaration","ClassExpression","getInstanceTypeOfClassLikeDeclaration","ClassDeclaration","getDeclaredTypeOfSymbol","getIteratorYieldResultFromIteratorResult","done","getBaseClassMemberOfClassElement","base","baseType","modifiers","StaticKeyword"],"sources":["type.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}