{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createEmptySection = createEmptySection;\n\nvar _wasmGen = require(\"@webassemblyjs/wasm-gen\");\n\nvar _helperBuffer = require(\"@webassemblyjs/helper-buffer\");\n\nvar _helperWasmBytecode = _interopRequireDefault(require(\"@webassemblyjs/helper-wasm-bytecode\"));\n\nvar t = _interopRequireWildcard(require(\"@webassemblyjs/ast\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction findLastSection(ast, forSection) {\n  var targetSectionId = _helperWasmBytecode.default.sections[forSection]; // $FlowIgnore: metadata can not be empty\n\n  var moduleSections = ast.body[0].metadata.sections;\n  var lastSection;\n  var lastId = 0;\n\n  for (var i = 0, len = moduleSections.length; i < len; i++) {\n    var section = moduleSections[i]; // Ignore custom section since they can actually occur everywhere\n\n    if (section.section === \"custom\") {\n      continue;\n    }\n\n    var sectionId = _helperWasmBytecode.default.sections[section.section];\n\n    if (targetSectionId > lastId && targetSectionId < sectionId) {\n      return lastSection;\n    }\n\n    lastId = sectionId;\n    lastSection = section;\n  }\n\n  return lastSection;\n}\n\nfunction createEmptySection(ast, uint8Buffer, section) {\n  // previous section after which we are going to insert our section\n  var lastSection = findLastSection(ast, section);\n  var start, end;\n  /**\n   * It's the first section\n   */\n\n  if (lastSection == null || lastSection.section === \"custom\") {\n    start = 8\n    /* wasm header size */\n    ;\n    end = start;\n  } else {\n    start = lastSection.startOffset + lastSection.size.value + 1;\n    end = start;\n  } // section id\n\n\n  start += 1;\n  var sizeStartLoc = {\n    line: -1,\n    column: start\n  };\n  var sizeEndLoc = {\n    line: -1,\n    column: start + 1\n  }; // 1 byte for the empty vector\n\n  var size = t.withLoc(t.numberLiteralFromRaw(1), sizeEndLoc, sizeStartLoc);\n  var vectorOfSizeStartLoc = {\n    line: -1,\n    column: sizeEndLoc.column\n  };\n  var vectorOfSizeEndLoc = {\n    line: -1,\n    column: sizeEndLoc.column + 1\n  };\n  var vectorOfSize = t.withLoc(t.numberLiteralFromRaw(0), vectorOfSizeEndLoc, vectorOfSizeStartLoc);\n  var sectionMetadata = t.sectionMetadata(section, start, size, vectorOfSize);\n  var sectionBytes = (0, _wasmGen.encodeNode)(sectionMetadata);\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, start - 1, end, sectionBytes); // Add section into the AST for later lookups\n\n  if (_typeof(ast.body[0].metadata) === \"object\") {\n    // $FlowIgnore: metadata can not be empty\n    ast.body[0].metadata.sections.push(sectionMetadata);\n    t.sortSectionMetadata(ast.body[0]);\n  }\n  /**\n   * Update AST\n   */\n  // Once we hit our section every that is after needs to be shifted by the delta\n\n\n  var deltaBytes = +sectionBytes.length;\n  var encounteredSection = false;\n  t.traverse(ast, {\n    SectionMetadata: function SectionMetadata(path) {\n      if (path.node.section === section) {\n        encounteredSection = true;\n        return;\n      }\n\n      if (encounteredSection === true) {\n        t.shiftSection(ast, path.node, deltaBytes);\n      }\n    }\n  });\n  return {\n    uint8Buffer: uint8Buffer,\n    sectionMetadata: sectionMetadata\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","createEmptySection","_wasmGen","require","_helperBuffer","_helperWasmBytecode","_interopRequireDefault","t","_interopRequireWildcard","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","get","set","default","_typeof","Symbol","iterator","constructor","findLastSection","ast","forSection","targetSectionId","sections","moduleSections","body","metadata","lastSection","lastId","i","len","length","section","sectionId","uint8Buffer","start","end","startOffset","size","sizeStartLoc","line","column","sizeEndLoc","withLoc","numberLiteralFromRaw","vectorOfSizeStartLoc","vectorOfSizeEndLoc","vectorOfSize","sectionMetadata","sectionBytes","encodeNode","overrideBytesInBuffer","push","sortSectionMetadata","deltaBytes","encounteredSection","traverse","SectionMetadata","path","node","shiftSection"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@webassemblyjs/helper-wasm-section/lib/create.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createEmptySection = createEmptySection;\n\nvar _wasmGen = require(\"@webassemblyjs/wasm-gen\");\n\nvar _helperBuffer = require(\"@webassemblyjs/helper-buffer\");\n\nvar _helperWasmBytecode = _interopRequireDefault(require(\"@webassemblyjs/helper-wasm-bytecode\"));\n\nvar t = _interopRequireWildcard(require(\"@webassemblyjs/ast\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction findLastSection(ast, forSection) {\n  var targetSectionId = _helperWasmBytecode.default.sections[forSection]; // $FlowIgnore: metadata can not be empty\n\n  var moduleSections = ast.body[0].metadata.sections;\n  var lastSection;\n  var lastId = 0;\n\n  for (var i = 0, len = moduleSections.length; i < len; i++) {\n    var section = moduleSections[i]; // Ignore custom section since they can actually occur everywhere\n\n    if (section.section === \"custom\") {\n      continue;\n    }\n\n    var sectionId = _helperWasmBytecode.default.sections[section.section];\n\n    if (targetSectionId > lastId && targetSectionId < sectionId) {\n      return lastSection;\n    }\n\n    lastId = sectionId;\n    lastSection = section;\n  }\n\n  return lastSection;\n}\n\nfunction createEmptySection(ast, uint8Buffer, section) {\n  // previous section after which we are going to insert our section\n  var lastSection = findLastSection(ast, section);\n  var start, end;\n  /**\n   * It's the first section\n   */\n\n  if (lastSection == null || lastSection.section === \"custom\") {\n    start = 8\n    /* wasm header size */\n    ;\n    end = start;\n  } else {\n    start = lastSection.startOffset + lastSection.size.value + 1;\n    end = start;\n  } // section id\n\n\n  start += 1;\n  var sizeStartLoc = {\n    line: -1,\n    column: start\n  };\n  var sizeEndLoc = {\n    line: -1,\n    column: start + 1\n  }; // 1 byte for the empty vector\n\n  var size = t.withLoc(t.numberLiteralFromRaw(1), sizeEndLoc, sizeStartLoc);\n  var vectorOfSizeStartLoc = {\n    line: -1,\n    column: sizeEndLoc.column\n  };\n  var vectorOfSizeEndLoc = {\n    line: -1,\n    column: sizeEndLoc.column + 1\n  };\n  var vectorOfSize = t.withLoc(t.numberLiteralFromRaw(0), vectorOfSizeEndLoc, vectorOfSizeStartLoc);\n  var sectionMetadata = t.sectionMetadata(section, start, size, vectorOfSize);\n  var sectionBytes = (0, _wasmGen.encodeNode)(sectionMetadata);\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, start - 1, end, sectionBytes); // Add section into the AST for later lookups\n\n  if (_typeof(ast.body[0].metadata) === \"object\") {\n    // $FlowIgnore: metadata can not be empty\n    ast.body[0].metadata.sections.push(sectionMetadata);\n    t.sortSectionMetadata(ast.body[0]);\n  }\n  /**\n   * Update AST\n   */\n  // Once we hit our section every that is after needs to be shifted by the delta\n\n\n  var deltaBytes = +sectionBytes.length;\n  var encounteredSection = false;\n  t.traverse(ast, {\n    SectionMetadata: function SectionMetadata(path) {\n      if (path.node.section === section) {\n        encounteredSection = true;\n        return;\n      }\n\n      if (encounteredSection === true) {\n        t.shiftSection(ast, path.node, deltaBytes);\n      }\n    }\n  });\n  return {\n    uint8Buffer: uint8Buffer,\n    sectionMetadata: sectionMetadata\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}