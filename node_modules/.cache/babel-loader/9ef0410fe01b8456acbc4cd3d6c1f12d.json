{"ast":null,"code":"const extractValueFromThisExpression = require('./ThisExpression').default;\n\nfunction navigate(obj, prop, value) {\n  if (value.computed) {\n    return value.optional ? `${obj}?.[${prop}]` : `${obj}[${prop}]`;\n  }\n\n  return value.optional ? `${obj}?.${prop}` : `${obj}.${prop}`;\n}\n/**\n * Extractor function for a TSNonNullExpression type value node.\n * A TSNonNullExpression is accessing a TypeScript Non-Null Assertion\n * Operator !\n *\n * @param - value - AST Value object with type `TSNonNullExpression`\n * @returns - The extracted value converted to correct type\n *  and maintaing `obj.property` convention.\n */\n\n\nexport default function extractValueFromTSNonNullExpression(value) {\n  // eslint-disable-next-line global-require\n  // const getValue = require('.').default;\n  const errorMessage = 'The prop value with an expression type of TSNonNullExpression could not be resolved. Please file an issue ( https://github.com/jsx-eslint/jsx-ast-utils/issues/new ) to get this fixed immediately.'; // it's just the name\n\n  if (value.type === 'Identifier') {\n    const {\n      name\n    } = value;\n    return name;\n  }\n\n  if (value.type === 'Literal') {\n    return value.value;\n  }\n\n  if (value.type === 'TSAsExpression') {\n    return extractValueFromTSNonNullExpression(value.expression);\n  }\n\n  if (value.type === 'ThisExpression') {\n    return extractValueFromThisExpression();\n  } // does not contains properties & is not parenthesized\n\n\n  if (value.type === 'TSNonNullExpression' && (!value.extra || value.extra.parenthesized === false)) {\n    const {\n      expression\n    } = value;\n    return `${extractValueFromTSNonNullExpression(expression)}${'!'}`;\n  } // does not contains properties & is parenthesized\n\n\n  if (value.type === 'TSNonNullExpression' && value.extra && value.extra.parenthesized === true) {\n    const {\n      expression\n    } = value;\n    return `${'('}${extractValueFromTSNonNullExpression(expression)}${'!'}${')'}`;\n  }\n\n  if (value.type === 'MemberExpression') {\n    // contains a property & is not parenthesized\n    if (!value.extra || value.extra.parenthesized === false) {\n      return navigate(extractValueFromTSNonNullExpression(value.object), extractValueFromTSNonNullExpression(value.property), value);\n    } // contains a property & is parenthesized\n\n\n    if (value.extra && value.extra.parenthesized === true) {\n      const result = navigate(extractValueFromTSNonNullExpression(value.object), extractValueFromTSNonNullExpression(value.property), value);\n      return `(${result})`;\n    }\n  } // try to fail silently, if specs for TSNonNullExpression change\n  // not throw, only log error. Similar to how it was done previously\n\n\n  if (value.expression) {\n    let {\n      expression\n    } = value;\n\n    while (expression) {\n      if (expression.type === 'Identifier') {\n        // eslint-disable-next-line no-console\n        console.error(errorMessage);\n        return expression.name;\n      }\n\n      ({\n        expression\n      } = expression);\n    }\n  } // eslint-disable-next-line no-console\n\n\n  console.error(errorMessage);\n  return '';\n}","map":{"version":3,"names":["extractValueFromThisExpression","require","default","navigate","obj","prop","value","computed","optional","extractValueFromTSNonNullExpression","errorMessage","type","name","expression","extra","parenthesized","object","property","result","console","error"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jsx-ast-utils/src/values/expressions/TSNonNullExpression.js"],"sourcesContent":["const extractValueFromThisExpression = require('./ThisExpression').default;\n\nfunction navigate(obj, prop, value) {\n  if (value.computed) {\n    return value.optional ? `${obj}?.[${prop}]` : `${obj}[${prop}]`;\n  }\n  return value.optional ? `${obj}?.${prop}` : `${obj}.${prop}`;\n}\n\n/**\n * Extractor function for a TSNonNullExpression type value node.\n * A TSNonNullExpression is accessing a TypeScript Non-Null Assertion\n * Operator !\n *\n * @param - value - AST Value object with type `TSNonNullExpression`\n * @returns - The extracted value converted to correct type\n *  and maintaing `obj.property` convention.\n */\nexport default function extractValueFromTSNonNullExpression(value) {\n  // eslint-disable-next-line global-require\n  // const getValue = require('.').default;\n  const errorMessage = 'The prop value with an expression type of TSNonNullExpression could not be resolved. Please file an issue ( https://github.com/jsx-eslint/jsx-ast-utils/issues/new ) to get this fixed immediately.';\n\n  // it's just the name\n  if (value.type === 'Identifier') {\n    const { name } = value;\n    return name;\n  }\n\n  if (value.type === 'Literal') {\n    return value.value;\n  }\n\n  if (value.type === 'TSAsExpression') {\n    return extractValueFromTSNonNullExpression(value.expression);\n  }\n\n  if (value.type === 'ThisExpression') {\n    return extractValueFromThisExpression();\n  }\n\n  // does not contains properties & is not parenthesized\n  if (value.type === 'TSNonNullExpression' && (!value.extra || value.extra.parenthesized === false)) {\n    const { expression } = value;\n    return `${extractValueFromTSNonNullExpression(expression)}${'!'}`;\n  }\n\n  // does not contains properties & is parenthesized\n  if (value.type === 'TSNonNullExpression' && value.extra && value.extra.parenthesized === true) {\n    const { expression } = value;\n    return `${'('}${extractValueFromTSNonNullExpression(expression)}${'!'}${')'}`;\n  }\n\n  if (value.type === 'MemberExpression') {\n    // contains a property & is not parenthesized\n    if ((!value.extra || value.extra.parenthesized === false)) {\n      return navigate(\n        extractValueFromTSNonNullExpression(value.object),\n        extractValueFromTSNonNullExpression(value.property),\n        value,\n      );\n    }\n\n    // contains a property & is parenthesized\n    if (value.extra && value.extra.parenthesized === true) {\n      const result = navigate(\n        extractValueFromTSNonNullExpression(value.object),\n        extractValueFromTSNonNullExpression(value.property),\n        value,\n      );\n      return `(${result})`;\n    }\n  }\n\n  // try to fail silently, if specs for TSNonNullExpression change\n  // not throw, only log error. Similar to how it was done previously\n  if (value.expression) {\n    let { expression } = value;\n    while (expression) {\n      if (expression.type === 'Identifier') {\n        // eslint-disable-next-line no-console\n        console.error(errorMessage);\n        return expression.name;\n      }\n      ({ expression } = expression);\n    }\n  }\n\n  // eslint-disable-next-line no-console\n  console.error(errorMessage);\n  return '';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}