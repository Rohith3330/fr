{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"@babel/core\");\n\nconst buildClassDecorator = _core.template.statement(`\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n`);\n\nconst buildClassPrototype = (0, _core.template)(`\n  CLASS_REF.prototype;\n`);\nconst buildGetDescriptor = (0, _core.template)(`\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n`);\nconst buildGetObjectInitializer = (0, _core.template)(`\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n`);\nconst WARNING_CALLS = new WeakSet();\n\nfunction applyEnsureOrdering(path) {\n  const decorators = (path.isClass() ? [path, ...path.get(\"body.body\")] : path.get(\"properties\")).reduce((acc, prop) => acc.concat(prop.node.decorators || []), []);\n  const identDecorators = decorators.filter(decorator => !_core.types.isIdentifier(decorator.expression));\n  if (identDecorators.length === 0) return;\n  return _core.types.sequenceExpression(identDecorators.map(decorator => {\n    const expression = decorator.expression;\n    const id = decorator.expression = path.scope.generateDeclaredUidIdentifier(\"dec\");\n    return _core.types.assignmentExpression(\"=\", id, expression);\n  }).concat([path.node]));\n}\n\nfunction applyClassDecorators(classPath) {\n  if (!hasClassDecorators(classPath.node)) return;\n  const decorators = classPath.node.decorators || [];\n  classPath.node.decorators = null;\n  const name = classPath.scope.generateDeclaredUidIdentifier(\"class\");\n  return decorators.map(dec => dec.expression).reverse().reduce(function (acc, decorator) {\n    return buildClassDecorator({\n      CLASS_REF: _core.types.cloneNode(name),\n      DECORATOR: _core.types.cloneNode(decorator),\n      INNER: acc\n    }).expression;\n  }, classPath.node);\n}\n\nfunction hasClassDecorators(classNode) {\n  return !!(classNode.decorators && classNode.decorators.length);\n}\n\nfunction applyMethodDecorators(path, state) {\n  if (!hasMethodDecorators(path.node.body.body)) return;\n  return applyTargetDecorators(path, state, path.node.body.body);\n}\n\nfunction hasMethodDecorators(body) {\n  return body.some(node => {\n    var _node$decorators;\n\n    return (_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length;\n  });\n}\n\nfunction applyObjectDecorators(path, state) {\n  if (!hasMethodDecorators(path.node.properties)) return;\n  return applyTargetDecorators(path, state, path.node.properties.filter(prop => prop.type !== \"SpreadElement\"));\n}\n\nfunction applyTargetDecorators(path, state, decoratedProps) {\n  const name = path.scope.generateDeclaredUidIdentifier(path.isClass() ? \"class\" : \"obj\");\n  const exprs = decoratedProps.reduce(function (acc, node) {\n    let decorators = [];\n\n    if (node.decorators != null) {\n      decorators = node.decorators;\n      node.decorators = null;\n    }\n\n    if (decorators.length === 0) return acc;\n\n    if (node.computed) {\n      throw path.buildCodeFrameError(\"Computed method/property decorators are not yet supported.\");\n    }\n\n    const property = _core.types.isLiteral(node.key) ? node.key : _core.types.stringLiteral(node.key.name);\n    const target = path.isClass() && !node.static ? buildClassPrototype({\n      CLASS_REF: name\n    }).expression : name;\n\n    if (_core.types.isClassProperty(node, {\n      static: false\n    })) {\n      const descriptor = path.scope.generateDeclaredUidIdentifier(\"descriptor\");\n      const initializer = node.value ? _core.types.functionExpression(null, [], _core.types.blockStatement([_core.types.returnStatement(node.value)])) : _core.types.nullLiteral();\n      node.value = _core.types.callExpression(state.addHelper(\"initializerWarningHelper\"), [descriptor, _core.types.thisExpression()]);\n      WARNING_CALLS.add(node.value);\n      acc.push(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(descriptor), _core.types.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map(dec => _core.types.cloneNode(dec.expression))), _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier(\"configurable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"enumerable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"writable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"initializer\"), initializer)])])));\n    } else {\n      acc.push(_core.types.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map(dec => _core.types.cloneNode(dec.expression))), _core.types.isObjectProperty(node) || _core.types.isClassProperty(node, {\n        static: true\n      }) ? buildGetObjectInitializer({\n        TEMP: path.scope.generateDeclaredUidIdentifier(\"init\"),\n        TARGET: _core.types.cloneNode(target),\n        PROPERTY: _core.types.cloneNode(property)\n      }).expression : buildGetDescriptor({\n        TARGET: _core.types.cloneNode(target),\n        PROPERTY: _core.types.cloneNode(property)\n      }).expression, _core.types.cloneNode(target)]));\n    }\n\n    return acc;\n  }, []);\n  return _core.types.sequenceExpression([_core.types.assignmentExpression(\"=\", _core.types.cloneNode(name), path.node), _core.types.sequenceExpression(exprs), _core.types.cloneNode(name)]);\n}\n\nfunction decoratedClassToExpression(_ref) {\n  let {\n    node,\n    scope\n  } = _ref;\n\n  if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {\n    return;\n  }\n\n  const ref = node.id ? _core.types.cloneNode(node.id) : scope.generateUidIdentifier(\"class\");\n  return _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(ref, _core.types.toExpression(node))]);\n}\n\nconst visitor = {\n  ExportDefaultDeclaration(path) {\n    const decl = path.get(\"declaration\");\n    if (!decl.isClassDeclaration()) return;\n    const replacement = decoratedClassToExpression(decl);\n\n    if (replacement) {\n      const [varDeclPath] = path.replaceWithMultiple([replacement, _core.types.exportNamedDeclaration(null, [_core.types.exportSpecifier(_core.types.cloneNode(replacement.declarations[0].id), _core.types.identifier(\"default\"))])]);\n\n      if (!decl.node.id) {\n        path.scope.registerDeclaration(varDeclPath);\n      }\n    }\n  },\n\n  ClassDeclaration(path) {\n    const replacement = decoratedClassToExpression(path);\n\n    if (replacement) {\n      path.replaceWith(replacement);\n    }\n  },\n\n  ClassExpression(path, state) {\n    const decoratedClass = applyEnsureOrdering(path) || applyClassDecorators(path) || applyMethodDecorators(path, state);\n    if (decoratedClass) path.replaceWith(decoratedClass);\n  },\n\n  ObjectExpression(path, state) {\n    const decoratedObject = applyEnsureOrdering(path) || applyObjectDecorators(path, state);\n    if (decoratedObject) path.replaceWith(decoratedObject);\n  },\n\n  AssignmentExpression(path, state) {\n    if (!WARNING_CALLS.has(path.node.right)) return;\n    path.replaceWith(_core.types.callExpression(state.addHelper(\"initializerDefineProperty\"), [_core.types.cloneNode(path.get(\"left.object\").node), _core.types.stringLiteral(path.get(\"left.property\").node.name || path.get(\"left.property\").node.value), _core.types.cloneNode(path.get(\"right.arguments\")[0].node), _core.types.cloneNode(path.get(\"right.arguments\")[1].node)]));\n  },\n\n  CallExpression(path, state) {\n    if (path.node.arguments.length !== 3) return;\n    if (!WARNING_CALLS.has(path.node.arguments[2])) return;\n\n    if (path.node.callee.name !== state.addHelper(\"defineProperty\").name) {\n      return;\n    }\n\n    path.replaceWith(_core.types.callExpression(state.addHelper(\"initializerDefineProperty\"), [_core.types.cloneNode(path.get(\"arguments\")[0].node), _core.types.cloneNode(path.get(\"arguments\")[1].node), _core.types.cloneNode(path.get(\"arguments.2.arguments\")[0].node), _core.types.cloneNode(path.get(\"arguments.2.arguments\")[1].node)]));\n  }\n\n};\nvar _default = visitor;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["buildClassDecorator","template","statement","buildClassPrototype","buildGetDescriptor","buildGetObjectInitializer","WARNING_CALLS","WeakSet","applyEnsureOrdering","path","decorators","isClass","get","reduce","acc","prop","concat","node","identDecorators","filter","decorator","t","isIdentifier","expression","length","sequenceExpression","map","id","scope","generateDeclaredUidIdentifier","assignmentExpression","applyClassDecorators","classPath","hasClassDecorators","name","dec","reverse","CLASS_REF","cloneNode","DECORATOR","INNER","classNode","applyMethodDecorators","state","hasMethodDecorators","body","applyTargetDecorators","some","_node$decorators","applyObjectDecorators","properties","type","decoratedProps","exprs","computed","buildCodeFrameError","property","isLiteral","key","stringLiteral","target","static","isClassProperty","descriptor","initializer","value","functionExpression","blockStatement","returnStatement","nullLiteral","callExpression","addHelper","thisExpression","add","push","arrayExpression","objectExpression","objectProperty","identifier","booleanLiteral","isObjectProperty","TEMP","TARGET","PROPERTY","decoratedClassToExpression","ref","generateUidIdentifier","variableDeclaration","variableDeclarator","toExpression","visitor","ExportDefaultDeclaration","decl","isClassDeclaration","replacement","varDeclPath","replaceWithMultiple","exportNamedDeclaration","exportSpecifier","declarations","registerDeclaration","ClassDeclaration","replaceWith","ClassExpression","decoratedClass","ObjectExpression","decoratedObject","AssignmentExpression","has","right","CallExpression","arguments","callee"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-proposal-decorators\\src\\transformer-legacy.ts"],"sourcesContent":["// Fork of https://github.com/loganfsmyth/babel-plugin-proposal-decorators-legacy\n\nimport { template, types as t, type PluginPass } from \"@babel/core\";\nimport type { NodePath, Visitor } from \"@babel/traverse\";\n\nconst buildClassDecorator = template.statement(`\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n`) as (replacements: {\n  DECORATOR: t.Expression;\n  CLASS_REF: t.Identifier;\n  INNER: t.Expression;\n}) => t.ExpressionStatement;\n\nconst buildClassPrototype = template(`\n  CLASS_REF.prototype;\n`) as (replacements: { CLASS_REF: t.Identifier }) => t.ExpressionStatement;\n\nconst buildGetDescriptor = template(`\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n`) as (replacements: {\n  TARGET: t.Expression;\n  PROPERTY: t.Literal;\n}) => t.ExpressionStatement;\n\nconst buildGetObjectInitializer = template(`\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n`) as (replacements: {\n  TEMP: t.Identifier;\n  TARGET: t.Expression;\n  PROPERTY: t.Literal;\n}) => t.ExpressionStatement;\n\nconst WARNING_CALLS = new WeakSet();\n\n// legacy decorator does not support ClassAccessorProperty\ntype ClassDecoratableElement =\n  | t.ClassMethod\n  | t.ClassPrivateMethod\n  | t.ClassProperty\n  | t.ClassPrivateProperty;\n\n/**\n * If the decorator expressions are non-identifiers, hoist them to before the class so we can be sure\n * that they are evaluated in order.\n */\nfunction applyEnsureOrdering(\n  path: NodePath<t.ClassExpression | t.ObjectExpression>,\n) {\n  // TODO: This should probably also hoist computed properties.\n  const decorators: t.Decorator[] = (\n    path.isClass()\n      ? [\n          path,\n          ...(path.get(\"body.body\") as NodePath<ClassDecoratableElement>[]),\n        ]\n      : path.get(\"properties\")\n  ).reduce(\n    (\n      acc: t.Decorator[],\n      prop: NodePath<\n        t.ObjectMember | t.ClassExpression | ClassDecoratableElement\n      >,\n    ) => acc.concat(prop.node.decorators || []),\n    [],\n  );\n\n  const identDecorators = decorators.filter(\n    decorator => !t.isIdentifier(decorator.expression),\n  );\n  if (identDecorators.length === 0) return;\n\n  return t.sequenceExpression(\n    identDecorators\n      .map((decorator): t.Expression => {\n        const expression = decorator.expression;\n        const id = (decorator.expression =\n          path.scope.generateDeclaredUidIdentifier(\"dec\"));\n        return t.assignmentExpression(\"=\", id, expression);\n      })\n      .concat([path.node]),\n  );\n}\n\n/**\n * Given a class expression with class-level decorators, create a new expression\n * with the proper decorated behavior.\n */\nfunction applyClassDecorators(classPath: NodePath<t.ClassExpression>) {\n  if (!hasClassDecorators(classPath.node)) return;\n\n  const decorators = classPath.node.decorators || [];\n  classPath.node.decorators = null;\n\n  const name = classPath.scope.generateDeclaredUidIdentifier(\"class\");\n\n  return decorators\n    .map(dec => dec.expression)\n    .reverse()\n    .reduce(function (acc, decorator) {\n      return buildClassDecorator({\n        CLASS_REF: t.cloneNode(name),\n        DECORATOR: t.cloneNode(decorator),\n        INNER: acc,\n      }).expression;\n    }, classPath.node);\n}\n\nfunction hasClassDecorators(classNode: t.Class) {\n  return !!(classNode.decorators && classNode.decorators.length);\n}\n\n/**\n * Given a class expression with method-level decorators, create a new expression\n * with the proper decorated behavior.\n */\nfunction applyMethodDecorators(\n  path: NodePath<t.ClassExpression>,\n  state: PluginPass,\n) {\n  if (!hasMethodDecorators(path.node.body.body)) return;\n\n  return applyTargetDecorators(\n    path,\n    state,\n    // @ts-expect-error ClassAccessorProperty is not supported in legacy decorator\n    path.node.body.body,\n  );\n}\n\nfunction hasMethodDecorators(\n  body: t.ClassBody[\"body\"] | t.ObjectExpression[\"properties\"],\n) {\n  return body.some(\n    node =>\n      // @ts-expect-error decorators not in SpreadElement/StaticBlock\n      node.decorators?.length,\n  );\n}\n\n/**\n * Given an object expression with property decorators, create a new expression\n * with the proper decorated behavior.\n */\nfunction applyObjectDecorators(\n  path: NodePath<t.ObjectExpression>,\n  state: PluginPass,\n) {\n  if (!hasMethodDecorators(path.node.properties)) return;\n\n  return applyTargetDecorators(\n    path,\n    state,\n    path.node.properties.filter(\n      (prop): prop is t.ObjectMember => prop.type !== \"SpreadElement\",\n    ),\n  );\n}\n\n/**\n * A helper to pull out property decorators into a sequence expression.\n */\nfunction applyTargetDecorators(\n  path: NodePath<t.ClassExpression | t.ObjectExpression>,\n  state: PluginPass,\n  decoratedProps: (t.ObjectMember | ClassDecoratableElement)[],\n) {\n  const name = path.scope.generateDeclaredUidIdentifier(\n    path.isClass() ? \"class\" : \"obj\",\n  );\n\n  const exprs = decoratedProps.reduce(function (acc, node) {\n    let decorators: t.Decorator[] = [];\n    if (node.decorators != null) {\n      decorators = node.decorators;\n      node.decorators = null;\n    }\n\n    if (decorators.length === 0) return acc;\n\n    if (\n      // @ts-expect-error computed is not in ClassPrivateProperty\n      node.computed\n    ) {\n      throw path.buildCodeFrameError(\n        \"Computed method/property decorators are not yet supported.\",\n      );\n    }\n\n    const property: t.Literal = t.isLiteral(node.key)\n      ? node.key\n      : t.stringLiteral(\n          // @ts-expect-error: should we handle ClassPrivateProperty?\n          node.key.name,\n        );\n\n    const target =\n      path.isClass() && !(node as ClassDecoratableElement).static\n        ? buildClassPrototype({\n            CLASS_REF: name,\n          }).expression\n        : name;\n\n    if (t.isClassProperty(node, { static: false })) {\n      const descriptor = path.scope.generateDeclaredUidIdentifier(\"descriptor\");\n\n      const initializer = node.value\n        ? t.functionExpression(\n            null,\n            [],\n            t.blockStatement([t.returnStatement(node.value)]),\n          )\n        : t.nullLiteral();\n\n      node.value = t.callExpression(\n        state.addHelper(\"initializerWarningHelper\"),\n        [descriptor, t.thisExpression()],\n      );\n\n      WARNING_CALLS.add(node.value);\n\n      acc.push(\n        t.assignmentExpression(\n          \"=\",\n          t.cloneNode(descriptor),\n          t.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [\n            t.cloneNode(target),\n            t.cloneNode(property),\n            t.arrayExpression(\n              decorators.map(dec => t.cloneNode(dec.expression)),\n            ),\n            t.objectExpression([\n              t.objectProperty(\n                t.identifier(\"configurable\"),\n                t.booleanLiteral(true),\n              ),\n              t.objectProperty(\n                t.identifier(\"enumerable\"),\n                t.booleanLiteral(true),\n              ),\n              t.objectProperty(\n                t.identifier(\"writable\"),\n                t.booleanLiteral(true),\n              ),\n              t.objectProperty(t.identifier(\"initializer\"), initializer),\n            ]),\n          ]),\n        ),\n      );\n    } else {\n      acc.push(\n        t.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [\n          t.cloneNode(target),\n          t.cloneNode(property),\n          t.arrayExpression(decorators.map(dec => t.cloneNode(dec.expression))),\n          t.isObjectProperty(node) || t.isClassProperty(node, { static: true })\n            ? buildGetObjectInitializer({\n                TEMP: path.scope.generateDeclaredUidIdentifier(\"init\"),\n                TARGET: t.cloneNode(target),\n                PROPERTY: t.cloneNode(property),\n              }).expression\n            : buildGetDescriptor({\n                TARGET: t.cloneNode(target),\n                PROPERTY: t.cloneNode(property),\n              }).expression,\n          t.cloneNode(target),\n        ]),\n      );\n    }\n\n    return acc;\n  }, []);\n\n  return t.sequenceExpression([\n    t.assignmentExpression(\"=\", t.cloneNode(name), path.node),\n    t.sequenceExpression(exprs),\n    t.cloneNode(name),\n  ]);\n}\n\nfunction decoratedClassToExpression({ node, scope }: NodePath<t.Class>) {\n  if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {\n    return;\n  }\n\n  const ref = node.id\n    ? t.cloneNode(node.id)\n    : scope.generateUidIdentifier(\"class\");\n\n  return t.variableDeclaration(\"let\", [\n    t.variableDeclarator(ref, t.toExpression(node)),\n  ]);\n}\n\nconst visitor: Visitor<PluginPass> = {\n  ExportDefaultDeclaration(path) {\n    const decl = path.get(\"declaration\");\n    if (!decl.isClassDeclaration()) return;\n\n    const replacement = decoratedClassToExpression(decl);\n    if (replacement) {\n      const [varDeclPath] = path.replaceWithMultiple([\n        replacement,\n        t.exportNamedDeclaration(null, [\n          t.exportSpecifier(\n            // @ts-expect-error todo(flow->ts) might be add more specific return type for decoratedClassToExpression\n            t.cloneNode(replacement.declarations[0].id),\n            t.identifier(\"default\"),\n          ),\n        ]),\n      ]);\n\n      if (!decl.node.id) {\n        path.scope.registerDeclaration(varDeclPath);\n      }\n    }\n  },\n  ClassDeclaration(path) {\n    const replacement = decoratedClassToExpression(path);\n    if (replacement) {\n      path.replaceWith(replacement);\n    }\n  },\n  ClassExpression(path, state) {\n    // Create a replacement for the class node if there is one. We do one pass to replace classes with\n    // class decorators, and a second pass to process method decorators.\n    const decoratedClass =\n      applyEnsureOrdering(path) ||\n      applyClassDecorators(path) ||\n      applyMethodDecorators(path, state);\n\n    if (decoratedClass) path.replaceWith(decoratedClass);\n  },\n  ObjectExpression(path, state) {\n    const decoratedObject =\n      applyEnsureOrdering(path) || applyObjectDecorators(path, state);\n\n    if (decoratedObject) path.replaceWith(decoratedObject);\n  },\n\n  AssignmentExpression(path, state) {\n    if (!WARNING_CALLS.has(path.node.right)) return;\n\n    path.replaceWith(\n      t.callExpression(state.addHelper(\"initializerDefineProperty\"), [\n        // @ts-expect-error todo(flow->ts) typesafe NodePath.get\n        t.cloneNode(path.get(\"left.object\").node),\n        t.stringLiteral(\n          // @ts-expect-error todo(flow->ts) typesafe NodePath.get\n          path.get(\"left.property\").node.name ||\n            // @ts-expect-error todo(flow->ts) typesafe NodePath.get\n            path.get(\"left.property\").node.value,\n        ),\n        // @ts-expect-error todo(flow->ts)\n        t.cloneNode(path.get(\"right.arguments\")[0].node),\n        // @ts-expect-error todo(flow->ts)\n        t.cloneNode(path.get(\"right.arguments\")[1].node),\n      ]),\n    );\n  },\n\n  CallExpression(path, state) {\n    if (path.node.arguments.length !== 3) return;\n    if (!WARNING_CALLS.has(path.node.arguments[2])) return;\n\n    // If the class properties plugin isn't enabled, this line will add an unused helper\n    // to the code. It's not ideal, but it's ok since the configuration is not valid anyway.\n    // @ts-expect-error todo(flow->ts) check that `callee` is Identifier\n    if (path.node.callee.name !== state.addHelper(\"defineProperty\").name) {\n      return;\n    }\n\n    path.replaceWith(\n      t.callExpression(state.addHelper(\"initializerDefineProperty\"), [\n        t.cloneNode(path.get(\"arguments\")[0].node),\n        t.cloneNode(path.get(\"arguments\")[1].node),\n        // @ts-expect-error todo(flow->ts)\n        t.cloneNode(path.get(\"arguments.2.arguments\")[0].node),\n        // @ts-expect-error todo(flow->ts)\n        t.cloneNode(path.get(\"arguments.2.arguments\")[1].node),\n      ]),\n    );\n  },\n};\n\nexport default visitor;\n"]},"metadata":{},"sourceType":"script"}