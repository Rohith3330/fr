{"ast":null,"code":"/**\n * @fileoverview Enforces consistent naming for boolean props\n * @author Ev Haus\n */\n'use strict';\n\nconst Components = require('../util/Components');\n\nconst propsUtil = require('../util/props');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst propWrapperUtil = require('../util/propWrapper');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst messages = {\n  patternMismatch: 'Prop name ({{propName}}) doesn\\'t match rule ({{pattern}})'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      category: 'Stylistic Issues',\n      description: 'Enforces consistent naming for boolean props',\n      recommended: false,\n      url: docsUrl('boolean-prop-naming')\n    },\n    messages,\n    schema: [{\n      additionalProperties: false,\n      properties: {\n        propTypeNames: {\n          items: {\n            type: 'string'\n          },\n          minItems: 1,\n          type: 'array',\n          uniqueItems: true\n        },\n        rule: {\n          default: '^(is|has)[A-Z]([A-Za-z0-9]?)+',\n          minLength: 1,\n          type: 'string'\n        },\n        message: {\n          minLength: 1,\n          type: 'string'\n        },\n        validateNested: {\n          default: false,\n          type: 'boolean'\n        }\n      },\n      type: 'object'\n    }]\n  },\n  create: Components.detect((context, components, utils) => {\n    const config = context.options[0] || {};\n    const rule = config.rule ? new RegExp(config.rule) : null;\n    const propTypeNames = config.propTypeNames || ['bool']; // Remembers all Flowtype object definitions\n\n    const objectTypeAnnotations = new Map();\n    /**\n     * Returns the prop key to ensure we handle the following cases:\n     * propTypes: {\n     *   full: React.PropTypes.bool,\n     *   short: PropTypes.bool,\n     *   direct: bool,\n     *   required: PropTypes.bool.isRequired\n     * }\n     * @param {Object} node The node we're getting the name of\n     * @returns {string | null}\n     */\n\n    function getPropKey(node) {\n      // Check for `ExperimentalSpreadProperty` (eslint 3/4) and `SpreadElement` (eslint 5)\n      // so we can skip validation of those fields.\n      // Otherwise it will look for `node.value.property` which doesn't exist and breaks eslint.\n      if (node.type === 'ExperimentalSpreadProperty' || node.type === 'SpreadElement') {\n        return null;\n      }\n\n      if (node.value && node.value.property) {\n        const name = node.value.property.name;\n\n        if (name === 'isRequired') {\n          if (node.value.object && node.value.object.property) {\n            return node.value.object.property.name;\n          }\n\n          return null;\n        }\n\n        return name;\n      }\n\n      if (node.value && node.value.type === 'Identifier') {\n        return node.value.name;\n      }\n\n      return null;\n    }\n    /**\n     * Returns the name of the given node (prop)\n     * @param {Object} node The node we're getting the name of\n     * @returns {string}\n     */\n\n\n    function getPropName(node) {\n      // Due to this bug https://github.com/babel/babel-eslint/issues/307\n      // we can't get the name of the Flow object key name. So we have\n      // to hack around it for now.\n      if (node.type === 'ObjectTypeProperty') {\n        return context.getSourceCode().getFirstToken(node).value;\n      }\n\n      return node.key.name;\n    }\n    /**\n     * Checks if prop is declared in flow way\n     * @param {Object} prop Property object, single prop type declaration\n     * @returns {Boolean}\n     */\n\n\n    function flowCheck(prop) {\n      return prop.type === 'ObjectTypeProperty' && prop.value.type === 'BooleanTypeAnnotation' && rule.test(getPropName(prop)) === false;\n    }\n    /**\n     * Checks if prop is declared in regular way\n     * @param {Object} prop Property object, single prop type declaration\n     * @returns {Boolean}\n     */\n\n\n    function regularCheck(prop) {\n      const propKey = getPropKey(prop);\n      return propKey && propTypeNames.indexOf(propKey) >= 0 && rule.test(getPropName(prop)) === false;\n    }\n\n    function tsCheck(prop) {\n      if (prop.type !== 'TSPropertySignature') return false;\n      const typeAnnotation = (prop.typeAnnotation || {}).typeAnnotation;\n      return typeAnnotation && typeAnnotation.type === 'TSBooleanKeyword' && rule.test(getPropName(prop)) === false;\n    }\n    /**\n     * Checks if prop is nested\n     * @param {Object} prop Property object, single prop type declaration\n     * @returns {Boolean}\n     */\n\n\n    function nestedPropTypes(prop) {\n      return prop.type === 'Property' && prop.value.type === 'CallExpression';\n    }\n    /**\n     * Runs recursive check on all proptypes\n     * @param {Array} proptypes A list of Property object (for each proptype defined)\n     * @param {Function} addInvalidProp callback to run for each error\n     */\n\n\n    function runCheck(proptypes, addInvalidProp) {\n      (proptypes || []).forEach(prop => {\n        if (config.validateNested && nestedPropTypes(prop)) {\n          runCheck(prop.value.arguments[0].properties, addInvalidProp);\n          return;\n        }\n\n        if (flowCheck(prop) || regularCheck(prop) || tsCheck(prop)) {\n          addInvalidProp(prop);\n        }\n      });\n    }\n    /**\n     * Checks and mark props with invalid naming\n     * @param {Object} node The component node we're testing\n     * @param {Array} proptypes A list of Property object (for each proptype defined)\n     */\n\n\n    function validatePropNaming(node, proptypes) {\n      const component = components.get(node) || node;\n      const invalidProps = component.invalidProps || [];\n      runCheck(proptypes, prop => {\n        invalidProps.push(prop);\n      });\n      components.set(node, {\n        invalidProps\n      });\n    }\n    /**\n     * Reports invalid prop naming\n     * @param {Object} component The component to process\n     */\n\n\n    function reportInvalidNaming(component) {\n      component.invalidProps.forEach(propNode => {\n        const propName = getPropName(propNode);\n        report(context, config.message || messages.patternMismatch, !config.message && 'patternMismatch', {\n          node: propNode,\n          data: {\n            component: propName,\n            propName,\n            pattern: config.rule\n          }\n        });\n      });\n    }\n\n    function checkPropWrapperArguments(node, args) {\n      if (!node || !Array.isArray(args)) {\n        return;\n      }\n\n      args.filter(arg => arg.type === 'ObjectExpression').forEach(object => validatePropNaming(node, object.properties));\n    }\n\n    function getComponentTypeAnnotation(component) {\n      // If this is a functional component that uses a global type, check it\n      if ((component.node.type === 'FunctionDeclaration' || component.node.type === 'ArrowFunctionExpression') && component.node.params && component.node.params.length > 0 && component.node.params[0].typeAnnotation) {\n        return component.node.params[0].typeAnnotation.typeAnnotation;\n      }\n\n      if (component.node.parent && component.node.parent.type === 'VariableDeclarator' && component.node.parent.id && component.node.parent.id.type === 'Identifier' && component.node.parent.id.typeAnnotation && component.node.parent.id.typeAnnotation.typeAnnotation && component.node.parent.id.typeAnnotation.typeAnnotation.typeParameters && (component.node.parent.id.typeAnnotation.typeAnnotation.typeParameters.type === 'TSTypeParameterInstantiation' || component.node.parent.id.typeAnnotation.typeAnnotation.typeParameters.type === 'TypeParameterInstantiation')) {\n        return component.node.parent.id.typeAnnotation.typeAnnotation.typeParameters.params.find(param => param.type === 'TSTypeReference' || param.type === 'GenericTypeAnnotation');\n      }\n    }\n\n    function findAllTypeAnnotations(identifier, node) {\n      if (node.type === 'TSTypeLiteral' || node.type === 'ObjectTypeAnnotation') {\n        const currentNode = [].concat(objectTypeAnnotations.get(identifier.name) || [], node);\n        objectTypeAnnotations.set(identifier.name, currentNode);\n      } else if (node.type === 'TSParenthesizedType' && (node.typeAnnotation.type === 'TSIntersectionType' || node.typeAnnotation.type === 'TSUnionType')) {\n        node.typeAnnotation.types.forEach(type => {\n          findAllTypeAnnotations(identifier, type);\n        });\n      } else if (node.type === 'TSIntersectionType' || node.type === 'TSUnionType' || node.type === 'IntersectionTypeAnnotation' || node.type === 'UnionTypeAnnotation') {\n        node.types.forEach(type => {\n          findAllTypeAnnotations(identifier, type);\n        });\n      }\n    } // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n\n    return {\n      'ClassProperty, PropertyDefinition'(node) {\n        if (!rule || !propsUtil.isPropTypesDeclaration(node)) {\n          return;\n        }\n\n        if (node.value && node.value.type === 'CallExpression' && propWrapperUtil.isPropWrapperFunction(context, context.getSourceCode().getText(node.value.callee))) {\n          checkPropWrapperArguments(node, node.value.arguments);\n        }\n\n        if (node.value && node.value.properties) {\n          validatePropNaming(node, node.value.properties);\n        }\n\n        if (node.typeAnnotation && node.typeAnnotation.typeAnnotation) {\n          validatePropNaming(node, node.typeAnnotation.typeAnnotation.properties);\n        }\n      },\n\n      MemberExpression(node) {\n        if (!rule || !propsUtil.isPropTypesDeclaration(node)) {\n          return;\n        }\n\n        const component = utils.getRelatedComponent(node);\n\n        if (!component || !node.parent.right) {\n          return;\n        }\n\n        const right = node.parent.right;\n\n        if (right.type === 'CallExpression' && propWrapperUtil.isPropWrapperFunction(context, context.getSourceCode().getText(right.callee))) {\n          checkPropWrapperArguments(component.node, right.arguments);\n          return;\n        }\n\n        validatePropNaming(component.node, node.parent.right.properties);\n      },\n\n      ObjectExpression(node) {\n        if (!rule) {\n          return;\n        } // Search for the proptypes declaration\n\n\n        node.properties.forEach(property => {\n          if (!propsUtil.isPropTypesDeclaration(property)) {\n            return;\n          }\n\n          validatePropNaming(node, property.value.properties);\n        });\n      },\n\n      TypeAlias(node) {\n        findAllTypeAnnotations(node.id, node.right);\n      },\n\n      TSTypeAliasDeclaration(node) {\n        findAllTypeAnnotations(node.id, node.typeAnnotation);\n      },\n\n      // eslint-disable-next-line object-shorthand\n      'Program:exit'() {\n        if (!rule) {\n          return;\n        }\n\n        const list = components.list();\n        Object.keys(list).forEach(component => {\n          const annotation = getComponentTypeAnnotation(list[component]);\n\n          if (annotation) {\n            let propType;\n\n            if (annotation.type === 'GenericTypeAnnotation') {\n              propType = objectTypeAnnotations.get(annotation.id.name);\n            } else if (annotation.type === 'ObjectTypeAnnotation') {\n              propType = annotation;\n            } else if (annotation.type === 'TSTypeReference') {\n              propType = objectTypeAnnotations.get(annotation.typeName.name);\n            }\n\n            if (propType) {\n              [].concat(propType).forEach(prop => {\n                validatePropNaming(list[component].node, prop.properties || prop.members);\n              });\n            }\n          }\n\n          if (list[component].invalidProps && list[component].invalidProps.length > 0) {\n            reportInvalidNaming(list[component]);\n          }\n        }); // Reset cache\n\n        objectTypeAnnotations.clear();\n      }\n\n    };\n  })\n};","map":{"version":3,"names":["Components","require","propsUtil","docsUrl","propWrapperUtil","report","messages","patternMismatch","module","exports","meta","docs","category","description","recommended","url","schema","additionalProperties","properties","propTypeNames","items","type","minItems","uniqueItems","rule","default","minLength","message","validateNested","create","detect","context","components","utils","config","options","RegExp","objectTypeAnnotations","Map","getPropKey","node","value","property","name","object","getPropName","getSourceCode","getFirstToken","key","flowCheck","prop","test","regularCheck","propKey","indexOf","tsCheck","typeAnnotation","nestedPropTypes","runCheck","proptypes","addInvalidProp","forEach","arguments","validatePropNaming","component","get","invalidProps","push","set","reportInvalidNaming","propNode","propName","data","pattern","checkPropWrapperArguments","args","Array","isArray","filter","arg","getComponentTypeAnnotation","params","length","parent","id","typeParameters","find","param","findAllTypeAnnotations","identifier","currentNode","concat","types","isPropTypesDeclaration","isPropWrapperFunction","getText","callee","MemberExpression","getRelatedComponent","right","ObjectExpression","TypeAlias","TSTypeAliasDeclaration","list","Object","keys","annotation","propType","typeName","members","clear"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/boolean-prop-naming.js"],"sourcesContent":["/**\n * @fileoverview Enforces consistent naming for boolean props\n * @author Ev Haus\n */\n\n'use strict';\n\nconst Components = require('../util/Components');\nconst propsUtil = require('../util/props');\nconst docsUrl = require('../util/docsUrl');\nconst propWrapperUtil = require('../util/propWrapper');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  patternMismatch: 'Prop name ({{propName}}) doesn\\'t match rule ({{pattern}})',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      category: 'Stylistic Issues',\n      description: 'Enforces consistent naming for boolean props',\n      recommended: false,\n      url: docsUrl('boolean-prop-naming'),\n    },\n\n    messages,\n\n    schema: [{\n      additionalProperties: false,\n      properties: {\n        propTypeNames: {\n          items: {\n            type: 'string',\n          },\n          minItems: 1,\n          type: 'array',\n          uniqueItems: true,\n        },\n        rule: {\n          default: '^(is|has)[A-Z]([A-Za-z0-9]?)+',\n          minLength: 1,\n          type: 'string',\n        },\n        message: {\n          minLength: 1,\n          type: 'string',\n        },\n        validateNested: {\n          default: false,\n          type: 'boolean',\n        },\n      },\n      type: 'object',\n    }],\n  },\n\n  create: Components.detect((context, components, utils) => {\n    const config = context.options[0] || {};\n    const rule = config.rule ? new RegExp(config.rule) : null;\n    const propTypeNames = config.propTypeNames || ['bool'];\n\n    // Remembers all Flowtype object definitions\n    const objectTypeAnnotations = new Map();\n\n    /**\n     * Returns the prop key to ensure we handle the following cases:\n     * propTypes: {\n     *   full: React.PropTypes.bool,\n     *   short: PropTypes.bool,\n     *   direct: bool,\n     *   required: PropTypes.bool.isRequired\n     * }\n     * @param {Object} node The node we're getting the name of\n     * @returns {string | null}\n     */\n    function getPropKey(node) {\n      // Check for `ExperimentalSpreadProperty` (eslint 3/4) and `SpreadElement` (eslint 5)\n      // so we can skip validation of those fields.\n      // Otherwise it will look for `node.value.property` which doesn't exist and breaks eslint.\n      if (node.type === 'ExperimentalSpreadProperty' || node.type === 'SpreadElement') {\n        return null;\n      }\n      if (node.value && node.value.property) {\n        const name = node.value.property.name;\n        if (name === 'isRequired') {\n          if (node.value.object && node.value.object.property) {\n            return node.value.object.property.name;\n          }\n          return null;\n        }\n        return name;\n      }\n      if (node.value && node.value.type === 'Identifier') {\n        return node.value.name;\n      }\n      return null;\n    }\n\n    /**\n     * Returns the name of the given node (prop)\n     * @param {Object} node The node we're getting the name of\n     * @returns {string}\n     */\n    function getPropName(node) {\n      // Due to this bug https://github.com/babel/babel-eslint/issues/307\n      // we can't get the name of the Flow object key name. So we have\n      // to hack around it for now.\n      if (node.type === 'ObjectTypeProperty') {\n        return context.getSourceCode().getFirstToken(node).value;\n      }\n\n      return node.key.name;\n    }\n\n    /**\n     * Checks if prop is declared in flow way\n     * @param {Object} prop Property object, single prop type declaration\n     * @returns {Boolean}\n     */\n    function flowCheck(prop) {\n      return (\n        prop.type === 'ObjectTypeProperty'\n        && prop.value.type === 'BooleanTypeAnnotation'\n        && rule.test(getPropName(prop)) === false\n      );\n    }\n\n    /**\n     * Checks if prop is declared in regular way\n     * @param {Object} prop Property object, single prop type declaration\n     * @returns {Boolean}\n     */\n    function regularCheck(prop) {\n      const propKey = getPropKey(prop);\n      return (\n        propKey\n        && propTypeNames.indexOf(propKey) >= 0\n        && rule.test(getPropName(prop)) === false\n      );\n    }\n\n    function tsCheck(prop) {\n      if (prop.type !== 'TSPropertySignature') return false;\n      const typeAnnotation = (prop.typeAnnotation || {}).typeAnnotation;\n      return (\n        typeAnnotation\n        && typeAnnotation.type === 'TSBooleanKeyword'\n        && rule.test(getPropName(prop)) === false\n      );\n    }\n\n    /**\n     * Checks if prop is nested\n     * @param {Object} prop Property object, single prop type declaration\n     * @returns {Boolean}\n     */\n    function nestedPropTypes(prop) {\n      return (\n        prop.type === 'Property'\n        && prop.value.type === 'CallExpression'\n      );\n    }\n\n    /**\n     * Runs recursive check on all proptypes\n     * @param {Array} proptypes A list of Property object (for each proptype defined)\n     * @param {Function} addInvalidProp callback to run for each error\n     */\n    function runCheck(proptypes, addInvalidProp) {\n      (proptypes || []).forEach((prop) => {\n        if (config.validateNested && nestedPropTypes(prop)) {\n          runCheck(prop.value.arguments[0].properties, addInvalidProp);\n          return;\n        }\n        if (flowCheck(prop) || regularCheck(prop) || tsCheck(prop)) {\n          addInvalidProp(prop);\n        }\n      });\n    }\n\n    /**\n     * Checks and mark props with invalid naming\n     * @param {Object} node The component node we're testing\n     * @param {Array} proptypes A list of Property object (for each proptype defined)\n     */\n    function validatePropNaming(node, proptypes) {\n      const component = components.get(node) || node;\n      const invalidProps = component.invalidProps || [];\n\n      runCheck(proptypes, (prop) => {\n        invalidProps.push(prop);\n      });\n\n      components.set(node, {\n        invalidProps,\n      });\n    }\n\n    /**\n     * Reports invalid prop naming\n     * @param {Object} component The component to process\n     */\n    function reportInvalidNaming(component) {\n      component.invalidProps.forEach((propNode) => {\n        const propName = getPropName(propNode);\n        report(context, config.message || messages.patternMismatch, !config.message && 'patternMismatch', {\n          node: propNode,\n          data: {\n            component: propName,\n            propName,\n            pattern: config.rule,\n          },\n        });\n      });\n    }\n\n    function checkPropWrapperArguments(node, args) {\n      if (!node || !Array.isArray(args)) {\n        return;\n      }\n      args.filter((arg) => arg.type === 'ObjectExpression').forEach((object) => validatePropNaming(node, object.properties));\n    }\n\n    function getComponentTypeAnnotation(component) {\n      // If this is a functional component that uses a global type, check it\n      if (\n        (component.node.type === 'FunctionDeclaration' || component.node.type === 'ArrowFunctionExpression')\n        && component.node.params\n        && component.node.params.length > 0\n        && component.node.params[0].typeAnnotation\n      ) {\n        return component.node.params[0].typeAnnotation.typeAnnotation;\n      }\n\n      if (\n        component.node.parent\n        && component.node.parent.type === 'VariableDeclarator'\n        && component.node.parent.id\n        && component.node.parent.id.type === 'Identifier'\n        && component.node.parent.id.typeAnnotation\n        && component.node.parent.id.typeAnnotation.typeAnnotation\n        && component.node.parent.id.typeAnnotation.typeAnnotation.typeParameters\n        && (\n          component.node.parent.id.typeAnnotation.typeAnnotation.typeParameters.type === 'TSTypeParameterInstantiation'\n          || component.node.parent.id.typeAnnotation.typeAnnotation.typeParameters.type === 'TypeParameterInstantiation'\n        )\n      ) {\n        return component.node.parent.id.typeAnnotation.typeAnnotation.typeParameters.params.find(\n          (param) => param.type === 'TSTypeReference' || param.type === 'GenericTypeAnnotation'\n        );\n      }\n    }\n\n    function findAllTypeAnnotations(identifier, node) {\n      if (node.type === 'TSTypeLiteral' || node.type === 'ObjectTypeAnnotation') {\n        const currentNode = [].concat(\n          objectTypeAnnotations.get(identifier.name) || [],\n          node\n        );\n        objectTypeAnnotations.set(identifier.name, currentNode);\n      } else if (\n        node.type === 'TSParenthesizedType'\n        && (\n          node.typeAnnotation.type === 'TSIntersectionType'\n          || node.typeAnnotation.type === 'TSUnionType'\n        )\n      ) {\n        node.typeAnnotation.types.forEach((type) => {\n          findAllTypeAnnotations(identifier, type);\n        });\n      } else if (\n        node.type === 'TSIntersectionType'\n        || node.type === 'TSUnionType'\n        || node.type === 'IntersectionTypeAnnotation'\n        || node.type === 'UnionTypeAnnotation'\n      ) {\n        node.types.forEach((type) => {\n          findAllTypeAnnotations(identifier, type);\n        });\n      }\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      'ClassProperty, PropertyDefinition'(node) {\n        if (!rule || !propsUtil.isPropTypesDeclaration(node)) {\n          return;\n        }\n        if (\n          node.value\n          && node.value.type === 'CallExpression'\n          && propWrapperUtil.isPropWrapperFunction(\n            context,\n            context.getSourceCode().getText(node.value.callee)\n          )\n        ) {\n          checkPropWrapperArguments(node, node.value.arguments);\n        }\n        if (node.value && node.value.properties) {\n          validatePropNaming(node, node.value.properties);\n        }\n        if (node.typeAnnotation && node.typeAnnotation.typeAnnotation) {\n          validatePropNaming(node, node.typeAnnotation.typeAnnotation.properties);\n        }\n      },\n\n      MemberExpression(node) {\n        if (!rule || !propsUtil.isPropTypesDeclaration(node)) {\n          return;\n        }\n        const component = utils.getRelatedComponent(node);\n        if (!component || !node.parent.right) {\n          return;\n        }\n        const right = node.parent.right;\n        if (\n          right.type === 'CallExpression'\n          && propWrapperUtil.isPropWrapperFunction(\n            context,\n            context.getSourceCode().getText(right.callee)\n          )\n        ) {\n          checkPropWrapperArguments(component.node, right.arguments);\n          return;\n        }\n        validatePropNaming(component.node, node.parent.right.properties);\n      },\n\n      ObjectExpression(node) {\n        if (!rule) {\n          return;\n        }\n\n        // Search for the proptypes declaration\n        node.properties.forEach((property) => {\n          if (!propsUtil.isPropTypesDeclaration(property)) {\n            return;\n          }\n          validatePropNaming(node, property.value.properties);\n        });\n      },\n\n      TypeAlias(node) {\n        findAllTypeAnnotations(node.id, node.right);\n      },\n\n      TSTypeAliasDeclaration(node) {\n        findAllTypeAnnotations(node.id, node.typeAnnotation);\n      },\n\n      // eslint-disable-next-line object-shorthand\n      'Program:exit'() {\n        if (!rule) {\n          return;\n        }\n\n        const list = components.list();\n\n        Object.keys(list).forEach((component) => {\n          const annotation = getComponentTypeAnnotation(list[component]);\n\n          if (annotation) {\n            let propType;\n            if (annotation.type === 'GenericTypeAnnotation') {\n              propType = objectTypeAnnotations.get(annotation.id.name);\n            } else if (annotation.type === 'ObjectTypeAnnotation') {\n              propType = annotation;\n            } else if (annotation.type === 'TSTypeReference') {\n              propType = objectTypeAnnotations.get(annotation.typeName.name);\n            }\n\n            if (propType) {\n              [].concat(propType).forEach((prop) => {\n                validatePropNaming(\n                  list[component].node,\n                  prop.properties || prop.members\n                );\n              });\n            }\n          }\n\n          if (list[component].invalidProps && list[component].invalidProps.length > 0) {\n            reportInvalidNaming(list[component]);\n          }\n        });\n\n        // Reset cache\n        objectTypeAnnotations.clear();\n      },\n    };\n  }),\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}