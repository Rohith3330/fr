{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"TargetNames\", {\n  enumerable: true,\n  get: function () {\n    return _options.TargetNames;\n  }\n});\nexports.default = getTargets;\nObject.defineProperty(exports, \"filterItems\", {\n  enumerable: true,\n  get: function () {\n    return _filterItems.default;\n  }\n});\nObject.defineProperty(exports, \"getInclusionReasons\", {\n  enumerable: true,\n  get: function () {\n    return _debug.getInclusionReasons;\n  }\n});\nexports.isBrowsersQueryValid = isBrowsersQueryValid;\nObject.defineProperty(exports, \"isRequired\", {\n  enumerable: true,\n  get: function () {\n    return _filterItems.isRequired;\n  }\n});\nObject.defineProperty(exports, \"prettifyTargets\", {\n  enumerable: true,\n  get: function () {\n    return _pretty.prettifyTargets;\n  }\n});\nObject.defineProperty(exports, \"unreleasedLabels\", {\n  enumerable: true,\n  get: function () {\n    return _targets.unreleasedLabels;\n  }\n});\n\nvar _browserslist = require(\"browserslist\");\n\nvar _helperValidatorOption = require(\"@babel/helper-validator-option\");\n\nvar _nativeModules = require(\"@babel/compat-data/native-modules\");\n\nvar _utils = require(\"./utils\");\n\nvar _targets = require(\"./targets\");\n\nvar _options = require(\"./options\");\n\nvar _pretty = require(\"./pretty\");\n\nvar _debug = require(\"./debug\");\n\nvar _filterItems = require(\"./filter-items\");\n\nconst ESM_SUPPORT = _nativeModules[\"es6.module\"];\nconst v = new _helperValidatorOption.OptionValidator(\"@babel/helper-compilation-targets\");\n\nfunction validateTargetNames(targets) {\n  const validTargets = Object.keys(_options.TargetNames);\n\n  for (const target of Object.keys(targets)) {\n    if (!(target in _options.TargetNames)) {\n      throw new Error(v.formatMessage(`'${target}' is not a valid target\n- Did you mean '${(0, _helperValidatorOption.findSuggestion)(target, validTargets)}'?`));\n    }\n  }\n\n  return targets;\n}\n\nfunction isBrowsersQueryValid(browsers) {\n  return typeof browsers === \"string\" || Array.isArray(browsers) && browsers.every(b => typeof b === \"string\");\n}\n\nfunction validateBrowsers(browsers) {\n  v.invariant(browsers === undefined || isBrowsersQueryValid(browsers), `'${String(browsers)}' is not a valid browserslist query`);\n  return browsers;\n}\n\nfunction getLowestVersions(browsers) {\n  return browsers.reduce((all, browser) => {\n    const [browserName, browserVersion] = browser.split(\" \");\n    const target = _targets.browserNameMap[browserName];\n\n    if (!target) {\n      return all;\n    }\n\n    try {\n      const splitVersion = browserVersion.split(\"-\")[0].toLowerCase();\n      const isSplitUnreleased = (0, _utils.isUnreleasedVersion)(splitVersion, target);\n\n      if (!all[target]) {\n        all[target] = isSplitUnreleased ? splitVersion : (0, _utils.semverify)(splitVersion);\n        return all;\n      }\n\n      const version = all[target];\n      const isUnreleased = (0, _utils.isUnreleasedVersion)(version, target);\n\n      if (isUnreleased && isSplitUnreleased) {\n        all[target] = (0, _utils.getLowestUnreleased)(version, splitVersion, target);\n      } else if (isUnreleased) {\n        all[target] = (0, _utils.semverify)(splitVersion);\n      } else if (!isUnreleased && !isSplitUnreleased) {\n        const parsedBrowserVersion = (0, _utils.semverify)(splitVersion);\n        all[target] = (0, _utils.semverMin)(version, parsedBrowserVersion);\n      }\n    } catch (e) {}\n\n    return all;\n  }, {});\n}\n\nfunction outputDecimalWarning(decimalTargets) {\n  if (!decimalTargets.length) {\n    return;\n  }\n\n  console.warn(\"Warning, the following targets are using a decimal version:\\n\");\n  decimalTargets.forEach(_ref => {\n    let {\n      target,\n      value\n    } = _ref;\n    return console.warn(`  ${target}: ${value}`);\n  });\n  console.warn(`\nWe recommend using a string for minor/patch versions to avoid numbers like 6.10\ngetting parsed as 6.1, which can lead to unexpected behavior.\n`);\n}\n\nfunction semverifyTarget(target, value) {\n  try {\n    return (0, _utils.semverify)(value);\n  } catch (error) {\n    throw new Error(v.formatMessage(`'${value}' is not a valid value for 'targets.${target}'.`));\n  }\n}\n\nfunction nodeTargetParser(value) {\n  const parsed = value === true || value === \"current\" ? process.versions.node : semverifyTarget(\"node\", value);\n  return [\"node\", parsed];\n}\n\nfunction defaultTargetParser(target, value) {\n  const version = (0, _utils.isUnreleasedVersion)(value, target) ? value.toLowerCase() : semverifyTarget(target, value);\n  return [target, version];\n}\n\nfunction generateTargets(inputTargets) {\n  const input = Object.assign({}, inputTargets);\n  delete input.esmodules;\n  delete input.browsers;\n  return input;\n}\n\nfunction resolveTargets(queries, env) {\n  const resolved = _browserslist(queries, {\n    mobileToDesktop: true,\n    env\n  });\n\n  return getLowestVersions(resolved);\n}\n\nfunction getTargets() {\n  let inputTargets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _browsers, _browsers2;\n\n  let {\n    browsers,\n    esmodules\n  } = inputTargets;\n  const {\n    configPath = \".\"\n  } = options;\n  validateBrowsers(browsers);\n  const input = generateTargets(inputTargets);\n  let targets = validateTargetNames(input);\n  const shouldParseBrowsers = !!browsers;\n  const hasTargets = shouldParseBrowsers || Object.keys(targets).length > 0;\n  const shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;\n\n  if (!browsers && shouldSearchForConfig) {\n    browsers = _browserslist.loadConfig({\n      config: options.configFile,\n      path: configPath,\n      env: options.browserslistEnv\n    });\n\n    if (browsers == null) {\n      {\n        browsers = [];\n      }\n    }\n  }\n\n  if (esmodules && (esmodules !== \"intersect\" || !((_browsers = browsers) != null && _browsers.length))) {\n    browsers = Object.keys(ESM_SUPPORT).map(browser => `${browser} >= ${ESM_SUPPORT[browser]}`).join(\", \");\n    esmodules = false;\n  }\n\n  if ((_browsers2 = browsers) != null && _browsers2.length) {\n    const queryBrowsers = resolveTargets(browsers, options.browserslistEnv);\n\n    if (esmodules === \"intersect\") {\n      for (const browser of Object.keys(queryBrowsers)) {\n        const version = queryBrowsers[browser];\n        const esmSupportVersion = ESM_SUPPORT[browser];\n\n        if (esmSupportVersion) {\n          queryBrowsers[browser] = (0, _utils.getHighestUnreleased)(version, (0, _utils.semverify)(esmSupportVersion), browser);\n        } else {\n          delete queryBrowsers[browser];\n        }\n      }\n    }\n\n    targets = Object.assign(queryBrowsers, targets);\n  }\n\n  const result = {};\n  const decimalWarnings = [];\n\n  for (const target of Object.keys(targets).sort()) {\n    const value = targets[target];\n\n    if (typeof value === \"number\" && value % 1 !== 0) {\n      decimalWarnings.push({\n        target,\n        value\n      });\n    }\n\n    const [parsedTarget, parsedValue] = target === \"node\" ? nodeTargetParser(value) : defaultTargetParser(target, value);\n\n    if (parsedValue) {\n      result[parsedTarget] = parsedValue;\n    }\n  }\n\n  outputDecimalWarning(decimalWarnings);\n  return result;\n}","map":{"version":3,"mappings":"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","names":["ESM_SUPPORT","browserModulesData","v","OptionValidator","validateTargetNames","targets","validTargets","Object","keys","TargetNames","target","Error","formatMessage","isBrowsersQueryValid","browsers","Array","isArray","every","b","validateBrowsers","invariant","undefined","String","getLowestVersions","reduce","all","browser","browserName","browserVersion","split","browserNameMap","splitVersion","toLowerCase","isSplitUnreleased","version","isUnreleased","parsedBrowserVersion","e","outputDecimalWarning","decimalTargets","length","console","warn","forEach","value","semverifyTarget","error","nodeTargetParser","parsed","process","versions","node","defaultTargetParser","generateTargets","inputTargets","input","esmodules","resolveTargets","queries","env","resolved","browserslist","mobileToDesktop","getTargets","options","configPath","shouldParseBrowsers","hasTargets","shouldSearchForConfig","ignoreBrowserslistConfig","loadConfig","config","configFile","path","browserslistEnv","_browsers","map","join","_browsers2","queryBrowsers","esmSupportVersion","assign","result","decimalWarnings","sort","push","parsedTarget","parsedValue"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-compilation-targets\\src\\index.ts"],"sourcesContent":["import browserslist from \"browserslist\";\nimport { findSuggestion } from \"@babel/helper-validator-option\";\nimport browserModulesData from \"@babel/compat-data/native-modules\";\n\nimport {\n  semverify,\n  semverMin,\n  isUnreleasedVersion,\n  getLowestUnreleased,\n  getHighestUnreleased,\n} from \"./utils\";\nimport { OptionValidator } from \"@babel/helper-validator-option\";\nimport { browserNameMap } from \"./targets\";\nimport { TargetNames } from \"./options\";\nimport type {\n  Target,\n  Targets,\n  InputTargets,\n  Browsers,\n  BrowserslistBrowserName,\n  TargetsTuple,\n} from \"./types\";\n\nexport type { Target, Targets, InputTargets };\n\nexport { prettifyTargets } from \"./pretty\";\nexport { getInclusionReasons } from \"./debug\";\nexport { default as filterItems, isRequired } from \"./filter-items\";\nexport { unreleasedLabels } from \"./targets\";\nexport { TargetNames };\n\nconst ESM_SUPPORT = browserModulesData[\"es6.module\"];\n\ndeclare const PACKAGE_JSON: { name: string; version: string };\nconst v = new OptionValidator(PACKAGE_JSON.name);\n\nfunction validateTargetNames(targets: Targets): TargetsTuple {\n  const validTargets = Object.keys(TargetNames);\n  for (const target of Object.keys(targets)) {\n    if (!(target in TargetNames)) {\n      throw new Error(\n        v.formatMessage(`'${target}' is not a valid target\n- Did you mean '${findSuggestion(target, validTargets)}'?`),\n      );\n    }\n  }\n\n  return targets as any;\n}\n\nexport function isBrowsersQueryValid(browsers: unknown): boolean {\n  return (\n    typeof browsers === \"string\" ||\n    (Array.isArray(browsers) && browsers.every(b => typeof b === \"string\"))\n  );\n}\n\nfunction validateBrowsers(browsers: Browsers | undefined) {\n  v.invariant(\n    browsers === undefined || isBrowsersQueryValid(browsers),\n    `'${String(browsers)}' is not a valid browserslist query`,\n  );\n\n  return browsers;\n}\n\nfunction getLowestVersions(browsers: Array<string>): Targets {\n  return browsers.reduce((all, browser) => {\n    const [browserName, browserVersion] = browser.split(\" \") as [\n      BrowserslistBrowserName,\n      string,\n    ];\n    const target: Target = browserNameMap[browserName];\n\n    if (!target) {\n      return all;\n    }\n\n    try {\n      // Browser version can return as \"10.0-10.2\"\n      const splitVersion = browserVersion.split(\"-\")[0].toLowerCase();\n      const isSplitUnreleased = isUnreleasedVersion(splitVersion, target);\n\n      if (!all[target]) {\n        all[target] = isSplitUnreleased\n          ? splitVersion\n          : semverify(splitVersion);\n        return all;\n      }\n\n      const version = all[target];\n      const isUnreleased = isUnreleasedVersion(version, target);\n\n      if (isUnreleased && isSplitUnreleased) {\n        all[target] = getLowestUnreleased(version, splitVersion, target);\n      } else if (isUnreleased) {\n        all[target] = semverify(splitVersion);\n      } else if (!isUnreleased && !isSplitUnreleased) {\n        const parsedBrowserVersion = semverify(splitVersion);\n\n        all[target] = semverMin(version, parsedBrowserVersion);\n      }\n    } catch (e) {}\n\n    return all;\n  }, {} as Record<Target, string>);\n}\n\nfunction outputDecimalWarning(\n  decimalTargets: Array<{ target: string; value: number }>,\n): void {\n  if (!decimalTargets.length) {\n    return;\n  }\n\n  console.warn(\"Warning, the following targets are using a decimal version:\\n\");\n  decimalTargets.forEach(({ target, value }) =>\n    console.warn(`  ${target}: ${value}`),\n  );\n  console.warn(`\nWe recommend using a string for minor/patch versions to avoid numbers like 6.10\ngetting parsed as 6.1, which can lead to unexpected behavior.\n`);\n}\n\nfunction semverifyTarget(target: keyof Targets, value: string) {\n  try {\n    return semverify(value);\n  } catch (error) {\n    throw new Error(\n      v.formatMessage(\n        `'${value}' is not a valid value for 'targets.${target}'.`,\n      ),\n    );\n  }\n}\n\n// Parse `node: true` and `node: \"current\"` to version\nfunction nodeTargetParser(value: true | string) {\n  const parsed =\n    value === true || value === \"current\"\n      ? process.versions.node\n      : semverifyTarget(\"node\", value);\n  return [\"node\" as const, parsed] as const;\n}\n\nfunction defaultTargetParser(\n  target: Exclude<Target, \"node\">,\n  value: string,\n): readonly [Exclude<Target, \"node\">, string] {\n  const version = isUnreleasedVersion(value, target)\n    ? value.toLowerCase()\n    : semverifyTarget(target, value);\n  return [target, version] as const;\n}\n\nfunction generateTargets(inputTargets: InputTargets): Targets {\n  const input = { ...inputTargets };\n  delete input.esmodules;\n  delete input.browsers;\n  return input as any as Targets;\n}\n\nfunction resolveTargets(queries: Browsers, env?: string): Targets {\n  const resolved = browserslist(queries, {\n    mobileToDesktop: true,\n    env,\n  });\n  return getLowestVersions(resolved);\n}\n\ntype GetTargetsOption = {\n  // This is not the path of the config file, but the path where start searching it from\n  configPath?: string;\n  // The path of the config file\n  configFile?: string;\n  // The env to pass to browserslist\n  browserslistEnv?: string;\n  // true to disable config loading\n  ignoreBrowserslistConfig?: boolean;\n};\n\nexport default function getTargets(\n  inputTargets: InputTargets = {} as InputTargets,\n  options: GetTargetsOption = {},\n): Targets {\n  let { browsers, esmodules } = inputTargets;\n  const { configPath = \".\" } = options;\n\n  validateBrowsers(browsers);\n\n  const input = generateTargets(inputTargets);\n  let targets: TargetsTuple = validateTargetNames(input);\n\n  const shouldParseBrowsers = !!browsers;\n  const hasTargets = shouldParseBrowsers || Object.keys(targets).length > 0;\n  const shouldSearchForConfig =\n    !options.ignoreBrowserslistConfig && !hasTargets;\n\n  if (!browsers && shouldSearchForConfig) {\n    browsers = browserslist.loadConfig({\n      config: options.configFile,\n      path: configPath,\n      env: options.browserslistEnv,\n    });\n    if (browsers == null) {\n      if (process.env.BABEL_8_BREAKING) {\n        // In Babel 8, if no targets are passed, we use browserslist's defaults\n        // and exclude IE 11.\n        browsers = [\"defaults, not ie 11\"];\n      } else {\n        // If no targets are passed, we need to overwrite browserslist's defaults\n        // so that we enable all transforms (acting like the now deprecated\n        // preset-latest).\n        browsers = [];\n      }\n    }\n  }\n\n  // `esmodules` as a target indicates the specific set of browsers supporting ES Modules.\n  // These values OVERRIDE the `browsers` field.\n  if (esmodules && (esmodules !== \"intersect\" || !browsers?.length)) {\n    browsers = Object.keys(ESM_SUPPORT)\n      .map(\n        (browser: keyof typeof ESM_SUPPORT) =>\n          `${browser} >= ${ESM_SUPPORT[browser]}`,\n      )\n      .join(\", \");\n    esmodules = false;\n  }\n\n  // If current value of `browsers` is undefined (`ignoreBrowserslistConfig` should be `false`)\n  // or an empty array (without any user config, use default config),\n  // we don't need to call `resolveTargets` to execute the related methods of `browserslist` library.\n  if (browsers?.length) {\n    const queryBrowsers = resolveTargets(browsers, options.browserslistEnv);\n\n    if (esmodules === \"intersect\") {\n      for (const browser of Object.keys(queryBrowsers) as Target[]) {\n        const version = queryBrowsers[browser];\n        const esmSupportVersion =\n          // @ts-expect-error ie is not in ESM_SUPPORT\n          ESM_SUPPORT[browser];\n\n        if (esmSupportVersion) {\n          queryBrowsers[browser] = getHighestUnreleased(\n            version,\n            semverify(esmSupportVersion),\n            browser,\n          );\n        } else {\n          delete queryBrowsers[browser];\n        }\n      }\n    }\n\n    targets = Object.assign(queryBrowsers, targets);\n  }\n\n  // Parse remaining targets\n  const result: Targets = {} as Targets;\n  const decimalWarnings = [];\n  for (const target of Object.keys(targets).sort() as Target[]) {\n    const value = targets[target];\n\n    // Warn when specifying minor/patch as a decimal\n    if (typeof value === \"number\" && value % 1 !== 0) {\n      decimalWarnings.push({ target, value });\n    }\n\n    const [parsedTarget, parsedValue] =\n      target === \"node\"\n        ? nodeTargetParser(value)\n        : defaultTargetParser(target, value as string);\n\n    if (parsedValue) {\n      // Merge (lowest wins)\n      result[parsedTarget] = parsedValue;\n    }\n  }\n\n  outputDecimalWarning(decimalWarnings);\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"script"}