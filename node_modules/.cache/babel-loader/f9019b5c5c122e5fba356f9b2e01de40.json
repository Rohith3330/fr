{"ast":null,"code":"import Literal from '../Literal';\nimport JSXElement from '../JSXElement';\nimport JSXFragment from '../JSXFragment';\nimport JSXText from '../JSXText';\nimport Identifier from './Identifier';\nimport TaggedTemplateExpression from './TaggedTemplateExpression';\nimport TemplateLiteral from './TemplateLiteral';\nimport FunctionExpression from './FunctionExpression';\nimport LogicalExpression from './LogicalExpression';\nimport MemberExpression from './MemberExpression';\nimport ChainExpression from './ChainExpression';\nimport OptionalCallExpression from './OptionalCallExpression';\nimport OptionalMemberExpression from './OptionalMemberExpression';\nimport CallExpression from './CallExpression';\nimport UnaryExpression from './UnaryExpression';\nimport ThisExpression from './ThisExpression';\nimport ConditionalExpression from './ConditionalExpression';\nimport BinaryExpression from './BinaryExpression';\nimport ObjectExpression from './ObjectExpression';\nimport NewExpression from './NewExpression';\nimport UpdateExpression from './UpdateExpression';\nimport ArrayExpression from './ArrayExpression';\nimport BindExpression from './BindExpression';\nimport SpreadElement from './SpreadElement';\nimport TypeCastExpression from './TypeCastExpression';\nimport SequenceExpression from './SequenceExpression';\nimport TSNonNullExpression from './TSNonNullExpression';\nimport AssignmentExpression from './AssignmentExpression'; // Composition map of types to their extractor functions.\n\nconst TYPES = {\n  Identifier,\n  Literal,\n  JSXElement,\n  JSXFragment,\n  JSXText,\n  TaggedTemplateExpression,\n  TemplateLiteral,\n  ArrowFunctionExpression: FunctionExpression,\n  FunctionExpression,\n  LogicalExpression,\n  MemberExpression,\n  ChainExpression,\n  OptionalCallExpression,\n  OptionalMemberExpression,\n  CallExpression,\n  UnaryExpression,\n  ThisExpression,\n  ConditionalExpression,\n  BinaryExpression,\n  ObjectExpression,\n  NewExpression,\n  UpdateExpression,\n  ArrayExpression,\n  BindExpression,\n  SpreadElement,\n  TypeCastExpression,\n  SequenceExpression,\n  TSNonNullExpression,\n  AssignmentExpression\n};\n\nconst noop = () => null;\n\nconst errorMessage = expression => `The prop value with an expression type of ${expression} could not be resolved. Please file an issue ( https://github.com/jsx-eslint/jsx-ast-utils/issues/new ) to get this fixed immediately.`;\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *all* possible expression types.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\n\n\nexport default function extract(value) {\n  // Value will not have the expression property when we recurse.\n  // The type for expression on ArrowFunctionExpression is a boolean.\n  let expression;\n\n  if (typeof value.expression !== 'boolean' && value.expression) {\n    expression = value.expression; // eslint-disable-line prefer-destructuring\n  } else {\n    expression = value;\n  }\n\n  let {\n    type\n  } = expression; // Typescript NonNull Expression is wrapped & it would end up in the wrong extractor\n\n  if (expression.object && expression.object.type === 'TSNonNullExpression') {\n    type = 'TSNonNullExpression';\n  }\n\n  while (type === 'TSAsExpression') {\n    ({\n      type\n    } = expression);\n\n    if (expression.expression) {\n      ({\n        expression\n      } = expression);\n    }\n  }\n\n  if (TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return TYPES[type](expression);\n} // Composition map of types to their extractor functions to handle literals.\n\nconst LITERAL_TYPES = { ...TYPES,\n  Literal: value => {\n    const extractedVal = TYPES.Literal.call(undefined, value);\n    const isNull = extractedVal === null; // This will be convention for attributes that have null\n    // value explicitly defined (<div prop={null} /> maps to 'null').\n\n    return isNull ? 'null' : extractedVal;\n  },\n  Identifier: value => {\n    const isUndefined = TYPES.Identifier.call(undefined, value) === undefined;\n    return isUndefined ? undefined : null;\n  },\n  JSXElement: noop,\n  JSXFragment: noop,\n  JSXText: noop,\n  ArrowFunctionExpression: noop,\n  FunctionExpression: noop,\n  LogicalExpression: noop,\n  MemberExpression: noop,\n  OptionalCallExpression: noop,\n  OptionalMemberExpression: noop,\n  CallExpression: noop,\n  UnaryExpression: value => {\n    const extractedVal = TYPES.UnaryExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  UpdateExpression: value => {\n    const extractedVal = TYPES.UpdateExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  ThisExpression: noop,\n  ConditionalExpression: noop,\n  BinaryExpression: noop,\n  ObjectExpression: noop,\n  NewExpression: noop,\n  ArrayExpression: value => {\n    const extractedVal = TYPES.ArrayExpression.call(undefined, value);\n    return extractedVal.filter(val => val !== null);\n  },\n  BindExpression: noop,\n  SpreadElement: noop,\n  TSNonNullExpression: noop,\n  TSAsExpression: noop,\n  TypeCastExpression: noop,\n  SequenceExpression: noop,\n  ChainExpression: noop\n};\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *some* possible types that map to literals.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\n\nexport function extractLiteral(value) {\n  // Value will not have the expression property when we recurse.\n  const expression = value.expression || value;\n  const {\n    type\n  } = expression;\n\n  if (LITERAL_TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return LITERAL_TYPES[type](expression);\n}","map":{"version":3,"names":["Literal","JSXElement","JSXFragment","JSXText","Identifier","TaggedTemplateExpression","TemplateLiteral","FunctionExpression","LogicalExpression","MemberExpression","ChainExpression","OptionalCallExpression","OptionalMemberExpression","CallExpression","UnaryExpression","ThisExpression","ConditionalExpression","BinaryExpression","ObjectExpression","NewExpression","UpdateExpression","ArrayExpression","BindExpression","SpreadElement","TypeCastExpression","SequenceExpression","TSNonNullExpression","AssignmentExpression","TYPES","ArrowFunctionExpression","noop","errorMessage","expression","extract","value","type","object","undefined","console","error","LITERAL_TYPES","extractedVal","call","isNull","isUndefined","filter","val","TSAsExpression","extractLiteral"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jsx-ast-utils/src/values/expressions/index.js"],"sourcesContent":["import Literal from '../Literal';\nimport JSXElement from '../JSXElement';\nimport JSXFragment from '../JSXFragment';\nimport JSXText from '../JSXText';\nimport Identifier from './Identifier';\nimport TaggedTemplateExpression from './TaggedTemplateExpression';\nimport TemplateLiteral from './TemplateLiteral';\nimport FunctionExpression from './FunctionExpression';\nimport LogicalExpression from './LogicalExpression';\nimport MemberExpression from './MemberExpression';\nimport ChainExpression from './ChainExpression';\nimport OptionalCallExpression from './OptionalCallExpression';\nimport OptionalMemberExpression from './OptionalMemberExpression';\nimport CallExpression from './CallExpression';\nimport UnaryExpression from './UnaryExpression';\nimport ThisExpression from './ThisExpression';\nimport ConditionalExpression from './ConditionalExpression';\nimport BinaryExpression from './BinaryExpression';\nimport ObjectExpression from './ObjectExpression';\nimport NewExpression from './NewExpression';\nimport UpdateExpression from './UpdateExpression';\nimport ArrayExpression from './ArrayExpression';\nimport BindExpression from './BindExpression';\nimport SpreadElement from './SpreadElement';\nimport TypeCastExpression from './TypeCastExpression';\nimport SequenceExpression from './SequenceExpression';\nimport TSNonNullExpression from './TSNonNullExpression';\nimport AssignmentExpression from './AssignmentExpression';\n\n// Composition map of types to their extractor functions.\nconst TYPES = {\n  Identifier,\n  Literal,\n  JSXElement,\n  JSXFragment,\n  JSXText,\n  TaggedTemplateExpression,\n  TemplateLiteral,\n  ArrowFunctionExpression: FunctionExpression,\n  FunctionExpression,\n  LogicalExpression,\n  MemberExpression,\n  ChainExpression,\n  OptionalCallExpression,\n  OptionalMemberExpression,\n  CallExpression,\n  UnaryExpression,\n  ThisExpression,\n  ConditionalExpression,\n  BinaryExpression,\n  ObjectExpression,\n  NewExpression,\n  UpdateExpression,\n  ArrayExpression,\n  BindExpression,\n  SpreadElement,\n  TypeCastExpression,\n  SequenceExpression,\n  TSNonNullExpression,\n  AssignmentExpression,\n};\n\nconst noop = () => null;\n\nconst errorMessage = (expression) => `The prop value with an expression type of ${expression} could not be resolved. Please file an issue ( https://github.com/jsx-eslint/jsx-ast-utils/issues/new ) to get this fixed immediately.`;\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *all* possible expression types.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\nexport default function extract(value) {\n  // Value will not have the expression property when we recurse.\n  // The type for expression on ArrowFunctionExpression is a boolean.\n  let expression;\n  if (\n    typeof value.expression !== 'boolean'\n    && value.expression\n  ) {\n    expression = value.expression; // eslint-disable-line prefer-destructuring\n  } else {\n    expression = value;\n  }\n  let { type } = expression;\n\n  // Typescript NonNull Expression is wrapped & it would end up in the wrong extractor\n  if (expression.object && expression.object.type === 'TSNonNullExpression') {\n    type = 'TSNonNullExpression';\n  }\n\n  while (type === 'TSAsExpression') {\n    ({ type } = expression);\n    if (expression.expression) {\n      ({ expression } = expression);\n    }\n  }\n\n  if (TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return TYPES[type](expression);\n}\n\n// Composition map of types to their extractor functions to handle literals.\nconst LITERAL_TYPES = {\n  ...TYPES,\n  Literal: (value) => {\n    const extractedVal = TYPES.Literal.call(undefined, value);\n    const isNull = extractedVal === null;\n    // This will be convention for attributes that have null\n    // value explicitly defined (<div prop={null} /> maps to 'null').\n    return isNull ? 'null' : extractedVal;\n  },\n  Identifier: (value) => {\n    const isUndefined = TYPES.Identifier.call(undefined, value) === undefined;\n    return isUndefined ? undefined : null;\n  },\n  JSXElement: noop,\n  JSXFragment: noop,\n  JSXText: noop,\n  ArrowFunctionExpression: noop,\n  FunctionExpression: noop,\n  LogicalExpression: noop,\n  MemberExpression: noop,\n  OptionalCallExpression: noop,\n  OptionalMemberExpression: noop,\n  CallExpression: noop,\n  UnaryExpression: (value) => {\n    const extractedVal = TYPES.UnaryExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  UpdateExpression: (value) => {\n    const extractedVal = TYPES.UpdateExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  ThisExpression: noop,\n  ConditionalExpression: noop,\n  BinaryExpression: noop,\n  ObjectExpression: noop,\n  NewExpression: noop,\n  ArrayExpression: (value) => {\n    const extractedVal = TYPES.ArrayExpression.call(undefined, value);\n    return extractedVal.filter((val) => val !== null);\n  },\n  BindExpression: noop,\n  SpreadElement: noop,\n  TSNonNullExpression: noop,\n  TSAsExpression: noop,\n  TypeCastExpression: noop,\n  SequenceExpression: noop,\n  ChainExpression: noop,\n};\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *some* possible types that map to literals.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\nexport function extractLiteral(value) {\n  // Value will not have the expression property when we recurse.\n  const expression = value.expression || value;\n  const { type } = expression;\n\n  if (LITERAL_TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return LITERAL_TYPES[type](expression);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}