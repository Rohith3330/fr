{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'require-await',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow async functions which have no `await` expression',\n      recommended: 'error',\n      requiresTypeChecking: true,\n      extendsBaseRule: true\n    },\n    schema: [],\n    messages: {\n      missingAwait: \"{{name}} has no 'await' expression.\"\n    }\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n    /**\n     * Push the scope info object to the stack.\n     */\n\n    function enterFunction(node) {\n      scopeInfo = {\n        upper: scopeInfo,\n        hasAwait: false,\n        hasAsync: node.async,\n        isGen: node.generator || false,\n        isAsyncYield: false\n      };\n    }\n    /**\n     * Pop the top scope info object from the stack.\n     * Also, it reports the function if needed.\n     */\n\n\n    function exitFunction(node) {\n      /* istanbul ignore if */\n      if (!scopeInfo) {\n        // this shouldn't ever happen, as we have to exit a function after we enter it\n        return;\n      }\n\n      if (node.async && !scopeInfo.hasAwait && !isEmptyFunction(node) && !(scopeInfo.isGen && scopeInfo.isAsyncYield)) {\n        context.report({\n          node,\n          loc: getFunctionHeadLoc(node, sourceCode),\n          messageId: 'missingAwait',\n          data: {\n            name: util.upperCaseFirst(util.getFunctionNameWithKind(node))\n          }\n        });\n      }\n\n      scopeInfo = scopeInfo.upper;\n    }\n    /**\n     * Checks if the node returns a thenable type\n     */\n\n\n    function isThenableType(node) {\n      const type = checker.getTypeAtLocation(node);\n      return tsutils.isThenableType(checker, node, type);\n    }\n    /**\n     * Marks the current scope as having an await\n     */\n\n\n    function markAsHasAwait() {\n      if (!scopeInfo) {\n        return;\n      }\n\n      scopeInfo.hasAwait = true;\n    }\n    /**\n     * mark `scopeInfo.isAsyncYield` to `true` if its a generator\n     * function and the delegate is `true`\n     */\n\n\n    function markAsHasDelegateGen(node) {\n      var _a;\n\n      if (!(scopeInfo === null || scopeInfo === void 0 ? void 0 : scopeInfo.isGen) || !node.argument) {\n        return;\n      }\n\n      if (((_a = node === null || node === void 0 ? void 0 : node.argument) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.Literal) {\n        // making this `false` as for literals we don't need to check the definition\n        // eg : async function* run() { yield* 1 }\n        scopeInfo.isAsyncYield || (scopeInfo.isAsyncYield = false);\n      }\n\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node === null || node === void 0 ? void 0 : node.argument);\n      const type = checker.getTypeAtLocation(tsNode);\n      const typesToCheck = expandUnionOrIntersectionType(type);\n\n      for (const type of typesToCheck) {\n        const asyncIterator = tsutils.getWellKnownSymbolPropertyOfType(type, 'asyncIterator', checker);\n\n        if (asyncIterator !== undefined) {\n          scopeInfo.isAsyncYield = true;\n          break;\n        }\n      }\n    }\n\n    return {\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n      ArrowFunctionExpression: enterFunction,\n      'FunctionDeclaration:exit': exitFunction,\n      'FunctionExpression:exit': exitFunction,\n      'ArrowFunctionExpression:exit': exitFunction,\n      AwaitExpression: markAsHasAwait,\n      'ForOfStatement[await = true]': markAsHasAwait,\n      'YieldExpression[delegate = true]': markAsHasDelegateGen,\n\n      // check body-less async arrow function.\n      // ignore `async () => await foo` because it's obviously correct\n      'ArrowFunctionExpression[async = true] > :not(BlockStatement, AwaitExpression)'(node) {\n        const expression = parserServices.esTreeNodeToTSNodeMap.get(node);\n\n        if (expression && isThenableType(expression)) {\n          markAsHasAwait();\n        }\n      },\n\n      ReturnStatement(node) {\n        // short circuit early to avoid unnecessary type checks\n        if (!scopeInfo || scopeInfo.hasAwait || !scopeInfo.hasAsync) {\n          return;\n        }\n\n        const {\n          expression\n        } = parserServices.esTreeNodeToTSNodeMap.get(node);\n\n        if (expression && isThenableType(expression)) {\n          markAsHasAwait();\n        }\n      }\n\n    };\n  }\n\n});\n\nfunction isEmptyFunction(node) {\n  var _a;\n\n  return ((_a = node.body) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.BlockStatement && node.body.body.length === 0;\n} // https://github.com/eslint/eslint/blob/03a69dbe86d5b5768a310105416ae726822e3c1c/lib/rules/utils/ast-utils.js#L382-L392\n\n/**\n * Gets the `(` token of the given function node.\n */\n\n\nfunction getOpeningParenOfParams(node, sourceCode) {\n  return util.nullThrows(node.id ? sourceCode.getTokenAfter(node.id, util.isOpeningParenToken) : sourceCode.getFirstToken(node, util.isOpeningParenToken), util.NullThrowsReasons.MissingToken('(', node.type));\n} // https://github.com/eslint/eslint/blob/03a69dbe86d5b5768a310105416ae726822e3c1c/lib/rules/utils/ast-utils.js#L1220-L1242\n\n/**\n * Gets the location of the given function node for reporting.\n */\n\n\nfunction getFunctionHeadLoc(node, sourceCode) {\n  const parent = util.nullThrows(node.parent, util.NullThrowsReasons.MissingParent);\n  let start = null;\n  let end = null;\n\n  if (node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression) {\n    const arrowToken = util.nullThrows(sourceCode.getTokenBefore(node.body, util.isArrowToken), util.NullThrowsReasons.MissingToken('=>', node.type));\n    start = arrowToken.loc.start;\n    end = arrowToken.loc.end;\n  } else if (parent.type === utils_1.AST_NODE_TYPES.Property || parent.type === utils_1.AST_NODE_TYPES.MethodDefinition) {\n    start = parent.loc.start;\n    end = getOpeningParenOfParams(node, sourceCode).loc.start;\n  } else {\n    start = node.loc.start;\n    end = getOpeningParenOfParams(node, sourceCode).loc.start;\n  }\n\n  return {\n    start,\n    end\n  };\n}\n\nfunction expandUnionOrIntersectionType(type) {\n  if (type.isUnionOrIntersection()) {\n    return type.types.flatMap(expandUnionOrIntersectionType);\n  }\n\n  return [type];\n}","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","extendsBaseRule","schema","messages","missingAwait","defaultOptions","create","context","parserServices","getParserServices","checker","program","getTypeChecker","sourceCode","getSourceCode","scopeInfo","enterFunction","node","upper","hasAwait","hasAsync","async","isGen","generator","isAsyncYield","exitFunction","isEmptyFunction","report","loc","getFunctionHeadLoc","messageId","data","upperCaseFirst","getFunctionNameWithKind","isThenableType","getTypeAtLocation","tsutils","markAsHasAwait","markAsHasDelegateGen","argument","_a","utils_1","Literal","tsNode","esTreeNodeToTSNodeMap","get","typesToCheck","expandUnionOrIntersectionType","asyncIterator","getWellKnownSymbolPropertyOfType","undefined","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","AwaitExpression","expression","ReturnStatement","body","BlockStatement","length","getOpeningParenOfParams","nullThrows","id","getTokenAfter","isOpeningParenToken","getFirstToken","NullThrowsReasons","MissingToken","parent","MissingParent","start","end","arrowToken","getTokenBefore","isArrowToken","Property","MethodDefinition","isUnionOrIntersection","types","flatMap"],"sources":["../../src/rules/require-await.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}