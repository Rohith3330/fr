{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.sourcemapCodec = {}));\n})(this, function (exports) {\n  'use strict';\n\n  var charToInteger = {};\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  for (var i = 0; i < chars.length; i++) {\n    charToInteger[chars.charCodeAt(i)] = i;\n  }\n\n  function decode(mappings) {\n    var decoded = [];\n    var line = [];\n    var segment = [0, 0, 0, 0, 0];\n    var j = 0;\n\n    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n      var c = mappings.charCodeAt(i);\n\n      if (c === 44) {\n        // \",\"\n        segmentify(line, segment, j);\n        j = 0;\n      } else if (c === 59) {\n        // \";\"\n        segmentify(line, segment, j);\n        j = 0;\n        decoded.push(line);\n        line = [];\n        segment[0] = 0;\n      } else {\n        var integer = charToInteger[c];\n\n        if (integer === undefined) {\n          throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n        }\n\n        var hasContinuationBit = integer & 32;\n        integer &= 31;\n        value += integer << shift;\n\n        if (hasContinuationBit) {\n          shift += 5;\n        } else {\n          var shouldNegate = value & 1;\n          value >>>= 1;\n\n          if (shouldNegate) {\n            value = value === 0 ? -0x80000000 : -value;\n          }\n\n          segment[j] += value;\n          j++;\n          value = shift = 0; // reset\n        }\n      }\n    }\n\n    segmentify(line, segment, j);\n    decoded.push(line);\n    return decoded;\n  }\n\n  function segmentify(line, segment, j) {\n    // This looks ugly, but we're creating specialized arrays with a specific\n    // length. This is much faster than creating a new array (which v8 expands to\n    // a capacity of 17 after pushing the first item), or slicing out a subarray\n    // (which is slow). Length 4 is assumed to be the most frequent, followed by\n    // length 5 (since not everything will have an associated name), followed by\n    // length 1 (it's probably rare for a source substring to not have an\n    // associated segment data).\n    if (j === 4) line.push([segment[0], segment[1], segment[2], segment[3]]);else if (j === 5) line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);else if (j === 1) line.push([segment[0]]);\n  }\n\n  function encode(decoded) {\n    var sourceFileIndex = 0; // second field\n\n    var sourceCodeLine = 0; // third field\n\n    var sourceCodeColumn = 0; // fourth field\n\n    var nameIndex = 0; // fifth field\n\n    var mappings = '';\n\n    for (var i = 0; i < decoded.length; i++) {\n      var line = decoded[i];\n      if (i > 0) mappings += ';';\n      if (line.length === 0) continue;\n      var generatedCodeColumn = 0; // first field\n\n      var lineMappings = [];\n\n      for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n        var segment = line_1[_i];\n        var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n        generatedCodeColumn = segment[0];\n\n        if (segment.length > 1) {\n          segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);\n          sourceFileIndex = segment[1];\n          sourceCodeLine = segment[2];\n          sourceCodeColumn = segment[3];\n        }\n\n        if (segment.length === 5) {\n          segmentMappings += encodeInteger(segment[4] - nameIndex);\n          nameIndex = segment[4];\n        }\n\n        lineMappings.push(segmentMappings);\n      }\n\n      mappings += lineMappings.join(',');\n    }\n\n    return mappings;\n  }\n\n  function encodeInteger(num) {\n    var result = '';\n    num = num < 0 ? -num << 1 | 1 : num << 1;\n\n    do {\n      var clamped = num & 31;\n      num >>>= 5;\n\n      if (num > 0) {\n        clamped |= 32;\n      }\n\n      result += chars[clamped];\n    } while (num > 0);\n\n    return result;\n  }\n\n  exports.decode = decode;\n  exports.encode = encode;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":"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","names":["charToInteger","chars","i","length","charCodeAt","decode","mappings","decoded","line","segment","j","shift","value","c","segmentify","push","integer","undefined","Error","String","fromCharCode","hasContinuationBit","shouldNegate","encode","sourceFileIndex","sourceCodeLine","sourceCodeColumn","nameIndex","generatedCodeColumn","lineMappings","_i","segmentMappings","encodeInteger","join","num","result","clamped"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\sourcemap-codec\\src\\sourcemap-codec.ts"],"sourcesContent":["export type SourceMapSegment =\n\t| [number]\n\t| [number, number, number, number]\n\t| [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nconst charToInteger: { [charCode: number]: number } = {};\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfor (let i = 0; i < chars.length; i++) {\n\tcharToInteger[chars.charCodeAt(i)] = i;\n}\n\nexport function decode(mappings: string): SourceMapMappings {\n\tconst decoded: SourceMapMappings = [];\n\tlet line: SourceMapLine = [];\n\tconst segment: SourceMapSegment = [\n\t\t0, // generated code column\n\t\t0, // source file index\n\t\t0, // source code line\n\t\t0, // source code column\n\t\t0, // name index\n\t];\n\n\tlet j = 0;\n\tfor (let i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n\t\tconst c = mappings.charCodeAt(i);\n\n\t\tif (c === 44) { // \",\"\n\t\t\tsegmentify(line, segment, j);\n\t\t\tj = 0;\n\n\t\t} else if (c === 59) { // \";\"\n\t\t\tsegmentify(line, segment, j);\n\t\t\tj = 0;\n\t\t\tdecoded.push(line);\n\t\t\tline = [];\n\t\t\tsegment[0] = 0;\n\n\t\t} else {\n\t\t\tlet integer = charToInteger[c];\n\t\t\tif (integer === undefined) {\n\t\t\t\tthrow new Error('Invalid character (' + String.fromCharCode(c) + ')');\n\t\t\t}\n\n\t\t\tconst hasContinuationBit = integer & 32;\n\n\t\t\tinteger &= 31;\n\t\t\tvalue += integer << shift;\n\n\t\t\tif (hasContinuationBit) {\n\t\t\t\tshift += 5;\n\t\t\t} else {\n\t\t\t\tconst shouldNegate = value & 1;\n\t\t\t\tvalue >>>= 1;\n\n\t\t\t\tif (shouldNegate) {\n\t\t\t\t\tvalue = value === 0 ? -0x80000000 : -value;\n\t\t\t\t}\n\n\t\t\t\tsegment[j] += value;\n\t\t\t\tj++;\n\t\t\t\tvalue = shift = 0; // reset\n\t\t\t}\n\t\t}\n\t}\n\n\tsegmentify(line, segment, j);\n\tdecoded.push(line);\n\n\treturn decoded;\n}\n\nfunction segmentify(line: SourceMapSegment[], segment: SourceMapSegment, j: number) {\n\t// This looks ugly, but we're creating specialized arrays with a specific\n\t// length. This is much faster than creating a new array (which v8 expands to\n\t// a capacity of 17 after pushing the first item), or slicing out a subarray\n\t// (which is slow). Length 4 is assumed to be the most frequent, followed by\n\t// length 5 (since not everything will have an associated name), followed by\n\t// length 1 (it's probably rare for a source substring to not have an\n\t// associated segment data).\n\tif (j === 4) line.push([segment[0], segment[1], segment[2], segment[3]]);\n\telse if (j === 5) line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n\telse if (j === 1) line.push([segment[0]]);\n}\n\nexport function encode(decoded: SourceMapMappings): string {\n\tlet sourceFileIndex = 0;  // second field\n\tlet sourceCodeLine = 0;   // third field\n\tlet sourceCodeColumn = 0; // fourth field\n\tlet nameIndex = 0;        // fifth field\n\tlet mappings = '';\n\n\tfor (let i = 0; i < decoded.length; i++) {\n\t\tconst line = decoded[i];\n\t\tif (i > 0) mappings += ';';\n\t\tif (line.length === 0) continue;\n\n\t\tlet generatedCodeColumn = 0; // first field\n\n\t\tconst lineMappings: string[] = [];\n\n\t\tfor (const segment of line) {\n\t\t\tlet segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n\t\t\tgeneratedCodeColumn = segment[0];\n\n\t\t\tif (segment.length > 1) {\n\t\t\t\tsegmentMappings +=\n\t\t\t\t\tencodeInteger(segment[1] - sourceFileIndex) +\n\t\t\t\t\tencodeInteger(segment[2] - sourceCodeLine) +\n\t\t\t\t\tencodeInteger(segment[3] - sourceCodeColumn);\n\n\t\t\t\tsourceFileIndex = segment[1];\n\t\t\t\tsourceCodeLine = segment[2];\n\t\t\t\tsourceCodeColumn = segment[3];\n\t\t\t}\n\n\t\t\tif (segment.length === 5) {\n\t\t\t\tsegmentMappings += encodeInteger(segment[4] - nameIndex);\n\t\t\t\tnameIndex = segment[4];\n\t\t\t}\n\n\t\t\tlineMappings.push(segmentMappings);\n\t\t}\n\n\t\tmappings += lineMappings.join(',');\n\t}\n\n\treturn mappings;\n}\n\nfunction encodeInteger(num: number): string {\n\tvar result = '';\n\tnum = num < 0 ? (-num << 1) | 1 : num << 1;\n\tdo {\n\t\tvar clamped = num & 31;\n\t\tnum >>>= 5;\n\t\tif (num > 0) {\n\t\t\tclamped |= 32;\n\t\t}\n\t\tresult += chars[clamped];\n\t} while (num > 0);\n\n\treturn result;\n}\n"]},"metadata":{},"sourceType":"script"}