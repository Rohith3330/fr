{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'triple-slash-reference',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow certain triple slash directives in favor of ES6-style import declarations',\n      recommended: 'error'\n    },\n    messages: {\n      tripleSlashReference: 'Do not use a triple slash reference for {{module}}, use `import` style instead.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        lib: {\n          enum: ['always', 'never']\n        },\n        path: {\n          enum: ['always', 'never']\n        },\n        types: {\n          enum: ['always', 'never', 'prefer-import']\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    lib: 'always',\n    path: 'never',\n    types: 'prefer-import'\n  }],\n\n  create(context, _ref) {\n    let [{\n      lib,\n      path,\n      types\n    }] = _ref;\n    let programNode;\n    const sourceCode = context.getSourceCode();\n    const references = [];\n\n    function hasMatchingReference(source) {\n      references.forEach(reference => {\n        if (reference.importName === source.value) {\n          context.report({\n            node: reference.comment,\n            messageId: 'tripleSlashReference',\n            data: {\n              module: reference.importName\n            }\n          });\n        }\n      });\n    }\n\n    return {\n      ImportDeclaration(node) {\n        if (programNode) {\n          hasMatchingReference(node.source);\n        }\n      },\n\n      TSImportEqualsDeclaration(node) {\n        if (programNode) {\n          const reference = node.moduleReference;\n\n          if (reference.type === utils_1.AST_NODE_TYPES.TSExternalModuleReference) {\n            hasMatchingReference(reference.expression);\n          }\n        }\n      },\n\n      Program(node) {\n        if (lib === 'always' && path === 'always' && types == 'always') {\n          return;\n        }\n\n        programNode = node;\n        const referenceRegExp = /^\\/\\s*<reference\\s*(types|path|lib)\\s*=\\s*[\"|'](.*)[\"|']/;\n        const commentsBefore = sourceCode.getCommentsBefore(programNode);\n        commentsBefore.forEach(comment => {\n          if (comment.type !== utils_1.AST_TOKEN_TYPES.Line) {\n            return;\n          }\n\n          const referenceResult = referenceRegExp.exec(comment.value);\n\n          if (referenceResult) {\n            if (referenceResult[1] === 'types' && types === 'never' || referenceResult[1] === 'path' && path === 'never' || referenceResult[1] === 'lib' && lib === 'never') {\n              context.report({\n                node: comment,\n                messageId: 'tripleSlashReference',\n                data: {\n                  module: referenceResult[2]\n                }\n              });\n              return;\n            }\n\n            if (referenceResult[1] === 'types' && types === 'prefer-import') {\n              references.push({\n                comment,\n                importName: referenceResult[2]\n              });\n            }\n          }\n        });\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","messages","tripleSlashReference","schema","properties","lib","enum","path","types","additionalProperties","defaultOptions","create","context","programNode","sourceCode","getSourceCode","references","hasMatchingReference","source","forEach","reference","importName","value","report","node","comment","messageId","data","module","ImportDeclaration","TSImportEqualsDeclaration","moduleReference","utils_1","TSExternalModuleReference","expression","Program","referenceRegExp","commentsBefore","getCommentsBefore","Line","referenceResult","exec","push"],"sources":["../../src/rules/triple-slash-reference.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}