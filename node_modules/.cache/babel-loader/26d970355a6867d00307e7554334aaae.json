{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _stringNaturalCompare = _interopRequireDefault(require(\"string-natural-compare\"));\n\nvar _utilities = require(\"../utilities\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst schema = [{\n  enum: ['asc', 'desc'],\n  type: 'string'\n}, {\n  additionalProperties: false,\n  type: 'object'\n}];\n/**\n * @private\n */\n\nconst sorters = {\n  asc: (a, b) => {\n    return (0, _stringNaturalCompare.default)(a, b, {\n      caseInsensitive: true\n    });\n  },\n  desc: (a, b) => {\n    return (0, _stringNaturalCompare.default)(b, a, {\n      caseInsensitive: true\n    });\n  }\n};\n\nconst generateOrderedList = (context, sort, properties) => {\n  const source = context.getSourceCode();\n  const items = properties.map(property => {\n    const name = (0, _utilities.getParameterName)(property, context);\n    const commentsBefore = source.getCommentsBefore(property);\n    const startIndex = commentsBefore.length > 0 ? commentsBefore[0].range[0] : property.range[0];\n    const isMethodProperty = property.value && property.value.type === 'FunctionTypeAnnotation';\n\n    if (property.type === 'ObjectTypeSpreadProperty' || !property.value || isMethodProperty) {\n      // NOTE: It could but currently does not fix recursive generic type arguments in GenericTypeAnnotation within ObjectTypeSpreadProperty.\n      // Maintain everything between the start of property including leading comments and the nextPunctuator `,` or `}`:\n      const nextPunctuator = source.getTokenAfter(property, {\n        filter: token => {\n          return token.type === 'Punctuator' || token.value === '|}';\n        }\n      });\n      const beforePunctuator = source.getTokenBefore(nextPunctuator, {\n        includeComments: true\n      });\n      const text = source.getText().slice(startIndex, beforePunctuator.range[1]);\n      return [property, name, text];\n    }\n\n    const colonToken = source.getTokenBefore(property.value, {\n      filter: token => {\n        return token.value === ':';\n      }\n    }); // Preserve all code until the colon verbatim:\n\n    const key = source.getText().slice(startIndex, colonToken.range[0]);\n    let value;\n\n    if (property.value.type === 'ObjectTypeAnnotation') {\n      // eslint-disable-next-line no-use-before-define\n      value = ' ' + generateFix(property.value, context, sort);\n    } else {\n      // NOTE: It could but currently does not fix recursive generic type arguments in GenericTypeAnnotation.\n      // Maintain everything between the `:` and the next Punctuator `,` or `}`:\n      const nextPunctuator = source.getTokenAfter(property, {\n        filter: token => {\n          return token.type === 'Punctuator' || token.value === '|}';\n        }\n      });\n      const beforePunctuator = source.getTokenBefore(nextPunctuator, {\n        includeComments: true\n      });\n      const text = source.getText().slice(colonToken.range[1], beforePunctuator.range[1]);\n      value = text;\n    }\n\n    return [property, name, key, value];\n  });\n  const itemGroups = [[]];\n  let itemGroupIndex = 0;\n\n  for (const item of items) {\n    if (item[0].type === 'ObjectTypeSpreadProperty') {\n      ++itemGroupIndex;\n      itemGroups[itemGroupIndex] = [item];\n      ++itemGroupIndex;\n      itemGroups[itemGroupIndex] = [];\n    } else {\n      itemGroups[itemGroupIndex].push(item);\n    }\n  }\n\n  const orderedList = [];\n\n  for (const itemGroup of itemGroups) {\n    if (itemGroup[0] && itemGroup[0].type !== 'ObjectTypeSpreadProperty') {\n      // console.log('itemGroup', itemGroup);\n      itemGroup.sort((first, second) => {\n        return sort(first[1], second[1]);\n      });\n    }\n\n    orderedList.push(...itemGroup.map(item => {\n      if (item.length === 3) {\n        return item[2];\n      }\n\n      return item[2] + ':' + item[3];\n    }));\n  }\n\n  return orderedList;\n};\n\nconst generateFix = (node, context, sort) => {\n  // this could be done much more cleanly in ESLint >=4\n  // as we can apply multiple fixes. That also means we can\n  // maintain code style in a much nicer way\n  let nodeText;\n  const newTypes = generateOrderedList(context, sort, node.properties);\n  const source = context.getSourceCode(node);\n  const originalSubstring = source.getText(node);\n  nodeText = originalSubstring;\n\n  for (const [index, property] of node.properties.entries()) {\n    const nextPunctuator = source.getTokenAfter(property, {\n      filter: token => {\n        return token.type === 'Punctuator' || token.value === '|}';\n      }\n    });\n    const beforePunctuator = source.getTokenBefore(nextPunctuator, {\n      includeComments: true\n    });\n    const commentsBefore = source.getCommentsBefore(property);\n    const startIndex = commentsBefore.length > 0 ? commentsBefore[0].range[0] : property.range[0];\n    const subString = source.getText().slice(startIndex, beforePunctuator.range[1]);\n    nodeText = nodeText.replace(subString, '$' + index);\n  }\n\n  for (const [index, item] of newTypes.entries()) {\n    nodeText = nodeText.replace('$' + index, item);\n  }\n\n  return nodeText;\n};\n\nconst create = context => {\n  const order = _lodash.default.get(context, ['options', 0], 'asc');\n\n  let prev;\n\n  const checkKeyOrder = node => {\n    prev = null; // eslint-disable-next-line unicorn/no-array-for-each\n\n    node.properties.forEach(identifierNode => {\n      const current = (0, _utilities.getParameterName)(identifierNode, context);\n      const last = prev; // keep track of the last token\n\n      prev = current || last;\n\n      if (!last || !current) {\n        return;\n      }\n\n      const sort = sorters[order];\n\n      if (sort(last, current) > 0) {\n        context.report({\n          data: {\n            current,\n            last,\n            order\n          },\n\n          fix(fixer) {\n            const nodeText = generateFix(node, context, sort);\n            return fixer.replaceText(node, nodeText);\n          },\n\n          loc: identifierNode.loc,\n          message: 'Expected type annotations to be in {{order}}ending order. \"{{current}}\" must be before \"{{last}}\".',\n          node: identifierNode\n        });\n      }\n    });\n  };\n\n  return {\n    ObjectTypeAnnotation: checkKeyOrder\n  };\n};\n\nvar _default = {\n  create,\n  meta: {\n    fixable: 'code'\n  },\n  schema\n};\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_lodash","_interopRequireDefault","require","_stringNaturalCompare","_utilities","obj","__esModule","schema","enum","type","additionalProperties","sorters","asc","a","b","caseInsensitive","desc","generateOrderedList","context","sort","properties","source","getSourceCode","items","map","property","name","getParameterName","commentsBefore","getCommentsBefore","startIndex","length","range","isMethodProperty","nextPunctuator","getTokenAfter","filter","token","beforePunctuator","getTokenBefore","includeComments","text","getText","slice","colonToken","key","generateFix","itemGroups","itemGroupIndex","item","push","orderedList","itemGroup","first","second","node","nodeText","newTypes","originalSubstring","index","entries","subString","replace","create","order","get","prev","checkKeyOrder","forEach","identifierNode","current","last","report","data","fix","fixer","replaceText","loc","message","ObjectTypeAnnotation","_default","meta","fixable","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-flowtype/dist/rules/sortKeys.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _stringNaturalCompare = _interopRequireDefault(require(\"string-natural-compare\"));\n\nvar _utilities = require(\"../utilities\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst schema = [{\n  enum: ['asc', 'desc'],\n  type: 'string'\n}, {\n  additionalProperties: false,\n  type: 'object'\n}];\n/**\n * @private\n */\n\nconst sorters = {\n  asc: (a, b) => {\n    return (0, _stringNaturalCompare.default)(a, b, {\n      caseInsensitive: true\n    });\n  },\n  desc: (a, b) => {\n    return (0, _stringNaturalCompare.default)(b, a, {\n      caseInsensitive: true\n    });\n  }\n};\n\nconst generateOrderedList = (context, sort, properties) => {\n  const source = context.getSourceCode();\n  const items = properties.map(property => {\n    const name = (0, _utilities.getParameterName)(property, context);\n    const commentsBefore = source.getCommentsBefore(property);\n    const startIndex = commentsBefore.length > 0 ? commentsBefore[0].range[0] : property.range[0];\n    const isMethodProperty = property.value && property.value.type === 'FunctionTypeAnnotation';\n\n    if (property.type === 'ObjectTypeSpreadProperty' || !property.value || isMethodProperty) {\n      // NOTE: It could but currently does not fix recursive generic type arguments in GenericTypeAnnotation within ObjectTypeSpreadProperty.\n      // Maintain everything between the start of property including leading comments and the nextPunctuator `,` or `}`:\n      const nextPunctuator = source.getTokenAfter(property, {\n        filter: token => {\n          return token.type === 'Punctuator' || token.value === '|}';\n        }\n      });\n      const beforePunctuator = source.getTokenBefore(nextPunctuator, {\n        includeComments: true\n      });\n      const text = source.getText().slice(startIndex, beforePunctuator.range[1]);\n      return [property, name, text];\n    }\n\n    const colonToken = source.getTokenBefore(property.value, {\n      filter: token => {\n        return token.value === ':';\n      }\n    }); // Preserve all code until the colon verbatim:\n\n    const key = source.getText().slice(startIndex, colonToken.range[0]);\n    let value;\n\n    if (property.value.type === 'ObjectTypeAnnotation') {\n      // eslint-disable-next-line no-use-before-define\n      value = ' ' + generateFix(property.value, context, sort);\n    } else {\n      // NOTE: It could but currently does not fix recursive generic type arguments in GenericTypeAnnotation.\n      // Maintain everything between the `:` and the next Punctuator `,` or `}`:\n      const nextPunctuator = source.getTokenAfter(property, {\n        filter: token => {\n          return token.type === 'Punctuator' || token.value === '|}';\n        }\n      });\n      const beforePunctuator = source.getTokenBefore(nextPunctuator, {\n        includeComments: true\n      });\n      const text = source.getText().slice(colonToken.range[1], beforePunctuator.range[1]);\n      value = text;\n    }\n\n    return [property, name, key, value];\n  });\n  const itemGroups = [[]];\n  let itemGroupIndex = 0;\n\n  for (const item of items) {\n    if (item[0].type === 'ObjectTypeSpreadProperty') {\n      ++itemGroupIndex;\n      itemGroups[itemGroupIndex] = [item];\n      ++itemGroupIndex;\n      itemGroups[itemGroupIndex] = [];\n    } else {\n      itemGroups[itemGroupIndex].push(item);\n    }\n  }\n\n  const orderedList = [];\n\n  for (const itemGroup of itemGroups) {\n    if (itemGroup[0] && itemGroup[0].type !== 'ObjectTypeSpreadProperty') {\n      // console.log('itemGroup', itemGroup);\n      itemGroup.sort((first, second) => {\n        return sort(first[1], second[1]);\n      });\n    }\n\n    orderedList.push(...itemGroup.map(item => {\n      if (item.length === 3) {\n        return item[2];\n      }\n\n      return item[2] + ':' + item[3];\n    }));\n  }\n\n  return orderedList;\n};\n\nconst generateFix = (node, context, sort) => {\n  // this could be done much more cleanly in ESLint >=4\n  // as we can apply multiple fixes. That also means we can\n  // maintain code style in a much nicer way\n  let nodeText;\n  const newTypes = generateOrderedList(context, sort, node.properties);\n  const source = context.getSourceCode(node);\n  const originalSubstring = source.getText(node);\n  nodeText = originalSubstring;\n\n  for (const [index, property] of node.properties.entries()) {\n    const nextPunctuator = source.getTokenAfter(property, {\n      filter: token => {\n        return token.type === 'Punctuator' || token.value === '|}';\n      }\n    });\n    const beforePunctuator = source.getTokenBefore(nextPunctuator, {\n      includeComments: true\n    });\n    const commentsBefore = source.getCommentsBefore(property);\n    const startIndex = commentsBefore.length > 0 ? commentsBefore[0].range[0] : property.range[0];\n    const subString = source.getText().slice(startIndex, beforePunctuator.range[1]);\n    nodeText = nodeText.replace(subString, '$' + index);\n  }\n\n  for (const [index, item] of newTypes.entries()) {\n    nodeText = nodeText.replace('$' + index, item);\n  }\n\n  return nodeText;\n};\n\nconst create = context => {\n  const order = _lodash.default.get(context, ['options', 0], 'asc');\n\n  let prev;\n\n  const checkKeyOrder = node => {\n    prev = null; // eslint-disable-next-line unicorn/no-array-for-each\n\n    node.properties.forEach(identifierNode => {\n      const current = (0, _utilities.getParameterName)(identifierNode, context);\n      const last = prev; // keep track of the last token\n\n      prev = current || last;\n\n      if (!last || !current) {\n        return;\n      }\n\n      const sort = sorters[order];\n\n      if (sort(last, current) > 0) {\n        context.report({\n          data: {\n            current,\n            last,\n            order\n          },\n\n          fix(fixer) {\n            const nodeText = generateFix(node, context, sort);\n            return fixer.replaceText(node, nodeText);\n          },\n\n          loc: identifierNode.loc,\n          message: 'Expected type annotations to be in {{order}}ending order. \"{{current}}\" must be before \"{{last}}\".',\n          node: identifierNode\n        });\n      }\n    });\n  };\n\n  return {\n    ObjectTypeAnnotation: checkKeyOrder\n  };\n};\n\nvar _default = {\n  create,\n  meta: {\n    fixable: 'code'\n  },\n  schema\n};\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}