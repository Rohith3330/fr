{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildDecoratedClass = buildDecoratedClass;\nexports.hasDecorators = hasDecorators;\nexports.hasOwnDecorators = hasOwnDecorators;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nfunction hasOwnDecorators(node) {\n  return !!(node.decorators && node.decorators.length);\n}\n\nfunction hasDecorators(node) {\n  return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);\n}\n\nfunction prop(key, value) {\n  if (!value) return null;\n  return _core.types.objectProperty(_core.types.identifier(key), value);\n}\n\nfunction method(key, body) {\n  return _core.types.objectMethod(\"method\", _core.types.identifier(key), [], _core.types.blockStatement(body));\n}\n\nfunction takeDecorators(node) {\n  let result;\n\n  if (node.decorators && node.decorators.length > 0) {\n    result = _core.types.arrayExpression(node.decorators.map(decorator => decorator.expression));\n  }\n\n  node.decorators = undefined;\n  return result;\n}\n\nfunction getKey(node) {\n  if (node.computed) {\n    return node.key;\n  } else if (_core.types.isIdentifier(node.key)) {\n    return _core.types.stringLiteral(node.key.name);\n  } else {\n    return _core.types.stringLiteral(String(node.key.value));\n  }\n}\n\nfunction extractElementDescriptor(file, classRef, superRef, path) {\n  const isMethod = path.isClassMethod();\n\n  if (path.isPrivate()) {\n    throw path.buildCodeFrameError(`Private ${isMethod ? \"methods\" : \"fields\"} in decorated classes are not supported yet.`);\n  }\n\n  if (path.node.type === \"ClassAccessorProperty\") {\n    throw path.buildCodeFrameError(`Accessor properties are not supported in 2018-09 decorator transform, please specify { \"version\": \"2021-12\" } instead.`);\n  }\n\n  if (path.node.type === \"StaticBlock\") {\n    throw path.buildCodeFrameError(`Static blocks are not supported in 2018-09 decorator transform, please specify { \"version\": \"2021-12\" } instead.`);\n  }\n\n  const {\n    node,\n    scope\n  } = path;\n\n  if (!path.isTSDeclareMethod()) {\n    new _helperReplaceSupers.default({\n      methodPath: path,\n      objectRef: classRef,\n      superRef,\n      file,\n      refToPreserve: classRef\n    }).replace();\n  }\n\n  const properties = [prop(\"kind\", _core.types.stringLiteral(_core.types.isClassMethod(node) ? node.kind : \"field\")), prop(\"decorators\", takeDecorators(node)), prop(\"static\", node.static && _core.types.booleanLiteral(true)), prop(\"key\", getKey(node))].filter(Boolean);\n\n  if (_core.types.isClassMethod(node)) {\n    const id = node.computed ? null : node.key;\n\n    const transformed = _core.types.toExpression(node);\n\n    properties.push(prop(\"value\", (0, _helperFunctionName.default)({\n      node: transformed,\n      id,\n      scope\n    }) || transformed));\n  } else if (_core.types.isClassProperty(node) && node.value) {\n    properties.push(method(\"value\", _core.template.statements.ast`return ${node.value}`));\n  } else {\n    properties.push(prop(\"value\", scope.buildUndefinedNode()));\n  }\n\n  path.remove();\n  return _core.types.objectExpression(properties);\n}\n\nfunction addDecorateHelper(file) {\n  try {\n    return file.addHelper(\"decorate\");\n  } catch (err) {\n    if (err.code === \"BABEL_HELPER_UNKNOWN\") {\n      err.message += \"\\n  '@babel/plugin-transform-decorators' in non-legacy mode\" + \" requires '@babel/core' version ^7.0.2 and you appear to be using\" + \" an older version.\";\n    }\n\n    throw err;\n  }\n}\n\nfunction buildDecoratedClass(ref, path, elements, file) {\n  const {\n    node,\n    scope\n  } = path;\n  const initializeId = scope.generateUidIdentifier(\"initialize\");\n  const isDeclaration = node.id && path.isDeclaration();\n  const isStrict = path.isInStrictMode();\n  const {\n    superClass\n  } = node;\n  node.type = \"ClassDeclaration\";\n  if (!node.id) node.id = _core.types.cloneNode(ref);\n  let superId;\n\n  if (superClass) {\n    superId = scope.generateUidIdentifierBasedOnNode(node.superClass, \"super\");\n    node.superClass = superId;\n  }\n\n  const classDecorators = takeDecorators(node);\n\n  const definitions = _core.types.arrayExpression(elements.filter(element => !element.node.abstract && element.node.type !== \"TSIndexSignature\").map(path => extractElementDescriptor(file, node.id, superId, path)));\n\n  const wrapperCall = _core.template.expression.ast`\n    ${addDecorateHelper(file)}(\n      ${classDecorators || _core.types.nullLiteral()},\n      function (${initializeId}, ${superClass ? _core.types.cloneNode(superId) : null}) {\n        ${node}\n        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };\n      },\n      ${superClass}\n    )\n  `;\n\n  if (!isStrict) {\n    wrapperCall.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral(\"use strict\")));\n  }\n\n  let replacement = wrapperCall;\n  let classPathDesc = \"arguments.1.body.body.0\";\n\n  if (isDeclaration) {\n    replacement = _core.template.statement.ast`let ${ref} = ${wrapperCall}`;\n    classPathDesc = \"declarations.0.init.\" + classPathDesc;\n  }\n\n  return {\n    instanceNodes: [_core.template.statement.ast`${_core.types.cloneNode(initializeId)}(this)`],\n\n    wrapClass(path) {\n      path.replaceWith(replacement);\n      return path.get(classPathDesc);\n    }\n\n  };\n}","map":{"version":3,"mappings":"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","names":["hasOwnDecorators","node","decorators","length","hasDecorators","body","some","prop","key","value","t","objectProperty","identifier","method","objectMethod","blockStatement","takeDecorators","result","arrayExpression","map","decorator","expression","undefined","getKey","computed","isIdentifier","stringLiteral","name","String","extractElementDescriptor","file","classRef","superRef","path","isMethod","isClassMethod","isPrivate","buildCodeFrameError","type","scope","isTSDeclareMethod","ReplaceSupers","methodPath","objectRef","refToPreserve","replace","properties","kind","static","booleanLiteral","filter","Boolean","id","transformed","toExpression","push","isClassProperty","template","statements","ast","buildUndefinedNode","remove","objectExpression","addDecorateHelper","addHelper","err","code","message","buildDecoratedClass","ref","elements","initializeId","generateUidIdentifier","isDeclaration","isStrict","isInStrictMode","superClass","cloneNode","superId","generateUidIdentifierBasedOnNode","classDecorators","definitions","element","abstract","wrapperCall","nullLiteral","arguments","directives","directive","directiveLiteral","replacement","classPathDesc","statement","instanceNodes","wrapClass","replaceWith","get"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-create-class-features-plugin\\src\\decorators.ts"],"sourcesContent":["// TODO(Babel 8): Remove this file\n\nimport { types as t, template } from \"@babel/core\";\nimport type { File } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport nameFunction from \"@babel/helper-function-name\";\n\ntype Decorable = Extract<t.Node, { decorators?: t.Decorator[] | null }>;\n\nexport function hasOwnDecorators(node: t.Node) {\n  // @ts-expect-error(flow->ts) TODO: maybe we could add t.isDecoratable to make ts happy\n  return !!(node.decorators && node.decorators.length);\n}\n\nexport function hasDecorators(node: t.Class) {\n  return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);\n}\n\nfunction prop(key: string, value?: t.Expression) {\n  if (!value) return null;\n  return t.objectProperty(t.identifier(key), value);\n}\n\nfunction method(key: string, body: t.Statement[]) {\n  return t.objectMethod(\n    \"method\",\n    t.identifier(key),\n    [],\n    t.blockStatement(body),\n  );\n}\n\nfunction takeDecorators(node: Decorable) {\n  let result: t.ArrayExpression | undefined;\n  if (node.decorators && node.decorators.length > 0) {\n    result = t.arrayExpression(\n      node.decorators.map(decorator => decorator.expression),\n    );\n  }\n  node.decorators = undefined;\n  return result;\n}\n\ntype AcceptedElement = Exclude<ClassElement, t.TSIndexSignature>;\ntype SupportedElement = Exclude<\n  AcceptedElement,\n  | t.ClassPrivateMethod\n  | t.ClassPrivateProperty\n  | t.ClassAccessorProperty\n  | t.StaticBlock\n>;\n\nfunction getKey(node: SupportedElement) {\n  if (node.computed) {\n    return node.key;\n  } else if (t.isIdentifier(node.key)) {\n    return t.stringLiteral(node.key.name);\n  } else {\n    return t.stringLiteral(\n      String(\n        // A non-identifier non-computed key\n        (node.key as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)\n          .value,\n      ),\n    );\n  }\n}\n\nfunction extractElementDescriptor(\n  file: File,\n  classRef: t.Identifier,\n  superRef: t.Identifier,\n  path: NodePath<AcceptedElement>,\n) {\n  const isMethod = path.isClassMethod();\n  if (path.isPrivate()) {\n    throw path.buildCodeFrameError(\n      `Private ${\n        isMethod ? \"methods\" : \"fields\"\n      } in decorated classes are not supported yet.`,\n    );\n  }\n  if (path.node.type === \"ClassAccessorProperty\") {\n    throw path.buildCodeFrameError(\n      `Accessor properties are not supported in 2018-09 decorator transform, please specify { \"version\": \"2021-12\" } instead.`,\n    );\n  }\n  if (path.node.type === \"StaticBlock\") {\n    throw path.buildCodeFrameError(\n      `Static blocks are not supported in 2018-09 decorator transform, please specify { \"version\": \"2021-12\" } instead.`,\n    );\n  }\n\n  const { node, scope } = path as NodePath<SupportedElement>;\n\n  if (!path.isTSDeclareMethod()) {\n    new ReplaceSupers({\n      methodPath: path as NodePath<\n        Exclude<SupportedElement, t.TSDeclareMethod>\n      >,\n      objectRef: classRef,\n      superRef,\n      file,\n      refToPreserve: classRef,\n    }).replace();\n  }\n\n  const properties: t.ObjectExpression[\"properties\"] = [\n    prop(\"kind\", t.stringLiteral(t.isClassMethod(node) ? node.kind : \"field\")),\n    prop(\"decorators\", takeDecorators(node as Decorable)),\n    prop(\"static\", node.static && t.booleanLiteral(true)),\n    prop(\"key\", getKey(node)),\n  ].filter(Boolean);\n\n  if (t.isClassMethod(node)) {\n    const id = node.computed\n      ? null\n      : (node.key as\n          | t.Identifier\n          | t.StringLiteral\n          | t.NumericLiteral\n          | t.BigIntLiteral);\n    const transformed = t.toExpression(node);\n    properties.push(\n      prop(\n        \"value\",\n        nameFunction({ node: transformed, id, scope }) || transformed,\n      ),\n    );\n  } else if (t.isClassProperty(node) && node.value) {\n    properties.push(\n      method(\"value\", template.statements.ast`return ${node.value}`),\n    );\n  } else {\n    properties.push(prop(\"value\", scope.buildUndefinedNode()));\n  }\n\n  path.remove();\n\n  return t.objectExpression(properties);\n}\n\nfunction addDecorateHelper(file: File) {\n  try {\n    return file.addHelper(\"decorate\");\n  } catch (err) {\n    if (err.code === \"BABEL_HELPER_UNKNOWN\") {\n      err.message +=\n        \"\\n  '@babel/plugin-transform-decorators' in non-legacy mode\" +\n        \" requires '@babel/core' version ^7.0.2 and you appear to be using\" +\n        \" an older version.\";\n    }\n    throw err;\n  }\n}\n\ntype ClassElement = t.Class[\"body\"][\"body\"][number];\ntype ClassElementPath = NodePath<ClassElement>;\n\nexport function buildDecoratedClass(\n  ref: t.Identifier,\n  path: NodePath<t.Class>,\n  elements: ClassElementPath[],\n  file: File,\n) {\n  const { node, scope } = path;\n  const initializeId = scope.generateUidIdentifier(\"initialize\");\n  const isDeclaration = node.id && path.isDeclaration();\n  const isStrict = path.isInStrictMode();\n  const { superClass } = node;\n\n  node.type = \"ClassDeclaration\";\n  if (!node.id) node.id = t.cloneNode(ref);\n\n  let superId: t.Identifier;\n  if (superClass) {\n    superId = scope.generateUidIdentifierBasedOnNode(node.superClass, \"super\");\n    node.superClass = superId;\n  }\n\n  const classDecorators = takeDecorators(node);\n  const definitions = t.arrayExpression(\n    elements\n      .filter(\n        element =>\n          // @ts-expect-error Ignore TypeScript's abstract methods (see #10514)\n          !element.node.abstract && element.node.type !== \"TSIndexSignature\",\n      )\n      .map(path =>\n        extractElementDescriptor(\n          file,\n          node.id,\n          superId,\n          // @ts-expect-error TS can not exclude TSIndexSignature\n          path,\n        ),\n      ),\n  );\n\n  const wrapperCall = template.expression.ast`\n    ${addDecorateHelper(file)}(\n      ${classDecorators || t.nullLiteral()},\n      function (${initializeId}, ${superClass ? t.cloneNode(superId) : null}) {\n        ${node}\n        return { F: ${t.cloneNode(node.id)}, d: ${definitions} };\n      },\n      ${superClass}\n    )\n  ` as t.CallExpression & { arguments: [unknown, t.FunctionExpression] };\n\n  if (!isStrict) {\n    wrapperCall.arguments[1].body.directives.push(\n      t.directive(t.directiveLiteral(\"use strict\")),\n    );\n  }\n\n  let replacement: t.Node = wrapperCall;\n  let classPathDesc = \"arguments.1.body.body.0\";\n  if (isDeclaration) {\n    replacement = template.statement.ast`let ${ref} = ${wrapperCall}`;\n    classPathDesc = \"declarations.0.init.\" + classPathDesc;\n  }\n\n  return {\n    instanceNodes: [template.statement.ast`${t.cloneNode(initializeId)}(this)`],\n    wrapClass(path: NodePath<t.Class>) {\n      path.replaceWith(replacement);\n      return path.get(classPathDesc) as NodePath;\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"script"}