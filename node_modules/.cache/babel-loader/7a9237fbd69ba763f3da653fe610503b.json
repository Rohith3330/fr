{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasRef = void 0;\n\nconst compile_1 = require(\"../../compile\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst ref_error_1 = require(\"../../compile/ref_error\");\n\nconst names_1 = require(\"../../compile/names\");\n\nconst ref_1 = require(\"../core/ref\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst def = {\n  keyword: \"ref\",\n  schemaType: \"string\",\n\n  code(cxt) {\n    (0, metadata_1.checkMetadata)(cxt);\n    const {\n      gen,\n      data,\n      schema: ref,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      schemaEnv: {\n        root\n      }\n    } = it;\n    const valid = gen.name(\"valid\");\n\n    if (parentSchema.nullable) {\n      gen.var(valid, (0, codegen_1._)`${data} === null`);\n      gen.if((0, codegen_1.not)(valid), validateJtdRef);\n    } else {\n      gen.var(valid, false);\n      validateJtdRef();\n    }\n\n    cxt.ok(valid);\n\n    function validateJtdRef() {\n      var _a;\n\n      const refSchema = (_a = root.schema.definitions) === null || _a === void 0 ? void 0 : _a[ref];\n\n      if (!refSchema) {\n        throw new ref_error_1.default(it.opts.uriResolver, \"\", ref, `No definition ${ref}`);\n      }\n\n      if (hasRef(refSchema) || !it.opts.inlineRefs) callValidate(refSchema);else inlineRefSchema(refSchema);\n    }\n\n    function callValidate(schema) {\n      const sch = compile_1.compileSchema.call(it.self, new compile_1.SchemaEnv({\n        schema,\n        root,\n        schemaPath: `/definitions/${ref}`\n      }));\n      const v = (0, ref_1.getValidate)(cxt, sch);\n      const errsCount = gen.const(\"_errs\", names_1.default.errors);\n      (0, ref_1.callRef)(cxt, v, sch, sch.$async);\n      gen.assign(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);\n    }\n\n    function inlineRefSchema(schema) {\n      const schName = gen.scopeValue(\"schema\", it.opts.code.source === true ? {\n        ref: schema,\n        code: (0, codegen_1.stringify)(schema)\n      } : {\n        ref: schema\n      });\n      cxt.subschema({\n        schema,\n        dataTypes: [],\n        schemaPath: codegen_1.nil,\n        topSchemaRef: schName,\n        errSchemaPath: `/definitions/${ref}`\n      }, valid);\n    }\n  }\n\n};\n\nfunction hasRef(schema) {\n  for (const key in schema) {\n    let sch;\n    if (key === \"ref\" || typeof (sch = schema[key]) == \"object\" && hasRef(sch)) return true;\n  }\n\n  return false;\n}\n\nexports.hasRef = hasRef;\nexports.default = def;","map":{"version":3,"mappings":"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","names":["def","keyword","schemaType","code","cxt","gen","data","schema","ref","parentSchema","it","schemaEnv","root","valid","name","nullable","var","if","validateJtdRef","ok","refSchema","definitions","_a","ref_error_1","opts","uriResolver","hasRef","inlineRefs","callValidate","inlineRefSchema","sch","compile_1","call","self","schemaPath","v","errsCount","const","names_1","errors","$async","assign","schName","scopeValue","source","subschema","dataTypes","codegen_1","topSchemaRef","errSchemaPath","key","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-webpack-plugin\\node_modules\\ajv\\lib\\vocabularies\\jtd\\ref.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {compileSchema, SchemaEnv} from \"../../compile\"\nimport {_, not, nil, stringify} from \"../../compile/codegen\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport N from \"../../compile/names\"\nimport {getValidate, callRef} from \"../core/ref\"\nimport {checkMetadata} from \"./metadata\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt) {\n    checkMetadata(cxt)\n    const {gen, data, schema: ref, parentSchema, it} = cxt\n    const {\n      schemaEnv: {root},\n    } = it\n    const valid = gen.name(\"valid\")\n    if (parentSchema.nullable) {\n      gen.var(valid, _`${data} === null`)\n      gen.if(not(valid), validateJtdRef)\n    } else {\n      gen.var(valid, false)\n      validateJtdRef()\n    }\n    cxt.ok(valid)\n\n    function validateJtdRef(): void {\n      const refSchema = (root.schema as AnySchemaObject).definitions?.[ref]\n      if (!refSchema) {\n        throw new MissingRefError(it.opts.uriResolver, \"\", ref, `No definition ${ref}`)\n      }\n      if (hasRef(refSchema) || !it.opts.inlineRefs) callValidate(refSchema)\n      else inlineRefSchema(refSchema)\n    }\n\n    function callValidate(schema: AnySchemaObject): void {\n      const sch = compileSchema.call(\n        it.self,\n        new SchemaEnv({schema, root, schemaPath: `/definitions/${ref}`})\n      )\n      const v = getValidate(cxt, sch)\n      const errsCount = gen.const(\"_errs\", N.errors)\n      callRef(cxt, v, sch, sch.$async)\n      gen.assign(valid, _`${errsCount} === ${N.errors}`)\n    }\n\n    function inlineRefSchema(schema: AnySchemaObject): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        it.opts.code.source === true ? {ref: schema, code: stringify(schema)} : {ref: schema}\n      )\n      cxt.subschema(\n        {\n          schema,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: `/definitions/${ref}`,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport function hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    let sch: AnySchemaObject\n    if (key === \"ref\" || (typeof (sch = schema[key]) == \"object\" && hasRef(sch))) return true\n  }\n  return false\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}