{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst nullable_1 = require(\"./nullable\");\n\nconst error_1 = require(\"./error\");\n\nconst types_1 = require(\"../discriminator/types\");\n\nconst error = {\n  message: cxt => {\n    const {\n      schema,\n      params\n    } = cxt;\n    return params.discrError ? params.discrError === types_1.DiscrError.Tag ? `tag \"${schema}\" must be string` : `value of tag \"${schema}\" must be in mapping` : (0, error_1.typeErrorMessage)(cxt, \"object\");\n  },\n  params: cxt => {\n    const {\n      schema,\n      params\n    } = cxt;\n    return params.discrError ? (0, codegen_1._)`{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}` : (0, error_1.typeErrorParams)(cxt, \"object\");\n  }\n};\nconst def = {\n  keyword: \"discriminator\",\n  schemaType: \"string\",\n  implements: [\"mapping\"],\n  error,\n\n  code(cxt) {\n    (0, metadata_1.checkMetadata)(cxt);\n    const {\n      gen,\n      data,\n      schema,\n      parentSchema\n    } = cxt;\n    const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);\n    gen.if(cond);\n    validateDiscriminator();\n    gen.elseIf((0, codegen_1.not)(valid));\n    cxt.error();\n    gen.endIf();\n    cxt.ok(valid);\n\n    function validateDiscriminator() {\n      const tag = gen.const(\"tag\", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(schema)}`);\n      gen.if((0, codegen_1._)`${tag} === undefined`);\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Tag,\n        tag\n      });\n      gen.elseIf((0, codegen_1._)`typeof ${tag} == \"string\"`);\n      validateMapping(tag);\n      gen.else();\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Tag,\n        tag\n      }, {\n        instancePath: schema\n      });\n      gen.endIf();\n    }\n\n    function validateMapping(tag) {\n      gen.if(false);\n\n      for (const tagValue in parentSchema.mapping) {\n        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);\n        gen.assign(valid, applyTagSchema(tagValue));\n      }\n\n      gen.else();\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Mapping,\n        tag\n      }, {\n        instancePath: schema,\n        schemaPath: \"mapping\",\n        parentSchema: true\n      });\n      gen.endIf();\n    }\n\n    function applyTagSchema(schemaProp) {\n      const _valid = gen.name(\"valid\");\n\n      cxt.subschema({\n        keyword: \"mapping\",\n        schemaProp,\n        jtdDiscriminator: schema\n      }, _valid);\n      return _valid;\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","cxt","schema","params","discrError","types_1","Tag","tag","def","keyword","schemaType","implements","code","gen","data","parentSchema","valid","cond","if","validateDiscriminator","elseIf","endIf","ok","const","validateMapping","else","instancePath","tagValue","mapping","assign","applyTagSchema","Mapping","schemaPath","schemaProp","_valid","name","subschema","jtdDiscriminator","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\vocabularies\\jtd\\discriminator.ts"],"sourcesContent":["import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not, getProperty, Name} from \"../../compile/codegen\"\nimport {checkMetadata} from \"./metadata\"\nimport {checkNullableObject} from \"./nullable\"\nimport {typeErrorMessage, typeErrorParams, _JTDTypeError} from \"./error\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\n\nexport type JTDDiscriminatorError =\n  | _JTDTypeError<\"discriminator\", \"object\", string>\n  | DiscrErrorObj<DiscrError.Tag>\n  | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: (cxt) => {\n    const {schema, params} = cxt\n    return params.discrError\n      ? params.discrError === DiscrError.Tag\n        ? `tag \"${schema}\" must be string`\n        : `value of tag \"${schema}\" must be in mapping`\n      : typeErrorMessage(cxt, \"object\")\n  },\n  params: (cxt) => {\n    const {schema, params} = cxt\n    return params.discrError\n      ? _`{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}`\n      : typeErrorParams(cxt, \"object\")\n  },\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  schemaType: \"string\",\n  implements: [\"mapping\"],\n  error,\n  code(cxt: KeywordCxt) {\n    checkMetadata(cxt)\n    const {gen, data, schema, parentSchema} = cxt\n    const [valid, cond] = checkNullableObject(cxt, data)\n\n    gen.if(cond)\n    validateDiscriminator()\n    gen.elseIf(not(valid))\n    cxt.error()\n    gen.endIf()\n    cxt.ok(valid)\n\n    function validateDiscriminator(): void {\n      const tag = gen.const(\"tag\", _`${data}${getProperty(schema)}`)\n      gen.if(_`${tag} === undefined`)\n      cxt.error(false, {discrError: DiscrError.Tag, tag})\n      gen.elseIf(_`typeof ${tag} == \"string\"`)\n      validateMapping(tag)\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Tag, tag}, {instancePath: schema})\n      gen.endIf()\n    }\n\n    function validateMapping(tag: Name): void {\n      gen.if(false)\n      for (const tagValue in parentSchema.mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(tagValue))\n      }\n      gen.else()\n      cxt.error(\n        false,\n        {discrError: DiscrError.Mapping, tag},\n        {instancePath: schema, schemaPath: \"mapping\", parentSchema: true}\n      )\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp: string): Name {\n      const _valid = gen.name(\"valid\")\n      cxt.subschema(\n        {\n          keyword: \"mapping\",\n          schemaProp,\n          jtdDiscriminator: schema,\n        },\n        _valid\n      )\n      return _valid\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}