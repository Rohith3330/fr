{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst schema = [{\n  additionalProperties: false,\n  properties: {\n    useImplicitExactTypes: {\n      type: 'boolean'\n    }\n  },\n  type: 'object'\n}];\nconst reComponentName = /^(Pure)?Component$/u;\nconst reReadOnly = /^\\$(ReadOnly|FlowFixMe)$/u;\n\nconst isReactComponent = node => {\n  if (!node.superClass) {\n    return false;\n  }\n\n  return (// class Foo extends Component { }\n    // class Foo extends PureComponent { }\n    node.superClass.type === 'Identifier' && reComponentName.test(node.superClass.name) || // class Foo extends React.Component { }\n    // class Foo extends React.PureComponent { }\n    node.superClass.type === 'MemberExpression' && node.superClass.object.name === 'React' && reComponentName.test(node.superClass.property.name)\n  );\n}; // type Props = {| +foo: string |}\n\n\nconst isReadOnlyObjectType = (node, _ref) => {\n  let {\n    useImplicitExactTypes\n  } = _ref;\n\n  if (!node || node.type !== 'ObjectTypeAnnotation') {\n    return false;\n  }\n\n  if (node.properties.length === 0) {\n    // we consider `{}` to be ReadOnly since it's exact AND has no props (when `implicitExactTypes=true`)\n    // we consider `{||}` to be ReadOnly since it's exact AND has no props (when `implicitExactTypes=false`)\n    if (useImplicitExactTypes === true && node.exact === false) {\n      return true;\n    }\n\n    if (node.exact === true) {\n      return true;\n    }\n  } // { +foo: ..., +bar: ..., ... }\n\n\n  return node.properties.length > 0 && node.properties.every(prop => {\n    return prop.variance && prop.variance.kind === 'plus';\n  });\n}; // type Props = {| +foo: string |} | {| +bar: number |}\n\n\nconst isReadOnlyObjectUnionType = (node, options) => {\n  if (!node || node.type !== 'UnionTypeAnnotation') {\n    return false;\n  }\n\n  return node.types.every(type => {\n    return isReadOnlyObjectType(type, options);\n  });\n};\n\nconst isReadOnlyType = (node, options) => {\n  return node.right.id && reReadOnly.test(node.right.id.name) || isReadOnlyObjectType(node.right, options) || isReadOnlyObjectUnionType(node.right, options);\n};\n\nconst create = context => {\n  const useImplicitExactTypes = _lodash.default.get(context, ['options', 0, 'useImplicitExactTypes'], false);\n\n  const options = {\n    useImplicitExactTypes\n  };\n  const readOnlyTypes = [];\n  const foundTypes = [];\n  const reportedFunctionalComponents = [];\n\n  const isReadOnlyClassProp = node => {\n    const id = node.superTypeParameters && node.superTypeParameters.params[0].id;\n    return id && !reReadOnly.test(id.name) && !readOnlyTypes.includes(id.name) && foundTypes.includes(id.name);\n  };\n\n  for (const node of context.getSourceCode().ast.body) {\n    let idName;\n    let typeNode; // type Props = $ReadOnly<{}>\n\n    if (node.type === 'TypeAlias') {\n      idName = node.id.name;\n      typeNode = node; // export type Props = $ReadOnly<{}>\n    } else if (node.type === 'ExportNamedDeclaration' && node.declaration && node.declaration.type === 'TypeAlias') {\n      idName = node.declaration.id.name;\n      typeNode = node.declaration;\n    }\n\n    if (idName) {\n      foundTypes.push(idName);\n\n      if (isReadOnlyType(typeNode, options)) {\n        readOnlyTypes.push(idName);\n      }\n    }\n  }\n\n  return {\n    // class components\n    ClassDeclaration(node) {\n      if (isReactComponent(node) && isReadOnlyClassProp(node)) {\n        context.report({\n          message: node.superTypeParameters.params[0].id.name + ' must be $ReadOnly',\n          node\n        });\n      } else if (node.superTypeParameters && node.superTypeParameters.params[0].type === 'ObjectTypeAnnotation' && !isReadOnlyObjectType(node.superTypeParameters.params[0], options)) {\n        context.report({\n          message: node.id.name + ' class props must be $ReadOnly',\n          node\n        });\n      }\n    },\n\n    // functional components\n    JSXElement(node) {\n      let currentNode = node;\n      let identifier;\n      let typeAnnotation;\n\n      while (currentNode && currentNode.type !== 'FunctionDeclaration') {\n        currentNode = currentNode.parent;\n      } // functional components can only have 1 param\n\n\n      if (!currentNode || currentNode.params.length !== 1) {\n        return;\n      }\n\n      if (currentNode.params[0].type === 'Identifier' && (typeAnnotation = currentNode.params[0].typeAnnotation)) {\n        if ((identifier = typeAnnotation.typeAnnotation.id) && foundTypes.includes(identifier.name) && !readOnlyTypes.includes(identifier.name) && !reReadOnly.test(identifier.name)) {\n          if (reportedFunctionalComponents.includes(identifier)) {\n            return;\n          }\n\n          context.report({\n            message: identifier.name + ' must be $ReadOnly',\n            node: identifier\n          });\n          reportedFunctionalComponents.push(identifier);\n          return;\n        }\n\n        if (typeAnnotation.typeAnnotation.type === 'ObjectTypeAnnotation' && !isReadOnlyObjectType(typeAnnotation.typeAnnotation, options)) {\n          context.report({\n            message: currentNode.id.name + ' component props must be $ReadOnly',\n            node\n          });\n        }\n      }\n    }\n\n  };\n};\n\nvar _default = {\n  create,\n  schema\n};\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_lodash","_interopRequireDefault","require","obj","__esModule","schema","additionalProperties","properties","useImplicitExactTypes","type","reComponentName","reReadOnly","isReactComponent","node","superClass","test","name","object","property","isReadOnlyObjectType","length","exact","every","prop","variance","kind","isReadOnlyObjectUnionType","options","types","isReadOnlyType","right","id","create","context","get","readOnlyTypes","foundTypes","reportedFunctionalComponents","isReadOnlyClassProp","superTypeParameters","params","includes","getSourceCode","ast","body","idName","typeNode","declaration","push","ClassDeclaration","report","message","JSXElement","currentNode","identifier","typeAnnotation","parent","_default","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-flowtype/dist/rules/requireReadonlyReactProps.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst schema = [{\n  additionalProperties: false,\n  properties: {\n    useImplicitExactTypes: {\n      type: 'boolean'\n    }\n  },\n  type: 'object'\n}];\nconst reComponentName = /^(Pure)?Component$/u;\nconst reReadOnly = /^\\$(ReadOnly|FlowFixMe)$/u;\n\nconst isReactComponent = node => {\n  if (!node.superClass) {\n    return false;\n  }\n\n  return (// class Foo extends Component { }\n    // class Foo extends PureComponent { }\n    node.superClass.type === 'Identifier' && reComponentName.test(node.superClass.name) || // class Foo extends React.Component { }\n    // class Foo extends React.PureComponent { }\n    node.superClass.type === 'MemberExpression' && node.superClass.object.name === 'React' && reComponentName.test(node.superClass.property.name)\n  );\n}; // type Props = {| +foo: string |}\n\n\nconst isReadOnlyObjectType = (node, {\n  useImplicitExactTypes\n}) => {\n  if (!node || node.type !== 'ObjectTypeAnnotation') {\n    return false;\n  }\n\n  if (node.properties.length === 0) {\n    // we consider `{}` to be ReadOnly since it's exact AND has no props (when `implicitExactTypes=true`)\n    // we consider `{||}` to be ReadOnly since it's exact AND has no props (when `implicitExactTypes=false`)\n    if (useImplicitExactTypes === true && node.exact === false) {\n      return true;\n    }\n\n    if (node.exact === true) {\n      return true;\n    }\n  } // { +foo: ..., +bar: ..., ... }\n\n\n  return node.properties.length > 0 && node.properties.every(prop => {\n    return prop.variance && prop.variance.kind === 'plus';\n  });\n}; // type Props = {| +foo: string |} | {| +bar: number |}\n\n\nconst isReadOnlyObjectUnionType = (node, options) => {\n  if (!node || node.type !== 'UnionTypeAnnotation') {\n    return false;\n  }\n\n  return node.types.every(type => {\n    return isReadOnlyObjectType(type, options);\n  });\n};\n\nconst isReadOnlyType = (node, options) => {\n  return node.right.id && reReadOnly.test(node.right.id.name) || isReadOnlyObjectType(node.right, options) || isReadOnlyObjectUnionType(node.right, options);\n};\n\nconst create = context => {\n  const useImplicitExactTypes = _lodash.default.get(context, ['options', 0, 'useImplicitExactTypes'], false);\n\n  const options = {\n    useImplicitExactTypes\n  };\n  const readOnlyTypes = [];\n  const foundTypes = [];\n  const reportedFunctionalComponents = [];\n\n  const isReadOnlyClassProp = node => {\n    const id = node.superTypeParameters && node.superTypeParameters.params[0].id;\n    return id && !reReadOnly.test(id.name) && !readOnlyTypes.includes(id.name) && foundTypes.includes(id.name);\n  };\n\n  for (const node of context.getSourceCode().ast.body) {\n    let idName;\n    let typeNode; // type Props = $ReadOnly<{}>\n\n    if (node.type === 'TypeAlias') {\n      idName = node.id.name;\n      typeNode = node; // export type Props = $ReadOnly<{}>\n    } else if (node.type === 'ExportNamedDeclaration' && node.declaration && node.declaration.type === 'TypeAlias') {\n      idName = node.declaration.id.name;\n      typeNode = node.declaration;\n    }\n\n    if (idName) {\n      foundTypes.push(idName);\n\n      if (isReadOnlyType(typeNode, options)) {\n        readOnlyTypes.push(idName);\n      }\n    }\n  }\n\n  return {\n    // class components\n    ClassDeclaration(node) {\n      if (isReactComponent(node) && isReadOnlyClassProp(node)) {\n        context.report({\n          message: node.superTypeParameters.params[0].id.name + ' must be $ReadOnly',\n          node\n        });\n      } else if (node.superTypeParameters && node.superTypeParameters.params[0].type === 'ObjectTypeAnnotation' && !isReadOnlyObjectType(node.superTypeParameters.params[0], options)) {\n        context.report({\n          message: node.id.name + ' class props must be $ReadOnly',\n          node\n        });\n      }\n    },\n\n    // functional components\n    JSXElement(node) {\n      let currentNode = node;\n      let identifier;\n      let typeAnnotation;\n\n      while (currentNode && currentNode.type !== 'FunctionDeclaration') {\n        currentNode = currentNode.parent;\n      } // functional components can only have 1 param\n\n\n      if (!currentNode || currentNode.params.length !== 1) {\n        return;\n      }\n\n      if (currentNode.params[0].type === 'Identifier' && (typeAnnotation = currentNode.params[0].typeAnnotation)) {\n        if ((identifier = typeAnnotation.typeAnnotation.id) && foundTypes.includes(identifier.name) && !readOnlyTypes.includes(identifier.name) && !reReadOnly.test(identifier.name)) {\n          if (reportedFunctionalComponents.includes(identifier)) {\n            return;\n          }\n\n          context.report({\n            message: identifier.name + ' must be $ReadOnly',\n            node: identifier\n          });\n          reportedFunctionalComponents.push(identifier);\n          return;\n        }\n\n        if (typeAnnotation.typeAnnotation.type === 'ObjectTypeAnnotation' && !isReadOnlyObjectType(typeAnnotation.typeAnnotation, options)) {\n          context.report({\n            message: currentNode.id.name + ' component props must be $ReadOnly',\n            node\n          });\n        }\n      }\n    }\n\n  };\n};\n\nvar _default = {\n  create,\n  schema\n};\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}