{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.access = access;\nexports.assertArray = assertArray;\nexports.assertAssumptions = assertAssumptions;\nexports.assertBabelrcSearch = assertBabelrcSearch;\nexports.assertBoolean = assertBoolean;\nexports.assertCallerMetadata = assertCallerMetadata;\nexports.assertCompact = assertCompact;\nexports.assertConfigApplicableTest = assertConfigApplicableTest;\nexports.assertConfigFileSearch = assertConfigFileSearch;\nexports.assertFunction = assertFunction;\nexports.assertIgnoreList = assertIgnoreList;\nexports.assertInputSourceMap = assertInputSourceMap;\nexports.assertObject = assertObject;\nexports.assertPluginList = assertPluginList;\nexports.assertRootMode = assertRootMode;\nexports.assertSourceMaps = assertSourceMaps;\nexports.assertSourceType = assertSourceType;\nexports.assertString = assertString;\nexports.assertTargets = assertTargets;\nexports.msg = msg;\n\nfunction _helperCompilationTargets() {\n  var data = require(\"@babel/helper-compilation-targets\");\n\n  _helperCompilationTargets = function _helperCompilationTargets() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _options = require(\"./options\");\n\nfunction msg(loc) {\n  switch (loc.type) {\n    case \"root\":\n      return \"\";\n\n    case \"env\":\n      return \"\".concat(msg(loc.parent), \".env[\\\"\").concat(loc.name, \"\\\"]\");\n\n    case \"overrides\":\n      return \"\".concat(msg(loc.parent), \".overrides[\").concat(loc.index, \"]\");\n\n    case \"option\":\n      return \"\".concat(msg(loc.parent), \".\").concat(loc.name);\n\n    case \"access\":\n      return \"\".concat(msg(loc.parent), \"[\").concat(JSON.stringify(loc.name), \"]\");\n\n    default:\n      throw new Error(\"Assertion failure: Unknown type \".concat(loc.type));\n  }\n}\n\nfunction access(loc, name) {\n  return {\n    type: \"access\",\n    name: name,\n    parent: loc\n  };\n}\n\nfunction assertRootMode(loc, value) {\n  if (value !== undefined && value !== \"root\" && value !== \"upward\" && value !== \"upward-optional\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a \\\"root\\\", \\\"upward\\\", \\\"upward-optional\\\" or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertSourceMaps(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"inline\" && value !== \"both\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a boolean, \\\"inline\\\", \\\"both\\\", or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertCompact(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"auto\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a boolean, \\\"auto\\\", or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertSourceType(loc, value) {\n  if (value !== undefined && value !== \"module\" && value !== \"script\" && value !== \"unambiguous\") {\n    throw new Error(\"\".concat(msg(loc), \" must be \\\"module\\\", \\\"script\\\", \\\"unambiguous\\\", or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertCallerMetadata(loc, value) {\n  var obj = assertObject(loc, value);\n\n  if (obj) {\n    if (typeof obj.name !== \"string\") {\n      throw new Error(\"\".concat(msg(loc), \" set but does not contain \\\"name\\\" property string\"));\n    }\n\n    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n      var prop = _Object$keys[_i];\n      var propLoc = access(loc, prop);\n      var _value = obj[prop];\n\n      if (_value != null && typeof _value !== \"boolean\" && typeof _value !== \"string\" && typeof _value !== \"number\") {\n        throw new Error(\"\".concat(msg(propLoc), \" must be null, undefined, a boolean, a string, or a number.\"));\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction assertInputSourceMap(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && (typeof value !== \"object\" || !value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be a boolean, object, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertString(loc, value) {\n  if (value !== undefined && typeof value !== \"string\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a string, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertFunction(loc, value) {\n  if (value !== undefined && typeof value !== \"function\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a function, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertBoolean(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a boolean, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertObject(loc, value) {\n  if (value !== undefined && (typeof value !== \"object\" || Array.isArray(value) || !value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be an object, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertArray(loc, value) {\n  if (value != null && !Array.isArray(value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be an array, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertIgnoreList(loc, value) {\n  var arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach(function (item, i) {\n      return assertIgnoreItem(access(loc, i), item);\n    });\n  }\n\n  return arr;\n}\n\nfunction assertIgnoreItem(loc, value) {\n  if (typeof value !== \"string\" && typeof value !== \"function\" && !(value instanceof RegExp)) {\n    throw new Error(\"\".concat(msg(loc), \" must be an array of string/Function/RegExp values, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertConfigApplicableTest(loc, value) {\n  if (value === undefined) return value;\n\n  if (Array.isArray(value)) {\n    value.forEach(function (item, i) {\n      if (!checkValidTest(item)) {\n        throw new Error(\"\".concat(msg(access(loc, i)), \" must be a string/Function/RegExp.\"));\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be a string/Function/RegExp, or an array of those\"));\n  }\n\n  return value;\n}\n\nfunction checkValidTest(value) {\n  return typeof value === \"string\" || typeof value === \"function\" || value instanceof RegExp;\n}\n\nfunction assertConfigFileSearch(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && typeof value !== \"string\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a undefined, a boolean, a string, \") + \"got \".concat(JSON.stringify(value)));\n  }\n\n  return value;\n}\n\nfunction assertBabelrcSearch(loc, value) {\n  if (value === undefined || typeof value === \"boolean\") return value;\n\n  if (Array.isArray(value)) {\n    value.forEach(function (item, i) {\n      if (!checkValidTest(item)) {\n        throw new Error(\"\".concat(msg(access(loc, i)), \" must be a string/Function/RegExp.\"));\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be a undefined, a boolean, a string/Function/RegExp \") + \"or an array of those, got \".concat(JSON.stringify(value)));\n  }\n\n  return value;\n}\n\nfunction assertPluginList(loc, value) {\n  var arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach(function (item, i) {\n      return assertPluginItem(access(loc, i), item);\n    });\n  }\n\n  return arr;\n}\n\nfunction assertPluginItem(loc, value) {\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      throw new Error(\"\".concat(msg(loc), \" must include an object\"));\n    }\n\n    if (value.length > 3) {\n      throw new Error(\"\".concat(msg(loc), \" may only be a two-tuple or three-tuple\"));\n    }\n\n    assertPluginTarget(access(loc, 0), value[0]);\n\n    if (value.length > 1) {\n      var opts = value[1];\n\n      if (opts !== undefined && opts !== false && (typeof opts !== \"object\" || Array.isArray(opts) || opts === null)) {\n        throw new Error(\"\".concat(msg(access(loc, 1)), \" must be an object, false, or undefined\"));\n      }\n    }\n\n    if (value.length === 3) {\n      var name = value[2];\n\n      if (name !== undefined && typeof name !== \"string\") {\n        throw new Error(\"\".concat(msg(access(loc, 2)), \" must be a string, or undefined\"));\n      }\n    }\n  } else {\n    assertPluginTarget(loc, value);\n  }\n\n  return value;\n}\n\nfunction assertPluginTarget(loc, value) {\n  if ((typeof value !== \"object\" || !value) && typeof value !== \"string\" && typeof value !== \"function\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a string, object, function\"));\n  }\n\n  return value;\n}\n\nfunction assertTargets(loc, value) {\n  if ((0, _helperCompilationTargets().isBrowsersQueryValid)(value)) return value;\n\n  if (typeof value !== \"object\" || !value || Array.isArray(value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be a string, an array of strings or an object\"));\n  }\n\n  var browsersLoc = access(loc, \"browsers\");\n  var esmodulesLoc = access(loc, \"esmodules\");\n  assertBrowsersList(browsersLoc, value.browsers);\n  assertBoolean(esmodulesLoc, value.esmodules);\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(value); _i2 < _Object$keys2.length; _i2++) {\n    var key = _Object$keys2[_i2];\n    var val = value[key];\n    var subLoc = access(loc, key);\n    if (key === \"esmodules\") assertBoolean(subLoc, val);else if (key === \"browsers\") assertBrowsersList(subLoc, val);else if (!Object.hasOwnProperty.call(_helperCompilationTargets().TargetNames, key)) {\n      var validTargets = Object.keys(_helperCompilationTargets().TargetNames).join(\", \");\n      throw new Error(\"\".concat(msg(subLoc), \" is not a valid target. Supported targets are \").concat(validTargets));\n    } else assertBrowserVersion(subLoc, val);\n  }\n\n  return value;\n}\n\nfunction assertBrowsersList(loc, value) {\n  if (value !== undefined && !(0, _helperCompilationTargets().isBrowsersQueryValid)(value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be undefined, a string or an array of strings\"));\n  }\n}\n\nfunction assertBrowserVersion(loc, value) {\n  if (typeof value === \"number\" && Math.round(value) === value) return;\n  if (typeof value === \"string\") return;\n  throw new Error(\"\".concat(msg(loc), \" must be a string or an integer number\"));\n}\n\nfunction assertAssumptions(loc, value) {\n  if (value === undefined) return;\n\n  if (typeof value !== \"object\" || value === null) {\n    throw new Error(\"\".concat(msg(loc), \" must be an object or undefined.\"));\n  }\n\n  var root = loc;\n\n  do {\n    root = root.parent;\n  } while (root.type !== \"root\");\n\n  var inPreset = root.source === \"preset\";\n\n  for (var _i3 = 0, _Object$keys3 = Object.keys(value); _i3 < _Object$keys3.length; _i3++) {\n    var name = _Object$keys3[_i3];\n    var subLoc = access(loc, name);\n\n    if (!_options.assumptionsNames.has(name)) {\n      throw new Error(\"\".concat(msg(subLoc), \" is not a supported assumption.\"));\n    }\n\n    if (typeof value[name] !== \"boolean\") {\n      throw new Error(\"\".concat(msg(subLoc), \" must be a boolean.\"));\n    }\n\n    if (inPreset && value[name] === false) {\n      throw new Error(\"\".concat(msg(subLoc), \" cannot be set to 'false' inside presets.\"));\n    }\n  }\n\n  return value;\n}\n\n0 && 0;","map":{"version":3,"mappings":"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","names":["_helperCompilationTargets","msg","loc","type","parent","name","index","JSON","stringify","Error","access","assertRootMode","value","undefined","assertSourceMaps","assertCompact","assertSourceType","assertCallerMetadata","obj","assertObject","Object","keys","prop","propLoc","assertInputSourceMap","assertString","assertFunction","assertBoolean","Array","isArray","assertArray","assertIgnoreList","arr","forEach","item","i","assertIgnoreItem","RegExp","assertConfigApplicableTest","checkValidTest","assertConfigFileSearch","assertBabelrcSearch","assertPluginList","assertPluginItem","length","assertPluginTarget","opts","assertTargets","browsersLoc","esmodulesLoc","assertBrowsersList","browsers","esmodules","key","val","subLoc","hasOwnProperty","call","TargetNames","validTargets","join","assertBrowserVersion","Math","round","assertAssumptions","root","inPreset","source","assumptionsNames","has"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\validation\\option-assertions.ts"],"sourcesContent":["import {\n  isBrowsersQueryValid,\n  TargetNames,\n} from \"@babel/helper-compilation-targets\";\n\nimport type {\n  ConfigFileSearch,\n  BabelrcSearch,\n  IgnoreList,\n  IgnoreItem,\n  PluginList,\n  PluginItem,\n  PluginTarget,\n  ConfigApplicableTest,\n  SourceMapsOption,\n  SourceTypeOption,\n  CompactOption,\n  RootInputSourceMapOption,\n  NestingPath,\n  CallerMetadata,\n  RootMode,\n  TargetsListOrObject,\n  AssumptionName,\n} from \"./options\";\n\nimport { assumptionsNames } from \"./options\";\n\nexport type { RootPath } from \"./options\";\n\nexport type ValidatorSet = {\n  [name: string]: Validator<any>;\n};\n\nexport type Validator<T> = (loc: OptionPath, value: unknown) => T;\n\nexport function msg(loc: NestingPath | GeneralPath): string {\n  switch (loc.type) {\n    case \"root\":\n      return ``;\n    case \"env\":\n      return `${msg(loc.parent)}.env[\"${loc.name}\"]`;\n    case \"overrides\":\n      return `${msg(loc.parent)}.overrides[${loc.index}]`;\n    case \"option\":\n      return `${msg(loc.parent)}.${loc.name}`;\n    case \"access\":\n      return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;\n    default:\n      // @ts-expect-error should not happen when code is type checked\n      throw new Error(`Assertion failure: Unknown type ${loc.type}`);\n  }\n}\n\nexport function access(loc: GeneralPath, name: string | number): AccessPath {\n  return {\n    type: \"access\",\n    name,\n    parent: loc,\n  };\n}\n\nexport type OptionPath = Readonly<{\n  type: \"option\";\n  name: string;\n  parent: NestingPath;\n}>;\ntype AccessPath = Readonly<{\n  type: \"access\";\n  name: string | number;\n  parent: GeneralPath;\n}>;\ntype GeneralPath = OptionPath | AccessPath;\n\nexport function assertRootMode(\n  loc: OptionPath,\n  value: unknown,\n): RootMode | void {\n  if (\n    value !== undefined &&\n    value !== \"root\" &&\n    value !== \"upward\" &&\n    value !== \"upward-optional\"\n  ) {\n    throw new Error(\n      `${msg(loc)} must be a \"root\", \"upward\", \"upward-optional\" or undefined`,\n    );\n  }\n  return value;\n}\n\nexport function assertSourceMaps(\n  loc: OptionPath,\n  value: unknown,\n): SourceMapsOption | void {\n  if (\n    value !== undefined &&\n    typeof value !== \"boolean\" &&\n    value !== \"inline\" &&\n    value !== \"both\"\n  ) {\n    throw new Error(\n      `${msg(loc)} must be a boolean, \"inline\", \"both\", or undefined`,\n    );\n  }\n  return value;\n}\n\nexport function assertCompact(\n  loc: OptionPath,\n  value: unknown,\n): CompactOption | void {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"auto\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"auto\", or undefined`);\n  }\n  return value;\n}\n\nexport function assertSourceType(\n  loc: OptionPath,\n  value: unknown,\n): SourceTypeOption | void {\n  if (\n    value !== undefined &&\n    value !== \"module\" &&\n    value !== \"script\" &&\n    value !== \"unambiguous\"\n  ) {\n    throw new Error(\n      `${msg(loc)} must be \"module\", \"script\", \"unambiguous\", or undefined`,\n    );\n  }\n  return value;\n}\n\nexport function assertCallerMetadata(\n  loc: OptionPath,\n  value: unknown,\n): CallerMetadata | undefined {\n  const obj = assertObject(loc, value);\n  if (obj) {\n    if (typeof obj.name !== \"string\") {\n      throw new Error(\n        `${msg(loc)} set but does not contain \"name\" property string`,\n      );\n    }\n\n    for (const prop of Object.keys(obj)) {\n      const propLoc = access(loc, prop);\n      const value = obj[prop];\n      if (\n        value != null &&\n        typeof value !== \"boolean\" &&\n        typeof value !== \"string\" &&\n        typeof value !== \"number\"\n      ) {\n        // NOTE(logan): I'm limiting the type here so that we can guarantee that\n        // the \"caller\" value will serialize to JSON nicely. We can always\n        // allow more complex structures later though.\n        throw new Error(\n          `${msg(\n            propLoc,\n          )} must be null, undefined, a boolean, a string, or a number.`,\n        );\n      }\n    }\n  }\n  // @ts-expect-error todo(flow->ts)\n  return value;\n}\n\nexport function assertInputSourceMap(\n  loc: OptionPath,\n  value: unknown,\n): RootInputSourceMapOption | void {\n  if (\n    value !== undefined &&\n    typeof value !== \"boolean\" &&\n    (typeof value !== \"object\" || !value)\n  ) {\n    throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);\n  }\n  return value;\n}\n\nexport function assertString(loc: GeneralPath, value: unknown): string | void {\n  if (value !== undefined && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a string, or undefined`);\n  }\n  return value;\n}\n\nexport function assertFunction(\n  loc: GeneralPath,\n  value: unknown,\n): Function | void {\n  if (value !== undefined && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a function, or undefined`);\n  }\n  return value;\n}\n\nexport function assertBoolean(\n  loc: GeneralPath,\n  value: unknown,\n): boolean | void {\n  if (value !== undefined && typeof value !== \"boolean\") {\n    throw new Error(`${msg(loc)} must be a boolean, or undefined`);\n  }\n  return value;\n}\n\nexport function assertObject(\n  loc: GeneralPath,\n  value: unknown,\n): { readonly [key: string]: unknown } | void {\n  if (\n    value !== undefined &&\n    (typeof value !== \"object\" || Array.isArray(value) || !value)\n  ) {\n    throw new Error(`${msg(loc)} must be an object, or undefined`);\n  }\n  // @ts-expect-error todo(flow->ts) value is still typed as unknown, also assert function typically should not return a value\n  return value;\n}\n\nexport function assertArray<T>(\n  loc: GeneralPath,\n  value: Array<T> | undefined | null,\n): ReadonlyArray<T> | undefined | null {\n  if (value != null && !Array.isArray(value)) {\n    throw new Error(`${msg(loc)} must be an array, or undefined`);\n  }\n  return value;\n}\n\nexport function assertIgnoreList(\n  loc: OptionPath,\n  value: unknown[] | undefined,\n): IgnoreList | void {\n  const arr = assertArray(loc, value);\n  if (arr) {\n    arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item));\n  }\n  // @ts-expect-error todo(flow->ts)\n  return arr;\n}\nfunction assertIgnoreItem(loc: GeneralPath, value: unknown): IgnoreItem {\n  if (\n    typeof value !== \"string\" &&\n    typeof value !== \"function\" &&\n    !(value instanceof RegExp)\n  ) {\n    throw new Error(\n      `${msg(\n        loc,\n      )} must be an array of string/Function/RegExp values, or undefined`,\n    );\n  }\n  return value as IgnoreItem;\n}\n\nexport function assertConfigApplicableTest(\n  loc: OptionPath,\n  value: unknown,\n): ConfigApplicableTest | void {\n  if (value === undefined) return value;\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(\n          `${msg(access(loc, i))} must be a string/Function/RegExp.`,\n        );\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(\n      `${msg(loc)} must be a string/Function/RegExp, or an array of those`,\n    );\n  }\n  return value as ConfigApplicableTest;\n}\n\nfunction checkValidTest(value: unknown): value is string | Function | RegExp {\n  return (\n    typeof value === \"string\" ||\n    typeof value === \"function\" ||\n    value instanceof RegExp\n  );\n}\n\nexport function assertConfigFileSearch(\n  loc: OptionPath,\n  value: unknown,\n): ConfigFileSearch | void {\n  if (\n    value !== undefined &&\n    typeof value !== \"boolean\" &&\n    typeof value !== \"string\"\n  ) {\n    throw new Error(\n      `${msg(loc)} must be a undefined, a boolean, a string, ` +\n        `got ${JSON.stringify(value)}`,\n    );\n  }\n\n  return value;\n}\n\nexport function assertBabelrcSearch(\n  loc: OptionPath,\n  value: unknown,\n): BabelrcSearch | void {\n  if (value === undefined || typeof value === \"boolean\") return value;\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(\n          `${msg(access(loc, i))} must be a string/Function/RegExp.`,\n        );\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(\n      `${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp ` +\n        `or an array of those, got ${JSON.stringify(value as any)}`,\n    );\n  }\n  return value as BabelrcSearch;\n}\n\nexport function assertPluginList(\n  loc: OptionPath,\n  value: unknown[] | null | undefined,\n): PluginList | void {\n  const arr = assertArray(loc, value);\n  if (arr) {\n    // Loop instead of using `.map` in order to preserve object identity\n    // for plugin array for use during config chain processing.\n    arr.forEach((item, i) => assertPluginItem(access(loc, i), item));\n  }\n  return arr as any;\n}\nfunction assertPluginItem(loc: GeneralPath, value: unknown): PluginItem {\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      throw new Error(`${msg(loc)} must include an object`);\n    }\n\n    if (value.length > 3) {\n      throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);\n    }\n\n    assertPluginTarget(access(loc, 0), value[0]);\n\n    if (value.length > 1) {\n      const opts = value[1];\n      if (\n        opts !== undefined &&\n        opts !== false &&\n        (typeof opts !== \"object\" || Array.isArray(opts) || opts === null)\n      ) {\n        throw new Error(\n          `${msg(access(loc, 1))} must be an object, false, or undefined`,\n        );\n      }\n    }\n    if (value.length === 3) {\n      const name = value[2];\n      if (name !== undefined && typeof name !== \"string\") {\n        throw new Error(\n          `${msg(access(loc, 2))} must be a string, or undefined`,\n        );\n      }\n    }\n  } else {\n    assertPluginTarget(loc, value);\n  }\n\n  // @ts-expect-error todo(flow->ts)\n  return value;\n}\nfunction assertPluginTarget(loc: GeneralPath, value: unknown): PluginTarget {\n  if (\n    (typeof value !== \"object\" || !value) &&\n    typeof value !== \"string\" &&\n    typeof value !== \"function\"\n  ) {\n    throw new Error(`${msg(loc)} must be a string, object, function`);\n  }\n  return value;\n}\n\nexport function assertTargets(\n  loc: GeneralPath,\n  value: any,\n): TargetsListOrObject {\n  if (isBrowsersQueryValid(value)) return value;\n\n  if (typeof value !== \"object\" || !value || Array.isArray(value)) {\n    throw new Error(\n      `${msg(loc)} must be a string, an array of strings or an object`,\n    );\n  }\n\n  const browsersLoc = access(loc, \"browsers\");\n  const esmodulesLoc = access(loc, \"esmodules\");\n\n  assertBrowsersList(browsersLoc, value.browsers);\n  assertBoolean(esmodulesLoc, value.esmodules);\n\n  for (const key of Object.keys(value)) {\n    const val = value[key];\n    const subLoc = access(loc, key);\n\n    if (key === \"esmodules\") assertBoolean(subLoc, val);\n    else if (key === \"browsers\") assertBrowsersList(subLoc, val);\n    else if (!Object.hasOwnProperty.call(TargetNames, key)) {\n      const validTargets = Object.keys(TargetNames).join(\", \");\n      throw new Error(\n        `${msg(\n          subLoc,\n        )} is not a valid target. Supported targets are ${validTargets}`,\n      );\n    } else assertBrowserVersion(subLoc, val);\n  }\n\n  return value;\n}\n\nfunction assertBrowsersList(loc: GeneralPath, value: unknown) {\n  if (value !== undefined && !isBrowsersQueryValid(value)) {\n    throw new Error(\n      `${msg(loc)} must be undefined, a string or an array of strings`,\n    );\n  }\n}\n\nfunction assertBrowserVersion(loc: GeneralPath, value: unknown) {\n  if (typeof value === \"number\" && Math.round(value) === value) return;\n  if (typeof value === \"string\") return;\n\n  throw new Error(`${msg(loc)} must be a string or an integer number`);\n}\n\nexport function assertAssumptions(\n  loc: GeneralPath,\n  value: { [key: string]: unknown },\n): { [name: string]: boolean } | void {\n  if (value === undefined) return;\n\n  if (typeof value !== \"object\" || value === null) {\n    throw new Error(`${msg(loc)} must be an object or undefined.`);\n  }\n\n  // todo(flow->ts): remove any\n  let root: any = loc;\n  do {\n    root = root.parent;\n  } while (root.type !== \"root\");\n  const inPreset = root.source === \"preset\";\n\n  for (const name of Object.keys(value)) {\n    const subLoc = access(loc, name);\n    if (!assumptionsNames.has(name as AssumptionName)) {\n      throw new Error(`${msg(subLoc)} is not a supported assumption.`);\n    }\n    if (typeof value[name] !== \"boolean\") {\n      throw new Error(`${msg(subLoc)} must be a boolean.`);\n    }\n    if (inPreset && value[name] === false) {\n      throw new Error(\n        `${msg(subLoc)} cannot be set to 'false' inside presets.`,\n      );\n    }\n  }\n\n  // @ts-expect-error todo(flow->ts)\n  return value;\n}\n"]},"metadata":{},"sourceType":"script"}