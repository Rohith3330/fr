{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'promise-function-async',\n  meta: {\n    type: 'suggestion',\n    fixable: 'code',\n    docs: {\n      description: 'Require any function or method that returns a Promise to be marked async',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    messages: {\n      missingAsync: 'Functions that return promises must be async.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowAny: {\n          description: 'Whether to consider `any` and `unknown` to be Promises.',\n          type: 'boolean'\n        },\n        allowedPromiseNames: {\n          description: 'Any extra names of classes or interfaces to be considered Promises.',\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n        checkArrowFunctions: {\n          type: 'boolean'\n        },\n        checkFunctionDeclarations: {\n          type: 'boolean'\n        },\n        checkFunctionExpressions: {\n          type: 'boolean'\n        },\n        checkMethodDeclarations: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    allowAny: true,\n    allowedPromiseNames: [],\n    checkArrowFunctions: true,\n    checkFunctionDeclarations: true,\n    checkFunctionExpressions: true,\n    checkMethodDeclarations: true\n  }],\n\n  create(context, _ref) {\n    let [{\n      allowAny,\n      allowedPromiseNames,\n      checkArrowFunctions,\n      checkFunctionDeclarations,\n      checkFunctionExpressions,\n      checkMethodDeclarations\n    }] = _ref;\n    const allAllowedPromiseNames = new Set(['Promise', ...allowedPromiseNames]);\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n\n    function validateNode(node) {\n      var _a;\n\n      const originalNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      const signatures = checker.getTypeAtLocation(originalNode).getCallSignatures();\n\n      if (!signatures.length) {\n        return;\n      }\n\n      const returnType = checker.getReturnTypeOfSignature(signatures[0]);\n\n      if (!util.containsAllTypesByName(returnType, allowAny, allAllowedPromiseNames)) {\n        // Return type is not a promise\n        return;\n      }\n\n      if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition) {\n        // Abstract method can't be async\n        return;\n      }\n\n      if (node.parent && (node.parent.type === utils_1.AST_NODE_TYPES.Property || node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition) && (node.parent.kind === 'get' || node.parent.kind === 'set')) {\n        // Getters and setters can't be async\n        return;\n      }\n\n      if (util.isTypeFlagSet(returnType, ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {\n        // Report without auto fixer because the return type is unknown\n        return context.report({\n          messageId: 'missingAsync',\n          node,\n          loc: util.getFunctionHeadLoc(node, sourceCode)\n        });\n      }\n\n      context.report({\n        messageId: 'missingAsync',\n        node,\n        loc: util.getFunctionHeadLoc(node, sourceCode),\n        fix: fixer => {\n          if (node.parent && (node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition || node.parent.type === utils_1.AST_NODE_TYPES.Property && node.parent.method)) {\n            // this function is a class method or object function property shorthand\n            const method = node.parent; // the token to put `async` before\n\n            let keyToken = sourceCode.getFirstToken(method); // if there are decorators then skip past them\n\n            if (method.type === utils_1.AST_NODE_TYPES.MethodDefinition && method.decorators) {\n              const lastDecorator = method.decorators[method.decorators.length - 1];\n              keyToken = sourceCode.getTokenAfter(lastDecorator);\n            } // if current token is a keyword like `static` or `public` then skip it\n\n\n            while (keyToken.type === utils_1.AST_TOKEN_TYPES.Keyword) {\n              keyToken = sourceCode.getTokenAfter(keyToken);\n            } // check if there is a space between key and previous token\n\n\n            const insertSpace = !sourceCode.isSpaceBetween(sourceCode.getTokenBefore(keyToken), keyToken);\n            let code = 'async ';\n\n            if (insertSpace) {\n              code = ` ${code}`;\n            }\n\n            return fixer.insertTextBefore(keyToken, code);\n          }\n\n          return fixer.insertTextBefore(node, 'async ');\n        }\n      });\n    }\n\n    return Object.assign(Object.assign(Object.assign({}, checkArrowFunctions && {\n      'ArrowFunctionExpression[async = false]'(node) {\n        validateNode(node);\n      }\n\n    }), checkFunctionDeclarations && {\n      'FunctionDeclaration[async = false]'(node) {\n        validateNode(node);\n      }\n\n    }), {\n      'FunctionExpression[async = false]'(node) {\n        if (node.parent && node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition && node.parent.kind === 'method') {\n          if (checkMethodDeclarations) {\n            validateNode(node);\n          }\n\n          return;\n        }\n\n        if (checkFunctionExpressions) {\n          validateNode(node);\n        }\n      }\n\n    });\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","fixable","docs","description","recommended","requiresTypeChecking","messages","missingAsync","schema","properties","allowAny","allowedPromiseNames","items","checkArrowFunctions","checkFunctionDeclarations","checkFunctionExpressions","checkMethodDeclarations","additionalProperties","defaultOptions","create","context","allAllowedPromiseNames","Set","parserServices","getParserServices","checker","program","getTypeChecker","sourceCode","getSourceCode","validateNode","node","originalNode","esTreeNodeToTSNodeMap","get","signatures","getTypeAtLocation","getCallSignatures","length","returnType","getReturnTypeOfSignature","containsAllTypesByName","parent","_a","utils_1","TSAbstractMethodDefinition","Property","MethodDefinition","kind","isTypeFlagSet","ts","TypeFlags","Any","Unknown","report","messageId","loc","getFunctionHeadLoc","fix","fixer","method","keyToken","getFirstToken","decorators","lastDecorator","getTokenAfter","Keyword","insertSpace","isSpaceBetween","getTokenBefore","code","insertTextBefore"],"sources":["../../src/rules/promise-function-async.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}