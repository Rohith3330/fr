{"ast":null,"code":"/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns `true`.\n * @returns {boolean} `true`.\n */\n\nfunction alwaysTrue() {\n  return true;\n}\n/**\n * Returns `false`.\n * @returns {boolean} `false`.\n */\n\n\nfunction alwaysFalse() {\n  return false;\n}\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow unused expressions\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unused-expressions\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowShortCircuit: {\n          type: \"boolean\",\n          default: false\n        },\n        allowTernary: {\n          type: \"boolean\",\n          default: false\n        },\n        allowTaggedTemplates: {\n          type: \"boolean\",\n          default: false\n        },\n        enforceForJSX: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unusedExpression: \"Expected an assignment or function call and instead saw an expression.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || {},\n          allowShortCircuit = config.allowShortCircuit || false,\n          allowTernary = config.allowTernary || false,\n          allowTaggedTemplates = config.allowTaggedTemplates || false,\n          enforceForJSX = config.enforceForJSX || false;\n    /**\n     * Has AST suggesting a directive.\n     * @param {ASTNode} node any node\n     * @returns {boolean} whether the given node structurally represents a directive\n     */\n\n    function looksLikeDirective(node) {\n      return node.type === \"ExpressionStatement\" && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n    }\n    /**\n     * Gets the leading sequence of members in a list that pass the predicate.\n     * @param {Function} predicate ([a] -> Boolean) the function used to make the determination\n     * @param {a[]} list the input list\n     * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n     */\n\n\n    function takeWhile(predicate, list) {\n      for (let i = 0; i < list.length; ++i) {\n        if (!predicate(list[i])) {\n          return list.slice(0, i);\n        }\n      }\n\n      return list.slice();\n    }\n    /**\n     * Gets leading directives nodes in a Node body.\n     * @param {ASTNode} node a Program or BlockStatement node\n     * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n     */\n\n\n    function directives(node) {\n      return takeWhile(looksLikeDirective, node.body);\n    }\n    /**\n     * Detect if a Node is a directive.\n     * @param {ASTNode} node any node\n     * @param {ASTNode[]} ancestors the given node's ancestors\n     * @returns {boolean} whether the given node is considered a directive in its current position\n     */\n\n\n    function isDirective(node, ancestors) {\n      const parent = ancestors[ancestors.length - 1],\n            grandparent = ancestors[ancestors.length - 2];\n      /**\n       * https://tc39.es/ecma262/#directive-prologue\n       *\n       * Only `FunctionBody`, `ScriptBody` and `ModuleBody` can have directive prologue.\n       * Class static blocks do not have directive prologue.\n       */\n\n      return (parent.type === \"Program\" || parent.type === \"BlockStatement\" && /Function/u.test(grandparent.type)) && directives(parent).includes(node);\n    }\n    /**\n     * The member functions return `true` if the type has no side-effects.\n     * Unknown nodes are handled as `false`, then this rule ignores those.\n     */\n\n\n    const Checker = Object.assign(Object.create(null), {\n      isDisallowed(node) {\n        return (Checker[node.type] || alwaysFalse)(node);\n      },\n\n      ArrayExpression: alwaysTrue,\n      ArrowFunctionExpression: alwaysTrue,\n      BinaryExpression: alwaysTrue,\n\n      ChainExpression(node) {\n        return Checker.isDisallowed(node.expression);\n      },\n\n      ClassExpression: alwaysTrue,\n\n      ConditionalExpression(node) {\n        if (allowTernary) {\n          return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);\n        }\n\n        return true;\n      },\n\n      FunctionExpression: alwaysTrue,\n      Identifier: alwaysTrue,\n\n      JSXElement() {\n        return enforceForJSX;\n      },\n\n      JSXFragment() {\n        return enforceForJSX;\n      },\n\n      Literal: alwaysTrue,\n\n      LogicalExpression(node) {\n        if (allowShortCircuit) {\n          return Checker.isDisallowed(node.right);\n        }\n\n        return true;\n      },\n\n      MemberExpression: alwaysTrue,\n      MetaProperty: alwaysTrue,\n      ObjectExpression: alwaysTrue,\n      SequenceExpression: alwaysTrue,\n\n      TaggedTemplateExpression() {\n        return !allowTaggedTemplates;\n      },\n\n      TemplateLiteral: alwaysTrue,\n      ThisExpression: alwaysTrue,\n\n      UnaryExpression(node) {\n        return node.operator !== \"void\" && node.operator !== \"delete\";\n      }\n\n    });\n    return {\n      ExpressionStatement(node) {\n        if (Checker.isDisallowed(node.expression) && !isDirective(node, context.getAncestors())) {\n          context.report({\n            node,\n            messageId: \"unusedExpression\"\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["alwaysTrue","alwaysFalse","module","exports","meta","type","docs","description","recommended","url","schema","properties","allowShortCircuit","default","allowTernary","allowTaggedTemplates","enforceForJSX","additionalProperties","messages","unusedExpression","create","context","config","options","looksLikeDirective","node","expression","value","takeWhile","predicate","list","i","length","slice","directives","body","isDirective","ancestors","parent","grandparent","test","includes","Checker","Object","assign","isDisallowed","ArrayExpression","ArrowFunctionExpression","BinaryExpression","ChainExpression","ClassExpression","ConditionalExpression","consequent","alternate","FunctionExpression","Identifier","JSXElement","JSXFragment","Literal","LogicalExpression","right","MemberExpression","MetaProperty","ObjectExpression","SequenceExpression","TaggedTemplateExpression","TemplateLiteral","ThisExpression","UnaryExpression","operator","ExpressionStatement","getAncestors","report","messageId"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/no-unused-expressions.js"],"sourcesContent":["/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns `true`.\n * @returns {boolean} `true`.\n */\nfunction alwaysTrue() {\n    return true;\n}\n\n/**\n * Returns `false`.\n * @returns {boolean} `false`.\n */\nfunction alwaysFalse() {\n    return false;\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unused expressions\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unused-expressions\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowShortCircuit: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowTernary: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowTaggedTemplates: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    enforceForJSX: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unusedExpression: \"Expected an assignment or function call and instead saw an expression.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            allowShortCircuit = config.allowShortCircuit || false,\n            allowTernary = config.allowTernary || false,\n            allowTaggedTemplates = config.allowTaggedTemplates || false,\n            enforceForJSX = config.enforceForJSX || false;\n\n        /**\n         * Has AST suggesting a directive.\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * Gets the leading sequence of members in a list that pass the predicate.\n         * @param {Function} predicate ([a] -> Boolean) the function used to make the determination\n         * @param {a[]} list the input list\n         * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n         */\n        function takeWhile(predicate, list) {\n            for (let i = 0; i < list.length; ++i) {\n                if (!predicate(list[i])) {\n                    return list.slice(0, i);\n                }\n            }\n            return list.slice();\n        }\n\n        /**\n         * Gets leading directives nodes in a Node body.\n         * @param {ASTNode} node a Program or BlockStatement node\n         * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n         */\n        function directives(node) {\n            return takeWhile(looksLikeDirective, node.body);\n        }\n\n        /**\n         * Detect if a Node is a directive.\n         * @param {ASTNode} node any node\n         * @param {ASTNode[]} ancestors the given node's ancestors\n         * @returns {boolean} whether the given node is considered a directive in its current position\n         */\n        function isDirective(node, ancestors) {\n            const parent = ancestors[ancestors.length - 1],\n                grandparent = ancestors[ancestors.length - 2];\n\n            /**\n             * https://tc39.es/ecma262/#directive-prologue\n             *\n             * Only `FunctionBody`, `ScriptBody` and `ModuleBody` can have directive prologue.\n             * Class static blocks do not have directive prologue.\n             */\n            return (parent.type === \"Program\" || parent.type === \"BlockStatement\" &&\n                    (/Function/u.test(grandparent.type))) &&\n                    directives(parent).includes(node);\n        }\n\n        /**\n         * The member functions return `true` if the type has no side-effects.\n         * Unknown nodes are handled as `false`, then this rule ignores those.\n         */\n        const Checker = Object.assign(Object.create(null), {\n            isDisallowed(node) {\n                return (Checker[node.type] || alwaysFalse)(node);\n            },\n\n            ArrayExpression: alwaysTrue,\n            ArrowFunctionExpression: alwaysTrue,\n            BinaryExpression: alwaysTrue,\n            ChainExpression(node) {\n                return Checker.isDisallowed(node.expression);\n            },\n            ClassExpression: alwaysTrue,\n            ConditionalExpression(node) {\n                if (allowTernary) {\n                    return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);\n                }\n                return true;\n            },\n            FunctionExpression: alwaysTrue,\n            Identifier: alwaysTrue,\n            JSXElement() {\n                return enforceForJSX;\n            },\n            JSXFragment() {\n                return enforceForJSX;\n            },\n            Literal: alwaysTrue,\n            LogicalExpression(node) {\n                if (allowShortCircuit) {\n                    return Checker.isDisallowed(node.right);\n                }\n                return true;\n            },\n            MemberExpression: alwaysTrue,\n            MetaProperty: alwaysTrue,\n            ObjectExpression: alwaysTrue,\n            SequenceExpression: alwaysTrue,\n            TaggedTemplateExpression() {\n                return !allowTaggedTemplates;\n            },\n            TemplateLiteral: alwaysTrue,\n            ThisExpression: alwaysTrue,\n            UnaryExpression(node) {\n                return node.operator !== \"void\" && node.operator !== \"delete\";\n            }\n        });\n\n        return {\n            ExpressionStatement(node) {\n                if (Checker.isDisallowed(node.expression) && !isDirective(node, context.getAncestors())) {\n                    context.report({ node, messageId: \"unusedExpression\" });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}