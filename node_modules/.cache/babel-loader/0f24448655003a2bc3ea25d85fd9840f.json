{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _readPkgUp = require('eslint-module-utils/readPkgUp');\n\nvar _readPkgUp2 = _interopRequireDefault(_readPkgUp);\n\nvar _minimatch = require('minimatch');\n\nvar _minimatch2 = _interopRequireDefault(_minimatch);\n\nvar _resolve = require('eslint-module-utils/resolve');\n\nvar _resolve2 = _interopRequireDefault(_resolve);\n\nvar _moduleVisitor = require('eslint-module-utils/moduleVisitor');\n\nvar _moduleVisitor2 = _interopRequireDefault(_moduleVisitor);\n\nvar _importType = require('../core/importType');\n\nvar _importType2 = _interopRequireDefault(_importType);\n\nvar _packagePath = require('../core/packagePath');\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar depFieldCache = new Map();\n\nfunction hasKeys() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return Object.keys(obj).length > 0;\n}\n\nfunction arrayOrKeys(arrayOrObject) {\n  return Array.isArray(arrayOrObject) ? arrayOrObject : Object.keys(arrayOrObject);\n}\n\nfunction extractDepFields(pkg) {\n  return {\n    dependencies: pkg.dependencies || {},\n    devDependencies: pkg.devDependencies || {},\n    optionalDependencies: pkg.optionalDependencies || {},\n    peerDependencies: pkg.peerDependencies || {},\n    // BundledDeps should be in the form of an array, but object notation is also supported by\n    // `npm`, so we convert it to an array if it is an object\n    bundledDependencies: arrayOrKeys(pkg.bundleDependencies || pkg.bundledDependencies || [])\n  };\n}\n\nfunction getDependencies(context, packageDir) {\n  var paths = [];\n\n  try {\n    var packageContent = {\n      dependencies: {},\n      devDependencies: {},\n      optionalDependencies: {},\n      peerDependencies: {},\n      bundledDependencies: []\n    };\n\n    if (packageDir && packageDir.length > 0) {\n      if (!Array.isArray(packageDir)) {\n        paths = [_path2['default'].resolve(packageDir)];\n      } else {\n        paths = packageDir.map(function (dir) {\n          return _path2['default'].resolve(dir);\n        });\n      }\n    }\n\n    if (paths.length > 0) {\n      // use rule config to find package.json\n      paths.forEach(function (dir) {\n        var packageJsonPath = _path2['default'].join(dir, 'package.json');\n\n        if (!depFieldCache.has(packageJsonPath)) {\n          var depFields = extractDepFields(JSON.parse(_fs2['default'].readFileSync(packageJsonPath, 'utf8')));\n          depFieldCache.set(packageJsonPath, depFields);\n        }\n\n        var _packageContent = depFieldCache.get(packageJsonPath);\n\n        Object.keys(packageContent).forEach(function (depsKey) {\n          return Object.assign(packageContent[depsKey], _packageContent[depsKey]);\n        });\n      });\n    } else {\n      // use closest package.json\n      Object.assign(packageContent, extractDepFields((0, _readPkgUp2['default'])({\n        cwd: context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename(),\n        normalize: false\n      }).pkg));\n    }\n\n    if (![packageContent.dependencies, packageContent.devDependencies, packageContent.optionalDependencies, packageContent.peerDependencies, packageContent.bundledDependencies].some(hasKeys)) {\n      return null;\n    }\n\n    return packageContent;\n  } catch (e) {\n    if (paths.length > 0 && e.code === 'ENOENT') {\n      context.report({\n        message: 'The package.json file could not be found.',\n        loc: {\n          line: 0,\n          column: 0\n        }\n      });\n    }\n\n    if (e.name === 'JSONError' || e instanceof SyntaxError) {\n      context.report({\n        message: 'The package.json file could not be parsed: ' + e.message,\n        loc: {\n          line: 0,\n          column: 0\n        }\n      });\n    }\n\n    return null;\n  }\n}\n\nfunction missingErrorMessage(packageName) {\n  return '\\'' + String(packageName) + '\\' should be listed in the project\\'s dependencies. ' + ('Run \\'npm i -S ' + String(packageName) + '\\' to add it');\n}\n\nfunction devDepErrorMessage(packageName) {\n  return '\\'' + String(packageName) + '\\' should be listed in the project\\'s dependencies, not devDependencies.';\n}\n\nfunction optDepErrorMessage(packageName) {\n  return '\\'' + String(packageName) + '\\' should be listed in the project\\'s dependencies, ' + 'not optionalDependencies.';\n}\n\nfunction getModuleOriginalName(name) {\n  var _name$split = name.split('/'),\n      _name$split2 = _slicedToArray(_name$split, 2),\n      first = _name$split2[0],\n      second = _name$split2[1];\n\n  return first.startsWith('@') ? String(first) + '/' + String(second) : first;\n}\n\nfunction getModuleRealName(resolved) {\n  return (0, _packagePath.getFilePackageName)(resolved);\n}\n\nfunction checkDependencyDeclaration(deps, packageName, declarationStatus) {\n  var newDeclarationStatus = declarationStatus || {\n    isInDeps: false,\n    isInDevDeps: false,\n    isInOptDeps: false,\n    isInPeerDeps: false,\n    isInBundledDeps: false\n  }; // in case of sub package.json inside a module\n  // check the dependencies on all hierarchy\n\n  var packageHierarchy = [];\n  var packageNameParts = packageName ? packageName.split('/') : [];\n  packageNameParts.forEach(function (namePart, index) {\n    if (!namePart.startsWith('@')) {\n      var ancestor = packageNameParts.slice(0, index + 1).join('/');\n      packageHierarchy.push(ancestor);\n    }\n  });\n  return packageHierarchy.reduce(function (result, ancestorName) {\n    return {\n      isInDeps: result.isInDeps || deps.dependencies[ancestorName] !== undefined,\n      isInDevDeps: result.isInDevDeps || deps.devDependencies[ancestorName] !== undefined,\n      isInOptDeps: result.isInOptDeps || deps.optionalDependencies[ancestorName] !== undefined,\n      isInPeerDeps: result.isInPeerDeps || deps.peerDependencies[ancestorName] !== undefined,\n      isInBundledDeps: result.isInBundledDeps || deps.bundledDependencies.indexOf(ancestorName) !== -1\n    };\n  }, newDeclarationStatus);\n}\n\nfunction reportIfMissing(context, deps, depsOptions, node, name) {\n  // Do not report when importing types\n  if (node.importKind === 'type' || node.importKind === 'typeof') {\n    return;\n  }\n\n  if ((0, _importType2['default'])(name, context) !== 'external') {\n    return;\n  }\n\n  var resolved = (0, _resolve2['default'])(name, context);\n\n  if (!resolved) {\n    return;\n  }\n\n  var importPackageName = getModuleOriginalName(name);\n  var declarationStatus = checkDependencyDeclaration(deps, importPackageName);\n\n  if (declarationStatus.isInDeps || depsOptions.allowDevDeps && declarationStatus.isInDevDeps || depsOptions.allowPeerDeps && declarationStatus.isInPeerDeps || depsOptions.allowOptDeps && declarationStatus.isInOptDeps || depsOptions.allowBundledDeps && declarationStatus.isInBundledDeps) {\n    return;\n  } // test the real name from the resolved package.json\n  // if not aliased imports (alias/react for example), importPackageName can be misinterpreted\n\n\n  var realPackageName = getModuleRealName(resolved);\n\n  if (realPackageName && realPackageName !== importPackageName) {\n    declarationStatus = checkDependencyDeclaration(deps, realPackageName, declarationStatus);\n\n    if (declarationStatus.isInDeps || depsOptions.allowDevDeps && declarationStatus.isInDevDeps || depsOptions.allowPeerDeps && declarationStatus.isInPeerDeps || depsOptions.allowOptDeps && declarationStatus.isInOptDeps || depsOptions.allowBundledDeps && declarationStatus.isInBundledDeps) {\n      return;\n    }\n  }\n\n  if (declarationStatus.isInDevDeps && !depsOptions.allowDevDeps) {\n    context.report(node, devDepErrorMessage(realPackageName || importPackageName));\n    return;\n  }\n\n  if (declarationStatus.isInOptDeps && !depsOptions.allowOptDeps) {\n    context.report(node, optDepErrorMessage(realPackageName || importPackageName));\n    return;\n  }\n\n  context.report(node, missingErrorMessage(realPackageName || importPackageName));\n}\n\nfunction testConfig(config, filename) {\n  // Simplest configuration first, either a boolean or nothing.\n  if (typeof config === 'boolean' || typeof config === 'undefined') {\n    return config;\n  } // Array of globs.\n\n\n  return config.some(function (c) {\n    return (0, _minimatch2['default'])(filename, c) || (0, _minimatch2['default'])(filename, _path2['default'].join(process.cwd(), c));\n  });\n}\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      url: (0, _docsUrl2['default'])('no-extraneous-dependencies')\n    },\n    schema: [{\n      'type': 'object',\n      'properties': {\n        'devDependencies': {\n          'type': ['boolean', 'array']\n        },\n        'optionalDependencies': {\n          'type': ['boolean', 'array']\n        },\n        'peerDependencies': {\n          'type': ['boolean', 'array']\n        },\n        'bundledDependencies': {\n          'type': ['boolean', 'array']\n        },\n        'packageDir': {\n          'type': ['string', 'array']\n        }\n      },\n      'additionalProperties': false\n    }]\n  },\n  create: function () {\n    function create(context) {\n      var options = context.options[0] || {};\n      var filename = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n      var deps = getDependencies(context, options.packageDir) || extractDepFields({});\n      var depsOptions = {\n        allowDevDeps: testConfig(options.devDependencies, filename) !== false,\n        allowOptDeps: testConfig(options.optionalDependencies, filename) !== false,\n        allowPeerDeps: testConfig(options.peerDependencies, filename) !== false,\n        allowBundledDeps: testConfig(options.bundledDependencies, filename) !== false\n      };\n      return (0, _moduleVisitor2['default'])(function (source, node) {\n        reportIfMissing(context, deps, depsOptions, node, source.value);\n      }, {\n        commonjs: true\n      });\n    }\n\n    return create;\n  }()\n};","map":{"version":3,"mappings":"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","names":["depFieldCache","Map","hasKeys","obj","Object","keys","length","arrayOrKeys","arrayOrObject","Array","isArray","extractDepFields","pkg","dependencies","devDependencies","optionalDependencies","peerDependencies","bundledDependencies","bundleDependencies","getDependencies","context","packageDir","paths","packageContent","path","resolve","map","dir","forEach","packageJsonPath","join","has","depFields","JSON","parse","fs","readFileSync","set","_packageContent","get","assign","depsKey","cwd","getPhysicalFilename","getFilename","normalize","some","e","code","report","message","loc","line","column","name","SyntaxError","missingErrorMessage","packageName","devDepErrorMessage","optDepErrorMessage","getModuleOriginalName","split","first","second","startsWith","getModuleRealName","resolved","checkDependencyDeclaration","deps","declarationStatus","newDeclarationStatus","isInDeps","isInDevDeps","isInOptDeps","isInPeerDeps","isInBundledDeps","packageHierarchy","packageNameParts","namePart","index","ancestor","slice","push","reduce","result","ancestorName","undefined","indexOf","reportIfMissing","depsOptions","node","importKind","importPackageName","allowDevDeps","allowPeerDeps","allowOptDeps","allowBundledDeps","realPackageName","testConfig","config","filename","c","process","module","exports","meta","type","docs","url","schema","create","options","source","value","commonjs"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\no-extraneous-dependencies.js"],"sourcesContent":["import path from 'path';\nimport fs from 'fs';\nimport readPkgUp from 'eslint-module-utils/readPkgUp';\nimport minimatch from 'minimatch';\nimport resolve from 'eslint-module-utils/resolve';\nimport moduleVisitor from 'eslint-module-utils/moduleVisitor';\nimport importType from '../core/importType';\nimport { getFilePackageName } from '../core/packagePath';\nimport docsUrl from '../docsUrl';\n\nconst depFieldCache = new Map();\n\nfunction hasKeys(obj = {}) {\n  return Object.keys(obj).length > 0;\n}\n\nfunction arrayOrKeys(arrayOrObject) {\n  return Array.isArray(arrayOrObject) ? arrayOrObject : Object.keys(arrayOrObject);\n}\n\nfunction extractDepFields(pkg) {\n  return {\n    dependencies: pkg.dependencies || {},\n    devDependencies: pkg.devDependencies || {},\n    optionalDependencies: pkg.optionalDependencies || {},\n    peerDependencies: pkg.peerDependencies || {},\n    // BundledDeps should be in the form of an array, but object notation is also supported by\n    // `npm`, so we convert it to an array if it is an object\n    bundledDependencies: arrayOrKeys(pkg.bundleDependencies || pkg.bundledDependencies || []),\n  };\n}\n\nfunction getDependencies(context, packageDir) {\n  let paths = [];\n  try {\n    const packageContent = {\n      dependencies: {},\n      devDependencies: {},\n      optionalDependencies: {},\n      peerDependencies: {},\n      bundledDependencies: [],\n    };\n\n    if (packageDir && packageDir.length > 0) {\n      if (!Array.isArray(packageDir)) {\n        paths = [path.resolve(packageDir)];\n      } else {\n        paths = packageDir.map(dir => path.resolve(dir));\n      }\n    }\n\n    if (paths.length > 0) {\n      // use rule config to find package.json\n      paths.forEach(dir => {\n        const packageJsonPath = path.join(dir, 'package.json');\n        if (!depFieldCache.has(packageJsonPath)) {\n          const depFields = extractDepFields(\n            JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')),\n          );\n          depFieldCache.set(packageJsonPath, depFields);\n        }\n        const _packageContent = depFieldCache.get(packageJsonPath);\n        Object.keys(packageContent).forEach(depsKey =>\n          Object.assign(packageContent[depsKey], _packageContent[depsKey]),\n        );\n      });\n    } else {\n      // use closest package.json\n      Object.assign(\n        packageContent,\n        extractDepFields(\n          readPkgUp({ cwd: context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename(), normalize: false }).pkg,\n        ),\n      );\n    }\n\n    if (![\n      packageContent.dependencies,\n      packageContent.devDependencies,\n      packageContent.optionalDependencies,\n      packageContent.peerDependencies,\n      packageContent.bundledDependencies,\n    ].some(hasKeys)) {\n      return null;\n    }\n\n    return packageContent;\n  } catch (e) {\n    if (paths.length > 0 && e.code === 'ENOENT') {\n      context.report({\n        message: 'The package.json file could not be found.',\n        loc: { line: 0, column: 0 },\n      });\n    }\n    if (e.name === 'JSONError' || e instanceof SyntaxError) {\n      context.report({\n        message: 'The package.json file could not be parsed: ' + e.message,\n        loc: { line: 0, column: 0 },\n      });\n    }\n\n    return null;\n  }\n}\n\nfunction missingErrorMessage(packageName) {\n  return `'${packageName}' should be listed in the project's dependencies. ` +\n    `Run 'npm i -S ${packageName}' to add it`;\n}\n\nfunction devDepErrorMessage(packageName) {\n  return `'${packageName}' should be listed in the project's dependencies, not devDependencies.`;\n}\n\nfunction optDepErrorMessage(packageName) {\n  return `'${packageName}' should be listed in the project's dependencies, ` +\n    `not optionalDependencies.`;\n}\n\nfunction getModuleOriginalName(name) {\n  const [first, second] = name.split('/');\n  return first.startsWith('@') ? `${first}/${second}` : first;\n}\n\nfunction getModuleRealName(resolved) {\n  return getFilePackageName(resolved);\n}\n\nfunction checkDependencyDeclaration(deps, packageName, declarationStatus) {\n  const newDeclarationStatus = declarationStatus || {\n    isInDeps: false,\n    isInDevDeps: false,\n    isInOptDeps: false,\n    isInPeerDeps: false,\n    isInBundledDeps: false,\n  };\n\n  // in case of sub package.json inside a module\n  // check the dependencies on all hierarchy\n  const packageHierarchy = [];\n  const packageNameParts = packageName ? packageName.split('/') : [];\n  packageNameParts.forEach((namePart, index) => {\n    if (!namePart.startsWith('@')) {\n      const ancestor = packageNameParts.slice(0, index + 1).join('/');\n      packageHierarchy.push(ancestor);\n    }\n  });\n\n  return packageHierarchy.reduce((result, ancestorName) => {\n    return {\n      isInDeps: result.isInDeps || deps.dependencies[ancestorName] !== undefined,\n      isInDevDeps: result.isInDevDeps || deps.devDependencies[ancestorName] !== undefined,\n      isInOptDeps: result.isInOptDeps || deps.optionalDependencies[ancestorName] !== undefined,\n      isInPeerDeps: result.isInPeerDeps || deps.peerDependencies[ancestorName] !== undefined,\n      isInBundledDeps:\n        result.isInBundledDeps || deps.bundledDependencies.indexOf(ancestorName) !== -1,\n    };\n  }, newDeclarationStatus);\n}\n\nfunction reportIfMissing(context, deps, depsOptions, node, name) {\n  // Do not report when importing types\n  if (\n    node.importKind === 'type' ||\n    node.importKind === 'typeof'\n  ) {\n    return;\n  }\n\n  if (importType(name, context) !== 'external') {\n    return;\n  }\n\n  const resolved = resolve(name, context);\n  if (!resolved) { return; }\n\n  const importPackageName = getModuleOriginalName(name);\n  let declarationStatus = checkDependencyDeclaration(deps, importPackageName);\n\n  if (\n    declarationStatus.isInDeps ||\n    (depsOptions.allowDevDeps && declarationStatus.isInDevDeps) ||\n    (depsOptions.allowPeerDeps && declarationStatus.isInPeerDeps) ||\n    (depsOptions.allowOptDeps && declarationStatus.isInOptDeps) ||\n    (depsOptions.allowBundledDeps && declarationStatus.isInBundledDeps)\n  ) {\n    return;\n  }\n\n  // test the real name from the resolved package.json\n  // if not aliased imports (alias/react for example), importPackageName can be misinterpreted\n  const realPackageName = getModuleRealName(resolved);\n  if (realPackageName && realPackageName !== importPackageName) {\n    declarationStatus = checkDependencyDeclaration(deps, realPackageName, declarationStatus);\n\n    if (\n      declarationStatus.isInDeps ||\n      (depsOptions.allowDevDeps && declarationStatus.isInDevDeps) ||\n      (depsOptions.allowPeerDeps && declarationStatus.isInPeerDeps) ||\n      (depsOptions.allowOptDeps && declarationStatus.isInOptDeps) ||\n      (depsOptions.allowBundledDeps && declarationStatus.isInBundledDeps)\n    ) {\n      return;\n    }\n  }\n\n  if (declarationStatus.isInDevDeps && !depsOptions.allowDevDeps) {\n    context.report(node, devDepErrorMessage(realPackageName || importPackageName));\n    return;\n  }\n\n  if (declarationStatus.isInOptDeps && !depsOptions.allowOptDeps) {\n    context.report(node, optDepErrorMessage(realPackageName || importPackageName));\n    return;\n  }\n\n  context.report(node, missingErrorMessage(realPackageName || importPackageName));\n}\n\nfunction testConfig(config, filename) {\n  // Simplest configuration first, either a boolean or nothing.\n  if (typeof config === 'boolean' || typeof config === 'undefined') {\n    return config;\n  }\n  // Array of globs.\n  return config.some(c => (\n    minimatch(filename, c) ||\n    minimatch(filename, path.join(process.cwd(), c))\n  ));\n}\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      url: docsUrl('no-extraneous-dependencies'),\n    },\n\n    schema: [\n      {\n        'type': 'object',\n        'properties': {\n          'devDependencies': { 'type': ['boolean', 'array'] },\n          'optionalDependencies': { 'type': ['boolean', 'array'] },\n          'peerDependencies': { 'type': ['boolean', 'array'] },\n          'bundledDependencies': { 'type': ['boolean', 'array'] },\n          'packageDir': { 'type': ['string', 'array'] },\n        },\n        'additionalProperties': false,\n      },\n    ],\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const filename = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n    const deps = getDependencies(context, options.packageDir) || extractDepFields({});\n\n    const depsOptions = {\n      allowDevDeps: testConfig(options.devDependencies, filename) !== false,\n      allowOptDeps: testConfig(options.optionalDependencies, filename) !== false,\n      allowPeerDeps: testConfig(options.peerDependencies, filename) !== false,\n      allowBundledDeps: testConfig(options.bundledDependencies, filename) !== false,\n    };\n\n    return moduleVisitor((source, node) => {\n      reportIfMissing(context, deps, depsOptions, node, source.value);\n    }, { commonjs: true });\n  },\n};\n"]},"metadata":{},"sourceType":"script"}