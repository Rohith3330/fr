{"ast":null,"code":"/**\n * @fileoverview Helper functions for ESLint class\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst path = require(\"path\");\n\nconst fs = require(\"fs\");\n\nconst fsp = fs.promises;\n\nconst isGlob = require(\"is-glob\");\n\nconst globby = require(\"globby\");\n\nconst hash = require(\"../cli-engine/hash\");\n\nconst minimatch = require(\"minimatch\"); //-----------------------------------------------------------------------------\n// Errors\n//-----------------------------------------------------------------------------\n\n/**\n * The error type when no files match a glob.\n */\n\n\nclass NoFilesFoundError extends Error {\n  /**\n   * @param {string} pattern The glob pattern which was not found.\n   * @param {boolean} globEnabled If `false` then the pattern was a glob pattern, but glob was disabled.\n   */\n  constructor(pattern, globEnabled) {\n    super(`No files matching '${pattern}' were found${!globEnabled ? \" (glob was disabled)\" : \"\"}.`);\n    this.messageTemplate = \"file-not-found\";\n    this.messageData = {\n      pattern,\n      globDisabled: !globEnabled\n    };\n  }\n\n}\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\n\n\nclass AllFilesIgnoredError extends Error {\n  /**\n   * @param {string} pattern The glob pattern which was not found.\n   */\n  constructor(pattern) {\n    super(`All files matched by '${pattern}' are ignored.`);\n    this.messageTemplate = \"all-files-ignored\";\n    this.messageData = {\n      pattern\n    };\n  }\n\n} //-----------------------------------------------------------------------------\n// General Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Check if a given value is a non-empty string or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is a non-empty string.\n */\n\n\nfunction isNonEmptyString(x) {\n  return typeof x === \"string\" && x.trim() !== \"\";\n}\n/**\n * Check if a given value is an array of non-empty stringss or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of non-empty stringss.\n */\n\n\nfunction isArrayOfNonEmptyString(x) {\n  return Array.isArray(x) && x.every(isNonEmptyString);\n} //-----------------------------------------------------------------------------\n// File-related Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Normalizes slashes in a file pattern to posix-style.\n * @param {string} pattern The pattern to replace slashes in.\n * @returns {string} The pattern with slashes normalized.\n */\n\n\nfunction normalizeToPosix(pattern) {\n  return pattern.replace(/\\\\/gu, \"/\");\n}\n/**\n * Check if a string is a glob pattern or not.\n * @param {string} pattern A glob pattern.\n * @returns {boolean} `true` if the string is a glob pattern.\n */\n\n\nfunction isGlobPattern(pattern) {\n  return isGlob(path.sep === \"\\\\\" ? normalizeToPosix(pattern) : pattern);\n}\n/**\n * Finds all files matching the options specified.\n * @param {Object} args The arguments objects.\n * @param {Array<string>} args.patterns An array of glob patterns.\n * @param {boolean} args.globInputPaths true to interpret glob patterns,\n *      false to not interpret glob patterns.\n * @param {string} args.cwd The current working directory to find from.\n * @param {FlatConfigArray} args.configs The configs for the current run.\n * @param {boolean} args.errorOnUnmatchedPattern Determines if an unmatched pattern\n *      should throw an error.\n * @returns {Promise<Array<string>>} The fully resolved file paths.\n * @throws {AllFilesIgnoredError} If there are no results due to an ignore pattern.\n * @throws {NoFilesFoundError} If no files matched the given patterns.\n */\n\n\nasync function findFiles(_ref) {\n  let {\n    patterns,\n    globInputPaths,\n    cwd,\n    configs,\n    errorOnUnmatchedPattern\n  } = _ref;\n  const results = [];\n  const globbyPatterns = [];\n  const missingPatterns = []; // check to see if we have explicit files and directories\n\n  const filePaths = patterns.map(filePath => path.resolve(cwd, filePath));\n  const stats = await Promise.all(filePaths.map(filePath => fsp.stat(filePath).catch(() => {})));\n  stats.forEach((stat, index) => {\n    const filePath = filePaths[index];\n    const pattern = normalizeToPosix(patterns[index]);\n\n    if (stat) {\n      // files are added directly to the list\n      if (stat.isFile()) {\n        results.push({\n          filePath,\n          ignored: configs.isIgnored(filePath)\n        });\n      } // directories need extensions attached\n\n\n      if (stat.isDirectory()) {\n        // filePatterns are all relative to cwd\n        const filePatterns = configs.files.filter(filePattern => {\n          // can only do this for strings, not functions\n          if (typeof filePattern !== \"string\") {\n            return false;\n          } // patterns starting with ** always apply\n\n\n          if (filePattern.startsWith(\"**\")) {\n            return true;\n          } // patterns ending with * are not used for file search\n\n\n          if (filePattern.endsWith(\"*\")) {\n            return false;\n          } // not sure how to handle negated patterns yet\n\n\n          if (filePattern.startsWith(\"!\")) {\n            return false;\n          } // check if the pattern would be inside the config base path or not\n\n\n          const fullFilePattern = path.join(cwd, filePattern);\n          const patternRelativeToConfigBasePath = path.relative(configs.basePath, fullFilePattern);\n\n          if (patternRelativeToConfigBasePath.startsWith(\"..\")) {\n            return false;\n          } // check if the pattern matches\n\n\n          if (minimatch(filePath, path.dirname(fullFilePattern), {\n            partial: true\n          })) {\n            return true;\n          } // check if the pattern is inside the directory or not\n\n\n          const patternRelativeToFilePath = path.relative(filePath, fullFilePattern);\n\n          if (patternRelativeToFilePath.startsWith(\"..\")) {\n            return false;\n          }\n\n          return true;\n        }).map(filePattern => {\n          if (filePattern.startsWith(\"**\")) {\n            return path.join(pattern, filePattern);\n          } // adjust the path to be relative to the cwd\n\n\n          return path.relative(cwd, path.join(configs.basePath, filePattern));\n        }).map(normalizeToPosix);\n\n        if (filePatterns.length) {\n          globbyPatterns.push(...filePatterns);\n        }\n      }\n\n      return;\n    } // save patterns for later use based on whether globs are enabled\n\n\n    if (globInputPaths && isGlobPattern(filePath)) {\n      globbyPatterns.push(pattern);\n    } else {\n      missingPatterns.push(pattern);\n    }\n  }); // note: globbyPatterns can be an empty array\n\n  const globbyResults = await globby(globbyPatterns, {\n    cwd,\n    absolute: true,\n    ignore: configs.ignores.filter(matcher => typeof matcher === \"string\")\n  }); // if there are no results, tell the user why\n\n  if (!results.length && !globbyResults.length) {\n    // try globby without ignoring anything\n\n    /* eslint-disable no-unreachable-loop -- We want to exit early. */\n    for (const globbyPattern of globbyPatterns) {\n      /* eslint-disable-next-line no-unused-vars -- Want to exit early. */\n      for await (const filePath of globby.stream(globbyPattern, {\n        cwd,\n        absolute: true\n      })) {\n        // files were found but ignored\n        throw new AllFilesIgnoredError(globbyPattern);\n      } // no files were found\n\n\n      if (errorOnUnmatchedPattern) {\n        throw new NoFilesFoundError(globbyPattern, globInputPaths);\n      }\n    }\n    /* eslint-enable no-unreachable-loop -- Go back to normal. */\n\n  } // there were patterns that didn't match anything, tell the user\n\n\n  if (errorOnUnmatchedPattern && missingPatterns.length) {\n    throw new NoFilesFoundError(missingPatterns[0], globInputPaths);\n  }\n\n  return [...results, ...globbyResults.map(filePath => ({\n    filePath: path.resolve(filePath),\n    ignored: false\n  }))];\n}\n/**\n * Checks whether a file exists at the given location\n * @param {string} resolvedPath A path from the CWD\n * @throws {Error} As thrown by `fs.statSync` or `fs.isFile`.\n * @returns {boolean} `true` if a file exists\n */\n\n\nfunction fileExists(resolvedPath) {\n  try {\n    return fs.statSync(resolvedPath).isFile();\n  } catch (error) {\n    if (error && (error.code === \"ENOENT\" || error.code === \"ENOTDIR\")) {\n      return false;\n    }\n\n    throw error;\n  }\n}\n/**\n * Checks whether a directory exists at the given location\n * @param {string} resolvedPath A path from the CWD\n * @throws {Error} As thrown by `fs.statSync` or `fs.isDirectory`.\n * @returns {boolean} `true` if a directory exists\n */\n\n\nfunction directoryExists(resolvedPath) {\n  try {\n    return fs.statSync(resolvedPath).isDirectory();\n  } catch (error) {\n    if (error && (error.code === \"ENOENT\" || error.code === \"ENOTDIR\")) {\n      return false;\n    }\n\n    throw error;\n  }\n} //-----------------------------------------------------------------------------\n// Results-related Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Checks if the given message is an error message.\n * @param {LintMessage} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\n\n\nfunction isErrorMessage(message) {\n  return message.severity === 2;\n}\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath File path of checked code\n * @param {string} baseDir Absolute path of base directory\n * @returns {LintResult} Result with single warning\n * @private\n */\n\n\nfunction createIgnoreResult(filePath, baseDir) {\n  let message;\n  const isHidden = filePath.split(path.sep).find(segment => /^\\./u.test(segment));\n  const isInNodeModules = baseDir && path.relative(baseDir, filePath).startsWith(\"node_modules\");\n\n  if (isHidden) {\n    message = \"File ignored by default.  Use a negated ignore pattern (like \\\"--ignore-pattern '!<relative/path/to/filename>'\\\") to override.\";\n  } else if (isInNodeModules) {\n    message = \"File ignored by default. Use \\\"--ignore-pattern '!node_modules/*'\\\" to override.\";\n  } else {\n    message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to override.\";\n  }\n\n  return {\n    filePath: path.resolve(filePath),\n    messages: [{\n      fatal: false,\n      severity: 1,\n      message\n    }],\n    suppressedMessages: [],\n    errorCount: 0,\n    warningCount: 1,\n    fatalErrorCount: 0,\n    fixableErrorCount: 0,\n    fixableWarningCount: 0\n  };\n} //-----------------------------------------------------------------------------\n// Options-related Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Check if a given value is a valid fix type or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is valid fix type.\n */\n\n\nfunction isFixType(x) {\n  return x === \"directive\" || x === \"problem\" || x === \"suggestion\" || x === \"layout\";\n}\n/**\n * Check if a given value is an array of fix types or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of fix types.\n */\n\n\nfunction isFixTypeArray(x) {\n  return Array.isArray(x) && x.every(isFixType);\n}\n/**\n * The error for invalid options.\n */\n\n\nclass ESLintInvalidOptionsError extends Error {\n  constructor(messages) {\n    super(`Invalid Options:\\n- ${messages.join(\"\\n- \")}`);\n    this.code = \"ESLINT_INVALID_OPTIONS\";\n    Error.captureStackTrace(this, ESLintInvalidOptionsError);\n  }\n\n}\n/**\n * Validates and normalizes options for the wrapped CLIEngine instance.\n * @param {FlatESLintOptions} options The options to process.\n * @throws {ESLintInvalidOptionsError} If of any of a variety of type errors.\n * @returns {FlatESLintOptions} The normalized options.\n */\n\n\nfunction processOptions(_ref2) {\n  let {\n    allowInlineConfig = true,\n    // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.\n    baseConfig = null,\n    cache = false,\n    cacheLocation = \".eslintcache\",\n    cacheStrategy = \"metadata\",\n    cwd = process.cwd(),\n    errorOnUnmatchedPattern = true,\n    fix = false,\n    fixTypes = null,\n    // ← should be null by default because if it's an array then it suppresses rules that don't have the `meta.type` property.\n    globInputPaths = true,\n    ignore = true,\n    ignorePath = null,\n    // ← should be null by default because if it's a string then it may throw ENOENT.\n    ignorePatterns = null,\n    overrideConfig = null,\n    overrideConfigFile = null,\n    plugins = {},\n    reportUnusedDisableDirectives = null,\n    // ← should be null by default because if it's a string then it overrides the 'reportUnusedDisableDirectives' setting in config files. And we cannot use `overrideConfig.reportUnusedDisableDirectives` instead because we cannot configure the `error` severity with that.\n    ...unknownOptions\n  } = _ref2;\n  const errors = [];\n  const unknownOptionKeys = Object.keys(unknownOptions);\n\n  if (unknownOptionKeys.length >= 1) {\n    errors.push(`Unknown options: ${unknownOptionKeys.join(\", \")}`);\n\n    if (unknownOptionKeys.includes(\"cacheFile\")) {\n      errors.push(\"'cacheFile' has been removed. Please use the 'cacheLocation' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"configFile\")) {\n      errors.push(\"'configFile' has been removed. Please use the 'overrideConfigFile' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"envs\")) {\n      errors.push(\"'envs' has been removed.\");\n    }\n\n    if (unknownOptionKeys.includes(\"extensions\")) {\n      errors.push(\"'extensions' has been removed.\");\n    }\n\n    if (unknownOptionKeys.includes(\"resolvePluginsRelativeTo\")) {\n      errors.push(\"'resolvePluginsRelativeTo' has been removed.\");\n    }\n\n    if (unknownOptionKeys.includes(\"globals\")) {\n      errors.push(\"'globals' has been removed. Please use the 'overrideConfig.languageOptions.globals' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"ignorePattern\")) {\n      errors.push(\"'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"parser\")) {\n      errors.push(\"'parser' has been removed. Please use the 'overrideConfig.languageOptions.parser' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"parserOptions\")) {\n      errors.push(\"'parserOptions' has been removed. Please use the 'overrideConfig.languageOptions.parserOptions' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"rules\")) {\n      errors.push(\"'rules' has been removed. Please use the 'overrideConfig.rules' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"rulePaths\")) {\n      errors.push(\"'rulePaths' has been removed. Please define your rules using plugins.\");\n    }\n  }\n\n  if (typeof allowInlineConfig !== \"boolean\") {\n    errors.push(\"'allowInlineConfig' must be a boolean.\");\n  }\n\n  if (typeof baseConfig !== \"object\") {\n    errors.push(\"'baseConfig' must be an object or null.\");\n  }\n\n  if (typeof cache !== \"boolean\") {\n    errors.push(\"'cache' must be a boolean.\");\n  }\n\n  if (!isNonEmptyString(cacheLocation)) {\n    errors.push(\"'cacheLocation' must be a non-empty string.\");\n  }\n\n  if (cacheStrategy !== \"metadata\" && cacheStrategy !== \"content\") {\n    errors.push(\"'cacheStrategy' must be any of \\\"metadata\\\", \\\"content\\\".\");\n  }\n\n  if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {\n    errors.push(\"'cwd' must be an absolute path.\");\n  }\n\n  if (typeof errorOnUnmatchedPattern !== \"boolean\") {\n    errors.push(\"'errorOnUnmatchedPattern' must be a boolean.\");\n  }\n\n  if (typeof fix !== \"boolean\" && typeof fix !== \"function\") {\n    errors.push(\"'fix' must be a boolean or a function.\");\n  }\n\n  if (fixTypes !== null && !isFixTypeArray(fixTypes)) {\n    errors.push(\"'fixTypes' must be an array of any of \\\"directive\\\", \\\"problem\\\", \\\"suggestion\\\", and \\\"layout\\\".\");\n  }\n\n  if (typeof globInputPaths !== \"boolean\") {\n    errors.push(\"'globInputPaths' must be a boolean.\");\n  }\n\n  if (typeof ignore !== \"boolean\") {\n    errors.push(\"'ignore' must be a boolean.\");\n  }\n\n  if (!isNonEmptyString(ignorePath) && ignorePath !== null) {\n    errors.push(\"'ignorePath' must be a non-empty string or null.\");\n  }\n\n  if (typeof overrideConfig !== \"object\") {\n    errors.push(\"'overrideConfig' must be an object or null.\");\n  }\n\n  if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null && overrideConfigFile !== true) {\n    errors.push(\"'overrideConfigFile' must be a non-empty string, null, or true.\");\n  }\n\n  if (typeof plugins !== \"object\") {\n    errors.push(\"'plugins' must be an object or null.\");\n  } else if (plugins !== null && Object.keys(plugins).includes(\"\")) {\n    errors.push(\"'plugins' must not include an empty string.\");\n  }\n\n  if (Array.isArray(plugins)) {\n    errors.push(\"'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.\");\n  }\n\n  if (reportUnusedDisableDirectives !== \"error\" && reportUnusedDisableDirectives !== \"warn\" && reportUnusedDisableDirectives !== \"off\" && reportUnusedDisableDirectives !== null) {\n    errors.push(\"'reportUnusedDisableDirectives' must be any of \\\"error\\\", \\\"warn\\\", \\\"off\\\", and null.\");\n  }\n\n  if (errors.length > 0) {\n    throw new ESLintInvalidOptionsError(errors);\n  }\n\n  return {\n    allowInlineConfig,\n    baseConfig,\n    cache,\n    cacheLocation,\n    cacheStrategy,\n    // when overrideConfigFile is true that means don't do config file lookup\n    configFile: overrideConfigFile === true ? false : overrideConfigFile,\n    overrideConfig,\n    cwd,\n    errorOnUnmatchedPattern,\n    fix,\n    fixTypes,\n    globInputPaths,\n    ignore,\n    ignorePath,\n    ignorePatterns,\n    reportUnusedDisableDirectives\n  };\n} //-----------------------------------------------------------------------------\n// Cache-related helpers\n//-----------------------------------------------------------------------------\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\n\n\nfunction getCacheFile(cacheFile, cwd) {\n  /*\n   * make sure the path separators are normalized for the environment/os\n   * keeping the trailing path separator if present\n   */\n  const normalizedCacheFile = path.normalize(cacheFile);\n  const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);\n  const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;\n  /**\n   * return the name for the cache file in case the provided parameter is a directory\n   * @returns {string} the resolved path to the cacheFile\n   */\n\n  function getCacheFileForDirectory() {\n    return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);\n  }\n\n  let fileStats;\n\n  try {\n    fileStats = fs.lstatSync(resolvedCacheFile);\n  } catch {\n    fileStats = null;\n  }\n  /*\n   * in case the file exists we need to verify if the provided path\n   * is a directory or a file. If it is a directory we want to create a file\n   * inside that directory\n   */\n\n\n  if (fileStats) {\n    /*\n     * is a directory or is a file, but the original file the user provided\n     * looks like a directory but `path.resolve` removed the `last path.sep`\n     * so we need to still treat this like a directory\n     */\n    if (fileStats.isDirectory() || looksLikeADirectory) {\n      return getCacheFileForDirectory();\n    } // is file so just use that file\n\n\n    return resolvedCacheFile;\n  }\n  /*\n   * here we known the file or directory doesn't exist,\n   * so we will try to infer if its a directory if it looks like a directory\n   * for the current operating system.\n   */\n  // if the last character passed is a path separator we assume is a directory\n\n\n  if (looksLikeADirectory) {\n    return getCacheFileForDirectory();\n  }\n\n  return resolvedCacheFile;\n} //-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n\nmodule.exports = {\n  isGlobPattern,\n  directoryExists,\n  fileExists,\n  findFiles,\n  isNonEmptyString,\n  isArrayOfNonEmptyString,\n  createIgnoreResult,\n  isErrorMessage,\n  processOptions,\n  getCacheFile\n};","map":{"version":3,"names":["path","require","fs","fsp","promises","isGlob","globby","hash","minimatch","NoFilesFoundError","Error","constructor","pattern","globEnabled","messageTemplate","messageData","globDisabled","AllFilesIgnoredError","isNonEmptyString","x","trim","isArrayOfNonEmptyString","Array","isArray","every","normalizeToPosix","replace","isGlobPattern","sep","findFiles","patterns","globInputPaths","cwd","configs","errorOnUnmatchedPattern","results","globbyPatterns","missingPatterns","filePaths","map","filePath","resolve","stats","Promise","all","stat","catch","forEach","index","isFile","push","ignored","isIgnored","isDirectory","filePatterns","files","filter","filePattern","startsWith","endsWith","fullFilePattern","join","patternRelativeToConfigBasePath","relative","basePath","dirname","partial","patternRelativeToFilePath","length","globbyResults","absolute","ignore","ignores","matcher","globbyPattern","stream","fileExists","resolvedPath","statSync","error","code","directoryExists","isErrorMessage","message","severity","createIgnoreResult","baseDir","isHidden","split","find","segment","test","isInNodeModules","messages","fatal","suppressedMessages","errorCount","warningCount","fatalErrorCount","fixableErrorCount","fixableWarningCount","isFixType","isFixTypeArray","ESLintInvalidOptionsError","captureStackTrace","processOptions","allowInlineConfig","baseConfig","cache","cacheLocation","cacheStrategy","process","fix","fixTypes","ignorePath","ignorePatterns","overrideConfig","overrideConfigFile","plugins","reportUnusedDisableDirectives","unknownOptions","errors","unknownOptionKeys","Object","keys","includes","isAbsolute","configFile","getCacheFile","cacheFile","normalizedCacheFile","normalize","resolvedCacheFile","looksLikeADirectory","slice","getCacheFileForDirectory","fileStats","lstatSync","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/eslint/eslint-helpers.js"],"sourcesContent":["/**\n * @fileoverview Helper functions for ESLint class\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst fsp = fs.promises;\nconst isGlob = require(\"is-glob\");\nconst globby = require(\"globby\");\nconst hash = require(\"../cli-engine/hash\");\nconst minimatch = require(\"minimatch\");\n\n//-----------------------------------------------------------------------------\n// Errors\n//-----------------------------------------------------------------------------\n\n/**\n * The error type when no files match a glob.\n */\nclass NoFilesFoundError extends Error {\n\n    /**\n     * @param {string} pattern The glob pattern which was not found.\n     * @param {boolean} globEnabled If `false` then the pattern was a glob pattern, but glob was disabled.\n     */\n    constructor(pattern, globEnabled) {\n        super(`No files matching '${pattern}' were found${!globEnabled ? \" (glob was disabled)\" : \"\"}.`);\n        this.messageTemplate = \"file-not-found\";\n        this.messageData = { pattern, globDisabled: !globEnabled };\n    }\n}\n\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\nclass AllFilesIgnoredError extends Error {\n\n    /**\n     * @param {string} pattern The glob pattern which was not found.\n     */\n    constructor(pattern) {\n        super(`All files matched by '${pattern}' are ignored.`);\n        this.messageTemplate = \"all-files-ignored\";\n        this.messageData = { pattern };\n    }\n}\n\n\n//-----------------------------------------------------------------------------\n// General Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Check if a given value is a non-empty string or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is a non-empty string.\n */\nfunction isNonEmptyString(x) {\n    return typeof x === \"string\" && x.trim() !== \"\";\n}\n\n/**\n * Check if a given value is an array of non-empty stringss or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of non-empty stringss.\n */\nfunction isArrayOfNonEmptyString(x) {\n    return Array.isArray(x) && x.every(isNonEmptyString);\n}\n\n//-----------------------------------------------------------------------------\n// File-related Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Normalizes slashes in a file pattern to posix-style.\n * @param {string} pattern The pattern to replace slashes in.\n * @returns {string} The pattern with slashes normalized.\n */\nfunction normalizeToPosix(pattern) {\n    return pattern.replace(/\\\\/gu, \"/\");\n}\n\n/**\n * Check if a string is a glob pattern or not.\n * @param {string} pattern A glob pattern.\n * @returns {boolean} `true` if the string is a glob pattern.\n */\nfunction isGlobPattern(pattern) {\n    return isGlob(path.sep === \"\\\\\" ? normalizeToPosix(pattern) : pattern);\n}\n\n/**\n * Finds all files matching the options specified.\n * @param {Object} args The arguments objects.\n * @param {Array<string>} args.patterns An array of glob patterns.\n * @param {boolean} args.globInputPaths true to interpret glob patterns,\n *      false to not interpret glob patterns.\n * @param {string} args.cwd The current working directory to find from.\n * @param {FlatConfigArray} args.configs The configs for the current run.\n * @param {boolean} args.errorOnUnmatchedPattern Determines if an unmatched pattern\n *      should throw an error.\n * @returns {Promise<Array<string>>} The fully resolved file paths.\n * @throws {AllFilesIgnoredError} If there are no results due to an ignore pattern.\n * @throws {NoFilesFoundError} If no files matched the given patterns.\n */\nasync function findFiles({\n    patterns,\n    globInputPaths,\n    cwd,\n    configs,\n    errorOnUnmatchedPattern\n}) {\n\n    const results = [];\n    const globbyPatterns = [];\n    const missingPatterns = [];\n\n    // check to see if we have explicit files and directories\n    const filePaths = patterns.map(filePath => path.resolve(cwd, filePath));\n    const stats = await Promise.all(\n        filePaths.map(\n            filePath => fsp.stat(filePath).catch(() => { })\n        )\n    );\n\n    stats.forEach((stat, index) => {\n\n        const filePath = filePaths[index];\n        const pattern = normalizeToPosix(patterns[index]);\n\n        if (stat) {\n\n            // files are added directly to the list\n            if (stat.isFile()) {\n                results.push({\n                    filePath,\n                    ignored: configs.isIgnored(filePath)\n                });\n            }\n\n            // directories need extensions attached\n            if (stat.isDirectory()) {\n\n                // filePatterns are all relative to cwd\n                const filePatterns = configs.files\n                    .filter(filePattern => {\n\n                        // can only do this for strings, not functions\n                        if (typeof filePattern !== \"string\") {\n                            return false;\n                        }\n\n                        // patterns starting with ** always apply\n                        if (filePattern.startsWith(\"**\")) {\n                            return true;\n                        }\n\n                        // patterns ending with * are not used for file search\n                        if (filePattern.endsWith(\"*\")) {\n                            return false;\n                        }\n\n                        // not sure how to handle negated patterns yet\n                        if (filePattern.startsWith(\"!\")) {\n                            return false;\n                        }\n\n                        // check if the pattern would be inside the config base path or not\n                        const fullFilePattern = path.join(cwd, filePattern);\n                        const patternRelativeToConfigBasePath = path.relative(configs.basePath, fullFilePattern);\n\n                        if (patternRelativeToConfigBasePath.startsWith(\"..\")) {\n                            return false;\n                        }\n\n                        // check if the pattern matches\n                        if (minimatch(filePath, path.dirname(fullFilePattern), { partial: true })) {\n                            return true;\n                        }\n\n                        // check if the pattern is inside the directory or not\n                        const patternRelativeToFilePath = path.relative(filePath, fullFilePattern);\n\n                        if (patternRelativeToFilePath.startsWith(\"..\")) {\n                            return false;\n                        }\n\n                        return true;\n                    })\n                    .map(filePattern => {\n                        if (filePattern.startsWith(\"**\")) {\n                            return path.join(pattern, filePattern);\n                        }\n\n                        // adjust the path to be relative to the cwd\n                        return path.relative(\n                            cwd,\n                            path.join(configs.basePath, filePattern)\n                        );\n                    })\n                    .map(normalizeToPosix);\n\n                if (filePatterns.length) {\n                    globbyPatterns.push(...filePatterns);\n                }\n\n            }\n\n            return;\n        }\n\n        // save patterns for later use based on whether globs are enabled\n        if (globInputPaths && isGlobPattern(filePath)) {\n            globbyPatterns.push(pattern);\n        } else {\n            missingPatterns.push(pattern);\n        }\n    });\n\n    // note: globbyPatterns can be an empty array\n    const globbyResults = (await globby(globbyPatterns, {\n        cwd,\n        absolute: true,\n        ignore: configs.ignores.filter(matcher => typeof matcher === \"string\")\n    }));\n\n    // if there are no results, tell the user why\n    if (!results.length && !globbyResults.length) {\n\n        // try globby without ignoring anything\n        /* eslint-disable no-unreachable-loop -- We want to exit early. */\n        for (const globbyPattern of globbyPatterns) {\n\n            /* eslint-disable-next-line no-unused-vars -- Want to exit early. */\n            for await (const filePath of globby.stream(globbyPattern, { cwd, absolute: true })) {\n\n                // files were found but ignored\n                throw new AllFilesIgnoredError(globbyPattern);\n            }\n\n            // no files were found\n            if (errorOnUnmatchedPattern) {\n                throw new NoFilesFoundError(globbyPattern, globInputPaths);\n            }\n        }\n        /* eslint-enable no-unreachable-loop -- Go back to normal. */\n\n    }\n\n    // there were patterns that didn't match anything, tell the user\n    if (errorOnUnmatchedPattern && missingPatterns.length) {\n        throw new NoFilesFoundError(missingPatterns[0], globInputPaths);\n    }\n\n\n    return [\n        ...results,\n        ...globbyResults.map(filePath => ({\n            filePath: path.resolve(filePath),\n            ignored: false\n        }))\n    ];\n}\n\n\n/**\n * Checks whether a file exists at the given location\n * @param {string} resolvedPath A path from the CWD\n * @throws {Error} As thrown by `fs.statSync` or `fs.isFile`.\n * @returns {boolean} `true` if a file exists\n */\nfunction fileExists(resolvedPath) {\n    try {\n        return fs.statSync(resolvedPath).isFile();\n    } catch (error) {\n        if (error && (error.code === \"ENOENT\" || error.code === \"ENOTDIR\")) {\n            return false;\n        }\n        throw error;\n    }\n}\n\n/**\n * Checks whether a directory exists at the given location\n * @param {string} resolvedPath A path from the CWD\n * @throws {Error} As thrown by `fs.statSync` or `fs.isDirectory`.\n * @returns {boolean} `true` if a directory exists\n */\nfunction directoryExists(resolvedPath) {\n    try {\n        return fs.statSync(resolvedPath).isDirectory();\n    } catch (error) {\n        if (error && (error.code === \"ENOENT\" || error.code === \"ENOTDIR\")) {\n            return false;\n        }\n        throw error;\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Results-related Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Checks if the given message is an error message.\n * @param {LintMessage} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\nfunction isErrorMessage(message) {\n    return message.severity === 2;\n}\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath File path of checked code\n * @param {string} baseDir Absolute path of base directory\n * @returns {LintResult} Result with single warning\n * @private\n */\nfunction createIgnoreResult(filePath, baseDir) {\n    let message;\n    const isHidden = filePath.split(path.sep)\n        .find(segment => /^\\./u.test(segment));\n    const isInNodeModules = baseDir && path.relative(baseDir, filePath).startsWith(\"node_modules\");\n\n    if (isHidden) {\n        message = \"File ignored by default.  Use a negated ignore pattern (like \\\"--ignore-pattern '!<relative/path/to/filename>'\\\") to override.\";\n    } else if (isInNodeModules) {\n        message = \"File ignored by default. Use \\\"--ignore-pattern '!node_modules/*'\\\" to override.\";\n    } else {\n        message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to override.\";\n    }\n\n    return {\n        filePath: path.resolve(filePath),\n        messages: [\n            {\n                fatal: false,\n                severity: 1,\n                message\n            }\n        ],\n        suppressedMessages: [],\n        errorCount: 0,\n        warningCount: 1,\n        fatalErrorCount: 0,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    };\n}\n\n//-----------------------------------------------------------------------------\n// Options-related Helpers\n//-----------------------------------------------------------------------------\n\n\n/**\n * Check if a given value is a valid fix type or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is valid fix type.\n */\nfunction isFixType(x) {\n    return x === \"directive\" || x === \"problem\" || x === \"suggestion\" || x === \"layout\";\n}\n\n/**\n * Check if a given value is an array of fix types or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of fix types.\n */\nfunction isFixTypeArray(x) {\n    return Array.isArray(x) && x.every(isFixType);\n}\n\n/**\n * The error for invalid options.\n */\nclass ESLintInvalidOptionsError extends Error {\n    constructor(messages) {\n        super(`Invalid Options:\\n- ${messages.join(\"\\n- \")}`);\n        this.code = \"ESLINT_INVALID_OPTIONS\";\n        Error.captureStackTrace(this, ESLintInvalidOptionsError);\n    }\n}\n\n/**\n * Validates and normalizes options for the wrapped CLIEngine instance.\n * @param {FlatESLintOptions} options The options to process.\n * @throws {ESLintInvalidOptionsError} If of any of a variety of type errors.\n * @returns {FlatESLintOptions} The normalized options.\n */\nfunction processOptions({\n    allowInlineConfig = true, // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.\n    baseConfig = null,\n    cache = false,\n    cacheLocation = \".eslintcache\",\n    cacheStrategy = \"metadata\",\n    cwd = process.cwd(),\n    errorOnUnmatchedPattern = true,\n    fix = false,\n    fixTypes = null, // ← should be null by default because if it's an array then it suppresses rules that don't have the `meta.type` property.\n    globInputPaths = true,\n    ignore = true,\n    ignorePath = null, // ← should be null by default because if it's a string then it may throw ENOENT.\n    ignorePatterns = null,\n    overrideConfig = null,\n    overrideConfigFile = null,\n    plugins = {},\n    reportUnusedDisableDirectives = null, // ← should be null by default because if it's a string then it overrides the 'reportUnusedDisableDirectives' setting in config files. And we cannot use `overrideConfig.reportUnusedDisableDirectives` instead because we cannot configure the `error` severity with that.\n    ...unknownOptions\n}) {\n    const errors = [];\n    const unknownOptionKeys = Object.keys(unknownOptions);\n\n    if (unknownOptionKeys.length >= 1) {\n        errors.push(`Unknown options: ${unknownOptionKeys.join(\", \")}`);\n        if (unknownOptionKeys.includes(\"cacheFile\")) {\n            errors.push(\"'cacheFile' has been removed. Please use the 'cacheLocation' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"configFile\")) {\n            errors.push(\"'configFile' has been removed. Please use the 'overrideConfigFile' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"envs\")) {\n            errors.push(\"'envs' has been removed.\");\n        }\n        if (unknownOptionKeys.includes(\"extensions\")) {\n            errors.push(\"'extensions' has been removed.\");\n        }\n        if (unknownOptionKeys.includes(\"resolvePluginsRelativeTo\")) {\n            errors.push(\"'resolvePluginsRelativeTo' has been removed.\");\n        }\n        if (unknownOptionKeys.includes(\"globals\")) {\n            errors.push(\"'globals' has been removed. Please use the 'overrideConfig.languageOptions.globals' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"ignorePattern\")) {\n            errors.push(\"'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"parser\")) {\n            errors.push(\"'parser' has been removed. Please use the 'overrideConfig.languageOptions.parser' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"parserOptions\")) {\n            errors.push(\"'parserOptions' has been removed. Please use the 'overrideConfig.languageOptions.parserOptions' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"rules\")) {\n            errors.push(\"'rules' has been removed. Please use the 'overrideConfig.rules' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"rulePaths\")) {\n            errors.push(\"'rulePaths' has been removed. Please define your rules using plugins.\");\n        }\n    }\n    if (typeof allowInlineConfig !== \"boolean\") {\n        errors.push(\"'allowInlineConfig' must be a boolean.\");\n    }\n    if (typeof baseConfig !== \"object\") {\n        errors.push(\"'baseConfig' must be an object or null.\");\n    }\n    if (typeof cache !== \"boolean\") {\n        errors.push(\"'cache' must be a boolean.\");\n    }\n    if (!isNonEmptyString(cacheLocation)) {\n        errors.push(\"'cacheLocation' must be a non-empty string.\");\n    }\n    if (\n        cacheStrategy !== \"metadata\" &&\n        cacheStrategy !== \"content\"\n    ) {\n        errors.push(\"'cacheStrategy' must be any of \\\"metadata\\\", \\\"content\\\".\");\n    }\n    if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {\n        errors.push(\"'cwd' must be an absolute path.\");\n    }\n    if (typeof errorOnUnmatchedPattern !== \"boolean\") {\n        errors.push(\"'errorOnUnmatchedPattern' must be a boolean.\");\n    }\n    if (typeof fix !== \"boolean\" && typeof fix !== \"function\") {\n        errors.push(\"'fix' must be a boolean or a function.\");\n    }\n    if (fixTypes !== null && !isFixTypeArray(fixTypes)) {\n        errors.push(\"'fixTypes' must be an array of any of \\\"directive\\\", \\\"problem\\\", \\\"suggestion\\\", and \\\"layout\\\".\");\n    }\n    if (typeof globInputPaths !== \"boolean\") {\n        errors.push(\"'globInputPaths' must be a boolean.\");\n    }\n    if (typeof ignore !== \"boolean\") {\n        errors.push(\"'ignore' must be a boolean.\");\n    }\n    if (!isNonEmptyString(ignorePath) && ignorePath !== null) {\n        errors.push(\"'ignorePath' must be a non-empty string or null.\");\n    }\n    if (typeof overrideConfig !== \"object\") {\n        errors.push(\"'overrideConfig' must be an object or null.\");\n    }\n    if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null && overrideConfigFile !== true) {\n        errors.push(\"'overrideConfigFile' must be a non-empty string, null, or true.\");\n    }\n    if (typeof plugins !== \"object\") {\n        errors.push(\"'plugins' must be an object or null.\");\n    } else if (plugins !== null && Object.keys(plugins).includes(\"\")) {\n        errors.push(\"'plugins' must not include an empty string.\");\n    }\n    if (Array.isArray(plugins)) {\n        errors.push(\"'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.\");\n    }\n    if (\n        reportUnusedDisableDirectives !== \"error\" &&\n        reportUnusedDisableDirectives !== \"warn\" &&\n        reportUnusedDisableDirectives !== \"off\" &&\n        reportUnusedDisableDirectives !== null\n    ) {\n        errors.push(\"'reportUnusedDisableDirectives' must be any of \\\"error\\\", \\\"warn\\\", \\\"off\\\", and null.\");\n    }\n    if (errors.length > 0) {\n        throw new ESLintInvalidOptionsError(errors);\n    }\n\n    return {\n        allowInlineConfig,\n        baseConfig,\n        cache,\n        cacheLocation,\n        cacheStrategy,\n\n        // when overrideConfigFile is true that means don't do config file lookup\n        configFile: overrideConfigFile === true ? false : overrideConfigFile,\n        overrideConfig,\n        cwd,\n        errorOnUnmatchedPattern,\n        fix,\n        fixTypes,\n        globInputPaths,\n        ignore,\n        ignorePath,\n        ignorePatterns,\n        reportUnusedDisableDirectives\n    };\n}\n\n\n//-----------------------------------------------------------------------------\n// Cache-related helpers\n//-----------------------------------------------------------------------------\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\nfunction getCacheFile(cacheFile, cwd) {\n\n    /*\n     * make sure the path separators are normalized for the environment/os\n     * keeping the trailing path separator if present\n     */\n    const normalizedCacheFile = path.normalize(cacheFile);\n\n    const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);\n    const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;\n\n    /**\n     * return the name for the cache file in case the provided parameter is a directory\n     * @returns {string} the resolved path to the cacheFile\n     */\n    function getCacheFileForDirectory() {\n        return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);\n    }\n\n    let fileStats;\n\n    try {\n        fileStats = fs.lstatSync(resolvedCacheFile);\n    } catch {\n        fileStats = null;\n    }\n\n\n    /*\n     * in case the file exists we need to verify if the provided path\n     * is a directory or a file. If it is a directory we want to create a file\n     * inside that directory\n     */\n    if (fileStats) {\n\n        /*\n         * is a directory or is a file, but the original file the user provided\n         * looks like a directory but `path.resolve` removed the `last path.sep`\n         * so we need to still treat this like a directory\n         */\n        if (fileStats.isDirectory() || looksLikeADirectory) {\n            return getCacheFileForDirectory();\n        }\n\n        // is file so just use that file\n        return resolvedCacheFile;\n    }\n\n    /*\n     * here we known the file or directory doesn't exist,\n     * so we will try to infer if its a directory if it looks like a directory\n     * for the current operating system.\n     */\n\n    // if the last character passed is a path separator we assume is a directory\n    if (looksLikeADirectory) {\n        return getCacheFileForDirectory();\n    }\n\n    return resolvedCacheFile;\n}\n\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = {\n    isGlobPattern,\n    directoryExists,\n    fileExists,\n    findFiles,\n\n    isNonEmptyString,\n    isArrayOfNonEmptyString,\n\n    createIgnoreResult,\n    isErrorMessage,\n\n    processOptions,\n\n    getCacheFile\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}