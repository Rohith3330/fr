{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar t = require(\"@babel/types\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nconst renameVisitor = {\n  ReferencedIdentifier(_ref, state) {\n    let {\n      node\n    } = _ref;\n\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      path.skip();\n\n      if (path.isMethod()) {\n        (0, _helperEnvironmentVisitor.requeueComputedKeyAndDecorators)(path);\n      }\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration()) {\n      const {\n        declaration\n      } = maybeExportDeclar.node;\n\n      if (t.isDeclaration(declaration) && !declaration.id) {\n        return;\n      }\n    }\n\n    if (maybeExportDeclar.isExportAllDeclaration()) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return path;\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return path;\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(path);\n      this.maybeConvertFromClassFunctionExpression(path);\n    }\n  }\n\n}\n\nexports.default = Renamer;","map":{"version":3,"mappings":"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","names":["renameVisitor","ReferencedIdentifier","state","node","name","oldName","newName","Scope","path","scope","bindingIdentifierEquals","binding","identifier","skip","isMethod","isVariableDeclaration","ids","getOuterBindingIdentifiers","Renamer","constructor","maybeConvertFromExportDeclaration","parentDeclar","maybeExportDeclar","parentPath","isExportDeclaration","isExportDefaultDeclaration","declaration","t","isDeclaration","id","isExportAllDeclaration","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","rename","block","find","isFunctionExpression","isClassExpression","bindingIds","blockToTraverse","type","cases","forEach","c","traverse","removeOwnBinding","bindings"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\scope\\lib\\renamer.ts"],"sourcesContent":["import type Binding from \"../binding\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport * as t from \"@babel/types\";\nimport type { NodePath, Visitor } from \"../..\";\nimport { requeueComputedKeyAndDecorators } from \"@babel/helper-environment-visitor\";\n\nconst renameVisitor: Visitor<Renamer> = {\n  ReferencedIdentifier({ node }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (\n      !path.scope.bindingIdentifierEquals(\n        state.oldName,\n        state.binding.identifier,\n      )\n    ) {\n      path.skip();\n      if (path.isMethod()) {\n        requeueComputedKeyAndDecorators(path);\n      }\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(\n    path: NodePath<t.AssignmentPattern | t.Declaration | t.VariableDeclarator>,\n    state,\n  ) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  },\n};\n\nexport default class Renamer {\n  constructor(binding: Binding, oldName: string, newName: string) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  declare oldName: string;\n  declare newName: string;\n  declare binding: Binding;\n\n  maybeConvertFromExportDeclaration(parentDeclar: NodePath) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration()) {\n      const { declaration } = maybeExportDeclar.node;\n      if (t.isDeclaration(declaration) && !declaration.id) {\n        return;\n      }\n    }\n\n    if (maybeExportDeclar.isExportAllDeclaration()) {\n      return;\n    }\n\n    splitExportDeclaration(\n      maybeExportDeclar as NodePath<\n        Exclude<t.ExportDeclaration, t.ExportAllDeclaration>\n      >,\n    );\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path: NodePath) {\n    return path; // TODO\n\n    // // retain the `name` of a class/function declaration\n\n    // if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    // if (this.binding.kind !== \"hoisted\") return;\n\n    // path.node.id = identifier(this.oldName);\n    // path.node._blockHoist = 3;\n\n    // path.replaceWith(\n    //   variableDeclaration(\"let\", [\n    //     variableDeclarator(identifier(this.newName), toExpression(path.node)),\n    //   ]),\n    // );\n  }\n\n  maybeConvertFromClassFunctionExpression(path: NodePath) {\n    return path; // TODO\n\n    // // retain the `name` of a class/function expression\n\n    // if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    // if (this.binding.kind !== \"local\") return;\n\n    // path.node.id = identifier(this.oldName);\n\n    // this.binding.scope.parent.push({\n    //   id: identifier(this.newName),\n    // });\n\n    // path.replaceWith(\n    //   assignmentExpression(\"=\", identifier(this.newName), path.node),\n    // );\n  }\n\n  rename(block?: t.Pattern | t.Scopable) {\n    const { binding, oldName, newName } = this;\n    const { scope, path } = binding;\n\n    const parentDeclar = path.find(\n      path =>\n        path.isDeclaration() ||\n        path.isFunctionExpression() ||\n        path.isClassExpression(),\n    );\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n      if (bindingIds[oldName] === binding.identifier) {\n        // When we are renaming an exported identifier, we need to ensure that\n        // the exported binding keeps the old name.\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n    if (blockToTraverse?.type === \"SwitchStatement\") {\n      // discriminant is not part of current scope, should be skipped.\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(path);\n      this.maybeConvertFromClassFunctionExpression(path);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}