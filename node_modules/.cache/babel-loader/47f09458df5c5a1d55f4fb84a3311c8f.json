{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nfunction helpers() {\n  const data = require(\"@babel/helpers\");\n\n  helpers = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _generator() {\n  const data = require(\"@babel/generator\");\n\n  _generator = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _template() {\n  const data = require(\"@babel/template\");\n\n  _template = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _t() {\n  const data = require(\"@babel/types\");\n\n  _t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _file = require(\"../transformation/file/file\");\n\nconst {\n  arrayExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  exportNamedDeclaration,\n  exportSpecifier,\n  expressionStatement,\n  functionExpression,\n  identifier,\n  memberExpression,\n  objectExpression,\n  program,\n  stringLiteral,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t();\n\nconst buildUmdWrapper = replacements => _template().default.statement`\n    (function (root, factory) {\n      if (typeof define === \"function\" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === \"object\") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  `(replacements);\n\nfunction buildGlobal(allowlist) {\n  const namespace = identifier(\"babelHelpers\");\n  const body = [];\n  const container = functionExpression(null, [identifier(\"global\")], blockStatement(body));\n  const tree = program([expressionStatement(callExpression(container, [conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", identifier(\"global\")), stringLiteral(\"undefined\")), identifier(\"self\"), identifier(\"global\"))]))]);\n  body.push(variableDeclaration(\"var\", [variableDeclarator(namespace, assignmentExpression(\"=\", memberExpression(identifier(\"global\"), namespace), objectExpression([])))]));\n  buildHelpers(body, namespace, allowlist);\n  return tree;\n}\n\nfunction buildModule(allowlist) {\n  const body = [];\n  const refs = buildHelpers(body, null, allowlist);\n  body.unshift(exportNamedDeclaration(null, Object.keys(refs).map(name => {\n    return exportSpecifier(cloneNode(refs[name]), identifier(name));\n  })));\n  return program(body, [], \"module\");\n}\n\nfunction buildUmd(allowlist) {\n  const namespace = identifier(\"babelHelpers\");\n  const body = [];\n  body.push(variableDeclaration(\"var\", [variableDeclarator(namespace, identifier(\"global\"))]));\n  buildHelpers(body, namespace, allowlist);\n  return program([buildUmdWrapper({\n    FACTORY_PARAMETERS: identifier(\"global\"),\n    BROWSER_ARGUMENTS: assignmentExpression(\"=\", memberExpression(identifier(\"root\"), namespace), objectExpression([])),\n    COMMON_ARGUMENTS: identifier(\"exports\"),\n    AMD_ARGUMENTS: arrayExpression([stringLiteral(\"exports\")]),\n    FACTORY_BODY: body,\n    UMD_ROOT: identifier(\"this\")\n  })]);\n}\n\nfunction buildVar(allowlist) {\n  const namespace = identifier(\"babelHelpers\");\n  const body = [];\n  body.push(variableDeclaration(\"var\", [variableDeclarator(namespace, objectExpression([]))]));\n  const tree = program(body);\n  buildHelpers(body, namespace, allowlist);\n  body.push(expressionStatement(namespace));\n  return tree;\n}\n\nfunction buildHelpers(body, namespace, allowlist) {\n  const getHelperReference = name => {\n    return namespace ? memberExpression(namespace, identifier(name)) : identifier(`_${name}`);\n  };\n\n  const refs = {};\n  helpers().list.forEach(function (name) {\n    if (allowlist && allowlist.indexOf(name) < 0) return;\n    const ref = refs[name] = getHelperReference(name);\n    helpers().ensure(name, _file.default);\n    const {\n      nodes\n    } = helpers().get(name, getHelperReference, ref);\n    body.push(...nodes);\n  });\n  return refs;\n}\n\nfunction _default(allowlist) {\n  let outputType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"global\";\n  let tree;\n  const build = {\n    global: buildGlobal,\n    module: buildModule,\n    umd: buildUmd,\n    var: buildVar\n  }[outputType];\n\n  if (build) {\n    tree = build(allowlist);\n  } else {\n    throw new Error(`Unsupported output type ${outputType}`);\n  }\n\n  return (0, _generator().default)(tree).code;\n}\n\n0 && 0;","map":{"version":3,"mappings":"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","names":["helpers","_generator","_template","_t","arrayExpression","assignmentExpression","binaryExpression","blockStatement","callExpression","cloneNode","conditionalExpression","exportNamedDeclaration","exportSpecifier","expressionStatement","functionExpression","identifier","memberExpression","objectExpression","program","stringLiteral","unaryExpression","variableDeclaration","variableDeclarator","buildUmdWrapper","replacements","template","statement","buildGlobal","allowlist","namespace","body","container","tree","push","buildHelpers","buildModule","refs","unshift","Object","keys","map","name","buildUmd","FACTORY_PARAMETERS","BROWSER_ARGUMENTS","COMMON_ARGUMENTS","AMD_ARGUMENTS","FACTORY_BODY","UMD_ROOT","buildVar","getHelperReference","list","forEach","indexOf","ref","ensure","File","nodes","get","outputType","build","global","module","umd","var","Error","code"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\tools\\build-external-helpers.ts"],"sourcesContent":["import * as helpers from \"@babel/helpers\";\nimport generator from \"@babel/generator\";\nimport template from \"@babel/template\";\nimport {\n  arrayExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  exportNamedDeclaration,\n  exportSpecifier,\n  expressionStatement,\n  functionExpression,\n  identifier,\n  memberExpression,\n  objectExpression,\n  program,\n  stringLiteral,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport File from \"../transformation/file/file\";\nimport type { PublicReplacements } from \"@babel/template/src/options\";\n\n// Wrapped to avoid wasting time parsing this when almost no-one uses\n// build-external-helpers.\nconst buildUmdWrapper = (replacements: PublicReplacements) =>\n  template.statement`\n    (function (root, factory) {\n      if (typeof define === \"function\" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === \"object\") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  `(replacements);\n\nfunction buildGlobal(allowlist?: Array<string>) {\n  const namespace = identifier(\"babelHelpers\");\n\n  const body: t.Statement[] = [];\n  const container = functionExpression(\n    null,\n    [identifier(\"global\")],\n    blockStatement(body),\n  );\n  const tree = program([\n    expressionStatement(\n      callExpression(container, [\n        // typeof global === \"undefined\" ? self : global\n        conditionalExpression(\n          binaryExpression(\n            \"===\",\n            unaryExpression(\"typeof\", identifier(\"global\")),\n            stringLiteral(\"undefined\"),\n          ),\n          identifier(\"self\"),\n          identifier(\"global\"),\n        ),\n      ]),\n    ),\n  ]);\n\n  body.push(\n    variableDeclaration(\"var\", [\n      variableDeclarator(\n        namespace,\n        assignmentExpression(\n          \"=\",\n          memberExpression(identifier(\"global\"), namespace),\n          objectExpression([]),\n        ),\n      ),\n    ]),\n  );\n\n  buildHelpers(body, namespace, allowlist);\n\n  return tree;\n}\n\nfunction buildModule(allowlist?: Array<string>) {\n  const body: t.Statement[] = [];\n  const refs = buildHelpers(body, null, allowlist);\n\n  body.unshift(\n    exportNamedDeclaration(\n      null,\n      Object.keys(refs).map(name => {\n        return exportSpecifier(cloneNode(refs[name]), identifier(name));\n      }),\n    ),\n  );\n\n  return program(body, [], \"module\");\n}\n\nfunction buildUmd(allowlist?: Array<string>) {\n  const namespace = identifier(\"babelHelpers\");\n\n  const body: t.Statement[] = [];\n  body.push(\n    variableDeclaration(\"var\", [\n      variableDeclarator(namespace, identifier(\"global\")),\n    ]),\n  );\n\n  buildHelpers(body, namespace, allowlist);\n\n  return program([\n    buildUmdWrapper({\n      FACTORY_PARAMETERS: identifier(\"global\"),\n      BROWSER_ARGUMENTS: assignmentExpression(\n        \"=\",\n        memberExpression(identifier(\"root\"), namespace),\n        objectExpression([]),\n      ),\n      COMMON_ARGUMENTS: identifier(\"exports\"),\n      AMD_ARGUMENTS: arrayExpression([stringLiteral(\"exports\")]),\n      FACTORY_BODY: body,\n      UMD_ROOT: identifier(\"this\"),\n    }),\n  ]);\n}\n\nfunction buildVar(allowlist?: Array<string>) {\n  const namespace = identifier(\"babelHelpers\");\n\n  const body: t.Statement[] = [];\n  body.push(\n    variableDeclaration(\"var\", [\n      variableDeclarator(namespace, objectExpression([])),\n    ]),\n  );\n  const tree = program(body);\n  buildHelpers(body, namespace, allowlist);\n  body.push(expressionStatement(namespace));\n  return tree;\n}\n\nfunction buildHelpers(\n  body: t.Statement[],\n  namespace: t.Expression,\n  allowlist?: Array<string>,\n): Record<string, t.MemberExpression>;\nfunction buildHelpers(\n  body: t.Statement[],\n  namespace: null,\n  allowlist?: Array<string>,\n): Record<string, t.Identifier>;\n\nfunction buildHelpers(\n  body: t.Statement[],\n  namespace: t.Expression | null,\n  allowlist?: Array<string>,\n) {\n  const getHelperReference = (name: string) => {\n    return namespace\n      ? memberExpression(namespace, identifier(name))\n      : identifier(`_${name}`);\n  };\n\n  const refs: { [key: string]: t.Identifier | t.MemberExpression } = {};\n  helpers.list.forEach(function (name) {\n    if (allowlist && allowlist.indexOf(name) < 0) return;\n\n    const ref = (refs[name] = getHelperReference(name));\n\n    helpers.ensure(name, File);\n    const { nodes } = helpers.get(name, getHelperReference, ref);\n\n    body.push(...nodes);\n  });\n  return refs;\n}\nexport default function (\n  allowlist?: Array<string>,\n  outputType: \"global\" | \"module\" | \"umd\" | \"var\" = \"global\",\n) {\n  let tree: t.Program;\n\n  const build = {\n    global: buildGlobal,\n    module: buildModule,\n    umd: buildUmd,\n    var: buildVar,\n  }[outputType];\n\n  if (build) {\n    tree = build(allowlist);\n  } else {\n    throw new Error(`Unsupported output type ${outputType}`);\n  }\n\n  return generator(tree).code;\n}\n"]},"metadata":{},"sourceType":"script"}