{"ast":null,"code":"/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n      {\n  breakableTypePattern\n} = require(\"../../shared/ast-utils\"),\n      CodePath = require(\"./code-path\"),\n      CodePathSegment = require(\"./code-path-segment\"),\n      IdGenerator = require(\"./id-generator\"),\n      debug = require(\"./debug-helpers\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n * @param {ASTNode} node A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\n\n\nfunction isCaseNode(node) {\n  return Boolean(node.test);\n}\n/**\n * Checks if a given node appears as the value of a PropertyDefinition node.\n * @param {ASTNode} node THe node to check.\n * @returns {boolean} `true` if the node is a PropertyDefinition value,\n *      false if not.\n */\n\n\nfunction isPropertyDefinitionValue(node) {\n  const parent = node.parent;\n  return parent && parent.type === \"PropertyDefinition\" && parent.value === node;\n}\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n * @param {string} operator The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"\n */\n\n\nfunction isHandledLogicalOperator(operator) {\n  return operator === \"&&\" || operator === \"||\" || operator === \"??\";\n}\n/**\n * Checks whether the given assignment operator is a logical assignment operator.\n * Logical assignments are taken into account for the code path analysis\n * because of their short-circuiting semantics.\n * @param {string} operator The operator found in the AssignmentExpression node\n * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"\n */\n\n\nfunction isLogicalAssignmentOperator(operator) {\n  return operator === \"&&=\" || operator === \"||=\" || operator === \"??=\";\n}\n/**\n * Gets the label if the parent node of a given node is a LabeledStatement.\n * @param {ASTNode} node A node to get.\n * @returns {string|null} The label or `null`.\n */\n\n\nfunction getLabel(node) {\n  if (node.parent.type === \"LabeledStatement\") {\n    return node.parent.label.name;\n  }\n\n  return null;\n}\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\n\n\nfunction isForkingByTrueOrFalse(node) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n      return parent.test === node;\n\n    case \"LogicalExpression\":\n      return isHandledLogicalOperator(parent.operator);\n\n    case \"AssignmentExpression\":\n      return isLogicalAssignmentOperator(parent.operator);\n\n    default:\n      return false;\n  }\n}\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n * @param {ASTNode} node A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\n\n\nfunction getBooleanValueIfSimpleConstant(node) {\n  if (node.type === \"Literal\") {\n    return Boolean(node.value);\n  }\n\n  return void 0;\n}\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n * @param {ASTNode} node An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\n\n\nfunction isIdentifierReference(node) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"LabeledStatement\":\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n    case \"ImportSpecifier\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"CatchClause\":\n      return false;\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n    case \"VariableDeclarator\":\n      return parent.id !== node;\n\n    case \"Property\":\n    case \"PropertyDefinition\":\n    case \"MethodDefinition\":\n      return parent.key !== node || parent.computed || parent.shorthand;\n\n    case \"AssignmentPattern\":\n      return parent.key !== node;\n\n    default:\n      return true;\n  }\n}\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction forwardCurrentToHead(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  const currentSegments = state.currentSegments;\n  const headSegments = state.headSegments;\n  const end = Math.max(currentSegments.length, headSegments.length);\n  let i, currentSegment, headSegment; // Fires leaving events.\n\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n\n    if (currentSegment !== headSegment && currentSegment) {\n      debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n      if (currentSegment.reachable) {\n        analyzer.emitter.emit(\"onCodePathSegmentEnd\", currentSegment, node);\n      }\n    }\n  } // Update state.\n\n\n  state.currentSegments = headSegments; // Fires entering events.\n\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n\n    if (currentSegment !== headSegment && headSegment) {\n      debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\n      CodePathSegment.markUsed(headSegment);\n\n      if (headSegment.reachable) {\n        analyzer.emitter.emit(\"onCodePathSegmentStart\", headSegment, node);\n      }\n    }\n  }\n}\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction leaveFromCurrentSegment(analyzer, node) {\n  const state = CodePath.getState(analyzer.codePath);\n  const currentSegments = state.currentSegments;\n\n  for (let i = 0; i < currentSegments.length; ++i) {\n    const currentSegment = currentSegments[i];\n    debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n    if (currentSegment.reachable) {\n      analyzer.emitter.emit(\"onCodePathSegmentEnd\", currentSegment, node);\n    }\n  }\n\n  state.currentSegments = [];\n}\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction preprocess(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  const parent = node.parent;\n\n  switch (parent.type) {\n    // The `arguments.length == 0` case is in `postprocess` function.\n    case \"CallExpression\":\n      if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {\n        state.makeOptionalRight();\n      }\n\n      break;\n\n    case \"MemberExpression\":\n      if (parent.optional === true && parent.property === node) {\n        state.makeOptionalRight();\n      }\n\n      break;\n\n    case \"LogicalExpression\":\n      if (parent.right === node && isHandledLogicalOperator(parent.operator)) {\n        state.makeLogicalRight();\n      }\n\n      break;\n\n    case \"AssignmentExpression\":\n      if (parent.right === node && isLogicalAssignmentOperator(parent.operator)) {\n        state.makeLogicalRight();\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      /*\n       * Fork if this node is at `consequent`/`alternate`.\n       * `popForkContext()` exists at `IfStatement:exit` and\n       * `ConditionalExpression:exit`.\n       */\n      if (parent.consequent === node) {\n        state.makeIfConsequent();\n      } else if (parent.alternate === node) {\n        state.makeIfAlternate();\n      }\n\n      break;\n\n    case \"SwitchCase\":\n      if (parent.consequent[0] === node) {\n        state.makeSwitchCaseBody(false, !parent.test);\n      }\n\n      break;\n\n    case \"TryStatement\":\n      if (parent.handler === node) {\n        state.makeCatchBlock();\n      } else if (parent.finalizer === node) {\n        state.makeFinallyBlock();\n      }\n\n      break;\n\n    case \"WhileStatement\":\n      if (parent.test === node) {\n        state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n      } else {\n        assert(parent.body === node);\n        state.makeWhileBody();\n      }\n\n      break;\n\n    case \"DoWhileStatement\":\n      if (parent.body === node) {\n        state.makeDoWhileBody();\n      } else {\n        assert(parent.test === node);\n        state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n      }\n\n      break;\n\n    case \"ForStatement\":\n      if (parent.test === node) {\n        state.makeForTest(getBooleanValueIfSimpleConstant(node));\n      } else if (parent.update === node) {\n        state.makeForUpdate();\n      } else if (parent.body === node) {\n        state.makeForBody();\n      }\n\n      break;\n\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      if (parent.left === node) {\n        state.makeForInOfLeft();\n      } else if (parent.right === node) {\n        state.makeForInOfRight();\n      } else {\n        assert(parent.body === node);\n        state.makeForInOfBody();\n      }\n\n      break;\n\n    case \"AssignmentPattern\":\n      /*\n       * Fork if this node is at `right`.\n       * `left` is executed always, so it uses the current path.\n       * `popForkContext()` exists at `AssignmentPattern:exit`.\n       */\n      if (parent.right === node) {\n        state.pushForkContext();\n        state.forkBypassPath();\n        state.forkPath();\n      }\n\n      break;\n\n    default:\n      break;\n  }\n}\n/**\n * Updates the code path due to the type of a given node in entering.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction processCodePathToEnter(analyzer, node) {\n  let codePath = analyzer.codePath;\n  let state = codePath && CodePath.getState(codePath);\n  const parent = node.parent;\n  /**\n   * Creates a new code path and trigger the onCodePathStart event\n   * based on the currently selected node.\n   * @param {string} origin The reason the code path was started.\n   * @returns {void}\n   */\n\n  function startCodePath(origin) {\n    if (codePath) {\n      // Emits onCodePathSegmentStart events if updated.\n      forwardCurrentToHead(analyzer, node);\n      debug.dumpState(node, state, false);\n    } // Create the code path of this scope.\n\n\n    codePath = analyzer.codePath = new CodePath({\n      id: analyzer.idGenerator.next(),\n      origin,\n      upper: codePath,\n      onLooped: analyzer.onLooped\n    });\n    state = CodePath.getState(codePath); // Emits onCodePathStart events.\n\n    debug.dump(`onCodePathStart ${codePath.id}`);\n    analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n  }\n  /*\n   * Special case: The right side of class field initializer is considered\n   * to be its own function, so we need to start a new code path in this\n   * case.\n   */\n\n\n  if (isPropertyDefinitionValue(node)) {\n    startCodePath(\"class-field-initializer\");\n    /*\n     * Intentional fall through because `node` needs to also be\n     * processed by the code below. For example, if we have:\n     *\n     * class Foo {\n     *     a = () => {}\n     * }\n     *\n     * In this case, we also need start a second code path.\n     */\n  }\n\n  switch (node.type) {\n    case \"Program\":\n      startCodePath(\"program\");\n      break;\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      startCodePath(\"function\");\n      break;\n\n    case \"StaticBlock\":\n      startCodePath(\"class-static-block\");\n      break;\n\n    case \"ChainExpression\":\n      state.pushChainContext();\n      break;\n\n    case \"CallExpression\":\n      if (node.optional === true) {\n        state.makeOptionalNode();\n      }\n\n      break;\n\n    case \"MemberExpression\":\n      if (node.optional === true) {\n        state.makeOptionalNode();\n      }\n\n      break;\n\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));\n      }\n\n      break;\n\n    case \"AssignmentExpression\":\n      if (isLogicalAssignmentOperator(node.operator)) {\n        state.pushChoiceContext(node.operator.slice(0, -1), // removes `=` from the end\n        isForkingByTrueOrFalse(node));\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      state.pushChoiceContext(\"test\", false);\n      break;\n\n    case \"SwitchStatement\":\n      state.pushSwitchContext(node.cases.some(isCaseNode), getLabel(node));\n      break;\n\n    case \"TryStatement\":\n      state.pushTryContext(Boolean(node.finalizer));\n      break;\n\n    case \"SwitchCase\":\n      /*\n       * Fork if this node is after the 2st node in `cases`.\n       * It's similar to `else` blocks.\n       * The next `test` node is processed in this path.\n       */\n      if (parent.discriminant !== node && parent.cases[0] !== node) {\n        state.forkPath();\n      }\n\n      break;\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.pushLoopContext(node.type, getLabel(node));\n      break;\n\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.pushBreakContext(false, node.label.name);\n      }\n\n      break;\n\n    default:\n      break;\n  } // Emits onCodePathSegmentStart events if updated.\n\n\n  forwardCurrentToHead(analyzer, node);\n  debug.dumpState(node, state, false);\n}\n/**\n * Updates the code path due to the type of a given node in leaving.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction processCodePathToExit(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  let dontForward = false;\n\n  switch (node.type) {\n    case \"ChainExpression\":\n      state.popChainContext();\n      break;\n\n    case \"IfStatement\":\n    case \"ConditionalExpression\":\n      state.popChoiceContext();\n      break;\n\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.popChoiceContext();\n      }\n\n      break;\n\n    case \"AssignmentExpression\":\n      if (isLogicalAssignmentOperator(node.operator)) {\n        state.popChoiceContext();\n      }\n\n      break;\n\n    case \"SwitchStatement\":\n      state.popSwitchContext();\n      break;\n\n    case \"SwitchCase\":\n      /*\n       * This is the same as the process at the 1st `consequent` node in\n       * `preprocess` function.\n       * Must do if this `consequent` is empty.\n       */\n      if (node.consequent.length === 0) {\n        state.makeSwitchCaseBody(true, !node.test);\n      }\n\n      if (state.forkContext.reachable) {\n        dontForward = true;\n      }\n\n      break;\n\n    case \"TryStatement\":\n      state.popTryContext();\n      break;\n\n    case \"BreakStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeBreak(node.label && node.label.name);\n      dontForward = true;\n      break;\n\n    case \"ContinueStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeContinue(node.label && node.label.name);\n      dontForward = true;\n      break;\n\n    case \"ReturnStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeReturn();\n      dontForward = true;\n      break;\n\n    case \"ThrowStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeThrow();\n      dontForward = true;\n      break;\n\n    case \"Identifier\":\n      if (isIdentifierReference(node)) {\n        state.makeFirstThrowablePathInTryBlock();\n        dontForward = true;\n      }\n\n      break;\n\n    case \"CallExpression\":\n    case \"ImportExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"YieldExpression\":\n      state.makeFirstThrowablePathInTryBlock();\n      break;\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.popLoopContext();\n      break;\n\n    case \"AssignmentPattern\":\n      state.popForkContext();\n      break;\n\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.popBreakContext();\n      }\n\n      break;\n\n    default:\n      break;\n  } // Emits onCodePathSegmentStart events if updated.\n\n\n  if (!dontForward) {\n    forwardCurrentToHead(analyzer, node);\n  }\n\n  debug.dumpState(node, state, true);\n}\n/**\n * Updates the code path to finalize the current code path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction postprocess(analyzer, node) {\n  /**\n   * Ends the code path for the current node.\n   * @returns {void}\n   */\n  function endCodePath() {\n    let codePath = analyzer.codePath; // Mark the current path as the final node.\n\n    CodePath.getState(codePath).makeFinal(); // Emits onCodePathSegmentEnd event of the current segments.\n\n    leaveFromCurrentSegment(analyzer, node); // Emits onCodePathEnd event of this code path.\n\n    debug.dump(`onCodePathEnd ${codePath.id}`);\n    analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n    debug.dumpDot(codePath);\n    codePath = analyzer.codePath = analyzer.codePath.upper;\n\n    if (codePath) {\n      debug.dumpState(node, CodePath.getState(codePath), true);\n    }\n  }\n\n  switch (node.type) {\n    case \"Program\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"StaticBlock\":\n      {\n        endCodePath();\n        break;\n      }\n    // The `arguments.length >= 1` case is in `preprocess` function.\n\n    case \"CallExpression\":\n      if (node.optional === true && node.arguments.length === 0) {\n        CodePath.getState(analyzer.codePath).makeOptionalRight();\n      }\n\n      break;\n\n    default:\n      break;\n  }\n  /*\n   * Special case: The right side of class field initializer is considered\n   * to be its own function, so we need to end a code path in this\n   * case.\n   *\n   * We need to check after the other checks in order to close the\n   * code paths in the correct order for code like this:\n   *\n   *\n   * class Foo {\n   *     a = () => {}\n   * }\n   *\n   * In this case, The ArrowFunctionExpression code path is closed first\n   * and then we need to close the code path for the PropertyDefinition\n   * value.\n   */\n\n\n  if (isPropertyDefinitionValue(node)) {\n    endCodePath();\n  }\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\n\n\nclass CodePathAnalyzer {\n  /**\n   * @param {EventGenerator} eventGenerator An event generator to wrap.\n   */\n  constructor(eventGenerator) {\n    this.original = eventGenerator;\n    this.emitter = eventGenerator.emitter;\n    this.codePath = null;\n    this.idGenerator = new IdGenerator(\"s\");\n    this.currentNode = null;\n    this.onLooped = this.onLooped.bind(this);\n  }\n  /**\n   * Does the process to enter a given AST node.\n   * This updates state of analysis and calls `enterNode` of the wrapped.\n   * @param {ASTNode} node A node which is entering.\n   * @returns {void}\n   */\n\n\n  enterNode(node) {\n    this.currentNode = node; // Updates the code path due to node's position in its parent node.\n\n    if (node.parent) {\n      preprocess(this, node);\n    }\n    /*\n     * Updates the code path.\n     * And emits onCodePathStart/onCodePathSegmentStart events.\n     */\n\n\n    processCodePathToEnter(this, node); // Emits node events.\n\n    this.original.enterNode(node);\n    this.currentNode = null;\n  }\n  /**\n   * Does the process to leave a given AST node.\n   * This updates state of analysis and calls `leaveNode` of the wrapped.\n   * @param {ASTNode} node A node which is leaving.\n   * @returns {void}\n   */\n\n\n  leaveNode(node) {\n    this.currentNode = node;\n    /*\n     * Updates the code path.\n     * And emits onCodePathStart/onCodePathSegmentStart events.\n     */\n\n    processCodePathToExit(this, node); // Emits node events.\n\n    this.original.leaveNode(node); // Emits the last onCodePathStart/onCodePathSegmentStart events.\n\n    postprocess(this, node);\n    this.currentNode = null;\n  }\n  /**\n   * This is called on a code path looped.\n   * Then this raises a looped event.\n   * @param {CodePathSegment} fromSegment A segment of prev.\n   * @param {CodePathSegment} toSegment A segment of next.\n   * @returns {void}\n   */\n\n\n  onLooped(fromSegment, toSegment) {\n    if (fromSegment.reachable && toSegment.reachable) {\n      debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n      this.emitter.emit(\"onCodePathSegmentLoop\", fromSegment, toSegment, this.currentNode);\n    }\n  }\n\n}\n\nmodule.exports = CodePathAnalyzer;","map":{"version":3,"names":["assert","require","breakableTypePattern","CodePath","CodePathSegment","IdGenerator","debug","isCaseNode","node","Boolean","test","isPropertyDefinitionValue","parent","type","value","isHandledLogicalOperator","operator","isLogicalAssignmentOperator","getLabel","label","name","isForkingByTrueOrFalse","getBooleanValueIfSimpleConstant","isIdentifierReference","id","key","computed","shorthand","forwardCurrentToHead","analyzer","codePath","state","getState","currentSegments","headSegments","end","Math","max","length","i","currentSegment","headSegment","dump","reachable","emitter","emit","markUsed","leaveFromCurrentSegment","preprocess","optional","arguments","makeOptionalRight","property","right","makeLogicalRight","consequent","makeIfConsequent","alternate","makeIfAlternate","makeSwitchCaseBody","handler","makeCatchBlock","finalizer","makeFinallyBlock","makeWhileTest","body","makeWhileBody","makeDoWhileBody","makeDoWhileTest","makeForTest","update","makeForUpdate","makeForBody","left","makeForInOfLeft","makeForInOfRight","makeForInOfBody","pushForkContext","forkBypassPath","forkPath","processCodePathToEnter","startCodePath","origin","dumpState","idGenerator","next","upper","onLooped","pushChainContext","makeOptionalNode","pushChoiceContext","slice","pushSwitchContext","cases","some","pushTryContext","discriminant","pushLoopContext","pushBreakContext","processCodePathToExit","dontForward","popChainContext","popChoiceContext","popSwitchContext","forkContext","popTryContext","makeBreak","makeContinue","makeReturn","makeThrow","makeFirstThrowablePathInTryBlock","popLoopContext","popForkContext","popBreakContext","postprocess","endCodePath","makeFinal","dumpDot","CodePathAnalyzer","constructor","eventGenerator","original","currentNode","bind","enterNode","leaveNode","fromSegment","toSegment","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/linter/code-path-analysis/code-path-analyzer.js"],"sourcesContent":["/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    { breakableTypePattern } = require(\"../../shared/ast-utils\"),\n    CodePath = require(\"./code-path\"),\n    CodePathSegment = require(\"./code-path-segment\"),\n    IdGenerator = require(\"./id-generator\"),\n    debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n * @param {ASTNode} node A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\nfunction isCaseNode(node) {\n    return Boolean(node.test);\n}\n\n/**\n * Checks if a given node appears as the value of a PropertyDefinition node.\n * @param {ASTNode} node THe node to check.\n * @returns {boolean} `true` if the node is a PropertyDefinition value,\n *      false if not.\n */\nfunction isPropertyDefinitionValue(node) {\n    const parent = node.parent;\n\n    return parent && parent.type === \"PropertyDefinition\" && parent.value === node;\n}\n\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n * @param {string} operator The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"\n */\nfunction isHandledLogicalOperator(operator) {\n    return operator === \"&&\" || operator === \"||\" || operator === \"??\";\n}\n\n/**\n * Checks whether the given assignment operator is a logical assignment operator.\n * Logical assignments are taken into account for the code path analysis\n * because of their short-circuiting semantics.\n * @param {string} operator The operator found in the AssignmentExpression node\n * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"\n */\nfunction isLogicalAssignmentOperator(operator) {\n    return operator === \"&&=\" || operator === \"||=\" || operator === \"??=\";\n}\n\n/**\n * Gets the label if the parent node of a given node is a LabeledStatement.\n * @param {ASTNode} node A node to get.\n * @returns {string|null} The label or `null`.\n */\nfunction getLabel(node) {\n    if (node.parent.type === \"LabeledStatement\") {\n        return node.parent.label.name;\n    }\n    return null;\n}\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\nfunction isForkingByTrueOrFalse(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n            return parent.test === node;\n\n        case \"LogicalExpression\":\n            return isHandledLogicalOperator(parent.operator);\n\n        case \"AssignmentExpression\":\n            return isLogicalAssignmentOperator(parent.operator);\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n * @param {ASTNode} node A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\nfunction getBooleanValueIfSimpleConstant(node) {\n    if (node.type === \"Literal\") {\n        return Boolean(node.value);\n    }\n    return void 0;\n}\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n * @param {ASTNode} node An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\nfunction isIdentifierReference(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"LabeledStatement\":\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n        case \"ArrayPattern\":\n        case \"RestElement\":\n        case \"ImportSpecifier\":\n        case \"ImportDefaultSpecifier\":\n        case \"ImportNamespaceSpecifier\":\n        case \"CatchClause\":\n            return false;\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n        case \"VariableDeclarator\":\n            return parent.id !== node;\n\n        case \"Property\":\n        case \"PropertyDefinition\":\n        case \"MethodDefinition\":\n            return (\n                parent.key !== node ||\n                parent.computed ||\n                parent.shorthand\n            );\n\n        case \"AssignmentPattern\":\n            return parent.key !== node;\n\n        default:\n            return true;\n    }\n}\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction forwardCurrentToHead(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const currentSegments = state.currentSegments;\n    const headSegments = state.headSegments;\n    const end = Math.max(currentSegments.length, headSegments.length);\n    let i, currentSegment, headSegment;\n\n    // Fires leaving events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && currentSegment) {\n            debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n            if (currentSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentEnd\",\n                    currentSegment,\n                    node\n                );\n            }\n        }\n    }\n\n    // Update state.\n    state.currentSegments = headSegments;\n\n    // Fires entering events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && headSegment) {\n            debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\n\n            CodePathSegment.markUsed(headSegment);\n            if (headSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentStart\",\n                    headSegment,\n                    node\n                );\n            }\n        }\n    }\n\n}\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction leaveFromCurrentSegment(analyzer, node) {\n    const state = CodePath.getState(analyzer.codePath);\n    const currentSegments = state.currentSegments;\n\n    for (let i = 0; i < currentSegments.length; ++i) {\n        const currentSegment = currentSegments[i];\n\n        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n        if (currentSegment.reachable) {\n            analyzer.emitter.emit(\n                \"onCodePathSegmentEnd\",\n                currentSegment,\n                node\n            );\n        }\n    }\n\n    state.currentSegments = [];\n}\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction preprocess(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (parent.type) {\n\n        // The `arguments.length == 0` case is in `postprocess` function.\n        case \"CallExpression\":\n            if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {\n                state.makeOptionalRight();\n            }\n            break;\n        case \"MemberExpression\":\n            if (parent.optional === true && parent.property === node) {\n                state.makeOptionalRight();\n            }\n            break;\n\n        case \"LogicalExpression\":\n            if (\n                parent.right === node &&\n                isHandledLogicalOperator(parent.operator)\n            ) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (\n                parent.right === node &&\n                isLogicalAssignmentOperator(parent.operator)\n            ) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n\n            /*\n             * Fork if this node is at `consequent`/`alternate`.\n             * `popForkContext()` exists at `IfStatement:exit` and\n             * `ConditionalExpression:exit`.\n             */\n            if (parent.consequent === node) {\n                state.makeIfConsequent();\n            } else if (parent.alternate === node) {\n                state.makeIfAlternate();\n            }\n            break;\n\n        case \"SwitchCase\":\n            if (parent.consequent[0] === node) {\n                state.makeSwitchCaseBody(false, !parent.test);\n            }\n            break;\n\n        case \"TryStatement\":\n            if (parent.handler === node) {\n                state.makeCatchBlock();\n            } else if (parent.finalizer === node) {\n                state.makeFinallyBlock();\n            }\n            break;\n\n        case \"WhileStatement\":\n            if (parent.test === node) {\n                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n            } else {\n                assert(parent.body === node);\n                state.makeWhileBody();\n            }\n            break;\n\n        case \"DoWhileStatement\":\n            if (parent.body === node) {\n                state.makeDoWhileBody();\n            } else {\n                assert(parent.test === node);\n                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n            }\n            break;\n\n        case \"ForStatement\":\n            if (parent.test === node) {\n                state.makeForTest(getBooleanValueIfSimpleConstant(node));\n            } else if (parent.update === node) {\n                state.makeForUpdate();\n            } else if (parent.body === node) {\n                state.makeForBody();\n            }\n            break;\n\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            if (parent.left === node) {\n                state.makeForInOfLeft();\n            } else if (parent.right === node) {\n                state.makeForInOfRight();\n            } else {\n                assert(parent.body === node);\n                state.makeForInOfBody();\n            }\n            break;\n\n        case \"AssignmentPattern\":\n\n            /*\n             * Fork if this node is at `right`.\n             * `left` is executed always, so it uses the current path.\n             * `popForkContext()` exists at `AssignmentPattern:exit`.\n             */\n            if (parent.right === node) {\n                state.pushForkContext();\n                state.forkBypassPath();\n                state.forkPath();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Updates the code path due to the type of a given node in entering.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToEnter(analyzer, node) {\n    let codePath = analyzer.codePath;\n    let state = codePath && CodePath.getState(codePath);\n    const parent = node.parent;\n\n    /**\n     * Creates a new code path and trigger the onCodePathStart event\n     * based on the currently selected node.\n     * @param {string} origin The reason the code path was started.\n     * @returns {void}\n     */\n    function startCodePath(origin) {\n        if (codePath) {\n\n            // Emits onCodePathSegmentStart events if updated.\n            forwardCurrentToHead(analyzer, node);\n            debug.dumpState(node, state, false);\n        }\n\n        // Create the code path of this scope.\n        codePath = analyzer.codePath = new CodePath({\n            id: analyzer.idGenerator.next(),\n            origin,\n            upper: codePath,\n            onLooped: analyzer.onLooped\n        });\n        state = CodePath.getState(codePath);\n\n        // Emits onCodePathStart events.\n        debug.dump(`onCodePathStart ${codePath.id}`);\n        analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n    }\n\n    /*\n     * Special case: The right side of class field initializer is considered\n     * to be its own function, so we need to start a new code path in this\n     * case.\n     */\n    if (isPropertyDefinitionValue(node)) {\n        startCodePath(\"class-field-initializer\");\n\n        /*\n         * Intentional fall through because `node` needs to also be\n         * processed by the code below. For example, if we have:\n         *\n         * class Foo {\n         *     a = () => {}\n         * }\n         *\n         * In this case, we also need start a second code path.\n         */\n\n    }\n\n    switch (node.type) {\n        case \"Program\":\n            startCodePath(\"program\");\n            break;\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n            startCodePath(\"function\");\n            break;\n\n        case \"StaticBlock\":\n            startCodePath(\"class-static-block\");\n            break;\n\n        case \"ChainExpression\":\n            state.pushChainContext();\n            break;\n        case \"CallExpression\":\n            if (node.optional === true) {\n                state.makeOptionalNode();\n            }\n            break;\n        case \"MemberExpression\":\n            if (node.optional === true) {\n                state.makeOptionalNode();\n            }\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.pushChoiceContext(\n                    node.operator,\n                    isForkingByTrueOrFalse(node)\n                );\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (isLogicalAssignmentOperator(node.operator)) {\n                state.pushChoiceContext(\n                    node.operator.slice(0, -1), // removes `=` from the end\n                    isForkingByTrueOrFalse(node)\n                );\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n            state.pushChoiceContext(\"test\", false);\n            break;\n\n        case \"SwitchStatement\":\n            state.pushSwitchContext(\n                node.cases.some(isCaseNode),\n                getLabel(node)\n            );\n            break;\n\n        case \"TryStatement\":\n            state.pushTryContext(Boolean(node.finalizer));\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * Fork if this node is after the 2st node in `cases`.\n             * It's similar to `else` blocks.\n             * The next `test` node is processed in this path.\n             */\n            if (parent.discriminant !== node && parent.cases[0] !== node) {\n                state.forkPath();\n            }\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.pushLoopContext(node.type, getLabel(node));\n            break;\n\n        case \"LabeledStatement\":\n            if (!breakableTypePattern.test(node.body.type)) {\n                state.pushBreakContext(false, node.label.name);\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    forwardCurrentToHead(analyzer, node);\n    debug.dumpState(node, state, false);\n}\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToExit(analyzer, node) {\n\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    let dontForward = false;\n\n    switch (node.type) {\n        case \"ChainExpression\":\n            state.popChainContext();\n            break;\n\n        case \"IfStatement\":\n        case \"ConditionalExpression\":\n            state.popChoiceContext();\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.popChoiceContext();\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (isLogicalAssignmentOperator(node.operator)) {\n                state.popChoiceContext();\n            }\n            break;\n\n        case \"SwitchStatement\":\n            state.popSwitchContext();\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * This is the same as the process at the 1st `consequent` node in\n             * `preprocess` function.\n             * Must do if this `consequent` is empty.\n             */\n            if (node.consequent.length === 0) {\n                state.makeSwitchCaseBody(true, !node.test);\n            }\n            if (state.forkContext.reachable) {\n                dontForward = true;\n            }\n            break;\n\n        case \"TryStatement\":\n            state.popTryContext();\n            break;\n\n        case \"BreakStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeBreak(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ContinueStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeContinue(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ReturnStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeReturn();\n            dontForward = true;\n            break;\n\n        case \"ThrowStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeThrow();\n            dontForward = true;\n            break;\n\n        case \"Identifier\":\n            if (isIdentifierReference(node)) {\n                state.makeFirstThrowablePathInTryBlock();\n                dontForward = true;\n            }\n            break;\n\n        case \"CallExpression\":\n        case \"ImportExpression\":\n        case \"MemberExpression\":\n        case \"NewExpression\":\n        case \"YieldExpression\":\n            state.makeFirstThrowablePathInTryBlock();\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.popLoopContext();\n            break;\n\n        case \"AssignmentPattern\":\n            state.popForkContext();\n            break;\n\n        case \"LabeledStatement\":\n            if (!breakableTypePattern.test(node.body.type)) {\n                state.popBreakContext();\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    if (!dontForward) {\n        forwardCurrentToHead(analyzer, node);\n    }\n    debug.dumpState(node, state, true);\n}\n\n/**\n * Updates the code path to finalize the current code path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction postprocess(analyzer, node) {\n\n    /**\n     * Ends the code path for the current node.\n     * @returns {void}\n     */\n    function endCodePath() {\n        let codePath = analyzer.codePath;\n\n        // Mark the current path as the final node.\n        CodePath.getState(codePath).makeFinal();\n\n        // Emits onCodePathSegmentEnd event of the current segments.\n        leaveFromCurrentSegment(analyzer, node);\n\n        // Emits onCodePathEnd event of this code path.\n        debug.dump(`onCodePathEnd ${codePath.id}`);\n        analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n        debug.dumpDot(codePath);\n\n        codePath = analyzer.codePath = analyzer.codePath.upper;\n        if (codePath) {\n            debug.dumpState(node, CodePath.getState(codePath), true);\n        }\n\n    }\n\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"StaticBlock\": {\n            endCodePath();\n            break;\n        }\n\n        // The `arguments.length >= 1` case is in `preprocess` function.\n        case \"CallExpression\":\n            if (node.optional === true && node.arguments.length === 0) {\n                CodePath.getState(analyzer.codePath).makeOptionalRight();\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    /*\n     * Special case: The right side of class field initializer is considered\n     * to be its own function, so we need to end a code path in this\n     * case.\n     *\n     * We need to check after the other checks in order to close the\n     * code paths in the correct order for code like this:\n     *\n     *\n     * class Foo {\n     *     a = () => {}\n     * }\n     *\n     * In this case, The ArrowFunctionExpression code path is closed first\n     * and then we need to close the code path for the PropertyDefinition\n     * value.\n     */\n    if (isPropertyDefinitionValue(node)) {\n        endCodePath();\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\nclass CodePathAnalyzer {\n\n    /**\n     * @param {EventGenerator} eventGenerator An event generator to wrap.\n     */\n    constructor(eventGenerator) {\n        this.original = eventGenerator;\n        this.emitter = eventGenerator.emitter;\n        this.codePath = null;\n        this.idGenerator = new IdGenerator(\"s\");\n        this.currentNode = null;\n        this.onLooped = this.onLooped.bind(this);\n    }\n\n    /**\n     * Does the process to enter a given AST node.\n     * This updates state of analysis and calls `enterNode` of the wrapped.\n     * @param {ASTNode} node A node which is entering.\n     * @returns {void}\n     */\n    enterNode(node) {\n        this.currentNode = node;\n\n        // Updates the code path due to node's position in its parent node.\n        if (node.parent) {\n            preprocess(this, node);\n        }\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToEnter(this, node);\n\n        // Emits node events.\n        this.original.enterNode(node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * Does the process to leave a given AST node.\n     * This updates state of analysis and calls `leaveNode` of the wrapped.\n     * @param {ASTNode} node A node which is leaving.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.currentNode = node;\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToExit(this, node);\n\n        // Emits node events.\n        this.original.leaveNode(node);\n\n        // Emits the last onCodePathStart/onCodePathSegmentStart events.\n        postprocess(this, node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * This is called on a code path looped.\n     * Then this raises a looped event.\n     * @param {CodePathSegment} fromSegment A segment of prev.\n     * @param {CodePathSegment} toSegment A segment of next.\n     * @returns {void}\n     */\n    onLooped(fromSegment, toSegment) {\n        if (fromSegment.reachable && toSegment.reachable) {\n            debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n            this.emitter.emit(\n                \"onCodePathSegmentLoop\",\n                fromSegment,\n                toSegment,\n                this.currentNode\n            );\n        }\n    }\n}\n\nmodule.exports = CodePathAnalyzer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}