{"ast":null,"code":"/**\n * @fileoverview Enforce component methods order\n * @author Yannick Croissant\n */\n'use strict';\n\nconst has = require('object.hasown/polyfill')();\n\nconst entries = require('object.entries');\n\nconst arrayIncludes = require('array-includes');\n\nconst Components = require('../util/Components');\n\nconst astUtil = require('../util/ast');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report');\n\nconst defaultConfig = {\n  order: ['static-methods', 'lifecycle', 'everything-else', 'render'],\n  groups: {\n    lifecycle: ['displayName', 'propTypes', 'contextTypes', 'childContextTypes', 'mixins', 'statics', 'defaultProps', 'constructor', 'getDefaultProps', 'state', 'getInitialState', 'getChildContext', 'getDerivedStateFromProps', 'componentWillMount', 'UNSAFE_componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'UNSAFE_componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'UNSAFE_componentWillUpdate', 'getSnapshotBeforeUpdate', 'componentDidUpdate', 'componentDidCatch', 'componentWillUnmount']\n  }\n};\n/**\n * Get the methods order from the default config and the user config\n * @param {Object} userConfig The user configuration.\n * @returns {Array} Methods order\n */\n\nfunction getMethodsOrder(userConfig) {\n  userConfig = userConfig || {};\n  const groups = Object.assign({}, defaultConfig.groups, userConfig.groups);\n  const order = userConfig.order || defaultConfig.order;\n  let config = [];\n  let entry;\n\n  for (let i = 0, j = order.length; i < j; i++) {\n    entry = order[i];\n\n    if (has(groups, entry)) {\n      config = config.concat(groups[entry]);\n    } else {\n      config.push(entry);\n    }\n  }\n\n  return config;\n} // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst messages = {\n  unsortedProps: '{{propA}} should be placed {{position}} {{propB}}'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce component methods order',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('sort-comp')\n    },\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        order: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n        groups: {\n          type: 'object',\n          patternProperties: {\n            '^.*$': {\n              type: 'array',\n              items: {\n                type: 'string'\n              }\n            }\n          }\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  create: Components.detect((context, components) => {\n    const errors = {};\n    const methodsOrder = getMethodsOrder(context.options[0]); // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    const regExpRegExp = /\\/(.*)\\/([gimsuy]*)/;\n    /**\n     * Get indexes of the matching patterns in methods order configuration\n     * @param {Object} method - Method metadata.\n     * @returns {Array} The matching patterns indexes. Return [Infinity] if there is no match.\n     */\n\n    function getRefPropIndexes(method) {\n      const methodGroupIndexes = [];\n      methodsOrder.forEach((currentGroup, groupIndex) => {\n        if (currentGroup === 'getters') {\n          if (method.getter) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'setters') {\n          if (method.setter) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'type-annotations') {\n          if (method.typeAnnotation) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'static-variables') {\n          if (method.staticVariable) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'static-methods') {\n          if (method.staticMethod) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'instance-variables') {\n          if (method.instanceVariable) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'instance-methods') {\n          if (method.instanceMethod) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (arrayIncludes(['displayName', 'propTypes', 'contextTypes', 'childContextTypes', 'mixins', 'statics', 'defaultProps', 'constructor', 'getDefaultProps', 'state', 'getInitialState', 'getChildContext', 'getDerivedStateFromProps', 'componentWillMount', 'UNSAFE_componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'UNSAFE_componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'UNSAFE_componentWillUpdate', 'getSnapshotBeforeUpdate', 'componentDidUpdate', 'componentDidCatch', 'componentWillUnmount', 'render'], currentGroup)) {\n          if (currentGroup === method.name) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else {\n          // Is the group a regex?\n          const isRegExp = currentGroup.match(regExpRegExp);\n\n          if (isRegExp) {\n            const isMatching = new RegExp(isRegExp[1], isRegExp[2]).test(method.name);\n\n            if (isMatching) {\n              methodGroupIndexes.push(groupIndex);\n            }\n          } else if (currentGroup === method.name) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        }\n      }); // No matching pattern, return 'everything-else' index\n\n      if (methodGroupIndexes.length === 0) {\n        const everythingElseIndex = methodsOrder.indexOf('everything-else');\n\n        if (everythingElseIndex !== -1) {\n          methodGroupIndexes.push(everythingElseIndex);\n        } else {\n          // No matching pattern and no 'everything-else' group\n          methodGroupIndexes.push(Infinity);\n        }\n      }\n\n      return methodGroupIndexes;\n    }\n    /**\n     * Get properties name\n     * @param {Object} node - Property.\n     * @returns {String} Property name.\n     */\n\n\n    function getPropertyName(node) {\n      if (node.kind === 'get') {\n        return 'getter functions';\n      }\n\n      if (node.kind === 'set') {\n        return 'setter functions';\n      }\n\n      return astUtil.getPropertyName(node);\n    }\n    /**\n     * Store a new error in the error list\n     * @param {Object} propA - Mispositioned property.\n     * @param {Object} propB - Reference property.\n     */\n\n\n    function storeError(propA, propB) {\n      // Initialize the error object if needed\n      if (!errors[propA.index]) {\n        errors[propA.index] = {\n          node: propA.node,\n          score: 0,\n          closest: {\n            distance: Infinity,\n            ref: {\n              node: null,\n              index: 0\n            }\n          }\n        };\n      } // Increment the prop score\n\n\n      errors[propA.index].score += 1; // Stop here if we already have pushed another node at this position\n\n      if (getPropertyName(errors[propA.index].node) !== getPropertyName(propA.node)) {\n        return;\n      } // Stop here if we already have a closer reference\n\n\n      if (Math.abs(propA.index - propB.index) > errors[propA.index].closest.distance) {\n        return;\n      } // Update the closest reference\n\n\n      errors[propA.index].closest.distance = Math.abs(propA.index - propB.index);\n      errors[propA.index].closest.ref.node = propB.node;\n      errors[propA.index].closest.ref.index = propB.index;\n    }\n    /**\n     * Dedupe errors, only keep the ones with the highest score and delete the others\n     */\n\n\n    function dedupeErrors() {\n      for (const i in errors) {\n        if (has(errors, i)) {\n          const index = errors[i].closest.ref.index;\n\n          if (errors[index]) {\n            if (errors[i].score > errors[index].score) {\n              delete errors[index];\n            } else {\n              delete errors[i];\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Report errors\n     */\n\n\n    function reportErrors() {\n      dedupeErrors();\n      entries(errors).forEach(entry => {\n        const nodeA = entry[1].node;\n        const nodeB = entry[1].closest.ref.node;\n        const indexA = entry[0];\n        const indexB = entry[1].closest.ref.index;\n        report(context, messages.unsortedProps, 'unsortedProps', {\n          node: nodeA,\n          data: {\n            propA: getPropertyName(nodeA),\n            propB: getPropertyName(nodeB),\n            position: indexA < indexB ? 'before' : 'after'\n          }\n        });\n      });\n    }\n    /**\n     * Compare two properties and find out if they are in the right order\n     * @param {Array} propertiesInfos Array containing all the properties metadata.\n     * @param {Object} propA First property name and metadata\n     * @param {Object} propB Second property name.\n     * @returns {Object} Object containing a correct true/false flag and the correct indexes for the two properties.\n     */\n\n\n    function comparePropsOrder(propertiesInfos, propA, propB) {\n      let i;\n      let j;\n      let k;\n      let l;\n      let refIndexA;\n      let refIndexB; // Get references indexes (the correct position) for given properties\n\n      const refIndexesA = getRefPropIndexes(propA);\n      const refIndexesB = getRefPropIndexes(propB); // Get current indexes for given properties\n\n      const classIndexA = propertiesInfos.indexOf(propA);\n      const classIndexB = propertiesInfos.indexOf(propB); // Loop around the references indexes for the 1st property\n\n      for (i = 0, j = refIndexesA.length; i < j; i++) {\n        refIndexA = refIndexesA[i]; // Loop around the properties for the 2nd property (for comparison)\n\n        for (k = 0, l = refIndexesB.length; k < l; k++) {\n          refIndexB = refIndexesB[k];\n\n          if ( // Comparing the same properties\n          refIndexA === refIndexB // 1st property is placed before the 2nd one in reference and in current component\n          || refIndexA < refIndexB && classIndexA < classIndexB // 1st property is placed after the 2nd one in reference and in current component\n          || refIndexA > refIndexB && classIndexA > classIndexB) {\n            return {\n              correct: true,\n              indexA: classIndexA,\n              indexB: classIndexB\n            };\n          }\n        }\n      } // We did not find any correct match between reference and current component\n\n\n      return {\n        correct: false,\n        indexA: refIndexA,\n        indexB: refIndexB\n      };\n    }\n    /**\n     * Check properties order from a properties list and store the eventual errors\n     * @param {Array} properties Array containing all the properties.\n     */\n\n\n    function checkPropsOrder(properties) {\n      const propertiesInfos = properties.map(node => ({\n        name: getPropertyName(node),\n        getter: node.kind === 'get',\n        setter: node.kind === 'set',\n        staticVariable: node.static && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition') && (!node.value || !astUtil.isFunctionLikeExpression(node.value)),\n        staticMethod: node.static && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition' || node.type === 'MethodDefinition') && node.value && astUtil.isFunctionLikeExpression(node.value),\n        instanceVariable: !node.static && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition') && (!node.value || !astUtil.isFunctionLikeExpression(node.value)),\n        instanceMethod: !node.static && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition') && node.value && astUtil.isFunctionLikeExpression(node.value),\n        typeAnnotation: !!node.typeAnnotation && node.value === null\n      })); // Loop around the properties\n\n      propertiesInfos.forEach((propA, i) => {\n        // Loop around the properties a second time (for comparison)\n        propertiesInfos.forEach((propB, k) => {\n          if (i === k) {\n            return;\n          } // Compare the properties order\n\n\n          const order = comparePropsOrder(propertiesInfos, propA, propB);\n\n          if (!order.correct) {\n            // Store an error if the order is incorrect\n            storeError({\n              node: properties[i],\n              index: order.indexA\n            }, {\n              node: properties[k],\n              index: order.indexB\n            });\n          }\n        });\n      });\n    }\n\n    return {\n      'Program:exit'() {\n        const list = components.list();\n        Object.keys(list).forEach(component => {\n          const properties = astUtil.getComponentProperties(list[component].node);\n          checkPropsOrder(properties);\n        });\n        reportErrors();\n      }\n\n    };\n  }),\n  defaultConfig\n};","map":{"version":3,"names":["has","require","entries","arrayIncludes","Components","astUtil","docsUrl","report","defaultConfig","order","groups","lifecycle","getMethodsOrder","userConfig","Object","assign","config","entry","i","j","length","concat","push","messages","unsortedProps","module","exports","meta","docs","description","category","recommended","url","schema","type","properties","items","patternProperties","additionalProperties","create","detect","context","components","errors","methodsOrder","options","regExpRegExp","getRefPropIndexes","method","methodGroupIndexes","forEach","currentGroup","groupIndex","getter","setter","typeAnnotation","staticVariable","staticMethod","instanceVariable","instanceMethod","name","isRegExp","match","isMatching","RegExp","test","everythingElseIndex","indexOf","Infinity","getPropertyName","node","kind","storeError","propA","propB","index","score","closest","distance","ref","Math","abs","dedupeErrors","reportErrors","nodeA","nodeB","indexA","indexB","data","position","comparePropsOrder","propertiesInfos","k","l","refIndexA","refIndexB","refIndexesA","refIndexesB","classIndexA","classIndexB","correct","checkPropsOrder","map","static","value","isFunctionLikeExpression","list","keys","component","getComponentProperties"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/sort-comp.js"],"sourcesContent":["/**\n * @fileoverview Enforce component methods order\n * @author Yannick Croissant\n */\n\n'use strict';\n\nconst has = require('object.hasown/polyfill')();\nconst entries = require('object.entries');\nconst arrayIncludes = require('array-includes');\n\nconst Components = require('../util/Components');\nconst astUtil = require('../util/ast');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\nconst defaultConfig = {\n  order: [\n    'static-methods',\n    'lifecycle',\n    'everything-else',\n    'render',\n  ],\n  groups: {\n    lifecycle: [\n      'displayName',\n      'propTypes',\n      'contextTypes',\n      'childContextTypes',\n      'mixins',\n      'statics',\n      'defaultProps',\n      'constructor',\n      'getDefaultProps',\n      'state',\n      'getInitialState',\n      'getChildContext',\n      'getDerivedStateFromProps',\n      'componentWillMount',\n      'UNSAFE_componentWillMount',\n      'componentDidMount',\n      'componentWillReceiveProps',\n      'UNSAFE_componentWillReceiveProps',\n      'shouldComponentUpdate',\n      'componentWillUpdate',\n      'UNSAFE_componentWillUpdate',\n      'getSnapshotBeforeUpdate',\n      'componentDidUpdate',\n      'componentDidCatch',\n      'componentWillUnmount',\n    ],\n  },\n};\n\n/**\n * Get the methods order from the default config and the user config\n * @param {Object} userConfig The user configuration.\n * @returns {Array} Methods order\n */\nfunction getMethodsOrder(userConfig) {\n  userConfig = userConfig || {};\n\n  const groups = Object.assign({}, defaultConfig.groups, userConfig.groups);\n  const order = userConfig.order || defaultConfig.order;\n\n  let config = [];\n  let entry;\n  for (let i = 0, j = order.length; i < j; i++) {\n    entry = order[i];\n    if (has(groups, entry)) {\n      config = config.concat(groups[entry]);\n    } else {\n      config.push(entry);\n    }\n  }\n\n  return config;\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  unsortedProps: '{{propA}} should be placed {{position}} {{propB}}',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce component methods order',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('sort-comp'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        order: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n        },\n        groups: {\n          type: 'object',\n          patternProperties: {\n            '^.*$': {\n              type: 'array',\n              items: {\n                type: 'string',\n              },\n            },\n          },\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components) => {\n    const errors = {};\n    const methodsOrder = getMethodsOrder(context.options[0]);\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    const regExpRegExp = /\\/(.*)\\/([gimsuy]*)/;\n\n    /**\n     * Get indexes of the matching patterns in methods order configuration\n     * @param {Object} method - Method metadata.\n     * @returns {Array} The matching patterns indexes. Return [Infinity] if there is no match.\n     */\n    function getRefPropIndexes(method) {\n      const methodGroupIndexes = [];\n\n      methodsOrder.forEach((currentGroup, groupIndex) => {\n        if (currentGroup === 'getters') {\n          if (method.getter) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'setters') {\n          if (method.setter) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'type-annotations') {\n          if (method.typeAnnotation) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'static-variables') {\n          if (method.staticVariable) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'static-methods') {\n          if (method.staticMethod) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'instance-variables') {\n          if (method.instanceVariable) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'instance-methods') {\n          if (method.instanceMethod) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (arrayIncludes([\n          'displayName',\n          'propTypes',\n          'contextTypes',\n          'childContextTypes',\n          'mixins',\n          'statics',\n          'defaultProps',\n          'constructor',\n          'getDefaultProps',\n          'state',\n          'getInitialState',\n          'getChildContext',\n          'getDerivedStateFromProps',\n          'componentWillMount',\n          'UNSAFE_componentWillMount',\n          'componentDidMount',\n          'componentWillReceiveProps',\n          'UNSAFE_componentWillReceiveProps',\n          'shouldComponentUpdate',\n          'componentWillUpdate',\n          'UNSAFE_componentWillUpdate',\n          'getSnapshotBeforeUpdate',\n          'componentDidUpdate',\n          'componentDidCatch',\n          'componentWillUnmount',\n          'render',\n        ], currentGroup)) {\n          if (currentGroup === method.name) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else {\n          // Is the group a regex?\n          const isRegExp = currentGroup.match(regExpRegExp);\n          if (isRegExp) {\n            const isMatching = new RegExp(isRegExp[1], isRegExp[2]).test(method.name);\n            if (isMatching) {\n              methodGroupIndexes.push(groupIndex);\n            }\n          } else if (currentGroup === method.name) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        }\n      });\n\n      // No matching pattern, return 'everything-else' index\n      if (methodGroupIndexes.length === 0) {\n        const everythingElseIndex = methodsOrder.indexOf('everything-else');\n\n        if (everythingElseIndex !== -1) {\n          methodGroupIndexes.push(everythingElseIndex);\n        } else {\n          // No matching pattern and no 'everything-else' group\n          methodGroupIndexes.push(Infinity);\n        }\n      }\n\n      return methodGroupIndexes;\n    }\n\n    /**\n     * Get properties name\n     * @param {Object} node - Property.\n     * @returns {String} Property name.\n     */\n    function getPropertyName(node) {\n      if (node.kind === 'get') {\n        return 'getter functions';\n      }\n\n      if (node.kind === 'set') {\n        return 'setter functions';\n      }\n\n      return astUtil.getPropertyName(node);\n    }\n\n    /**\n     * Store a new error in the error list\n     * @param {Object} propA - Mispositioned property.\n     * @param {Object} propB - Reference property.\n     */\n    function storeError(propA, propB) {\n      // Initialize the error object if needed\n      if (!errors[propA.index]) {\n        errors[propA.index] = {\n          node: propA.node,\n          score: 0,\n          closest: {\n            distance: Infinity,\n            ref: {\n              node: null,\n              index: 0,\n            },\n          },\n        };\n      }\n      // Increment the prop score\n      errors[propA.index].score += 1;\n      // Stop here if we already have pushed another node at this position\n      if (getPropertyName(errors[propA.index].node) !== getPropertyName(propA.node)) {\n        return;\n      }\n      // Stop here if we already have a closer reference\n      if (Math.abs(propA.index - propB.index) > errors[propA.index].closest.distance) {\n        return;\n      }\n      // Update the closest reference\n      errors[propA.index].closest.distance = Math.abs(propA.index - propB.index);\n      errors[propA.index].closest.ref.node = propB.node;\n      errors[propA.index].closest.ref.index = propB.index;\n    }\n\n    /**\n     * Dedupe errors, only keep the ones with the highest score and delete the others\n     */\n    function dedupeErrors() {\n      for (const i in errors) {\n        if (has(errors, i)) {\n          const index = errors[i].closest.ref.index;\n          if (errors[index]) {\n            if (errors[i].score > errors[index].score) {\n              delete errors[index];\n            } else {\n              delete errors[i];\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Report errors\n     */\n    function reportErrors() {\n      dedupeErrors();\n\n      entries(errors).forEach((entry) => {\n        const nodeA = entry[1].node;\n        const nodeB = entry[1].closest.ref.node;\n        const indexA = entry[0];\n        const indexB = entry[1].closest.ref.index;\n\n        report(context, messages.unsortedProps, 'unsortedProps', {\n          node: nodeA,\n          data: {\n            propA: getPropertyName(nodeA),\n            propB: getPropertyName(nodeB),\n            position: indexA < indexB ? 'before' : 'after',\n          },\n        });\n      });\n    }\n\n    /**\n     * Compare two properties and find out if they are in the right order\n     * @param {Array} propertiesInfos Array containing all the properties metadata.\n     * @param {Object} propA First property name and metadata\n     * @param {Object} propB Second property name.\n     * @returns {Object} Object containing a correct true/false flag and the correct indexes for the two properties.\n     */\n    function comparePropsOrder(propertiesInfos, propA, propB) {\n      let i;\n      let j;\n      let k;\n      let l;\n      let refIndexA;\n      let refIndexB;\n\n      // Get references indexes (the correct position) for given properties\n      const refIndexesA = getRefPropIndexes(propA);\n      const refIndexesB = getRefPropIndexes(propB);\n\n      // Get current indexes for given properties\n      const classIndexA = propertiesInfos.indexOf(propA);\n      const classIndexB = propertiesInfos.indexOf(propB);\n\n      // Loop around the references indexes for the 1st property\n      for (i = 0, j = refIndexesA.length; i < j; i++) {\n        refIndexA = refIndexesA[i];\n\n        // Loop around the properties for the 2nd property (for comparison)\n        for (k = 0, l = refIndexesB.length; k < l; k++) {\n          refIndexB = refIndexesB[k];\n\n          if (\n            // Comparing the same properties\n            refIndexA === refIndexB\n            // 1st property is placed before the 2nd one in reference and in current component\n            || ((refIndexA < refIndexB) && (classIndexA < classIndexB))\n            // 1st property is placed after the 2nd one in reference and in current component\n            || ((refIndexA > refIndexB) && (classIndexA > classIndexB))\n          ) {\n            return {\n              correct: true,\n              indexA: classIndexA,\n              indexB: classIndexB,\n            };\n          }\n        }\n      }\n\n      // We did not find any correct match between reference and current component\n      return {\n        correct: false,\n        indexA: refIndexA,\n        indexB: refIndexB,\n      };\n    }\n\n    /**\n     * Check properties order from a properties list and store the eventual errors\n     * @param {Array} properties Array containing all the properties.\n     */\n    function checkPropsOrder(properties) {\n      const propertiesInfos = properties.map((node) => ({\n        name: getPropertyName(node),\n        getter: node.kind === 'get',\n        setter: node.kind === 'set',\n        staticVariable: node.static\n          && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition')\n          && (!node.value || !astUtil.isFunctionLikeExpression(node.value)),\n        staticMethod: node.static\n          && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition' || node.type === 'MethodDefinition')\n          && node.value\n          && (astUtil.isFunctionLikeExpression(node.value)),\n        instanceVariable: !node.static\n          && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition')\n          && (!node.value || !astUtil.isFunctionLikeExpression(node.value)),\n        instanceMethod: !node.static\n          && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition')\n          && node.value\n          && (astUtil.isFunctionLikeExpression(node.value)),\n        typeAnnotation: !!node.typeAnnotation && node.value === null,\n      }));\n\n      // Loop around the properties\n      propertiesInfos.forEach((propA, i) => {\n        // Loop around the properties a second time (for comparison)\n        propertiesInfos.forEach((propB, k) => {\n          if (i === k) {\n            return;\n          }\n\n          // Compare the properties order\n          const order = comparePropsOrder(propertiesInfos, propA, propB);\n\n          if (!order.correct) {\n            // Store an error if the order is incorrect\n            storeError({\n              node: properties[i],\n              index: order.indexA,\n            }, {\n              node: properties[k],\n              index: order.indexB,\n            });\n          }\n        });\n      });\n    }\n\n    return {\n      'Program:exit'() {\n        const list = components.list();\n        Object.keys(list).forEach((component) => {\n          const properties = astUtil.getComponentProperties(list[component].node);\n          checkPropsOrder(properties);\n        });\n\n        reportErrors();\n      },\n    };\n  }),\n\n  defaultConfig,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}