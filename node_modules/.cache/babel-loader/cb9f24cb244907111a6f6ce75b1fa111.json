{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\nimport { make_node } from \"./utils/index.js\";\nimport { AST_Accessor, AST_Array, AST_Arrow, AST_Assign, AST_Atom, AST_Await, AST_BigInt, AST_Binary, AST_Block, AST_BlockStatement, AST_Boolean, AST_Break, AST_Call, AST_Case, AST_Catch, AST_Chain, AST_Class, AST_ClassStaticBlock, AST_ClassExpression, AST_ClassProperty, AST_ClassPrivateProperty, AST_ConciseMethod, AST_Conditional, AST_Const, AST_Constant, AST_Continue, AST_Debugger, AST_Default, AST_DefaultAssign, AST_DefClass, AST_Definitions, AST_Defun, AST_Destructuring, AST_Directive, AST_Do, AST_Dot, AST_DotHash, AST_EmptyStatement, AST_Expansion, AST_Export, AST_False, AST_Finally, AST_For, AST_ForIn, AST_ForOf, AST_Function, AST_Hole, AST_If, AST_Import, AST_ImportMeta, AST_Label, AST_LabeledStatement, AST_LabelRef, AST_Lambda, AST_Let, AST_NameMapping, AST_New, AST_NewTarget, AST_Node, AST_Null, AST_Number, AST_Object, AST_ObjectGetter, AST_ObjectKeyVal, AST_ObjectProperty, AST_ObjectSetter, AST_PrefixedTemplateString, AST_PrivateGetter, AST_PrivateMethod, AST_PrivateSetter, AST_PropAccess, AST_RegExp, AST_Return, AST_Sequence, AST_SimpleStatement, AST_Statement, AST_String, AST_Sub, AST_Super, AST_Switch, AST_SwitchBranch, AST_Symbol, AST_SymbolCatch, AST_SymbolClass, AST_SymbolClassProperty, AST_SymbolConst, AST_SymbolDefClass, AST_SymbolDefun, AST_SymbolExport, AST_SymbolExportForeign, AST_SymbolFunarg, AST_SymbolImport, AST_SymbolImportForeign, AST_SymbolLambda, AST_SymbolLet, AST_SymbolMethod, AST_SymbolRef, AST_SymbolVar, AST_TemplateSegment, AST_TemplateString, AST_This, AST_Throw, AST_Token, AST_Toplevel, AST_True, AST_Try, AST_Unary, AST_UnaryPostfix, AST_UnaryPrefix, AST_Var, AST_VarDef, AST_While, AST_With, AST_Yield } from \"./ast.js\";\nimport { is_basic_identifier_string } from \"./parse.js\";\n\n(function () {\n  var normalize_directives = function (body) {\n    var in_directive = true;\n\n    for (var i = 0; i < body.length; i++) {\n      if (in_directive && body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {\n        body[i] = new AST_Directive({\n          start: body[i].start,\n          end: body[i].end,\n          value: body[i].body.value\n        });\n      } else if (in_directive && !(body[i] instanceof AST_Statement && body[i].body instanceof AST_String)) {\n        in_directive = false;\n      }\n    }\n\n    return body;\n  };\n\n  const assert_clause_from_moz = assertions => {\n    if (assertions && assertions.length > 0) {\n      return new AST_Object({\n        start: my_start_token(assertions),\n        end: my_end_token(assertions),\n        properties: assertions.map(assertion_kv => new AST_ObjectKeyVal({\n          start: my_start_token(assertion_kv),\n          end: my_end_token(assertion_kv),\n          key: assertion_kv.key.name || assertion_kv.key.value,\n          value: from_moz(assertion_kv.value)\n        }))\n      });\n    }\n\n    return null;\n  };\n\n  var MOZ_TO_ME = {\n    Program: function (M) {\n      return new AST_Toplevel({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: normalize_directives(M.body.map(from_moz))\n      });\n    },\n    ArrayPattern: function (M) {\n      return new AST_Destructuring({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        names: M.elements.map(function (elm) {\n          if (elm === null) {\n            return new AST_Hole();\n          }\n\n          return from_moz(elm);\n        }),\n        is_array: true\n      });\n    },\n    ObjectPattern: function (M) {\n      return new AST_Destructuring({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        names: M.properties.map(from_moz),\n        is_array: false\n      });\n    },\n    AssignmentPattern: function (M) {\n      return new AST_DefaultAssign({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        left: from_moz(M.left),\n        operator: \"=\",\n        right: from_moz(M.right)\n      });\n    },\n    SpreadElement: function (M) {\n      return new AST_Expansion({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.argument)\n      });\n    },\n    RestElement: function (M) {\n      return new AST_Expansion({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.argument)\n      });\n    },\n    TemplateElement: function (M) {\n      return new AST_TemplateSegment({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        value: M.value.cooked,\n        raw: M.value.raw\n      });\n    },\n    TemplateLiteral: function (M) {\n      var segments = [];\n\n      for (var i = 0; i < M.quasis.length; i++) {\n        segments.push(from_moz(M.quasis[i]));\n\n        if (M.expressions[i]) {\n          segments.push(from_moz(M.expressions[i]));\n        }\n      }\n\n      return new AST_TemplateString({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        segments: segments\n      });\n    },\n    TaggedTemplateExpression: function (M) {\n      return new AST_PrefixedTemplateString({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        template_string: from_moz(M.quasi),\n        prefix: from_moz(M.tag)\n      });\n    },\n    FunctionDeclaration: function (M) {\n      return new AST_Defun({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: M.params.map(from_moz),\n        is_generator: M.generator,\n        async: M.async,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    FunctionExpression: function (M) {\n      return new AST_Function({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: M.params.map(from_moz),\n        is_generator: M.generator,\n        async: M.async,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    ArrowFunctionExpression: function (M) {\n      const body = M.body.type === \"BlockStatement\" ? from_moz(M.body).body : [make_node(AST_Return, {}, {\n        value: from_moz(M.body)\n      })];\n      return new AST_Arrow({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        argnames: M.params.map(from_moz),\n        body,\n        async: M.async\n      });\n    },\n    ExpressionStatement: function (M) {\n      return new AST_SimpleStatement({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.expression)\n      });\n    },\n    TryStatement: function (M) {\n      var handlers = M.handlers || [M.handler];\n\n      if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n        throw new Error(\"Multiple catch clauses are not supported.\");\n      }\n\n      return new AST_Try({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.block).body,\n        bcatch: from_moz(handlers[0]),\n        bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n      });\n    },\n    Property: function (M) {\n      var key = M.key;\n      var args = {\n        start: my_start_token(key || M.value),\n        end: my_end_token(M.value),\n        key: key.type == \"Identifier\" ? key.name : key.value,\n        value: from_moz(M.value)\n      };\n\n      if (M.computed) {\n        args.key = from_moz(M.key);\n      }\n\n      if (M.method) {\n        args.is_generator = M.value.generator;\n        args.async = M.value.async;\n\n        if (!M.computed) {\n          args.key = new AST_SymbolMethod({\n            name: args.key\n          });\n        } else {\n          args.key = from_moz(M.key);\n        }\n\n        return new AST_ConciseMethod(args);\n      }\n\n      if (M.kind == \"init\") {\n        if (key.type != \"Identifier\" && key.type != \"Literal\") {\n          args.key = from_moz(key);\n        }\n\n        return new AST_ObjectKeyVal(args);\n      }\n\n      if (typeof args.key === \"string\" || typeof args.key === \"number\") {\n        args.key = new AST_SymbolMethod({\n          name: args.key\n        });\n      }\n\n      args.value = new AST_Accessor(args.value);\n      if (M.kind == \"get\") return new AST_ObjectGetter(args);\n      if (M.kind == \"set\") return new AST_ObjectSetter(args);\n\n      if (M.kind == \"method\") {\n        args.async = M.value.async;\n        args.is_generator = M.value.generator;\n        args.quote = M.computed ? \"\\\"\" : null;\n        return new AST_ConciseMethod(args);\n      }\n    },\n    MethodDefinition: function (M) {\n      var args = {\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: M.computed ? from_moz(M.key) : new AST_SymbolMethod({\n          name: M.key.name || M.key.value\n        }),\n        value: from_moz(M.value),\n        static: M.static\n      };\n\n      if (M.kind == \"get\") {\n        return new AST_ObjectGetter(args);\n      }\n\n      if (M.kind == \"set\") {\n        return new AST_ObjectSetter(args);\n      }\n\n      args.is_generator = M.value.generator;\n      args.async = M.value.async;\n      return new AST_ConciseMethod(args);\n    },\n    FieldDefinition: function (M) {\n      let key;\n\n      if (M.computed) {\n        key = from_moz(M.key);\n      } else {\n        if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in FieldDefinition\");\n        key = from_moz(M.key);\n      }\n\n      return new AST_ClassProperty({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key,\n        value: from_moz(M.value),\n        static: M.static\n      });\n    },\n    PropertyDefinition: function (M) {\n      let key;\n\n      if (M.computed) {\n        key = from_moz(M.key);\n      } else {\n        if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in PropertyDefinition\");\n        key = from_moz(M.key);\n      }\n\n      return new AST_ClassProperty({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key,\n        value: from_moz(M.value),\n        static: M.static\n      });\n    },\n    StaticBlock: function (M) {\n      return new AST_ClassStaticBlock({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: M.body.map(from_moz)\n      });\n    },\n    ArrayExpression: function (M) {\n      return new AST_Array({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        elements: M.elements.map(function (elem) {\n          return elem === null ? new AST_Hole() : from_moz(elem);\n        })\n      });\n    },\n    ObjectExpression: function (M) {\n      return new AST_Object({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        properties: M.properties.map(function (prop) {\n          if (prop.type === \"SpreadElement\") {\n            return from_moz(prop);\n          }\n\n          prop.type = \"Property\";\n          return from_moz(prop);\n        })\n      });\n    },\n    SequenceExpression: function (M) {\n      return new AST_Sequence({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expressions: M.expressions.map(from_moz)\n      });\n    },\n    MemberExpression: function (M) {\n      return new (M.computed ? AST_Sub : AST_Dot)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        property: M.computed ? from_moz(M.property) : M.property.name,\n        expression: from_moz(M.object),\n        optional: M.optional || false\n      });\n    },\n    ChainExpression: function (M) {\n      return new AST_Chain({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.expression)\n      });\n    },\n    SwitchCase: function (M) {\n      return new (M.test ? AST_Case : AST_Default)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.test),\n        body: M.consequent.map(from_moz)\n      });\n    },\n    VariableDeclaration: function (M) {\n      return new (M.kind === \"const\" ? AST_Const : M.kind === \"let\" ? AST_Let : AST_Var)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        definitions: M.declarations.map(from_moz)\n      });\n    },\n    ImportDeclaration: function (M) {\n      var imported_name = null;\n      var imported_names = null;\n      M.specifiers.forEach(function (specifier) {\n        if (specifier.type === \"ImportSpecifier\") {\n          if (!imported_names) {\n            imported_names = [];\n          }\n\n          imported_names.push(new AST_NameMapping({\n            start: my_start_token(specifier),\n            end: my_end_token(specifier),\n            foreign_name: from_moz(specifier.imported),\n            name: from_moz(specifier.local)\n          }));\n        } else if (specifier.type === \"ImportDefaultSpecifier\") {\n          imported_name = from_moz(specifier.local);\n        } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n          if (!imported_names) {\n            imported_names = [];\n          }\n\n          imported_names.push(new AST_NameMapping({\n            start: my_start_token(specifier),\n            end: my_end_token(specifier),\n            foreign_name: new AST_SymbolImportForeign({\n              name: \"*\"\n            }),\n            name: from_moz(specifier.local)\n          }));\n        }\n      });\n      return new AST_Import({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        imported_name: imported_name,\n        imported_names: imported_names,\n        module_name: from_moz(M.source),\n        assert_clause: assert_clause_from_moz(M.assertions)\n      });\n    },\n    ExportAllDeclaration: function (M) {\n      return new AST_Export({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        exported_names: [new AST_NameMapping({\n          name: new AST_SymbolExportForeign({\n            name: \"*\"\n          }),\n          foreign_name: new AST_SymbolExportForeign({\n            name: \"*\"\n          })\n        })],\n        module_name: from_moz(M.source),\n        assert_clause: assert_clause_from_moz(M.assertions)\n      });\n    },\n    ExportNamedDeclaration: function (M) {\n      return new AST_Export({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        exported_definition: from_moz(M.declaration),\n        exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(function (specifier) {\n          return new AST_NameMapping({\n            foreign_name: from_moz(specifier.exported),\n            name: from_moz(specifier.local)\n          });\n        }) : null,\n        module_name: from_moz(M.source),\n        assert_clause: assert_clause_from_moz(M.assertions)\n      });\n    },\n    ExportDefaultDeclaration: function (M) {\n      return new AST_Export({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        exported_value: from_moz(M.declaration),\n        is_default: true\n      });\n    },\n    Literal: function (M) {\n      var val = M.value,\n          args = {\n        start: my_start_token(M),\n        end: my_end_token(M)\n      };\n      var rx = M.regex;\n\n      if (rx && rx.pattern) {\n        // RegExpLiteral as per ESTree AST spec\n        args.value = {\n          source: rx.pattern,\n          flags: rx.flags\n        };\n        return new AST_RegExp(args);\n      } else if (rx) {\n        // support legacy RegExp\n        const rx_source = M.raw || val;\n        const match = rx_source.match(/^\\/(.*)\\/(\\w*)$/);\n        if (!match) throw new Error(\"Invalid regex source \" + rx_source);\n        const [_, source, flags] = match;\n        args.value = {\n          source,\n          flags\n        };\n        return new AST_RegExp(args);\n      }\n\n      if (val === null) return new AST_Null(args);\n\n      switch (typeof val) {\n        case \"string\":\n          args.value = val;\n          return new AST_String(args);\n\n        case \"number\":\n          args.value = val;\n          args.raw = M.raw || val.toString();\n          return new AST_Number(args);\n\n        case \"boolean\":\n          return new (val ? AST_True : AST_False)(args);\n      }\n    },\n    MetaProperty: function (M) {\n      if (M.meta.name === \"new\" && M.property.name === \"target\") {\n        return new AST_NewTarget({\n          start: my_start_token(M),\n          end: my_end_token(M)\n        });\n      } else if (M.meta.name === \"import\" && M.property.name === \"meta\") {\n        return new AST_ImportMeta({\n          start: my_start_token(M),\n          end: my_end_token(M)\n        });\n      }\n    },\n    Identifier: function (M) {\n      var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];\n      return new (p.type == \"LabeledStatement\" ? AST_Label : p.type == \"VariableDeclarator\" && p.id === M ? p.kind == \"const\" ? AST_SymbolConst : p.kind == \"let\" ? AST_SymbolLet : AST_SymbolVar : /Import.*Specifier/.test(p.type) ? p.local === M ? AST_SymbolImport : AST_SymbolImportForeign : p.type == \"ExportSpecifier\" ? p.local === M ? AST_SymbolExport : AST_SymbolExportForeign : p.type == \"FunctionExpression\" ? p.id === M ? AST_SymbolLambda : AST_SymbolFunarg : p.type == \"FunctionDeclaration\" ? p.id === M ? AST_SymbolDefun : AST_SymbolFunarg : p.type == \"ArrowFunctionExpression\" ? p.params.includes(M) ? AST_SymbolFunarg : AST_SymbolRef : p.type == \"ClassExpression\" ? p.id === M ? AST_SymbolClass : AST_SymbolRef : p.type == \"Property\" ? p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolMethod : p.type == \"PropertyDefinition\" || p.type === \"FieldDefinition\" ? p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolClassProperty : p.type == \"ClassDeclaration\" ? p.id === M ? AST_SymbolDefClass : AST_SymbolRef : p.type == \"MethodDefinition\" ? p.computed ? AST_SymbolRef : AST_SymbolMethod : p.type == \"CatchClause\" ? AST_SymbolCatch : p.type == \"BreakStatement\" || p.type == \"ContinueStatement\" ? AST_LabelRef : AST_SymbolRef)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: M.name\n      });\n    },\n\n    BigIntLiteral(M) {\n      return new AST_BigInt({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        value: M.value\n      });\n    },\n\n    EmptyStatement: function (M) {\n      return new AST_EmptyStatement({\n        start: my_start_token(M),\n        end: my_end_token(M)\n      });\n    },\n    BlockStatement: function (M) {\n      return new AST_BlockStatement({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: M.body.map(from_moz)\n      });\n    },\n    IfStatement: function (M) {\n      return new AST_If({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        condition: from_moz(M.test),\n        body: from_moz(M.consequent),\n        alternative: from_moz(M.alternate)\n      });\n    },\n    LabeledStatement: function (M) {\n      return new AST_LabeledStatement({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        label: from_moz(M.label),\n        body: from_moz(M.body)\n      });\n    },\n    BreakStatement: function (M) {\n      return new AST_Break({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        label: from_moz(M.label)\n      });\n    },\n    ContinueStatement: function (M) {\n      return new AST_Continue({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        label: from_moz(M.label)\n      });\n    },\n    WithStatement: function (M) {\n      return new AST_With({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.object),\n        body: from_moz(M.body)\n      });\n    },\n    SwitchStatement: function (M) {\n      return new AST_Switch({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.discriminant),\n        body: M.cases.map(from_moz)\n      });\n    },\n    ReturnStatement: function (M) {\n      return new AST_Return({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        value: from_moz(M.argument)\n      });\n    },\n    ThrowStatement: function (M) {\n      return new AST_Throw({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        value: from_moz(M.argument)\n      });\n    },\n    WhileStatement: function (M) {\n      return new AST_While({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        condition: from_moz(M.test),\n        body: from_moz(M.body)\n      });\n    },\n    DoWhileStatement: function (M) {\n      return new AST_Do({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        condition: from_moz(M.test),\n        body: from_moz(M.body)\n      });\n    },\n    ForStatement: function (M) {\n      return new AST_For({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        init: from_moz(M.init),\n        condition: from_moz(M.test),\n        step: from_moz(M.update),\n        body: from_moz(M.body)\n      });\n    },\n    ForInStatement: function (M) {\n      return new AST_ForIn({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        init: from_moz(M.left),\n        object: from_moz(M.right),\n        body: from_moz(M.body)\n      });\n    },\n    ForOfStatement: function (M) {\n      return new AST_ForOf({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        init: from_moz(M.left),\n        object: from_moz(M.right),\n        body: from_moz(M.body),\n        await: M.await\n      });\n    },\n    AwaitExpression: function (M) {\n      return new AST_Await({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.argument)\n      });\n    },\n    YieldExpression: function (M) {\n      return new AST_Yield({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.argument),\n        is_star: M.delegate\n      });\n    },\n    DebuggerStatement: function (M) {\n      return new AST_Debugger({\n        start: my_start_token(M),\n        end: my_end_token(M)\n      });\n    },\n    VariableDeclarator: function (M) {\n      return new AST_VarDef({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        value: from_moz(M.init)\n      });\n    },\n    CatchClause: function (M) {\n      return new AST_Catch({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        argname: from_moz(M.param),\n        body: from_moz(M.body).body\n      });\n    },\n    ThisExpression: function (M) {\n      return new AST_This({\n        start: my_start_token(M),\n        end: my_end_token(M)\n      });\n    },\n    Super: function (M) {\n      return new AST_Super({\n        start: my_start_token(M),\n        end: my_end_token(M)\n      });\n    },\n    BinaryExpression: function (M) {\n      return new AST_Binary({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        operator: M.operator,\n        left: from_moz(M.left),\n        right: from_moz(M.right)\n      });\n    },\n    LogicalExpression: function (M) {\n      return new AST_Binary({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        operator: M.operator,\n        left: from_moz(M.left),\n        right: from_moz(M.right)\n      });\n    },\n    AssignmentExpression: function (M) {\n      return new AST_Assign({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        operator: M.operator,\n        left: from_moz(M.left),\n        right: from_moz(M.right)\n      });\n    },\n    ConditionalExpression: function (M) {\n      return new AST_Conditional({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        condition: from_moz(M.test),\n        consequent: from_moz(M.consequent),\n        alternative: from_moz(M.alternate)\n      });\n    },\n    NewExpression: function (M) {\n      return new AST_New({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.callee),\n        args: M.arguments.map(from_moz)\n      });\n    },\n    CallExpression: function (M) {\n      return new AST_Call({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.callee),\n        optional: M.optional,\n        args: M.arguments.map(from_moz)\n      });\n    }\n  };\n\n  MOZ_TO_ME.UpdateExpression = MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n    var prefix = \"prefix\" in M ? M.prefix : M.type == \"UnaryExpression\" ? true : false;\n    return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n      start: my_start_token(M),\n      end: my_end_token(M),\n      operator: M.operator,\n      expression: from_moz(M.argument)\n    });\n  };\n\n  MOZ_TO_ME.ClassDeclaration = MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {\n    return new (M.type === \"ClassDeclaration\" ? AST_DefClass : AST_ClassExpression)({\n      start: my_start_token(M),\n      end: my_end_token(M),\n      name: from_moz(M.id),\n      extends: from_moz(M.superClass),\n      properties: M.body.body.map(from_moz)\n    });\n  };\n\n  def_to_moz(AST_EmptyStatement, function To_Moz_EmptyStatement() {\n    return {\n      type: \"EmptyStatement\"\n    };\n  });\n  def_to_moz(AST_BlockStatement, function To_Moz_BlockStatement(M) {\n    return {\n      type: \"BlockStatement\",\n      body: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_If, function To_Moz_IfStatement(M) {\n    return {\n      type: \"IfStatement\",\n      test: to_moz(M.condition),\n      consequent: to_moz(M.body),\n      alternate: to_moz(M.alternative)\n    };\n  });\n  def_to_moz(AST_LabeledStatement, function To_Moz_LabeledStatement(M) {\n    return {\n      type: \"LabeledStatement\",\n      label: to_moz(M.label),\n      body: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_Break, function To_Moz_BreakStatement(M) {\n    return {\n      type: \"BreakStatement\",\n      label: to_moz(M.label)\n    };\n  });\n  def_to_moz(AST_Continue, function To_Moz_ContinueStatement(M) {\n    return {\n      type: \"ContinueStatement\",\n      label: to_moz(M.label)\n    };\n  });\n  def_to_moz(AST_With, function To_Moz_WithStatement(M) {\n    return {\n      type: \"WithStatement\",\n      object: to_moz(M.expression),\n      body: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_Switch, function To_Moz_SwitchStatement(M) {\n    return {\n      type: \"SwitchStatement\",\n      discriminant: to_moz(M.expression),\n      cases: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Return, function To_Moz_ReturnStatement(M) {\n    return {\n      type: \"ReturnStatement\",\n      argument: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_Throw, function To_Moz_ThrowStatement(M) {\n    return {\n      type: \"ThrowStatement\",\n      argument: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_While, function To_Moz_WhileStatement(M) {\n    return {\n      type: \"WhileStatement\",\n      test: to_moz(M.condition),\n      body: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_Do, function To_Moz_DoWhileStatement(M) {\n    return {\n      type: \"DoWhileStatement\",\n      test: to_moz(M.condition),\n      body: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_For, function To_Moz_ForStatement(M) {\n    return {\n      type: \"ForStatement\",\n      init: to_moz(M.init),\n      test: to_moz(M.condition),\n      update: to_moz(M.step),\n      body: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_ForIn, function To_Moz_ForInStatement(M) {\n    return {\n      type: \"ForInStatement\",\n      left: to_moz(M.init),\n      right: to_moz(M.object),\n      body: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_ForOf, function To_Moz_ForOfStatement(M) {\n    return {\n      type: \"ForOfStatement\",\n      left: to_moz(M.init),\n      right: to_moz(M.object),\n      body: to_moz(M.body),\n      await: M.await\n    };\n  });\n  def_to_moz(AST_Await, function To_Moz_AwaitExpression(M) {\n    return {\n      type: \"AwaitExpression\",\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Yield, function To_Moz_YieldExpression(M) {\n    return {\n      type: \"YieldExpression\",\n      argument: to_moz(M.expression),\n      delegate: M.is_star\n    };\n  });\n  def_to_moz(AST_Debugger, function To_Moz_DebuggerStatement() {\n    return {\n      type: \"DebuggerStatement\"\n    };\n  });\n  def_to_moz(AST_VarDef, function To_Moz_VariableDeclarator(M) {\n    return {\n      type: \"VariableDeclarator\",\n      id: to_moz(M.name),\n      init: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n    return {\n      type: \"CatchClause\",\n      param: to_moz(M.argname),\n      body: to_moz_block(M)\n    };\n  });\n  def_to_moz(AST_This, function To_Moz_ThisExpression() {\n    return {\n      type: \"ThisExpression\"\n    };\n  });\n  def_to_moz(AST_Super, function To_Moz_Super() {\n    return {\n      type: \"Super\"\n    };\n  });\n  def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n    return {\n      type: \"BinaryExpression\",\n      operator: M.operator,\n      left: to_moz(M.left),\n      right: to_moz(M.right)\n    };\n  });\n  def_to_moz(AST_Binary, function To_Moz_LogicalExpression(M) {\n    return {\n      type: \"LogicalExpression\",\n      operator: M.operator,\n      left: to_moz(M.left),\n      right: to_moz(M.right)\n    };\n  });\n  def_to_moz(AST_Assign, function To_Moz_AssignmentExpression(M) {\n    return {\n      type: \"AssignmentExpression\",\n      operator: M.operator,\n      left: to_moz(M.left),\n      right: to_moz(M.right)\n    };\n  });\n  def_to_moz(AST_Conditional, function To_Moz_ConditionalExpression(M) {\n    return {\n      type: \"ConditionalExpression\",\n      test: to_moz(M.condition),\n      consequent: to_moz(M.consequent),\n      alternate: to_moz(M.alternative)\n    };\n  });\n  def_to_moz(AST_New, function To_Moz_NewExpression(M) {\n    return {\n      type: \"NewExpression\",\n      callee: to_moz(M.expression),\n      arguments: M.args.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Call, function To_Moz_CallExpression(M) {\n    return {\n      type: \"CallExpression\",\n      callee: to_moz(M.expression),\n      optional: M.optional,\n      arguments: M.args.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n    return to_moz_scope(\"Program\", M);\n  });\n  def_to_moz(AST_Expansion, function To_Moz_Spread(M) {\n    return {\n      type: to_moz_in_destructuring() ? \"RestElement\" : \"SpreadElement\",\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {\n    return {\n      type: \"TaggedTemplateExpression\",\n      tag: to_moz(M.prefix),\n      quasi: to_moz(M.template_string)\n    };\n  });\n  def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {\n    var quasis = [];\n    var expressions = [];\n\n    for (var i = 0; i < M.segments.length; i++) {\n      if (i % 2 !== 0) {\n        expressions.push(to_moz(M.segments[i]));\n      } else {\n        quasis.push({\n          type: \"TemplateElement\",\n          value: {\n            raw: M.segments[i].raw,\n            cooked: M.segments[i].value\n          },\n          tail: i === M.segments.length - 1\n        });\n      }\n    }\n\n    return {\n      type: \"TemplateLiteral\",\n      quasis: quasis,\n      expressions: expressions\n    };\n  });\n  def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {\n    return {\n      type: \"FunctionDeclaration\",\n      id: to_moz(M.name),\n      params: M.argnames.map(to_moz),\n      generator: M.is_generator,\n      async: M.async,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_Function, function To_Moz_FunctionExpression(M, parent) {\n    var is_generator = parent.is_generator !== undefined ? parent.is_generator : M.is_generator;\n    return {\n      type: \"FunctionExpression\",\n      id: to_moz(M.name),\n      params: M.argnames.map(to_moz),\n      generator: is_generator,\n      async: M.async,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {\n    var body = {\n      type: \"BlockStatement\",\n      body: M.body.map(to_moz)\n    };\n    return {\n      type: \"ArrowFunctionExpression\",\n      params: M.argnames.map(to_moz),\n      async: M.async,\n      body: body\n    };\n  });\n  def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {\n    if (M.is_array) {\n      return {\n        type: \"ArrayPattern\",\n        elements: M.names.map(to_moz)\n      };\n    }\n\n    return {\n      type: \"ObjectPattern\",\n      properties: M.names.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n    return {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: M.value,\n        raw: M.print_to_string()\n      },\n      directive: M.value\n    };\n  });\n  def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {\n    return {\n      type: \"ExpressionStatement\",\n      expression: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n    return {\n      type: \"SwitchCase\",\n      test: to_moz(M.expression),\n      consequent: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n    return {\n      type: \"TryStatement\",\n      block: to_moz_block(M),\n      handler: to_moz(M.bcatch),\n      guardedHandlers: [],\n      finalizer: to_moz(M.bfinally)\n    };\n  });\n  def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n    return {\n      type: \"CatchClause\",\n      param: to_moz(M.argname),\n      guard: null,\n      body: to_moz_block(M)\n    };\n  });\n  def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n    return {\n      type: \"VariableDeclaration\",\n      kind: M instanceof AST_Const ? \"const\" : M instanceof AST_Let ? \"let\" : \"var\",\n      declarations: M.definitions.map(to_moz)\n    };\n  });\n\n  const assert_clause_to_moz = assert_clause => {\n    const assertions = [];\n\n    if (assert_clause) {\n      for (const {\n        key,\n        value\n      } of assert_clause.properties) {\n        const key_moz = is_basic_identifier_string(key) ? {\n          type: \"Identifier\",\n          name: key\n        } : {\n          type: \"Literal\",\n          value: key,\n          raw: JSON.stringify(key)\n        };\n        assertions.push({\n          type: \"ImportAttribute\",\n          key: key_moz,\n          value: to_moz(value)\n        });\n      }\n    }\n\n    return assertions;\n  };\n\n  def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {\n    if (M.exported_names) {\n      if (M.exported_names[0].name.name === \"*\") {\n        return {\n          type: \"ExportAllDeclaration\",\n          source: to_moz(M.module_name),\n          assertions: assert_clause_to_moz(M.assert_clause)\n        };\n      }\n\n      return {\n        type: \"ExportNamedDeclaration\",\n        specifiers: M.exported_names.map(function (name_mapping) {\n          return {\n            type: \"ExportSpecifier\",\n            exported: to_moz(name_mapping.foreign_name),\n            local: to_moz(name_mapping.name)\n          };\n        }),\n        declaration: to_moz(M.exported_definition),\n        source: to_moz(M.module_name),\n        assertions: assert_clause_to_moz(M.assert_clause)\n      };\n    }\n\n    return {\n      type: M.is_default ? \"ExportDefaultDeclaration\" : \"ExportNamedDeclaration\",\n      declaration: to_moz(M.exported_value || M.exported_definition)\n    };\n  });\n  def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n    var specifiers = [];\n\n    if (M.imported_name) {\n      specifiers.push({\n        type: \"ImportDefaultSpecifier\",\n        local: to_moz(M.imported_name)\n      });\n    }\n\n    if (M.imported_names && M.imported_names[0].foreign_name.name === \"*\") {\n      specifiers.push({\n        type: \"ImportNamespaceSpecifier\",\n        local: to_moz(M.imported_names[0].name)\n      });\n    } else if (M.imported_names) {\n      M.imported_names.forEach(function (name_mapping) {\n        specifiers.push({\n          type: \"ImportSpecifier\",\n          local: to_moz(name_mapping.name),\n          imported: to_moz(name_mapping.foreign_name)\n        });\n      });\n    }\n\n    return {\n      type: \"ImportDeclaration\",\n      specifiers: specifiers,\n      source: to_moz(M.module_name),\n      assertions: assert_clause_to_moz(M.assert_clause)\n    };\n  });\n  def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {\n    return {\n      type: \"MetaProperty\",\n      meta: {\n        type: \"Identifier\",\n        name: \"import\"\n      },\n      property: {\n        type: \"Identifier\",\n        name: \"meta\"\n      }\n    };\n  });\n  def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {\n    return {\n      type: \"SequenceExpression\",\n      expressions: M.expressions.map(to_moz)\n    };\n  });\n  def_to_moz(AST_DotHash, function To_Moz_PrivateMemberExpression(M) {\n    return {\n      type: \"MemberExpression\",\n      object: to_moz(M.expression),\n      computed: false,\n      property: {\n        type: \"PrivateIdentifier\",\n        name: M.property\n      },\n      optional: M.optional\n    };\n  });\n  def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n    var isComputed = M instanceof AST_Sub;\n    return {\n      type: \"MemberExpression\",\n      object: to_moz(M.expression),\n      computed: isComputed,\n      property: isComputed ? to_moz(M.property) : {\n        type: \"Identifier\",\n        name: M.property\n      },\n      optional: M.optional\n    };\n  });\n  def_to_moz(AST_Chain, function To_Moz_ChainExpression(M) {\n    return {\n      type: \"ChainExpression\",\n      expression: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n    return {\n      type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n      operator: M.operator,\n      prefix: M instanceof AST_UnaryPrefix,\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n    if (M.operator == \"=\" && to_moz_in_destructuring()) {\n      return {\n        type: \"AssignmentPattern\",\n        left: to_moz(M.left),\n        right: to_moz(M.right)\n      };\n    }\n\n    const type = M.operator == \"&&\" || M.operator == \"||\" || M.operator === \"??\" ? \"LogicalExpression\" : \"BinaryExpression\";\n    return {\n      type,\n      left: to_moz(M.left),\n      operator: M.operator,\n      right: to_moz(M.right)\n    };\n  });\n  def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n    return {\n      type: \"ArrayExpression\",\n      elements: M.elements.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {\n    return {\n      type: \"ObjectExpression\",\n      properties: M.properties.map(to_moz)\n    };\n  });\n  def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {\n    var key = M.key instanceof AST_Node ? to_moz(M.key) : {\n      type: \"Identifier\",\n      value: M.key\n    };\n\n    if (typeof M.key === \"number\") {\n      key = {\n        type: \"Literal\",\n        value: Number(M.key)\n      };\n    }\n\n    if (typeof M.key === \"string\") {\n      key = {\n        type: \"Identifier\",\n        name: M.key\n      };\n    }\n\n    var kind;\n    var string_or_num = typeof M.key === \"string\" || typeof M.key === \"number\";\n    var computed = string_or_num ? false : !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef;\n\n    if (M instanceof AST_ObjectKeyVal) {\n      kind = \"init\";\n      computed = !string_or_num;\n    } else if (M instanceof AST_ObjectGetter) {\n      kind = \"get\";\n    } else if (M instanceof AST_ObjectSetter) {\n      kind = \"set\";\n    }\n\n    if (M instanceof AST_PrivateGetter || M instanceof AST_PrivateSetter) {\n      const kind = M instanceof AST_PrivateGetter ? \"get\" : \"set\";\n      return {\n        type: \"MethodDefinition\",\n        computed: false,\n        kind: kind,\n        static: M.static,\n        key: {\n          type: \"PrivateIdentifier\",\n          name: M.key.name\n        },\n        value: to_moz(M.value)\n      };\n    }\n\n    if (M instanceof AST_ClassPrivateProperty) {\n      return {\n        type: \"PropertyDefinition\",\n        key: {\n          type: \"PrivateIdentifier\",\n          name: M.key.name\n        },\n        value: to_moz(M.value),\n        computed: false,\n        static: M.static\n      };\n    }\n\n    if (M instanceof AST_ClassProperty) {\n      return {\n        type: \"PropertyDefinition\",\n        key,\n        value: to_moz(M.value),\n        computed,\n        static: M.static\n      };\n    }\n\n    if (parent instanceof AST_Class) {\n      return {\n        type: \"MethodDefinition\",\n        computed: computed,\n        kind: kind,\n        static: M.static,\n        key: to_moz(M.key),\n        value: to_moz(M.value)\n      };\n    }\n\n    return {\n      type: \"Property\",\n      computed: computed,\n      kind: kind,\n      key: key,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {\n    if (parent instanceof AST_Object) {\n      return {\n        type: \"Property\",\n        computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n        kind: \"init\",\n        method: true,\n        shorthand: false,\n        key: to_moz(M.key),\n        value: to_moz(M.value)\n      };\n    }\n\n    const key = M instanceof AST_PrivateMethod ? {\n      type: \"PrivateIdentifier\",\n      name: M.key.name\n    } : to_moz(M.key);\n    return {\n      type: \"MethodDefinition\",\n      kind: M.key === \"constructor\" ? \"constructor\" : \"method\",\n      key,\n      value: to_moz(M.value),\n      computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n      static: M.static\n    };\n  });\n  def_to_moz(AST_Class, function To_Moz_Class(M) {\n    var type = M instanceof AST_ClassExpression ? \"ClassExpression\" : \"ClassDeclaration\";\n    return {\n      type: type,\n      superClass: to_moz(M.extends),\n      id: M.name ? to_moz(M.name) : null,\n      body: {\n        type: \"ClassBody\",\n        body: M.properties.map(to_moz)\n      }\n    };\n  });\n  def_to_moz(AST_ClassStaticBlock, function To_Moz_StaticBlock(M) {\n    return {\n      type: \"StaticBlock\",\n      body: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n    return {\n      type: \"MetaProperty\",\n      meta: {\n        type: \"Identifier\",\n        name: \"new\"\n      },\n      property: {\n        type: \"Identifier\",\n        name: \"target\"\n      }\n    };\n  });\n  def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {\n    if (M instanceof AST_SymbolMethod && parent.quote) {\n      return {\n        type: \"Literal\",\n        value: M.name\n      };\n    }\n\n    var def = M.definition();\n    return {\n      type: \"Identifier\",\n      name: def ? def.mangled_name || def.name : M.name\n    };\n  });\n  def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n    const pattern = M.value.source;\n    const flags = M.value.flags;\n    return {\n      type: \"Literal\",\n      value: null,\n      raw: M.print_to_string(),\n      regex: {\n        pattern,\n        flags\n      }\n    };\n  });\n  def_to_moz(AST_Constant, function To_Moz_Literal(M) {\n    var value = M.value;\n    return {\n      type: \"Literal\",\n      value: value,\n      raw: M.raw || M.print_to_string()\n    };\n  });\n  def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n    return {\n      type: \"Identifier\",\n      name: String(M.value)\n    };\n  });\n  def_to_moz(AST_BigInt, M => ({\n    type: \"BigIntLiteral\",\n    value: M.value\n  }));\n  AST_Boolean.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n  AST_Null.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n  AST_Hole.DEFMETHOD(\"to_mozilla_ast\", function To_Moz_ArrayHole() {\n    return null;\n  });\n  AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n  AST_Lambda.DEFMETHOD(\"to_mozilla_ast\", AST_Function.prototype.to_mozilla_ast);\n  /* -----[ tools ]----- */\n\n  function my_start_token(moznode) {\n    var loc = moznode.loc,\n        start = loc && loc.start;\n    var range = moznode.range;\n    return new AST_Token(\"\", \"\", start && start.line || 0, start && start.column || 0, range ? range[0] : moznode.start, false, [], [], loc && loc.source);\n  }\n\n  function my_end_token(moznode) {\n    var loc = moznode.loc,\n        end = loc && loc.end;\n    var range = moznode.range;\n    return new AST_Token(\"\", \"\", end && end.line || 0, end && end.column || 0, range ? range[0] : moznode.end, false, [], [], loc && loc.source);\n  }\n\n  var FROM_MOZ_STACK = null;\n\n  function from_moz(node) {\n    FROM_MOZ_STACK.push(node);\n    var ret = node != null ? MOZ_TO_ME[node.type](node) : null;\n    FROM_MOZ_STACK.pop();\n    return ret;\n  }\n\n  AST_Node.from_mozilla_ast = function (node) {\n    var save_stack = FROM_MOZ_STACK;\n    FROM_MOZ_STACK = [];\n    var ast = from_moz(node);\n    FROM_MOZ_STACK = save_stack;\n    return ast;\n  };\n\n  function set_moz_loc(mynode, moznode) {\n    var start = mynode.start;\n    var end = mynode.end;\n\n    if (!(start && end)) {\n      return moznode;\n    }\n\n    if (start.pos != null && end.endpos != null) {\n      moznode.range = [start.pos, end.endpos];\n    }\n\n    if (start.line) {\n      moznode.loc = {\n        start: {\n          line: start.line,\n          column: start.col\n        },\n        end: end.endline ? {\n          line: end.endline,\n          column: end.endcol\n        } : null\n      };\n\n      if (start.file) {\n        moznode.loc.source = start.file;\n      }\n    }\n\n    return moznode;\n  }\n\n  function def_to_moz(mytype, handler) {\n    mytype.DEFMETHOD(\"to_mozilla_ast\", function (parent) {\n      return set_moz_loc(this, handler(this, parent));\n    });\n  }\n\n  var TO_MOZ_STACK = null;\n\n  function to_moz(node) {\n    if (TO_MOZ_STACK === null) {\n      TO_MOZ_STACK = [];\n    }\n\n    TO_MOZ_STACK.push(node);\n    var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;\n    TO_MOZ_STACK.pop();\n\n    if (TO_MOZ_STACK.length === 0) {\n      TO_MOZ_STACK = null;\n    }\n\n    return ast;\n  }\n\n  function to_moz_in_destructuring() {\n    var i = TO_MOZ_STACK.length;\n\n    while (i--) {\n      if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function to_moz_block(node) {\n    return {\n      type: \"BlockStatement\",\n      body: node.body.map(to_moz)\n    };\n  }\n\n  function to_moz_scope(type, node) {\n    var body = node.body.map(to_moz);\n\n    if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n      body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n    }\n\n    return {\n      type: type,\n      body: body\n    };\n  }\n})();","map":{"version":3,"names":["make_node","AST_Accessor","AST_Array","AST_Arrow","AST_Assign","AST_Atom","AST_Await","AST_BigInt","AST_Binary","AST_Block","AST_BlockStatement","AST_Boolean","AST_Break","AST_Call","AST_Case","AST_Catch","AST_Chain","AST_Class","AST_ClassStaticBlock","AST_ClassExpression","AST_ClassProperty","AST_ClassPrivateProperty","AST_ConciseMethod","AST_Conditional","AST_Const","AST_Constant","AST_Continue","AST_Debugger","AST_Default","AST_DefaultAssign","AST_DefClass","AST_Definitions","AST_Defun","AST_Destructuring","AST_Directive","AST_Do","AST_Dot","AST_DotHash","AST_EmptyStatement","AST_Expansion","AST_Export","AST_False","AST_Finally","AST_For","AST_ForIn","AST_ForOf","AST_Function","AST_Hole","AST_If","AST_Import","AST_ImportMeta","AST_Label","AST_LabeledStatement","AST_LabelRef","AST_Lambda","AST_Let","AST_NameMapping","AST_New","AST_NewTarget","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectProperty","AST_ObjectSetter","AST_PrefixedTemplateString","AST_PrivateGetter","AST_PrivateMethod","AST_PrivateSetter","AST_PropAccess","AST_RegExp","AST_Return","AST_Sequence","AST_SimpleStatement","AST_Statement","AST_String","AST_Sub","AST_Super","AST_Switch","AST_SwitchBranch","AST_Symbol","AST_SymbolCatch","AST_SymbolClass","AST_SymbolClassProperty","AST_SymbolConst","AST_SymbolDefClass","AST_SymbolDefun","AST_SymbolExport","AST_SymbolExportForeign","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolImportForeign","AST_SymbolLambda","AST_SymbolLet","AST_SymbolMethod","AST_SymbolRef","AST_SymbolVar","AST_TemplateSegment","AST_TemplateString","AST_This","AST_Throw","AST_Token","AST_Toplevel","AST_True","AST_Try","AST_Unary","AST_UnaryPostfix","AST_UnaryPrefix","AST_Var","AST_VarDef","AST_While","AST_With","AST_Yield","is_basic_identifier_string","normalize_directives","body","in_directive","i","length","start","end","value","assert_clause_from_moz","assertions","my_start_token","my_end_token","properties","map","assertion_kv","key","name","from_moz","MOZ_TO_ME","Program","M","ArrayPattern","names","elements","elm","is_array","ObjectPattern","AssignmentPattern","left","operator","right","SpreadElement","expression","argument","RestElement","TemplateElement","cooked","raw","TemplateLiteral","segments","quasis","push","expressions","TaggedTemplateExpression","template_string","quasi","prefix","tag","FunctionDeclaration","id","argnames","params","is_generator","generator","async","FunctionExpression","ArrowFunctionExpression","type","ExpressionStatement","TryStatement","handlers","handler","guardedHandlers","Error","block","bcatch","bfinally","finalizer","Property","args","computed","method","kind","quote","MethodDefinition","static","FieldDefinition","PropertyDefinition","StaticBlock","ArrayExpression","elem","ObjectExpression","prop","SequenceExpression","MemberExpression","property","object","optional","ChainExpression","SwitchCase","test","consequent","VariableDeclaration","definitions","declarations","ImportDeclaration","imported_name","imported_names","specifiers","forEach","specifier","foreign_name","imported","local","module_name","source","assert_clause","ExportAllDeclaration","exported_names","ExportNamedDeclaration","exported_definition","declaration","exported","ExportDefaultDeclaration","exported_value","is_default","Literal","val","rx","regex","pattern","flags","rx_source","match","_","toString","MetaProperty","meta","Identifier","p","FROM_MOZ_STACK","includes","BigIntLiteral","EmptyStatement","BlockStatement","IfStatement","condition","alternative","alternate","LabeledStatement","label","BreakStatement","ContinueStatement","WithStatement","SwitchStatement","discriminant","cases","ReturnStatement","ThrowStatement","WhileStatement","DoWhileStatement","ForStatement","init","step","update","ForInStatement","ForOfStatement","await","AwaitExpression","YieldExpression","is_star","delegate","DebuggerStatement","VariableDeclarator","CatchClause","argname","param","ThisExpression","Super","BinaryExpression","LogicalExpression","AssignmentExpression","ConditionalExpression","NewExpression","callee","arguments","CallExpression","UpdateExpression","UnaryExpression","To_Moz_Unary","ClassDeclaration","ClassExpression","From_Moz_Class","extends","superClass","def_to_moz","To_Moz_EmptyStatement","To_Moz_BlockStatement","to_moz","To_Moz_IfStatement","To_Moz_LabeledStatement","To_Moz_BreakStatement","To_Moz_ContinueStatement","To_Moz_WithStatement","To_Moz_SwitchStatement","To_Moz_ReturnStatement","To_Moz_ThrowStatement","To_Moz_WhileStatement","To_Moz_DoWhileStatement","To_Moz_ForStatement","To_Moz_ForInStatement","To_Moz_ForOfStatement","To_Moz_AwaitExpression","To_Moz_YieldExpression","To_Moz_DebuggerStatement","To_Moz_VariableDeclarator","To_Moz_CatchClause","to_moz_block","To_Moz_ThisExpression","To_Moz_Super","To_Moz_BinaryExpression","To_Moz_LogicalExpression","To_Moz_AssignmentExpression","To_Moz_ConditionalExpression","To_Moz_NewExpression","To_Moz_CallExpression","To_Moz_Program","to_moz_scope","To_Moz_Spread","to_moz_in_destructuring","To_Moz_TaggedTemplateExpression","To_Moz_TemplateLiteral","tail","To_Moz_FunctionDeclaration","To_Moz_FunctionExpression","parent","undefined","To_Moz_ArrowFunctionExpression","To_Moz_ObjectPattern","To_Moz_Directive","print_to_string","directive","To_Moz_ExpressionStatement","To_Moz_SwitchCase","To_Moz_TryStatement","guard","To_Moz_VariableDeclaration","assert_clause_to_moz","key_moz","JSON","stringify","To_Moz_ExportDeclaration","name_mapping","To_Moz_ImportDeclaration","To_Moz_MetaProperty","To_Moz_SequenceExpression","To_Moz_PrivateMemberExpression","To_Moz_MemberExpression","isComputed","To_Moz_ChainExpression","To_Moz_ArrayExpression","To_Moz_ObjectExpression","To_Moz_Property","Number","string_or_num","To_Moz_MethodDefinition","shorthand","To_Moz_Class","To_Moz_StaticBlock","To_Moz_Identifier","def","definition","mangled_name","To_Moz_RegExpLiteral","To_Moz_Literal","To_Moz_Atom","String","DEFMETHOD","prototype","to_mozilla_ast","To_Moz_ArrayHole","moznode","loc","range","line","column","node","ret","pop","from_mozilla_ast","save_stack","ast","set_moz_loc","mynode","pos","endpos","col","endline","endcol","file","mytype","TO_MOZ_STACK","unshift"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/terser/lib/mozilla-ast.js"],"sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nimport { make_node } from \"./utils/index.js\";\nimport {\n    AST_Accessor,\n    AST_Array,\n    AST_Arrow,\n    AST_Assign,\n    AST_Atom,\n    AST_Await,\n    AST_BigInt,\n    AST_Binary,\n    AST_Block,\n    AST_BlockStatement,\n    AST_Boolean,\n    AST_Break,\n    AST_Call,\n    AST_Case,\n    AST_Catch,\n    AST_Chain,\n    AST_Class,\n    AST_ClassStaticBlock,\n    AST_ClassExpression,\n    AST_ClassProperty,\n    AST_ClassPrivateProperty,\n    AST_ConciseMethod,\n    AST_Conditional,\n    AST_Const,\n    AST_Constant,\n    AST_Continue,\n    AST_Debugger,\n    AST_Default,\n    AST_DefaultAssign,\n    AST_DefClass,\n    AST_Definitions,\n    AST_Defun,\n    AST_Destructuring,\n    AST_Directive,\n    AST_Do,\n    AST_Dot,\n    AST_DotHash,\n    AST_EmptyStatement,\n    AST_Expansion,\n    AST_Export,\n    AST_False,\n    AST_Finally,\n    AST_For,\n    AST_ForIn,\n    AST_ForOf,\n    AST_Function,\n    AST_Hole,\n    AST_If,\n    AST_Import,\n    AST_ImportMeta,\n    AST_Label,\n    AST_LabeledStatement,\n    AST_LabelRef,\n    AST_Lambda,\n    AST_Let,\n    AST_NameMapping,\n    AST_New,\n    AST_NewTarget,\n    AST_Node,\n    AST_Null,\n    AST_Number,\n    AST_Object,\n    AST_ObjectGetter,\n    AST_ObjectKeyVal,\n    AST_ObjectProperty,\n    AST_ObjectSetter,\n    AST_PrefixedTemplateString,\n    AST_PrivateGetter,\n    AST_PrivateMethod,\n    AST_PrivateSetter,\n    AST_PropAccess,\n    AST_RegExp,\n    AST_Return,\n    AST_Sequence,\n    AST_SimpleStatement,\n    AST_Statement,\n    AST_String,\n    AST_Sub,\n    AST_Super,\n    AST_Switch,\n    AST_SwitchBranch,\n    AST_Symbol,\n    AST_SymbolCatch,\n    AST_SymbolClass,\n    AST_SymbolClassProperty,\n    AST_SymbolConst,\n    AST_SymbolDefClass,\n    AST_SymbolDefun,\n    AST_SymbolExport,\n    AST_SymbolExportForeign,\n    AST_SymbolFunarg,\n    AST_SymbolImport,\n    AST_SymbolImportForeign,\n    AST_SymbolLambda,\n    AST_SymbolLet,\n    AST_SymbolMethod,\n    AST_SymbolRef,\n    AST_SymbolVar,\n    AST_TemplateSegment,\n    AST_TemplateString,\n    AST_This,\n    AST_Throw,\n    AST_Token,\n    AST_Toplevel,\n    AST_True,\n    AST_Try,\n    AST_Unary,\n    AST_UnaryPostfix,\n    AST_UnaryPrefix,\n    AST_Var,\n    AST_VarDef,\n    AST_While,\n    AST_With,\n    AST_Yield,\n} from \"./ast.js\";\nimport { is_basic_identifier_string } from \"./parse.js\";\n\n(function() {\n\n    var normalize_directives = function(body) {\n        var in_directive = true;\n\n        for (var i = 0; i < body.length; i++) {\n            if (in_directive && body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {\n                body[i] = new AST_Directive({\n                    start: body[i].start,\n                    end: body[i].end,\n                    value: body[i].body.value\n                });\n            } else if (in_directive && !(body[i] instanceof AST_Statement && body[i].body instanceof AST_String)) {\n                in_directive = false;\n            }\n        }\n\n        return body;\n    };\n\n    const assert_clause_from_moz = (assertions) => {\n        if (assertions && assertions.length > 0) {\n            return new AST_Object({\n                start: my_start_token(assertions),\n                end: my_end_token(assertions),\n                properties: assertions.map((assertion_kv) =>\n                    new AST_ObjectKeyVal({\n                        start: my_start_token(assertion_kv),\n                        end: my_end_token(assertion_kv),\n                        key: assertion_kv.key.name || assertion_kv.key.value,\n                        value: from_moz(assertion_kv.value)\n                    })\n                )\n            });\n        }\n        return null;\n    };\n\n    var MOZ_TO_ME = {\n        Program: function(M) {\n            return new AST_Toplevel({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: normalize_directives(M.body.map(from_moz))\n            });\n        },\n\n        ArrayPattern: function(M) {\n            return new AST_Destructuring({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                names: M.elements.map(function(elm) {\n                    if (elm === null) {\n                        return new AST_Hole();\n                    }\n                    return from_moz(elm);\n                }),\n                is_array: true\n            });\n        },\n\n        ObjectPattern: function(M) {\n            return new AST_Destructuring({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                names: M.properties.map(from_moz),\n                is_array: false\n            });\n        },\n\n        AssignmentPattern: function(M) {\n            return new AST_DefaultAssign({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                left: from_moz(M.left),\n                operator: \"=\",\n                right: from_moz(M.right)\n            });\n        },\n\n        SpreadElement: function(M) {\n            return new AST_Expansion({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n\n        RestElement: function(M) {\n            return new AST_Expansion({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n\n        TemplateElement: function(M) {\n            return new AST_TemplateSegment({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                value: M.value.cooked,\n                raw: M.value.raw\n            });\n        },\n\n        TemplateLiteral: function(M) {\n            var segments = [];\n            for (var i = 0; i < M.quasis.length; i++) {\n                segments.push(from_moz(M.quasis[i]));\n                if (M.expressions[i]) {\n                    segments.push(from_moz(M.expressions[i]));\n                }\n            }\n            return new AST_TemplateString({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                segments: segments\n            });\n        },\n\n        TaggedTemplateExpression: function(M) {\n            return new AST_PrefixedTemplateString({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                template_string: from_moz(M.quasi),\n                prefix: from_moz(M.tag)\n            });\n        },\n\n        FunctionDeclaration: function(M) {\n            return new AST_Defun({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: M.params.map(from_moz),\n                is_generator: M.generator,\n                async: M.async,\n                body: normalize_directives(from_moz(M.body).body)\n            });\n        },\n\n        FunctionExpression: function(M) {\n            return new AST_Function({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: M.params.map(from_moz),\n                is_generator: M.generator,\n                async: M.async,\n                body: normalize_directives(from_moz(M.body).body)\n            });\n        },\n\n        ArrowFunctionExpression: function(M) {\n            const body = M.body.type === \"BlockStatement\"\n                ? from_moz(M.body).body\n                : [make_node(AST_Return, {}, { value: from_moz(M.body) })];\n            return new AST_Arrow({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argnames: M.params.map(from_moz),\n                body,\n                async: M.async,\n            });\n        },\n\n        ExpressionStatement: function(M) {\n            return new AST_SimpleStatement({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: from_moz(M.expression)\n            });\n        },\n\n        TryStatement: function(M) {\n            var handlers = M.handlers || [M.handler];\n            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                throw new Error(\"Multiple catch clauses are not supported.\");\n            }\n            return new AST_Try({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                body     : from_moz(M.block).body,\n                bcatch   : from_moz(handlers[0]),\n                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n            });\n        },\n\n        Property: function(M) {\n            var key = M.key;\n            var args = {\n                start    : my_start_token(key || M.value),\n                end      : my_end_token(M.value),\n                key      : key.type == \"Identifier\" ? key.name : key.value,\n                value    : from_moz(M.value)\n            };\n            if (M.computed) {\n                args.key = from_moz(M.key);\n            }\n            if (M.method) {\n                args.is_generator = M.value.generator;\n                args.async = M.value.async;\n                if (!M.computed) {\n                    args.key = new AST_SymbolMethod({ name: args.key });\n                } else {\n                    args.key = from_moz(M.key);\n                }\n                return new AST_ConciseMethod(args);\n            }\n            if (M.kind == \"init\") {\n                if (key.type != \"Identifier\" && key.type != \"Literal\") {\n                    args.key = from_moz(key);\n                }\n                return new AST_ObjectKeyVal(args);\n            }\n            if (typeof args.key === \"string\" || typeof args.key === \"number\") {\n                args.key = new AST_SymbolMethod({\n                    name: args.key\n                });\n            }\n            args.value = new AST_Accessor(args.value);\n            if (M.kind == \"get\") return new AST_ObjectGetter(args);\n            if (M.kind == \"set\") return new AST_ObjectSetter(args);\n            if (M.kind == \"method\") {\n                args.async = M.value.async;\n                args.is_generator = M.value.generator;\n                args.quote = M.computed ? \"\\\"\" : null;\n                return new AST_ConciseMethod(args);\n            }\n        },\n\n        MethodDefinition: function(M) {\n            var args = {\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                key      : M.computed ? from_moz(M.key) : new AST_SymbolMethod({ name: M.key.name || M.key.value }),\n                value    : from_moz(M.value),\n                static   : M.static,\n            };\n            if (M.kind == \"get\") {\n                return new AST_ObjectGetter(args);\n            }\n            if (M.kind == \"set\") {\n                return new AST_ObjectSetter(args);\n            }\n            args.is_generator = M.value.generator;\n            args.async = M.value.async;\n            return new AST_ConciseMethod(args);\n        },\n\n        FieldDefinition: function(M) {\n            let key;\n            if (M.computed) {\n                key = from_moz(M.key);\n            } else {\n                if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in FieldDefinition\");\n                key = from_moz(M.key);\n            }\n            return new AST_ClassProperty({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                key,\n                value    : from_moz(M.value),\n                static   : M.static,\n            });\n        },\n\n        PropertyDefinition: function(M) {\n            let key;\n            if (M.computed) {\n                key = from_moz(M.key);\n            } else {\n                if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in PropertyDefinition\");\n                key = from_moz(M.key);\n            }\n\n            return new AST_ClassProperty({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                key,\n                value    : from_moz(M.value),\n                static   : M.static,\n            });\n        },\n\n        StaticBlock: function(M) {\n            return new AST_ClassStaticBlock({\n                start : my_start_token(M),\n                end   : my_end_token(M),\n                body  : M.body.map(from_moz),\n            });\n        },\n\n        ArrayExpression: function(M) {\n            return new AST_Array({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                elements : M.elements.map(function(elem) {\n                    return elem === null ? new AST_Hole() : from_moz(elem);\n                })\n            });\n        },\n\n        ObjectExpression: function(M) {\n            return new AST_Object({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                properties : M.properties.map(function(prop) {\n                    if (prop.type === \"SpreadElement\") {\n                        return from_moz(prop);\n                    }\n                    prop.type = \"Property\";\n                    return from_moz(prop);\n                })\n            });\n        },\n\n        SequenceExpression: function(M) {\n            return new AST_Sequence({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expressions: M.expressions.map(from_moz)\n            });\n        },\n\n        MemberExpression: function(M) {\n            return new (M.computed ? AST_Sub : AST_Dot)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                property   : M.computed ? from_moz(M.property) : M.property.name,\n                expression : from_moz(M.object),\n                optional   : M.optional || false\n            });\n        },\n\n        ChainExpression: function(M) {\n            return new AST_Chain({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.expression)\n            });\n        },\n\n        SwitchCase: function(M) {\n            return new (M.test ? AST_Case : AST_Default)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.test),\n                body       : M.consequent.map(from_moz)\n            });\n        },\n\n        VariableDeclaration: function(M) {\n            return new (M.kind === \"const\" ? AST_Const :\n                        M.kind === \"let\" ? AST_Let : AST_Var)({\n                start       : my_start_token(M),\n                end         : my_end_token(M),\n                definitions : M.declarations.map(from_moz)\n            });\n        },\n\n        ImportDeclaration: function(M) {\n            var imported_name = null;\n            var imported_names = null;\n            M.specifiers.forEach(function (specifier) {\n                if (specifier.type === \"ImportSpecifier\") {\n                    if (!imported_names) { imported_names = []; }\n                    imported_names.push(new AST_NameMapping({\n                        start: my_start_token(specifier),\n                        end: my_end_token(specifier),\n                        foreign_name: from_moz(specifier.imported),\n                        name: from_moz(specifier.local)\n                    }));\n                } else if (specifier.type === \"ImportDefaultSpecifier\") {\n                    imported_name = from_moz(specifier.local);\n                } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                    if (!imported_names) { imported_names = []; }\n                    imported_names.push(new AST_NameMapping({\n                        start: my_start_token(specifier),\n                        end: my_end_token(specifier),\n                        foreign_name: new AST_SymbolImportForeign({ name: \"*\" }),\n                        name: from_moz(specifier.local)\n                    }));\n                }\n            });\n            return new AST_Import({\n                start       : my_start_token(M),\n                end         : my_end_token(M),\n                imported_name: imported_name,\n                imported_names : imported_names,\n                module_name : from_moz(M.source),\n                assert_clause: assert_clause_from_moz(M.assertions)\n            });\n        },\n\n        ExportAllDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_names: [\n                    new AST_NameMapping({\n                        name: new AST_SymbolExportForeign({ name: \"*\" }),\n                        foreign_name: new AST_SymbolExportForeign({ name: \"*\" })\n                    })\n                ],\n                module_name: from_moz(M.source),\n                assert_clause: assert_clause_from_moz(M.assertions)\n            });\n        },\n\n        ExportNamedDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_definition: from_moz(M.declaration),\n                exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(function (specifier) {\n                    return new AST_NameMapping({\n                        foreign_name: from_moz(specifier.exported),\n                        name: from_moz(specifier.local)\n                    });\n                }) : null,\n                module_name: from_moz(M.source),\n                assert_clause: assert_clause_from_moz(M.assertions)\n            });\n        },\n\n        ExportDefaultDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_value: from_moz(M.declaration),\n                is_default: true\n            });\n        },\n\n        Literal: function(M) {\n            var val = M.value, args = {\n                start  : my_start_token(M),\n                end    : my_end_token(M)\n            };\n            var rx = M.regex;\n            if (rx && rx.pattern) {\n                // RegExpLiteral as per ESTree AST spec\n                args.value = {\n                    source: rx.pattern,\n                    flags: rx.flags\n                };\n                return new AST_RegExp(args);\n            } else if (rx) {\n                // support legacy RegExp\n                const rx_source = M.raw || val;\n                const match = rx_source.match(/^\\/(.*)\\/(\\w*)$/);\n                if (!match) throw new Error(\"Invalid regex source \" + rx_source);\n                const [_, source, flags] = match;\n                args.value = { source, flags };\n                return new AST_RegExp(args);\n            }\n            if (val === null) return new AST_Null(args);\n            switch (typeof val) {\n              case \"string\":\n                args.value = val;\n                return new AST_String(args);\n              case \"number\":\n                args.value = val;\n                args.raw = M.raw || val.toString();\n                return new AST_Number(args);\n              case \"boolean\":\n                return new (val ? AST_True : AST_False)(args);\n            }\n        },\n\n        MetaProperty: function(M) {\n            if (M.meta.name === \"new\" && M.property.name === \"target\") {\n                return new AST_NewTarget({\n                    start: my_start_token(M),\n                    end: my_end_token(M)\n                });\n            } else if (M.meta.name === \"import\" && M.property.name === \"meta\") {\n                return new AST_ImportMeta({\n                    start: my_start_token(M),\n                    end: my_end_token(M)\n                });\n            }\n        },\n\n        Identifier: function(M) {\n            var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];\n            return new (  p.type == \"LabeledStatement\" ? AST_Label\n                        : p.type == \"VariableDeclarator\" && p.id === M ? (p.kind == \"const\" ? AST_SymbolConst : p.kind == \"let\" ? AST_SymbolLet : AST_SymbolVar)\n                        : /Import.*Specifier/.test(p.type) ? (p.local === M ? AST_SymbolImport : AST_SymbolImportForeign)\n                        : p.type == \"ExportSpecifier\" ? (p.local === M ? AST_SymbolExport : AST_SymbolExportForeign)\n                        : p.type == \"FunctionExpression\" ? (p.id === M ? AST_SymbolLambda : AST_SymbolFunarg)\n                        : p.type == \"FunctionDeclaration\" ? (p.id === M ? AST_SymbolDefun : AST_SymbolFunarg)\n                        : p.type == \"ArrowFunctionExpression\" ? (p.params.includes(M)) ? AST_SymbolFunarg : AST_SymbolRef\n                        : p.type == \"ClassExpression\" ? (p.id === M ? AST_SymbolClass : AST_SymbolRef)\n                        : p.type == \"Property\" ? (p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolMethod)\n                        : p.type == \"PropertyDefinition\" || p.type === \"FieldDefinition\" ? (p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolClassProperty)\n                        : p.type == \"ClassDeclaration\" ? (p.id === M ? AST_SymbolDefClass : AST_SymbolRef)\n                        : p.type == \"MethodDefinition\" ? (p.computed ? AST_SymbolRef : AST_SymbolMethod)\n                        : p.type == \"CatchClause\" ? AST_SymbolCatch\n                        : p.type == \"BreakStatement\" || p.type == \"ContinueStatement\" ? AST_LabelRef\n                        : AST_SymbolRef)({\n                            start : my_start_token(M),\n                            end   : my_end_token(M),\n                            name  : M.name\n                        });\n        },\n\n        BigIntLiteral(M) {\n            return new AST_BigInt({\n                start : my_start_token(M),\n                end   : my_end_token(M),\n                value : M.value\n            });\n        },\n\n        EmptyStatement: function(M) {\n            return new AST_EmptyStatement({\n                start: my_start_token(M),\n                end: my_end_token(M)\n            });\n        },\n\n        BlockStatement: function(M) {\n            return new AST_BlockStatement({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: M.body.map(from_moz)\n            });\n        },\n\n        IfStatement: function(M) {\n            return new AST_If({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                condition: from_moz(M.test),\n                body: from_moz(M.consequent),\n                alternative: from_moz(M.alternate)\n            });\n        },\n\n        LabeledStatement: function(M) {\n            return new AST_LabeledStatement({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                label: from_moz(M.label),\n                body: from_moz(M.body)\n            });\n        },\n\n        BreakStatement: function(M) {\n            return new AST_Break({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                label: from_moz(M.label)\n            });\n        },\n\n        ContinueStatement: function(M) {\n            return new AST_Continue({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                label: from_moz(M.label)\n            });\n        },\n\n        WithStatement: function(M) {\n            return new AST_With({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.object),\n                body: from_moz(M.body)\n            });\n        },\n\n        SwitchStatement: function(M) {\n            return new AST_Switch({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.discriminant),\n                body: M.cases.map(from_moz)\n            });\n        },\n\n        ReturnStatement: function(M) {\n            return new AST_Return({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                value: from_moz(M.argument)\n            });\n        },\n\n        ThrowStatement: function(M) {\n            return new AST_Throw({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                value: from_moz(M.argument)\n            });\n        },\n\n        WhileStatement: function(M) {\n            return new AST_While({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                condition: from_moz(M.test),\n                body: from_moz(M.body)\n            });\n        },\n\n        DoWhileStatement: function(M) {\n            return new AST_Do({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                condition: from_moz(M.test),\n                body: from_moz(M.body)\n            });\n        },\n\n        ForStatement: function(M) {\n            return new AST_For({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.init),\n                condition: from_moz(M.test),\n                step: from_moz(M.update),\n                body: from_moz(M.body)\n            });\n        },\n\n        ForInStatement: function(M) {\n            return new AST_ForIn({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.left),\n                object: from_moz(M.right),\n                body: from_moz(M.body)\n            });\n        },\n\n        ForOfStatement: function(M) {\n            return new AST_ForOf({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.left),\n                object: from_moz(M.right),\n                body: from_moz(M.body),\n                await: M.await\n            });\n        },\n\n        AwaitExpression: function(M) {\n            return new AST_Await({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n\n        YieldExpression: function(M) {\n            return new AST_Yield({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument),\n                is_star: M.delegate\n            });\n        },\n\n        DebuggerStatement: function(M) {\n            return new AST_Debugger({\n                start: my_start_token(M),\n                end: my_end_token(M)\n            });\n        },\n\n        VariableDeclarator: function(M) {\n            return new AST_VarDef({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                value: from_moz(M.init)\n            });\n        },\n\n        CatchClause: function(M) {\n            return new AST_Catch({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argname: from_moz(M.param),\n                body: from_moz(M.body).body\n            });\n        },\n\n        ThisExpression: function(M) {\n            return new AST_This({\n                start: my_start_token(M),\n                end: my_end_token(M)\n            });\n        },\n\n        Super: function(M) {\n            return new AST_Super({\n                start: my_start_token(M),\n                end: my_end_token(M)\n            });\n        },\n\n        BinaryExpression: function(M) {\n            return new AST_Binary({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                operator: M.operator,\n                left: from_moz(M.left),\n                right: from_moz(M.right)\n            });\n        },\n\n        LogicalExpression: function(M) {\n            return new AST_Binary({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                operator: M.operator,\n                left: from_moz(M.left),\n                right: from_moz(M.right)\n            });\n        },\n\n        AssignmentExpression: function(M) {\n            return new AST_Assign({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                operator: M.operator,\n                left: from_moz(M.left),\n                right: from_moz(M.right)\n            });\n        },\n\n        ConditionalExpression: function(M) {\n            return new AST_Conditional({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                condition: from_moz(M.test),\n                consequent: from_moz(M.consequent),\n                alternative: from_moz(M.alternate)\n            });\n        },\n\n        NewExpression: function(M) {\n            return new AST_New({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.callee),\n                args: M.arguments.map(from_moz)\n            });\n        },\n\n        CallExpression: function(M) {\n            return new AST_Call({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.callee),\n                optional: M.optional,\n                args: M.arguments.map(from_moz)\n            });\n        }\n    };\n\n    MOZ_TO_ME.UpdateExpression =\n    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n        var prefix = \"prefix\" in M ? M.prefix\n            : M.type == \"UnaryExpression\" ? true : false;\n        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n            start      : my_start_token(M),\n            end        : my_end_token(M),\n            operator   : M.operator,\n            expression : from_moz(M.argument)\n        });\n    };\n\n    MOZ_TO_ME.ClassDeclaration =\n    MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {\n        return new (M.type === \"ClassDeclaration\" ? AST_DefClass : AST_ClassExpression)({\n            start    : my_start_token(M),\n            end      : my_end_token(M),\n            name     : from_moz(M.id),\n            extends  : from_moz(M.superClass),\n            properties: M.body.body.map(from_moz)\n        });\n    };\n\n    def_to_moz(AST_EmptyStatement, function To_Moz_EmptyStatement() {\n        return {\n            type: \"EmptyStatement\"\n        };\n    });\n    def_to_moz(AST_BlockStatement, function To_Moz_BlockStatement(M) {\n        return {\n            type: \"BlockStatement\",\n            body: M.body.map(to_moz)\n        };\n    });\n    def_to_moz(AST_If, function To_Moz_IfStatement(M) {\n        return {\n            type: \"IfStatement\",\n            test: to_moz(M.condition),\n            consequent: to_moz(M.body),\n            alternate: to_moz(M.alternative)\n        };\n    });\n    def_to_moz(AST_LabeledStatement, function To_Moz_LabeledStatement(M) {\n        return {\n            type: \"LabeledStatement\",\n            label: to_moz(M.label),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_Break, function To_Moz_BreakStatement(M) {\n        return {\n            type: \"BreakStatement\",\n            label: to_moz(M.label)\n        };\n    });\n    def_to_moz(AST_Continue, function To_Moz_ContinueStatement(M) {\n        return {\n            type: \"ContinueStatement\",\n            label: to_moz(M.label)\n        };\n    });\n    def_to_moz(AST_With, function To_Moz_WithStatement(M) {\n        return {\n            type: \"WithStatement\",\n            object: to_moz(M.expression),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_Switch, function To_Moz_SwitchStatement(M) {\n        return {\n            type: \"SwitchStatement\",\n            discriminant: to_moz(M.expression),\n            cases: M.body.map(to_moz)\n        };\n    });\n    def_to_moz(AST_Return, function To_Moz_ReturnStatement(M) {\n        return {\n            type: \"ReturnStatement\",\n            argument: to_moz(M.value)\n        };\n    });\n    def_to_moz(AST_Throw, function To_Moz_ThrowStatement(M) {\n        return {\n            type: \"ThrowStatement\",\n            argument: to_moz(M.value)\n        };\n    });\n    def_to_moz(AST_While, function To_Moz_WhileStatement(M) {\n        return {\n            type: \"WhileStatement\",\n            test: to_moz(M.condition),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_Do, function To_Moz_DoWhileStatement(M) {\n        return {\n            type: \"DoWhileStatement\",\n            test: to_moz(M.condition),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_For, function To_Moz_ForStatement(M) {\n        return {\n            type: \"ForStatement\",\n            init: to_moz(M.init),\n            test: to_moz(M.condition),\n            update: to_moz(M.step),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_ForIn, function To_Moz_ForInStatement(M) {\n        return {\n            type: \"ForInStatement\",\n            left: to_moz(M.init),\n            right: to_moz(M.object),\n            body: to_moz(M.body)\n        };\n    });\n    def_to_moz(AST_ForOf, function To_Moz_ForOfStatement(M) {\n        return {\n            type: \"ForOfStatement\",\n            left: to_moz(M.init),\n            right: to_moz(M.object),\n            body: to_moz(M.body),\n            await: M.await\n        };\n    });\n    def_to_moz(AST_Await, function To_Moz_AwaitExpression(M) {\n        return {\n            type: \"AwaitExpression\",\n            argument: to_moz(M.expression)\n        };\n    });\n    def_to_moz(AST_Yield, function To_Moz_YieldExpression(M) {\n        return {\n            type: \"YieldExpression\",\n            argument: to_moz(M.expression),\n            delegate: M.is_star\n        };\n    });\n    def_to_moz(AST_Debugger, function To_Moz_DebuggerStatement() {\n        return {\n            type: \"DebuggerStatement\"\n        };\n    });\n    def_to_moz(AST_VarDef, function To_Moz_VariableDeclarator(M) {\n        return {\n            type: \"VariableDeclarator\",\n            id: to_moz(M.name),\n            init: to_moz(M.value)\n        };\n    });\n    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n        return {\n            type: \"CatchClause\",\n            param: to_moz(M.argname),\n            body: to_moz_block(M)\n        };\n    });\n\n    def_to_moz(AST_This, function To_Moz_ThisExpression() {\n        return {\n            type: \"ThisExpression\"\n        };\n    });\n    def_to_moz(AST_Super, function To_Moz_Super() {\n        return {\n            type: \"Super\"\n        };\n    });\n    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n        return {\n            type: \"BinaryExpression\",\n            operator: M.operator,\n            left: to_moz(M.left),\n            right: to_moz(M.right)\n        };\n    });\n    def_to_moz(AST_Binary, function To_Moz_LogicalExpression(M) {\n        return {\n            type: \"LogicalExpression\",\n            operator: M.operator,\n            left: to_moz(M.left),\n            right: to_moz(M.right)\n        };\n    });\n    def_to_moz(AST_Assign, function To_Moz_AssignmentExpression(M) {\n        return {\n            type: \"AssignmentExpression\",\n            operator: M.operator,\n            left: to_moz(M.left),\n            right: to_moz(M.right)\n        };\n    });\n    def_to_moz(AST_Conditional, function To_Moz_ConditionalExpression(M) {\n        return {\n            type: \"ConditionalExpression\",\n            test: to_moz(M.condition),\n            consequent: to_moz(M.consequent),\n            alternate: to_moz(M.alternative)\n        };\n    });\n    def_to_moz(AST_New, function To_Moz_NewExpression(M) {\n        return {\n            type: \"NewExpression\",\n            callee: to_moz(M.expression),\n            arguments: M.args.map(to_moz)\n        };\n    });\n    def_to_moz(AST_Call, function To_Moz_CallExpression(M) {\n        return {\n            type: \"CallExpression\",\n            callee: to_moz(M.expression),\n            optional: M.optional,\n            arguments: M.args.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n        return to_moz_scope(\"Program\", M);\n    });\n\n    def_to_moz(AST_Expansion, function To_Moz_Spread(M) {\n        return {\n            type: to_moz_in_destructuring() ? \"RestElement\" : \"SpreadElement\",\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {\n        return {\n            type: \"TaggedTemplateExpression\",\n            tag: to_moz(M.prefix),\n            quasi: to_moz(M.template_string)\n        };\n    });\n\n    def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {\n        var quasis = [];\n        var expressions = [];\n        for (var i = 0; i < M.segments.length; i++) {\n            if (i % 2 !== 0) {\n                expressions.push(to_moz(M.segments[i]));\n            } else {\n                quasis.push({\n                    type: \"TemplateElement\",\n                    value: {\n                        raw: M.segments[i].raw,\n                        cooked: M.segments[i].value\n                    },\n                    tail: i === M.segments.length - 1\n                });\n            }\n        }\n        return {\n            type: \"TemplateLiteral\",\n            quasis: quasis,\n            expressions: expressions\n        };\n    });\n\n    def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {\n        return {\n            type: \"FunctionDeclaration\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz),\n            generator: M.is_generator,\n            async: M.async,\n            body: to_moz_scope(\"BlockStatement\", M)\n        };\n    });\n\n    def_to_moz(AST_Function, function To_Moz_FunctionExpression(M, parent) {\n        var is_generator = parent.is_generator !== undefined ?\n            parent.is_generator : M.is_generator;\n        return {\n            type: \"FunctionExpression\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz),\n            generator: is_generator,\n            async: M.async,\n            body: to_moz_scope(\"BlockStatement\", M)\n        };\n    });\n\n    def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {\n        var body = {\n            type: \"BlockStatement\",\n            body: M.body.map(to_moz)\n        };\n        return {\n            type: \"ArrowFunctionExpression\",\n            params: M.argnames.map(to_moz),\n            async: M.async,\n            body: body\n        };\n    });\n\n    def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {\n        if (M.is_array) {\n            return {\n                type: \"ArrayPattern\",\n                elements: M.names.map(to_moz)\n            };\n        }\n        return {\n            type: \"ObjectPattern\",\n            properties: M.names.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: {\n                type: \"Literal\",\n                value: M.value,\n                raw: M.print_to_string()\n            },\n            directive: M.value\n        };\n    });\n\n    def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: to_moz(M.body)\n        };\n    });\n\n    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n        return {\n            type: \"SwitchCase\",\n            test: to_moz(M.expression),\n            consequent: M.body.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n        return {\n            type: \"TryStatement\",\n            block: to_moz_block(M),\n            handler: to_moz(M.bcatch),\n            guardedHandlers: [],\n            finalizer: to_moz(M.bfinally)\n        };\n    });\n\n    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n        return {\n            type: \"CatchClause\",\n            param: to_moz(M.argname),\n            guard: null,\n            body: to_moz_block(M)\n        };\n    });\n\n    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n        return {\n            type: \"VariableDeclaration\",\n            kind:\n                M instanceof AST_Const ? \"const\" :\n                M instanceof AST_Let ? \"let\" : \"var\",\n            declarations: M.definitions.map(to_moz)\n        };\n    });\n\n    const assert_clause_to_moz = assert_clause => {\n        const assertions = [];\n        if (assert_clause) {\n            for (const { key, value } of assert_clause.properties) {\n                const key_moz = is_basic_identifier_string(key)\n                    ? { type: \"Identifier\", name: key }\n                    : { type: \"Literal\", value: key, raw: JSON.stringify(key) };\n                assertions.push({\n                    type: \"ImportAttribute\",\n                    key: key_moz,\n                    value: to_moz(value)\n                });\n            }\n        }\n        return assertions;\n    };\n\n    def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {\n        if (M.exported_names) {\n            if (M.exported_names[0].name.name === \"*\") {\n                return {\n                    type: \"ExportAllDeclaration\",\n                    source: to_moz(M.module_name),\n                    assertions: assert_clause_to_moz(M.assert_clause)\n                };\n            }\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: M.exported_names.map(function (name_mapping) {\n                    return {\n                        type: \"ExportSpecifier\",\n                        exported: to_moz(name_mapping.foreign_name),\n                        local: to_moz(name_mapping.name)\n                    };\n                }),\n                declaration: to_moz(M.exported_definition),\n                source: to_moz(M.module_name),\n                assertions: assert_clause_to_moz(M.assert_clause)\n            };\n        }\n        return {\n            type: M.is_default ? \"ExportDefaultDeclaration\" : \"ExportNamedDeclaration\",\n            declaration: to_moz(M.exported_value || M.exported_definition)\n        };\n    });\n\n    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n        var specifiers = [];\n        if (M.imported_name) {\n            specifiers.push({\n                type: \"ImportDefaultSpecifier\",\n                local: to_moz(M.imported_name)\n            });\n        }\n        if (M.imported_names && M.imported_names[0].foreign_name.name === \"*\") {\n            specifiers.push({\n                type: \"ImportNamespaceSpecifier\",\n                local: to_moz(M.imported_names[0].name)\n            });\n        } else if (M.imported_names) {\n            M.imported_names.forEach(function(name_mapping) {\n                specifiers.push({\n                    type: \"ImportSpecifier\",\n                    local: to_moz(name_mapping.name),\n                    imported: to_moz(name_mapping.foreign_name)\n                });\n            });\n        }\n        return {\n            type: \"ImportDeclaration\",\n            specifiers: specifiers,\n            source: to_moz(M.module_name),\n            assertions: assert_clause_to_moz(M.assert_clause)\n        };\n    });\n\n    def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"import\"\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"meta\"\n            }\n        };\n    });\n\n    def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {\n        return {\n            type: \"SequenceExpression\",\n            expressions: M.expressions.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_DotHash, function To_Moz_PrivateMemberExpression(M) {\n        return {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: false,\n            property: {\n                type: \"PrivateIdentifier\",\n                name: M.property\n            },\n            optional: M.optional\n        };\n    });\n\n    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n        var isComputed = M instanceof AST_Sub;\n        return {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: isComputed,\n            property: isComputed ? to_moz(M.property) : {type: \"Identifier\", name: M.property},\n            optional: M.optional\n        };\n    });\n\n    def_to_moz(AST_Chain, function To_Moz_ChainExpression(M) {\n        return {\n            type: \"ChainExpression\",\n            expression: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n        return {\n            type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n            operator: M.operator,\n            prefix: M instanceof AST_UnaryPrefix,\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n        if (M.operator == \"=\" && to_moz_in_destructuring()) {\n            return {\n                type: \"AssignmentPattern\",\n                left: to_moz(M.left),\n                right: to_moz(M.right)\n            };\n        }\n\n        const type = M.operator == \"&&\" || M.operator == \"||\" || M.operator === \"??\"\n            ? \"LogicalExpression\"\n            : \"BinaryExpression\";\n\n        return {\n            type,\n            left: to_moz(M.left),\n            operator: M.operator,\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n        return {\n            type: \"ArrayExpression\",\n            elements: M.elements.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {\n        return {\n            type: \"ObjectExpression\",\n            properties: M.properties.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {\n        var key = M.key instanceof AST_Node ? to_moz(M.key) : {\n            type: \"Identifier\",\n            value: M.key\n        };\n        if (typeof M.key === \"number\") {\n            key = {\n                type: \"Literal\",\n                value: Number(M.key)\n            };\n        }\n        if (typeof M.key === \"string\") {\n            key = {\n                type: \"Identifier\",\n                name: M.key\n            };\n        }\n        var kind;\n        var string_or_num = typeof M.key === \"string\" || typeof M.key === \"number\";\n        var computed = string_or_num ? false : !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef;\n        if (M instanceof AST_ObjectKeyVal) {\n            kind = \"init\";\n            computed = !string_or_num;\n        } else\n        if (M instanceof AST_ObjectGetter) {\n            kind = \"get\";\n        } else\n        if (M instanceof AST_ObjectSetter) {\n            kind = \"set\";\n        }\n        if (M instanceof AST_PrivateGetter || M instanceof AST_PrivateSetter) {\n            const kind = M instanceof AST_PrivateGetter ? \"get\" : \"set\";\n            return {\n                type: \"MethodDefinition\",\n                computed: false,\n                kind: kind,\n                static: M.static,\n                key: {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.name\n                },\n                value: to_moz(M.value)\n            };\n        }\n        if (M instanceof AST_ClassPrivateProperty) {\n            return {\n                type: \"PropertyDefinition\",\n                key: {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.name\n                },\n                value: to_moz(M.value),\n                computed: false,\n                static: M.static\n            };\n        }\n        if (M instanceof AST_ClassProperty) {\n            return {\n                type: \"PropertyDefinition\",\n                key,\n                value: to_moz(M.value),\n                computed,\n                static: M.static\n            };\n        }\n        if (parent instanceof AST_Class) {\n            return {\n                type: \"MethodDefinition\",\n                computed: computed,\n                kind: kind,\n                static: M.static,\n                key: to_moz(M.key),\n                value: to_moz(M.value)\n            };\n        }\n        return {\n            type: \"Property\",\n            computed: computed,\n            kind: kind,\n            key: key,\n            value: to_moz(M.value)\n        };\n    });\n\n    def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {\n        if (parent instanceof AST_Object) {\n            return {\n                type: \"Property\",\n                computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n                kind: \"init\",\n                method: true,\n                shorthand: false,\n                key: to_moz(M.key),\n                value: to_moz(M.value)\n            };\n        }\n\n        const key = M instanceof AST_PrivateMethod\n            ? {\n                type: \"PrivateIdentifier\",\n                name: M.key.name\n            }\n            : to_moz(M.key);\n\n        return {\n            type: \"MethodDefinition\",\n            kind: M.key === \"constructor\" ? \"constructor\" : \"method\",\n            key,\n            value: to_moz(M.value),\n            computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n            static: M.static,\n        };\n    });\n\n    def_to_moz(AST_Class, function To_Moz_Class(M) {\n        var type = M instanceof AST_ClassExpression ? \"ClassExpression\" : \"ClassDeclaration\";\n        return {\n            type: type,\n            superClass: to_moz(M.extends),\n            id: M.name ? to_moz(M.name) : null,\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz)\n            }\n        };\n    });\n\n    def_to_moz(AST_ClassStaticBlock, function To_Moz_StaticBlock(M) {\n        return {\n            type: \"StaticBlock\",\n            body: M.body.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"new\"\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"target\"\n            }\n        };\n    });\n\n    def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {\n        if (M instanceof AST_SymbolMethod && parent.quote) {\n            return {\n                type: \"Literal\",\n                value: M.name\n            };\n        }\n        var def = M.definition();\n        return {\n            type: \"Identifier\",\n            name: def ? def.mangled_name || def.name : M.name\n        };\n    });\n\n    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n        const pattern = M.value.source;\n        const flags = M.value.flags;\n        return {\n            type: \"Literal\",\n            value: null,\n            raw: M.print_to_string(),\n            regex: { pattern, flags }\n        };\n    });\n\n    def_to_moz(AST_Constant, function To_Moz_Literal(M) {\n        var value = M.value;\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: M.raw || M.print_to_string()\n        };\n    });\n\n    def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n        return {\n            type: \"Identifier\",\n            name: String(M.value)\n        };\n    });\n\n    def_to_moz(AST_BigInt, M => ({\n        type: \"BigIntLiteral\",\n        value: M.value\n    }));\n\n    AST_Boolean.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Null.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Hole.DEFMETHOD(\"to_mozilla_ast\", function To_Moz_ArrayHole() { return null; });\n\n    AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n    AST_Lambda.DEFMETHOD(\"to_mozilla_ast\", AST_Function.prototype.to_mozilla_ast);\n\n    /* -----[ tools ]----- */\n\n    function my_start_token(moznode) {\n        var loc = moznode.loc, start = loc && loc.start;\n        var range = moznode.range;\n        return new AST_Token(\n            \"\",\n            \"\",\n            start && start.line || 0,\n            start && start.column || 0,\n            range ? range [0] : moznode.start,\n            false,\n            [],\n            [],\n            loc && loc.source,\n        );\n    }\n\n    function my_end_token(moznode) {\n        var loc = moznode.loc, end = loc && loc.end;\n        var range = moznode.range;\n        return new AST_Token(\n            \"\",\n            \"\",\n            end && end.line || 0,\n            end && end.column || 0,\n            range ? range [0] : moznode.end,\n            false,\n            [],\n            [],\n            loc && loc.source,\n        );\n    }\n\n    var FROM_MOZ_STACK = null;\n\n    function from_moz(node) {\n        FROM_MOZ_STACK.push(node);\n        var ret = node != null ? MOZ_TO_ME[node.type](node) : null;\n        FROM_MOZ_STACK.pop();\n        return ret;\n    }\n\n    AST_Node.from_mozilla_ast = function(node) {\n        var save_stack = FROM_MOZ_STACK;\n        FROM_MOZ_STACK = [];\n        var ast = from_moz(node);\n        FROM_MOZ_STACK = save_stack;\n        return ast;\n    };\n\n    function set_moz_loc(mynode, moznode) {\n        var start = mynode.start;\n        var end = mynode.end;\n        if (!(start && end)) {\n            return moznode;\n        }\n        if (start.pos != null && end.endpos != null) {\n            moznode.range = [start.pos, end.endpos];\n        }\n        if (start.line) {\n            moznode.loc = {\n                start: {line: start.line, column: start.col},\n                end: end.endline ? {line: end.endline, column: end.endcol} : null\n            };\n            if (start.file) {\n                moznode.loc.source = start.file;\n            }\n        }\n        return moznode;\n    }\n\n    function def_to_moz(mytype, handler) {\n        mytype.DEFMETHOD(\"to_mozilla_ast\", function(parent) {\n            return set_moz_loc(this, handler(this, parent));\n        });\n    }\n\n    var TO_MOZ_STACK = null;\n\n    function to_moz(node) {\n        if (TO_MOZ_STACK === null) { TO_MOZ_STACK = []; }\n        TO_MOZ_STACK.push(node);\n        var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;\n        TO_MOZ_STACK.pop();\n        if (TO_MOZ_STACK.length === 0) { TO_MOZ_STACK = null; }\n        return ast;\n    }\n\n    function to_moz_in_destructuring() {\n        var i = TO_MOZ_STACK.length;\n        while (i--) {\n            if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function to_moz_block(node) {\n        return {\n            type: \"BlockStatement\",\n            body: node.body.map(to_moz)\n        };\n    }\n\n    function to_moz_scope(type, node) {\n        var body = node.body.map(to_moz);\n        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n        }\n        return {\n            type: type,\n            body: body\n        };\n    }\n})();\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}