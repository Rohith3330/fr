{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _core = require(\"@babel/core\");\n\nvar _pluginSyntaxDecorators = require(\"@babel/plugin-syntax-decorators\");\n\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nfunction incrementId(id) {\n  let idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id.length - 1;\n\n  if (idx === -1) {\n    id.unshift(65);\n    return;\n  }\n\n  const current = id[idx];\n\n  if (current === 90) {\n    id[idx] = 97;\n  } else if (current === 122) {\n    id[idx] = 65;\n    incrementId(id, idx - 1);\n  } else {\n    id[idx] = current + 1;\n  }\n}\n\nfunction createPrivateUidGeneratorForClass(classPath) {\n  const currentPrivateId = [];\n  const privateNames = new Set();\n  classPath.traverse({\n    PrivateName(path) {\n      privateNames.add(path.node.id.name);\n    }\n\n  });\n  return () => {\n    let reifiedId;\n\n    do {\n      incrementId(currentPrivateId);\n      reifiedId = String.fromCharCode(...currentPrivateId);\n    } while (privateNames.has(reifiedId));\n\n    return _core.types.privateName(_core.types.identifier(reifiedId));\n  };\n}\n\nfunction createLazyPrivateUidGeneratorForClass(classPath) {\n  let generator;\n  return () => {\n    if (!generator) {\n      generator = createPrivateUidGeneratorForClass(classPath);\n    }\n\n    return generator();\n  };\n}\n\nfunction replaceClassWithVar(path) {\n  if (path.type === \"ClassDeclaration\") {\n    const varId = path.scope.generateUidIdentifierBasedOnNode(path.node.id);\n\n    const classId = _core.types.identifier(path.node.id.name);\n\n    path.scope.rename(classId.name, varId.name);\n    path.insertBefore(_core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(varId)]));\n    path.get(\"id\").replaceWith(classId);\n    return [_core.types.cloneNode(varId), path];\n  } else {\n    let className;\n    let varId;\n\n    if (path.node.id) {\n      className = path.node.id.name;\n      varId = path.scope.parent.generateDeclaredUidIdentifier(className);\n      path.scope.rename(className, varId.name);\n    } else if (path.parentPath.node.type === \"VariableDeclarator\" && path.parentPath.node.id.type === \"Identifier\") {\n      className = path.parentPath.node.id.name;\n      varId = path.scope.parent.generateDeclaredUidIdentifier(className);\n    } else {\n      varId = path.scope.parent.generateDeclaredUidIdentifier(\"decorated_class\");\n    }\n\n    const newClassExpr = _core.types.classExpression(className && _core.types.identifier(className), path.node.superClass, path.node.body);\n\n    const [newPath] = path.replaceWith(_core.types.sequenceExpression([newClassExpr, varId]));\n    return [_core.types.cloneNode(varId), newPath.get(\"expressions.0\")];\n  }\n}\n\nfunction generateClassProperty(key, value, isStatic) {\n  if (key.type === \"PrivateName\") {\n    return _core.types.classPrivateProperty(key, value, undefined, isStatic);\n  } else {\n    return _core.types.classProperty(key, value, undefined, undefined, isStatic);\n  }\n}\n\nfunction addProxyAccessorsFor(element, originalKey, targetKey) {\n  let isComputed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const {\n    static: isStatic\n  } = element.node;\n\n  const getterBody = _core.types.blockStatement([_core.types.returnStatement(_core.types.memberExpression(_core.types.thisExpression(), _core.types.cloneNode(targetKey)))]);\n\n  const setterBody = _core.types.blockStatement([_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.thisExpression(), _core.types.cloneNode(targetKey)), _core.types.identifier(\"v\")))]);\n\n  let getter, setter;\n\n  if (originalKey.type === \"PrivateName\") {\n    getter = _core.types.classPrivateMethod(\"get\", _core.types.cloneNode(originalKey), [], getterBody, isStatic);\n    setter = _core.types.classPrivateMethod(\"set\", _core.types.cloneNode(originalKey), [_core.types.identifier(\"v\")], setterBody, isStatic);\n  } else {\n    getter = _core.types.classMethod(\"get\", _core.types.cloneNode(originalKey), [], getterBody, isComputed, isStatic);\n    setter = _core.types.classMethod(\"set\", _core.types.cloneNode(originalKey), [_core.types.identifier(\"v\")], setterBody, isComputed, isStatic);\n  }\n\n  element.insertAfter(setter);\n  element.insertAfter(getter);\n}\n\nfunction extractProxyAccessorsFor(targetKey) {\n  return [_core.types.functionExpression(undefined, [], _core.types.blockStatement([_core.types.returnStatement(_core.types.memberExpression(_core.types.thisExpression(), _core.types.cloneNode(targetKey)))])), _core.types.functionExpression(undefined, [_core.types.identifier(\"value\")], _core.types.blockStatement([_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.thisExpression(), _core.types.cloneNode(targetKey)), _core.types.identifier(\"value\")))]))];\n}\n\nconst FIELD = 0;\nconst ACCESSOR = 1;\nconst METHOD = 2;\nconst GETTER = 3;\nconst SETTER = 4;\nconst STATIC = 5;\n\nfunction getElementKind(element) {\n  switch (element.node.type) {\n    case \"ClassProperty\":\n    case \"ClassPrivateProperty\":\n      return FIELD;\n\n    case \"ClassAccessorProperty\":\n      return ACCESSOR;\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (element.node.kind === \"get\") {\n        return GETTER;\n      } else if (element.node.kind === \"set\") {\n        return SETTER;\n      } else {\n        return METHOD;\n      }\n\n  }\n}\n\nfunction isDecoratorInfo(info) {\n  return \"decorators\" in info;\n}\n\nfunction filteredOrderedDecoratorInfo(info) {\n  const filtered = info.filter(isDecoratorInfo);\n  return [...filtered.filter(el => el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...filtered.filter(el => !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...filtered.filter(el => el.isStatic && el.kind === FIELD), ...filtered.filter(el => !el.isStatic && el.kind === FIELD)];\n}\n\nfunction generateDecorationExprs(info) {\n  return _core.types.arrayExpression(filteredOrderedDecoratorInfo(info).map(el => {\n    const decs = el.decorators.length > 1 ? _core.types.arrayExpression(el.decorators) : el.decorators[0];\n    const kind = el.isStatic ? el.kind + STATIC : el.kind;\n    const decInfo = [decs, _core.types.numericLiteral(kind), el.name];\n    const {\n      privateMethods\n    } = el;\n\n    if (Array.isArray(privateMethods)) {\n      decInfo.push(...privateMethods);\n    } else if (privateMethods) {\n      decInfo.push(privateMethods);\n    }\n\n    return _core.types.arrayExpression(decInfo);\n  }));\n}\n\nfunction extractElementLocalAssignments(decorationInfo) {\n  const localIds = [];\n\n  for (const el of filteredOrderedDecoratorInfo(decorationInfo)) {\n    const {\n      locals\n    } = el;\n\n    if (Array.isArray(locals)) {\n      localIds.push(...locals);\n    } else if (locals !== undefined) {\n      localIds.push(locals);\n    }\n  }\n\n  return localIds;\n}\n\nfunction addCallAccessorsFor(element, key, getId, setId) {\n  element.insertAfter(_core.types.classPrivateMethod(\"get\", _core.types.cloneNode(key), [], _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.cloneNode(getId), [_core.types.thisExpression()]))])));\n  element.insertAfter(_core.types.classPrivateMethod(\"set\", _core.types.cloneNode(key), [_core.types.identifier(\"v\")], _core.types.blockStatement([_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(setId), [_core.types.thisExpression(), _core.types.identifier(\"v\")]))])));\n}\n\nfunction isNotTsParameter(node) {\n  return node.type !== \"TSParameterProperty\";\n}\n\nfunction movePrivateAccessor(element, key, methodLocalVar, isStatic) {\n  let params;\n  let block;\n\n  if (element.node.kind === \"set\") {\n    params = [_core.types.identifier(\"v\")];\n    block = [_core.types.expressionStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression(), _core.types.identifier(\"v\")]))];\n  } else {\n    params = [];\n    block = [_core.types.returnStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression()]))];\n  }\n\n  element.replaceWith(_core.types.classPrivateMethod(element.node.kind, _core.types.cloneNode(key), params, _core.types.blockStatement(block), isStatic));\n}\n\nfunction isClassDecoratableElementPath(path) {\n  const {\n    type\n  } = path;\n  return type !== \"TSDeclareMethod\" && type !== \"TSIndexSignature\" && type !== \"StaticBlock\";\n}\n\nfunction staticBlockToIIFE(block) {\n  return _core.types.callExpression(_core.types.arrowFunctionExpression([], _core.types.blockStatement(block.body)), []);\n}\n\nfunction maybeSequenceExpression(exprs) {\n  if (exprs.length === 0) return _core.types.unaryExpression(\"void\", _core.types.numericLiteral(0));\n  if (exprs.length === 1) return exprs[0];\n  return _core.types.sequenceExpression(exprs);\n}\n\nfunction transformClass(path, state, constantSuper, version) {\n  const body = path.get(\"body.body\");\n  const classDecorators = path.node.decorators;\n  let hasElementDecorators = false;\n  const generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path);\n\n  for (const element of body) {\n    if (!isClassDecoratableElementPath(element)) {\n      continue;\n    }\n\n    if (element.node.decorators && element.node.decorators.length > 0) {\n      hasElementDecorators = true;\n    } else if (element.node.type === \"ClassAccessorProperty\") {\n      const {\n        key,\n        value,\n        static: isStatic,\n        computed\n      } = element.node;\n      const newId = generateClassPrivateUid();\n      const valueNode = value ? _core.types.cloneNode(value) : undefined;\n      const newField = generateClassProperty(newId, valueNode, isStatic);\n      const [newPath] = element.replaceWith(newField);\n      addProxyAccessorsFor(newPath, key, newId, computed);\n    }\n  }\n\n  if (!classDecorators && !hasElementDecorators) return;\n  const elementDecoratorInfo = [];\n  let firstFieldPath;\n  let constructorPath;\n  let requiresProtoInit = false;\n  let requiresStaticInit = false;\n  const decoratedPrivateMethods = new Set();\n  let protoInitLocal, staticInitLocal, classInitLocal, classLocal;\n  const assignments = [];\n  const scopeParent = path.scope.parent;\n\n  const memoiseExpression = (expression, hint) => {\n    const localEvaluatedId = scopeParent.generateDeclaredUidIdentifier(hint);\n    assignments.push(_core.types.assignmentExpression(\"=\", localEvaluatedId, expression));\n    return _core.types.cloneNode(localEvaluatedId);\n  };\n\n  if (classDecorators) {\n    classInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initClass\");\n    const [localId, classPath] = replaceClassWithVar(path);\n    path = classPath;\n    classLocal = localId;\n    path.node.decorators = null;\n\n    for (const classDecorator of classDecorators) {\n      if (!scopeParent.isStatic(classDecorator.expression)) {\n        classDecorator.expression = memoiseExpression(classDecorator.expression, \"dec\");\n      }\n    }\n  } else {\n    if (!path.node.id) {\n      path.node.id = path.scope.generateUidIdentifier(\"Class\");\n    }\n\n    classLocal = _core.types.cloneNode(path.node.id);\n  }\n\n  if (hasElementDecorators) {\n    for (const element of body) {\n      if (!isClassDecoratableElementPath(element)) {\n        continue;\n      }\n\n      const {\n        node\n      } = element;\n      const decorators = element.get(\"decorators\");\n      const hasDecorators = Array.isArray(decorators) && decorators.length > 0;\n\n      if (hasDecorators) {\n        for (const decoratorPath of decorators) {\n          if (!scopeParent.isStatic(decoratorPath.node.expression)) {\n            decoratorPath.node.expression = memoiseExpression(decoratorPath.node.expression, \"dec\");\n          }\n        }\n      }\n\n      const isComputed = \"computed\" in element.node && element.node.computed === true;\n\n      if (isComputed) {\n        if (!scopeParent.isStatic(node.key)) {\n          node.key = memoiseExpression(node.key, \"computedKey\");\n        }\n      }\n\n      const kind = getElementKind(element);\n      const {\n        key\n      } = node;\n      const isPrivate = key.type === \"PrivateName\";\n      const isStatic = !!element.node.static;\n      let name = \"computedKey\";\n\n      if (isPrivate) {\n        name = key.id.name;\n      } else if (!isComputed && key.type === \"Identifier\") {\n        name = key.name;\n      }\n\n      if (element.isClassMethod({\n        kind: \"constructor\"\n      })) {\n        constructorPath = element;\n      }\n\n      if (hasDecorators) {\n        let locals;\n        let privateMethods;\n\n        if (kind === ACCESSOR) {\n          const {\n            value\n          } = element.node;\n          const params = [_core.types.thisExpression()];\n\n          if (value) {\n            params.push(_core.types.cloneNode(value));\n          }\n\n          const newId = generateClassPrivateUid();\n          const newFieldInitId = element.scope.parent.generateDeclaredUidIdentifier(`init_${name}`);\n\n          const newValue = _core.types.callExpression(_core.types.cloneNode(newFieldInitId), params);\n\n          const newField = generateClassProperty(newId, newValue, isStatic);\n          const [newPath] = element.replaceWith(newField);\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(newId);\n            const getId = newPath.scope.parent.generateDeclaredUidIdentifier(`get_${name}`);\n            const setId = newPath.scope.parent.generateDeclaredUidIdentifier(`set_${name}`);\n            addCallAccessorsFor(newPath, key, getId, setId);\n            locals = [newFieldInitId, getId, setId];\n          } else {\n            addProxyAccessorsFor(newPath, key, newId, isComputed);\n            locals = newFieldInitId;\n          }\n        } else if (kind === FIELD) {\n          const initId = element.scope.parent.generateDeclaredUidIdentifier(`init_${name}`);\n          const valuePath = element.get(\"value\");\n          valuePath.replaceWith(_core.types.callExpression(_core.types.cloneNode(initId), [_core.types.thisExpression(), valuePath.node].filter(v => v)));\n          locals = initId;\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(key);\n          }\n        } else if (isPrivate) {\n          locals = element.scope.parent.generateDeclaredUidIdentifier(`call_${name}`);\n          const replaceSupers = new _helperReplaceSupers.default({\n            constantSuper,\n            methodPath: element,\n            objectRef: classLocal,\n            superRef: path.node.superClass,\n            file: state.file,\n            refToPreserve: classLocal\n          });\n          replaceSupers.replace();\n          const {\n            params,\n            body,\n            async: isAsync\n          } = element.node;\n          privateMethods = _core.types.functionExpression(undefined, params.filter(isNotTsParameter), body, isAsync);\n\n          if (kind === GETTER || kind === SETTER) {\n            movePrivateAccessor(element, _core.types.cloneNode(key), _core.types.cloneNode(locals), isStatic);\n          } else {\n            const node = element.node;\n            path.node.body.body.unshift(_core.types.classPrivateProperty(key, _core.types.cloneNode(locals), [], node.static));\n            decoratedPrivateMethods.add(key.id.name);\n            element.remove();\n          }\n        }\n\n        let nameExpr;\n\n        if (isComputed) {\n          nameExpr = _core.types.cloneNode(key);\n        } else if (key.type === \"PrivateName\") {\n          nameExpr = _core.types.stringLiteral(key.id.name);\n        } else if (key.type === \"Identifier\") {\n          nameExpr = _core.types.stringLiteral(key.name);\n        } else {\n          nameExpr = _core.types.cloneNode(key);\n        }\n\n        elementDecoratorInfo.push({\n          kind,\n          decorators: decorators.map(d => d.node.expression),\n          name: nameExpr,\n          isStatic,\n          privateMethods,\n          locals\n        });\n\n        if (kind !== FIELD) {\n          if (isStatic) {\n            requiresStaticInit = true;\n          } else {\n            requiresProtoInit = true;\n          }\n        }\n\n        if (element.node) {\n          element.node.decorators = null;\n        }\n\n        if (!firstFieldPath && (kind === FIELD || kind === ACCESSOR)) {\n          firstFieldPath = element;\n        }\n      }\n    }\n  }\n\n  const elementDecorations = generateDecorationExprs(elementDecoratorInfo);\n\n  const classDecorations = _core.types.arrayExpression((classDecorators || []).map(d => d.expression));\n\n  const locals = extractElementLocalAssignments(elementDecoratorInfo);\n\n  if (requiresProtoInit) {\n    protoInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initProto\");\n    locals.push(protoInitLocal);\n\n    const protoInitCall = _core.types.callExpression(_core.types.cloneNode(protoInitLocal), [_core.types.thisExpression()]);\n\n    if (firstFieldPath) {\n      const value = firstFieldPath.get(\"value\");\n      const body = [protoInitCall];\n\n      if (value.node) {\n        body.push(value.node);\n      }\n\n      value.replaceWith(_core.types.sequenceExpression(body));\n    } else if (constructorPath) {\n      if (path.node.superClass) {\n        path.traverse({\n          CallExpression: {\n            exit(path) {\n              if (!path.get(\"callee\").isSuper()) return;\n              path.replaceWith(_core.types.callExpression(_core.types.cloneNode(protoInitLocal), [path.node]));\n              path.skip();\n            }\n\n          }\n        });\n      } else {\n        constructorPath.node.body.body.unshift(_core.types.expressionStatement(protoInitCall));\n      }\n    } else {\n      const body = [_core.types.expressionStatement(protoInitCall)];\n\n      if (path.node.superClass) {\n        body.unshift(_core.types.expressionStatement(_core.types.callExpression(_core.types.super(), [_core.types.spreadElement(_core.types.identifier(\"args\"))])));\n      }\n\n      path.node.body.body.unshift(_core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), [_core.types.restElement(_core.types.identifier(\"args\"))], _core.types.blockStatement(body)));\n    }\n  }\n\n  if (requiresStaticInit) {\n    staticInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initStatic\");\n    locals.push(staticInitLocal);\n  }\n\n  if (decoratedPrivateMethods.size > 0) {\n    path.traverse({\n      PrivateName(path) {\n        if (!decoratedPrivateMethods.has(path.node.id.name)) return;\n        const parentPath = path.parentPath;\n        const parentParentPath = parentPath.parentPath;\n\n        if (parentParentPath.node.type === \"AssignmentExpression\" && parentParentPath.node.left === parentPath.node || parentParentPath.node.type === \"UpdateExpression\" || parentParentPath.node.type === \"RestElement\" || parentParentPath.node.type === \"ArrayPattern\" || parentParentPath.node.type === \"ObjectProperty\" && parentParentPath.node.value === parentPath.node && parentParentPath.parentPath.type === \"ObjectPattern\" || parentParentPath.node.type === \"ForOfStatement\" && parentParentPath.node.left === parentPath.node) {\n          throw path.buildCodeFrameError(`Decorated private methods are not updatable, but \"#${path.node.id.name}\" is updated via this expression.`);\n        }\n      }\n\n    });\n  }\n\n  let classInitInjected = false;\n\n  const classInitCall = classInitLocal && _core.types.callExpression(_core.types.cloneNode(classInitLocal), []);\n\n  const originalClass = path.node;\n\n  if (classDecorators) {\n    locals.push(classLocal, classInitLocal);\n    const statics = [];\n    let staticBlocks = [];\n    path.get(\"body.body\").forEach(element => {\n      if (element.isStaticBlock()) {\n        staticBlocks.push(element.node);\n        element.remove();\n        return;\n      }\n\n      const isProperty = element.isClassProperty() || element.isClassPrivateProperty();\n\n      if ((isProperty || element.isClassPrivateMethod()) && element.node.static) {\n        if (isProperty && staticBlocks.length > 0) {\n          const allValues = staticBlocks.map(staticBlockToIIFE);\n          if (element.node.value) allValues.push(element.node.value);\n          element.node.value = maybeSequenceExpression(allValues);\n          staticBlocks = [];\n        }\n\n        element.node.static = false;\n        statics.push(element.node);\n        element.remove();\n      }\n    });\n\n    if (statics.length > 0 || staticBlocks.length > 0) {\n      const staticsClass = _core.template.expression.ast`\n        class extends ${state.addHelper(\"identity\")} {}\n      `;\n      staticsClass.body.body = [_core.types.staticBlock([_core.types.toStatement(path.node, false)]), ...statics];\n      const constructorBody = [];\n\n      const newExpr = _core.types.newExpression(staticsClass, []);\n\n      if (staticBlocks.length > 0) {\n        constructorBody.push(...staticBlocks.map(staticBlockToIIFE));\n      }\n\n      if (classInitCall) {\n        classInitInjected = true;\n        constructorBody.push(classInitCall);\n      }\n\n      if (constructorBody.length > 0) {\n        constructorBody.unshift(_core.types.callExpression(_core.types.super(), [_core.types.cloneNode(classLocal)]));\n        staticsClass.body.body.push(_core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), [], _core.types.blockStatement([_core.types.expressionStatement(_core.types.sequenceExpression(constructorBody))])));\n      } else {\n        newExpr.arguments.push(_core.types.cloneNode(classLocal));\n      }\n\n      path.replaceWith(newExpr);\n    }\n  }\n\n  if (!classInitInjected && classInitCall) {\n    path.node.body.body.push(_core.types.staticBlock([_core.types.expressionStatement(classInitCall)]));\n  }\n\n  originalClass.body.body.unshift(_core.types.staticBlock([_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.arrayPattern(locals), _core.types.callExpression(state.addHelper(version === \"2021-12\" ? \"applyDecs\" : \"applyDecs2203\"), [_core.types.thisExpression(), elementDecorations, classDecorations]))), requiresStaticInit && _core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(staticInitLocal), [_core.types.thisExpression()]))].filter(Boolean)));\n  path.insertBefore(assignments.map(expr => _core.types.expressionStatement(expr)));\n  path.scope.crawl();\n  return path;\n}\n\nfunction _default(_ref, _ref2, version) {\n  let {\n    assertVersion,\n    assumption\n  } = _ref;\n  let {\n    loose\n  } = _ref2;\n\n  var _assumption;\n\n  assertVersion(version === \"2021-12\" ? \"^7.16.0\" : \"^7.19.0\");\n  const VISITED = new WeakSet();\n  const constantSuper = (_assumption = assumption(\"constantSuper\")) != null ? _assumption : loose;\n  return {\n    name: \"proposal-decorators\",\n    inherits: _pluginSyntaxDecorators.default,\n    visitor: {\n      \"ExportNamedDeclaration|ExportDefaultDeclaration\"(path) {\n        var _declaration$decorato;\n\n        const {\n          declaration\n        } = path.node;\n\n        if ((declaration == null ? void 0 : declaration.type) === \"ClassDeclaration\" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0) {\n          (0, _helperSplitExportDeclaration.default)(path);\n        }\n      },\n\n      Class(path, state) {\n        if (VISITED.has(path)) return;\n        const newPath = transformClass(path, state, constantSuper, version);\n        if (newPath) VISITED.add(newPath);\n      }\n\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["incrementId","id","idx","length","unshift","current","createPrivateUidGeneratorForClass","classPath","currentPrivateId","privateNames","Set","traverse","PrivateName","path","add","node","name","reifiedId","String","fromCharCode","has","t","privateName","identifier","createLazyPrivateUidGeneratorForClass","generator","replaceClassWithVar","type","varId","scope","generateUidIdentifierBasedOnNode","classId","rename","insertBefore","variableDeclaration","variableDeclarator","get","replaceWith","cloneNode","className","parent","generateDeclaredUidIdentifier","parentPath","newClassExpr","classExpression","superClass","body","newPath","sequenceExpression","generateClassProperty","key","value","isStatic","classPrivateProperty","undefined","classProperty","addProxyAccessorsFor","element","originalKey","targetKey","isComputed","static","getterBody","blockStatement","returnStatement","memberExpression","thisExpression","setterBody","expressionStatement","assignmentExpression","getter","setter","classPrivateMethod","classMethod","insertAfter","extractProxyAccessorsFor","functionExpression","FIELD","ACCESSOR","METHOD","GETTER","SETTER","STATIC","getElementKind","kind","isDecoratorInfo","info","filteredOrderedDecoratorInfo","filtered","filter","el","generateDecorationExprs","arrayExpression","map","decs","decorators","decInfo","numericLiteral","privateMethods","Array","isArray","push","extractElementLocalAssignments","decorationInfo","localIds","locals","addCallAccessorsFor","getId","setId","callExpression","isNotTsParameter","movePrivateAccessor","methodLocalVar","params","block","isClassDecoratableElementPath","staticBlockToIIFE","arrowFunctionExpression","maybeSequenceExpression","exprs","unaryExpression","transformClass","state","constantSuper","version","classDecorators","hasElementDecorators","generateClassPrivateUid","computed","newId","valueNode","newField","elementDecoratorInfo","firstFieldPath","constructorPath","requiresProtoInit","requiresStaticInit","decoratedPrivateMethods","protoInitLocal","staticInitLocal","classInitLocal","classLocal","assignments","scopeParent","memoiseExpression","expression","hint","localEvaluatedId","localId","classDecorator","generateUidIdentifier","hasDecorators","decoratorPath","isPrivate","isClassMethod","newFieldInitId","newValue","initId","valuePath","v","replaceSupers","ReplaceSupers","methodPath","objectRef","superRef","file","refToPreserve","replace","async","isAsync","remove","nameExpr","stringLiteral","d","elementDecorations","classDecorations","protoInitCall","CallExpression","exit","isSuper","skip","super","spreadElement","restElement","size","parentParentPath","left","buildCodeFrameError","classInitInjected","classInitCall","originalClass","statics","staticBlocks","forEach","isStaticBlock","isProperty","isClassProperty","isClassPrivateProperty","isClassPrivateMethod","allValues","staticsClass","template","ast","addHelper","staticBlock","toStatement","constructorBody","newExpr","newExpression","arguments","arrayPattern","Boolean","expr","crawl","assertVersion","assumption","loose","VISITED","WeakSet","inherits","syntaxDecorators","visitor","declaration","Class"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-proposal-decorators\\src\\transformer-2022-03.ts"],"sourcesContent":["import type { NodePath, Scope } from \"@babel/traverse\";\nimport { types as t, template } from \"@babel/core\";\nimport syntaxDecorators from \"@babel/plugin-syntax-decorators\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport * as charCodes from \"charcodes\";\nimport type { PluginAPI, PluginObject, PluginPass } from \"@babel/core\";\nimport type { Options } from \"./index\";\n\ntype ClassDecoratableElement =\n  | t.ClassMethod\n  | t.ClassPrivateMethod\n  | t.ClassProperty\n  | t.ClassPrivateProperty\n  | t.ClassAccessorProperty;\n\ntype ClassElement =\n  | ClassDecoratableElement\n  | t.TSDeclareMethod\n  | t.TSIndexSignature\n  | t.StaticBlock;\n\nfunction incrementId(id: number[], idx = id.length - 1): void {\n  // If index is -1, id needs an additional character, unshift A\n  if (idx === -1) {\n    id.unshift(charCodes.uppercaseA);\n    return;\n  }\n\n  const current = id[idx];\n\n  if (current === charCodes.uppercaseZ) {\n    // if current is Z, skip to a\n    id[idx] = charCodes.lowercaseA;\n  } else if (current === charCodes.lowercaseZ) {\n    // if current is z, reset to A and carry the 1\n    id[idx] = charCodes.uppercaseA;\n    incrementId(id, idx - 1);\n  } else {\n    // else, increment by one\n    id[idx] = current + 1;\n  }\n}\n\n/**\n * Generates a new private name that is unique to the given class. This can be\n * used to create extra class fields and methods for the implementation, while\n * keeping the length of those names as small as possible. This is important for\n * minification purposes (though private names can generally be minified,\n * transpilations and polyfills cannot yet).\n */\nfunction createPrivateUidGeneratorForClass(\n  classPath: NodePath<t.ClassDeclaration | t.ClassExpression>,\n): () => t.PrivateName {\n  const currentPrivateId: number[] = [];\n  const privateNames = new Set<string>();\n\n  classPath.traverse({\n    PrivateName(path) {\n      privateNames.add(path.node.id.name);\n    },\n  });\n\n  return (): t.PrivateName => {\n    let reifiedId;\n    do {\n      incrementId(currentPrivateId);\n      reifiedId = String.fromCharCode(...currentPrivateId);\n    } while (privateNames.has(reifiedId));\n\n    return t.privateName(t.identifier(reifiedId));\n  };\n}\n\n/**\n * Wraps the above generator function so that it's run lazily the first time\n * it's actually required. Several types of decoration do not require this, so it\n * saves iterating the class elements an additional time and allocating the space\n * for the Sets of element names.\n */\nfunction createLazyPrivateUidGeneratorForClass(\n  classPath: NodePath<t.ClassDeclaration | t.ClassExpression>,\n): () => t.PrivateName {\n  let generator: () => t.PrivateName;\n\n  return (): t.PrivateName => {\n    if (!generator) {\n      generator = createPrivateUidGeneratorForClass(classPath);\n    }\n\n    return generator();\n  };\n}\n\n/**\n * Takes a class definition and replaces it with an equivalent class declaration\n * which is then assigned to a local variable. This allows us to reassign the\n * local variable with the decorated version of the class. The class definition\n * retains its original name so that `toString` is not affected, other\n * references to the class are renamed instead.\n */\nfunction replaceClassWithVar(\n  path: NodePath<t.ClassDeclaration | t.ClassExpression>,\n): [t.Identifier, NodePath<t.ClassDeclaration | t.ClassExpression>] {\n  if (path.type === \"ClassDeclaration\") {\n    const varId = path.scope.generateUidIdentifierBasedOnNode(path.node.id);\n    const classId = t.identifier(path.node.id.name);\n\n    path.scope.rename(classId.name, varId.name);\n\n    path.insertBefore(\n      t.variableDeclaration(\"let\", [t.variableDeclarator(varId)]),\n    );\n    path.get(\"id\").replaceWith(classId);\n\n    return [t.cloneNode(varId), path];\n  } else {\n    let className: string;\n    let varId: t.Identifier;\n\n    if (path.node.id) {\n      className = path.node.id.name;\n      varId = path.scope.parent.generateDeclaredUidIdentifier(className);\n      path.scope.rename(className, varId.name);\n    } else if (\n      path.parentPath.node.type === \"VariableDeclarator\" &&\n      path.parentPath.node.id.type === \"Identifier\"\n    ) {\n      className = path.parentPath.node.id.name;\n      varId = path.scope.parent.generateDeclaredUidIdentifier(className);\n    } else {\n      varId =\n        path.scope.parent.generateDeclaredUidIdentifier(\"decorated_class\");\n    }\n\n    const newClassExpr = t.classExpression(\n      className && t.identifier(className),\n      path.node.superClass,\n      path.node.body,\n    );\n\n    const [newPath] = path.replaceWith(\n      t.sequenceExpression([newClassExpr, varId]),\n    );\n\n    return [\n      t.cloneNode(varId),\n      newPath.get(\"expressions.0\") as NodePath<t.ClassExpression>,\n    ];\n  }\n}\n\nfunction generateClassProperty(\n  key: t.PrivateName | t.Identifier,\n  value: t.Expression | undefined,\n  isStatic: boolean,\n): t.ClassPrivateProperty | t.ClassProperty {\n  if (key.type === \"PrivateName\") {\n    return t.classPrivateProperty(key, value, undefined, isStatic);\n  } else {\n    return t.classProperty(key, value, undefined, undefined, isStatic);\n  }\n}\n\nfunction addProxyAccessorsFor(\n  element: NodePath<ClassDecoratableElement>,\n  originalKey: t.PrivateName | t.Expression,\n  targetKey: t.PrivateName,\n  isComputed = false,\n): void {\n  const { static: isStatic } = element.node;\n\n  const getterBody = t.blockStatement([\n    t.returnStatement(\n      t.memberExpression(t.thisExpression(), t.cloneNode(targetKey)),\n    ),\n  ]);\n\n  const setterBody = t.blockStatement([\n    t.expressionStatement(\n      t.assignmentExpression(\n        \"=\",\n        t.memberExpression(t.thisExpression(), t.cloneNode(targetKey)),\n        t.identifier(\"v\"),\n      ),\n    ),\n  ]);\n\n  let getter: t.ClassMethod | t.ClassPrivateMethod,\n    setter: t.ClassMethod | t.ClassPrivateMethod;\n\n  if (originalKey.type === \"PrivateName\") {\n    getter = t.classPrivateMethod(\n      \"get\",\n      t.cloneNode(originalKey),\n      [],\n      getterBody,\n      isStatic,\n    );\n    setter = t.classPrivateMethod(\n      \"set\",\n      t.cloneNode(originalKey),\n      [t.identifier(\"v\")],\n      setterBody,\n      isStatic,\n    );\n  } else {\n    getter = t.classMethod(\n      \"get\",\n      t.cloneNode(originalKey),\n      [],\n      getterBody,\n      isComputed,\n      isStatic,\n    );\n    setter = t.classMethod(\n      \"set\",\n      t.cloneNode(originalKey),\n      [t.identifier(\"v\")],\n      setterBody,\n      isComputed,\n      isStatic,\n    );\n  }\n\n  element.insertAfter(setter);\n  element.insertAfter(getter);\n}\n\nfunction extractProxyAccessorsFor(\n  targetKey: t.PrivateName,\n): t.FunctionExpression[] {\n  return [\n    t.functionExpression(\n      undefined,\n      [],\n      t.blockStatement([\n        t.returnStatement(\n          t.memberExpression(t.thisExpression(), t.cloneNode(targetKey)),\n        ),\n      ]),\n    ),\n    t.functionExpression(\n      undefined,\n      [t.identifier(\"value\")],\n      t.blockStatement([\n        t.expressionStatement(\n          t.assignmentExpression(\n            \"=\",\n            t.memberExpression(t.thisExpression(), t.cloneNode(targetKey)),\n            t.identifier(\"value\"),\n          ),\n        ),\n      ]),\n    ),\n  ];\n}\n\nconst FIELD = 0;\nconst ACCESSOR = 1;\nconst METHOD = 2;\nconst GETTER = 3;\nconst SETTER = 4;\n\nconst STATIC = 5;\n\nfunction getElementKind(element: NodePath<ClassDecoratableElement>): number {\n  switch (element.node.type) {\n    case \"ClassProperty\":\n    case \"ClassPrivateProperty\":\n      return FIELD;\n    case \"ClassAccessorProperty\":\n      return ACCESSOR;\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (element.node.kind === \"get\") {\n        return GETTER;\n      } else if (element.node.kind === \"set\") {\n        return SETTER;\n      } else {\n        return METHOD;\n      }\n  }\n}\n\n// Information about the decorators applied to an element\ninterface DecoratorInfo {\n  // The expressions of the decorators themselves\n  decorators: t.Expression[];\n\n  // The kind of the decorated value, matches the kind value passed to applyDecs\n  kind: number;\n\n  // whether or not the field is static\n  isStatic: boolean;\n\n  // The name of the decorator\n  name: t.StringLiteral | t.Expression;\n\n  privateMethods: t.FunctionExpression | t.FunctionExpression[] | undefined;\n\n  // The names of local variables that will be used/returned from the decoration\n  locals: t.Identifier | t.Identifier[] | undefined;\n}\n\n// Information about a computed property key. These must be evaluated\n// interspersed with decorator expressions, which is why they get added to the\n// array of DecoratorInfos later on.\ninterface ComputedPropInfo {\n  localComputedNameId: t.Identifier;\n  keyNode: t.Expression;\n}\n\nfunction isDecoratorInfo(\n  info: DecoratorInfo | ComputedPropInfo,\n): info is DecoratorInfo {\n  return \"decorators\" in info;\n}\n\nfunction filteredOrderedDecoratorInfo(\n  info: (DecoratorInfo | ComputedPropInfo)[],\n): DecoratorInfo[] {\n  const filtered = info.filter(isDecoratorInfo);\n\n  return [\n    ...filtered.filter(\n      el => el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER,\n    ),\n    ...filtered.filter(\n      el => !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER,\n    ),\n    ...filtered.filter(el => el.isStatic && el.kind === FIELD),\n    ...filtered.filter(el => !el.isStatic && el.kind === FIELD),\n  ];\n}\n\nfunction generateDecorationExprs(\n  info: (DecoratorInfo | ComputedPropInfo)[],\n): t.ArrayExpression {\n  return t.arrayExpression(\n    filteredOrderedDecoratorInfo(info).map(el => {\n      const decs =\n        el.decorators.length > 1\n          ? t.arrayExpression(el.decorators)\n          : el.decorators[0];\n\n      const kind = el.isStatic ? el.kind + STATIC : el.kind;\n\n      const decInfo = [decs, t.numericLiteral(kind), el.name];\n\n      const { privateMethods } = el;\n\n      if (Array.isArray(privateMethods)) {\n        decInfo.push(...privateMethods);\n      } else if (privateMethods) {\n        decInfo.push(privateMethods);\n      }\n\n      return t.arrayExpression(decInfo);\n    }),\n  );\n}\n\nfunction extractElementLocalAssignments(\n  decorationInfo: (DecoratorInfo | ComputedPropInfo)[],\n) {\n  const localIds: t.Identifier[] = [];\n\n  for (const el of filteredOrderedDecoratorInfo(decorationInfo)) {\n    const { locals } = el;\n\n    if (Array.isArray(locals)) {\n      localIds.push(...locals);\n    } else if (locals !== undefined) {\n      localIds.push(locals);\n    }\n  }\n\n  return localIds;\n}\n\nfunction addCallAccessorsFor(\n  element: NodePath,\n  key: t.PrivateName,\n  getId: t.Identifier,\n  setId: t.Identifier,\n) {\n  element.insertAfter(\n    t.classPrivateMethod(\n      \"get\",\n      t.cloneNode(key),\n      [],\n      t.blockStatement([\n        t.returnStatement(\n          t.callExpression(t.cloneNode(getId), [t.thisExpression()]),\n        ),\n      ]),\n    ),\n  );\n\n  element.insertAfter(\n    t.classPrivateMethod(\n      \"set\",\n      t.cloneNode(key),\n      [t.identifier(\"v\")],\n      t.blockStatement([\n        t.expressionStatement(\n          t.callExpression(t.cloneNode(setId), [\n            t.thisExpression(),\n            t.identifier(\"v\"),\n          ]),\n        ),\n      ]),\n    ),\n  );\n}\n\nfunction isNotTsParameter(\n  node: t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty,\n): node is t.Identifier | t.Pattern | t.RestElement {\n  return node.type !== \"TSParameterProperty\";\n}\n\nfunction movePrivateAccessor(\n  element: NodePath<t.ClassPrivateMethod>,\n  key: t.PrivateName,\n  methodLocalVar: t.Identifier,\n  isStatic: boolean,\n) {\n  let params: (t.Identifier | t.RestElement)[];\n  let block: t.Statement[];\n\n  if (element.node.kind === \"set\") {\n    params = [t.identifier(\"v\")];\n    block = [\n      t.expressionStatement(\n        t.callExpression(methodLocalVar, [\n          t.thisExpression(),\n          t.identifier(\"v\"),\n        ]),\n      ),\n    ];\n  } else {\n    params = [];\n    block = [\n      t.returnStatement(t.callExpression(methodLocalVar, [t.thisExpression()])),\n    ];\n  }\n\n  element.replaceWith(\n    t.classPrivateMethod(\n      element.node.kind,\n      t.cloneNode(key),\n      params,\n      t.blockStatement(block),\n      isStatic,\n    ),\n  );\n}\n\nfunction isClassDecoratableElementPath(\n  path: NodePath<ClassElement>,\n): path is NodePath<ClassDecoratableElement> {\n  const { type } = path;\n\n  return (\n    type !== \"TSDeclareMethod\" &&\n    type !== \"TSIndexSignature\" &&\n    type !== \"StaticBlock\"\n  );\n}\n\nfunction staticBlockToIIFE(block: t.StaticBlock) {\n  return t.callExpression(\n    t.arrowFunctionExpression([], t.blockStatement(block.body)),\n    [],\n  );\n}\n\nfunction maybeSequenceExpression(exprs: t.Expression[]) {\n  if (exprs.length === 0) return t.unaryExpression(\"void\", t.numericLiteral(0));\n  if (exprs.length === 1) return exprs[0];\n  return t.sequenceExpression(exprs);\n}\n\nfunction transformClass(\n  path: NodePath<t.ClassExpression | t.ClassDeclaration>,\n  state: PluginPass,\n  constantSuper: boolean,\n  version: \"2022-03\" | \"2021-12\",\n): NodePath {\n  const body = path.get(\"body.body\");\n\n  const classDecorators = path.node.decorators;\n  let hasElementDecorators = false;\n\n  const generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path);\n\n  // Iterate over the class to see if we need to decorate it, and also to\n  // transform simple auto accessors which are not decorated\n  for (const element of body) {\n    if (!isClassDecoratableElementPath(element)) {\n      continue;\n    }\n\n    if (element.node.decorators && element.node.decorators.length > 0) {\n      hasElementDecorators = true;\n    } else if (element.node.type === \"ClassAccessorProperty\") {\n      const { key, value, static: isStatic, computed } = element.node;\n\n      const newId = generateClassPrivateUid();\n\n      const valueNode = value ? t.cloneNode(value) : undefined;\n\n      const newField = generateClassProperty(newId, valueNode, isStatic);\n\n      const [newPath] = element.replaceWith(newField);\n      addProxyAccessorsFor(newPath, key, newId, computed);\n    }\n  }\n\n  // If nothing is decorated, return\n  if (!classDecorators && !hasElementDecorators) return;\n\n  const elementDecoratorInfo: (DecoratorInfo | ComputedPropInfo)[] = [];\n\n  let firstFieldPath:\n    | NodePath<t.ClassProperty | t.ClassPrivateProperty>\n    | undefined;\n  let constructorPath: NodePath<t.ClassMethod> | undefined;\n  let requiresProtoInit = false;\n  let requiresStaticInit = false;\n  const decoratedPrivateMethods = new Set<string>();\n\n  let protoInitLocal: t.Identifier,\n    staticInitLocal: t.Identifier,\n    classInitLocal: t.Identifier,\n    classLocal: t.Identifier;\n  const assignments: t.AssignmentExpression[] = [];\n  const scopeParent: Scope = path.scope.parent;\n\n  const memoiseExpression = (expression: t.Expression, hint: string) => {\n    const localEvaluatedId = scopeParent.generateDeclaredUidIdentifier(hint);\n    assignments.push(t.assignmentExpression(\"=\", localEvaluatedId, expression));\n    return t.cloneNode(localEvaluatedId);\n  };\n\n  if (classDecorators) {\n    classInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initClass\");\n\n    const [localId, classPath] = replaceClassWithVar(path);\n    path = classPath;\n    classLocal = localId;\n\n    path.node.decorators = null;\n\n    for (const classDecorator of classDecorators) {\n      if (!scopeParent.isStatic(classDecorator.expression)) {\n        classDecorator.expression = memoiseExpression(\n          classDecorator.expression,\n          \"dec\",\n        );\n      }\n    }\n  } else {\n    if (!path.node.id) {\n      path.node.id = path.scope.generateUidIdentifier(\"Class\");\n    }\n    classLocal = t.cloneNode(path.node.id);\n  }\n\n  if (hasElementDecorators) {\n    for (const element of body) {\n      if (!isClassDecoratableElementPath(element)) {\n        continue;\n      }\n\n      const { node } = element;\n      const decorators = element.get(\"decorators\");\n\n      const hasDecorators = Array.isArray(decorators) && decorators.length > 0;\n\n      if (hasDecorators) {\n        for (const decoratorPath of decorators) {\n          if (!scopeParent.isStatic(decoratorPath.node.expression)) {\n            decoratorPath.node.expression = memoiseExpression(\n              decoratorPath.node.expression,\n              \"dec\",\n            );\n          }\n        }\n      }\n\n      const isComputed =\n        \"computed\" in element.node && element.node.computed === true;\n      if (isComputed) {\n        if (!scopeParent.isStatic(node.key)) {\n          node.key = memoiseExpression(node.key as t.Expression, \"computedKey\");\n        }\n      }\n\n      const kind = getElementKind(element);\n      const { key } = node;\n\n      const isPrivate = key.type === \"PrivateName\";\n\n      const isStatic = !!element.node.static;\n\n      let name = \"computedKey\";\n\n      if (isPrivate) {\n        name = (key as t.PrivateName).id.name;\n      } else if (!isComputed && key.type === \"Identifier\") {\n        name = key.name;\n      }\n\n      if (element.isClassMethod({ kind: \"constructor\" })) {\n        constructorPath = element;\n      }\n\n      if (hasDecorators) {\n        let locals: t.Identifier | t.Identifier[];\n        let privateMethods: t.FunctionExpression | t.FunctionExpression[];\n\n        if (kind === ACCESSOR) {\n          const { value } = element.node as t.ClassAccessorProperty;\n\n          const params: t.Expression[] = [t.thisExpression()];\n\n          if (value) {\n            params.push(t.cloneNode(value));\n          }\n\n          const newId = generateClassPrivateUid();\n          const newFieldInitId =\n            element.scope.parent.generateDeclaredUidIdentifier(`init_${name}`);\n          const newValue = t.callExpression(\n            t.cloneNode(newFieldInitId),\n            params,\n          );\n\n          const newField = generateClassProperty(newId, newValue, isStatic);\n          const [newPath] = element.replaceWith(newField);\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(newId);\n\n            const getId = newPath.scope.parent.generateDeclaredUidIdentifier(\n              `get_${name}`,\n            );\n            const setId = newPath.scope.parent.generateDeclaredUidIdentifier(\n              `set_${name}`,\n            );\n\n            addCallAccessorsFor(newPath, key as t.PrivateName, getId, setId);\n\n            locals = [newFieldInitId, getId, setId];\n          } else {\n            addProxyAccessorsFor(newPath, key, newId, isComputed);\n            locals = newFieldInitId;\n          }\n        } else if (kind === FIELD) {\n          const initId = element.scope.parent.generateDeclaredUidIdentifier(\n            `init_${name}`,\n          );\n          const valuePath = (\n            element as NodePath<t.ClassProperty | t.ClassPrivateProperty>\n          ).get(\"value\");\n\n          valuePath.replaceWith(\n            t.callExpression(\n              t.cloneNode(initId),\n              [t.thisExpression(), valuePath.node].filter(v => v),\n            ),\n          );\n\n          locals = initId;\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(key as t.PrivateName);\n          }\n        } else if (isPrivate) {\n          locals = element.scope.parent.generateDeclaredUidIdentifier(\n            `call_${name}`,\n          ) as t.Identifier;\n\n          const replaceSupers = new ReplaceSupers({\n            constantSuper,\n            methodPath: element as NodePath<t.ClassPrivateMethod>,\n            objectRef: classLocal,\n            superRef: path.node.superClass,\n            file: state.file,\n            refToPreserve: classLocal,\n          });\n\n          replaceSupers.replace();\n\n          const {\n            params,\n            body,\n            async: isAsync,\n          } = element.node as t.ClassPrivateMethod;\n\n          privateMethods = t.functionExpression(\n            undefined,\n            params.filter(isNotTsParameter),\n            body,\n            isAsync,\n          );\n\n          if (kind === GETTER || kind === SETTER) {\n            movePrivateAccessor(\n              element as NodePath<t.ClassPrivateMethod>,\n              t.cloneNode(key as t.PrivateName),\n              t.cloneNode(locals),\n              isStatic,\n            );\n          } else {\n            const node = element.node as t.ClassPrivateMethod;\n\n            // Unshift\n            path.node.body.body.unshift(\n              t.classPrivateProperty(\n                key as t.PrivateName,\n                t.cloneNode(locals),\n                [],\n                node.static,\n              ),\n            );\n\n            decoratedPrivateMethods.add((key as t.PrivateName).id.name);\n\n            element.remove();\n          }\n        }\n\n        let nameExpr: t.Expression;\n\n        if (isComputed) {\n          nameExpr = t.cloneNode(key as t.Expression);\n        } else if (key.type === \"PrivateName\") {\n          nameExpr = t.stringLiteral(key.id.name);\n        } else if (key.type === \"Identifier\") {\n          nameExpr = t.stringLiteral(key.name);\n        } else {\n          nameExpr = t.cloneNode(key as t.Expression);\n        }\n\n        elementDecoratorInfo.push({\n          kind,\n          decorators: decorators.map(d => d.node.expression),\n          name: nameExpr,\n          isStatic,\n          privateMethods,\n          locals,\n        });\n\n        if (kind !== FIELD) {\n          if (isStatic) {\n            requiresStaticInit = true;\n          } else {\n            requiresProtoInit = true;\n          }\n        }\n\n        if (element.node) {\n          element.node.decorators = null;\n        }\n\n        if (!firstFieldPath && (kind === FIELD || kind === ACCESSOR)) {\n          firstFieldPath = element as NodePath<\n            t.ClassProperty | t.ClassPrivateProperty\n          >;\n        }\n      }\n    }\n  }\n\n  const elementDecorations = generateDecorationExprs(elementDecoratorInfo);\n  const classDecorations = t.arrayExpression(\n    (classDecorators || []).map(d => d.expression),\n  );\n\n  const locals: t.Identifier[] =\n    extractElementLocalAssignments(elementDecoratorInfo);\n\n  if (requiresProtoInit) {\n    protoInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initProto\");\n    locals.push(protoInitLocal);\n\n    const protoInitCall = t.callExpression(t.cloneNode(protoInitLocal), [\n      t.thisExpression(),\n    ]);\n\n    if (firstFieldPath) {\n      const value = firstFieldPath.get(\"value\");\n      const body: t.Expression[] = [protoInitCall];\n\n      if (value.node) {\n        body.push(value.node);\n      }\n\n      value.replaceWith(t.sequenceExpression(body));\n    } else if (constructorPath) {\n      if (path.node.superClass) {\n        path.traverse({\n          CallExpression: {\n            exit(path) {\n              if (!path.get(\"callee\").isSuper()) return;\n\n              path.replaceWith(\n                t.callExpression(t.cloneNode(protoInitLocal), [path.node]),\n              );\n\n              path.skip();\n            },\n          },\n        });\n      } else {\n        constructorPath.node.body.body.unshift(\n          t.expressionStatement(protoInitCall),\n        );\n      }\n    } else {\n      const body: t.Statement[] = [t.expressionStatement(protoInitCall)];\n\n      if (path.node.superClass) {\n        body.unshift(\n          t.expressionStatement(\n            t.callExpression(t.super(), [\n              t.spreadElement(t.identifier(\"args\")),\n            ]),\n          ),\n        );\n      }\n\n      path.node.body.body.unshift(\n        t.classMethod(\n          \"constructor\",\n          t.identifier(\"constructor\"),\n          [t.restElement(t.identifier(\"args\"))],\n          t.blockStatement(body),\n        ),\n      );\n    }\n  }\n\n  if (requiresStaticInit) {\n    staticInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initStatic\");\n    locals.push(staticInitLocal);\n  }\n\n  if (decoratedPrivateMethods.size > 0) {\n    path.traverse({\n      PrivateName(path) {\n        if (!decoratedPrivateMethods.has(path.node.id.name)) return;\n\n        const parentPath = path.parentPath;\n        const parentParentPath = parentPath.parentPath;\n\n        if (\n          // this.bar().#x = 123;\n          (parentParentPath.node.type === \"AssignmentExpression\" &&\n            parentParentPath.node.left === parentPath.node) ||\n          // this.#x++;\n          parentParentPath.node.type === \"UpdateExpression\" ||\n          // ([...this.#x] = foo);\n          parentParentPath.node.type === \"RestElement\" ||\n          // ([this.#x] = foo);\n          parentParentPath.node.type === \"ArrayPattern\" ||\n          // ({ a: this.#x } = bar);\n          (parentParentPath.node.type === \"ObjectProperty\" &&\n            parentParentPath.node.value === parentPath.node &&\n            parentParentPath.parentPath.type === \"ObjectPattern\") ||\n          // for (this.#x of []);\n          (parentParentPath.node.type === \"ForOfStatement\" &&\n            parentParentPath.node.left === parentPath.node)\n        ) {\n          throw path.buildCodeFrameError(\n            `Decorated private methods are not updatable, but \"#${path.node.id.name}\" is updated via this expression.`,\n          );\n        }\n      },\n    });\n  }\n\n  let classInitInjected = false;\n  const classInitCall =\n    classInitLocal && t.callExpression(t.cloneNode(classInitLocal), []);\n\n  const originalClass = path.node;\n\n  if (classDecorators) {\n    locals.push(classLocal, classInitLocal);\n    const statics: (\n      | t.ClassProperty\n      | t.ClassPrivateProperty\n      | t.ClassPrivateMethod\n    )[] = [];\n    let staticBlocks: t.StaticBlock[] = [];\n    path.get(\"body.body\").forEach(element => {\n      // Static blocks cannot be compiled to \"instance blocks\", but we can inline\n      // them as IIFEs in the next property.\n      if (element.isStaticBlock()) {\n        staticBlocks.push(element.node);\n        element.remove();\n        return;\n      }\n\n      const isProperty =\n        element.isClassProperty() || element.isClassPrivateProperty();\n\n      if (\n        (isProperty || element.isClassPrivateMethod()) &&\n        element.node.static\n      ) {\n        if (isProperty && staticBlocks.length > 0) {\n          const allValues: t.Expression[] = staticBlocks.map(staticBlockToIIFE);\n          if (element.node.value) allValues.push(element.node.value);\n          element.node.value = maybeSequenceExpression(allValues);\n          staticBlocks = [];\n        }\n\n        element.node.static = false;\n        statics.push(element.node);\n        element.remove();\n      }\n    });\n\n    if (statics.length > 0 || staticBlocks.length > 0) {\n      const staticsClass = template.expression.ast`\n        class extends ${state.addHelper(\"identity\")} {}\n      ` as t.ClassExpression;\n      staticsClass.body.body = [\n        t.staticBlock([t.toStatement(path.node, false)]),\n        ...statics,\n      ];\n\n      const constructorBody: t.Expression[] = [];\n\n      const newExpr = t.newExpression(staticsClass, []);\n\n      if (staticBlocks.length > 0) {\n        constructorBody.push(...staticBlocks.map(staticBlockToIIFE));\n      }\n      if (classInitCall) {\n        classInitInjected = true;\n        constructorBody.push(classInitCall);\n      }\n      if (constructorBody.length > 0) {\n        constructorBody.unshift(\n          t.callExpression(t.super(), [t.cloneNode(classLocal)]),\n        );\n\n        staticsClass.body.body.push(\n          t.classMethod(\n            \"constructor\",\n            t.identifier(\"constructor\"),\n            [],\n            t.blockStatement([\n              t.expressionStatement(t.sequenceExpression(constructorBody)),\n            ]),\n          ),\n        );\n      } else {\n        newExpr.arguments.push(t.cloneNode(classLocal));\n      }\n\n      path.replaceWith(newExpr);\n    }\n  }\n  if (!classInitInjected && classInitCall) {\n    path.node.body.body.push(\n      t.staticBlock([t.expressionStatement(classInitCall)]),\n    );\n  }\n\n  originalClass.body.body.unshift(\n    t.staticBlock(\n      [\n        t.expressionStatement(\n          t.assignmentExpression(\n            \"=\",\n            t.arrayPattern(locals),\n            t.callExpression(\n              state.addHelper(\n                version === \"2021-12\" ? \"applyDecs\" : \"applyDecs2203\",\n              ),\n              [t.thisExpression(), elementDecorations, classDecorations],\n            ),\n          ),\n        ),\n        requiresStaticInit &&\n          t.expressionStatement(\n            t.callExpression(t.cloneNode(staticInitLocal), [\n              t.thisExpression(),\n            ]),\n          ),\n      ].filter(Boolean),\n    ),\n  );\n\n  // When path is a ClassExpression, path.insertBefore will convert `path`\n  // into a SequenceExpression\n  path.insertBefore(assignments.map(expr => t.expressionStatement(expr)));\n\n  // Recrawl the scope to make sure new identifiers are properly synced\n  path.scope.crawl();\n\n  return path;\n}\n\nexport default function (\n  { assertVersion, assumption }: PluginAPI,\n  { loose }: Options,\n  version: \"2022-03\" | \"2021-12\",\n): PluginObject {\n  assertVersion(version === \"2021-12\" ? \"^7.16.0\" : \"^7.19.0\");\n\n  const VISITED = new WeakSet<NodePath>();\n  const constantSuper = assumption(\"constantSuper\") ?? loose;\n\n  return {\n    name: \"proposal-decorators\",\n    inherits: syntaxDecorators,\n\n    visitor: {\n      \"ExportNamedDeclaration|ExportDefaultDeclaration\"(\n        path: NodePath<t.ExportNamedDeclaration | t.ExportDefaultDeclaration>,\n      ) {\n        const { declaration } = path.node;\n        if (\n          declaration?.type === \"ClassDeclaration\" &&\n          // When compiling class decorators we need to replace the class\n          // binding, so we must split it in two separate declarations.\n          declaration.decorators?.length > 0\n        ) {\n          splitExportDeclaration(path);\n        }\n      },\n\n      Class(path, state) {\n        if (VISITED.has(path)) return;\n\n        const newPath = transformClass(path, state, constantSuper, version);\n        if (newPath) VISITED.add(newPath);\n      },\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"script"}