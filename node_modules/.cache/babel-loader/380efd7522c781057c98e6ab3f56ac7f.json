{"ast":null,"code":"import * as t from \"../../lib/index.js\";\nimport stringifyValidator, { isValueType } from \"../utils/stringifyValidator.js\";\nconst parentMaps = new Map([[\"File\", new Set([\"null\"])]]);\n\nfunction registerParentMaps(parent, nodes) {\n  for (const node of nodes) {\n    if (!parentMaps.has(node)) {\n      parentMaps.set(node, new Set());\n    }\n\n    parentMaps.get(node).add(parent);\n  }\n}\n\nfunction getNodeTypesFromValidator(validator) {\n  if (validator === undefined) return [];\n\n  if (validator.each) {\n    return getNodeTypesFromValidator(validator.each);\n  }\n\n  if (validator.chainOf) {\n    return getNodeTypesFromValidator(validator.chainOf[1]);\n  }\n\n  let nodeTypes = [];\n\n  if (validator.oneOfNodeTypes) {\n    nodeTypes = validator.oneOfNodeTypes;\n  }\n\n  if (validator.oneOfNodeOrValueTypes) {\n    nodeTypes = validator.oneOfNodeOrValueTypes.filter(type => !isValueType(type));\n  }\n\n  return nodeTypes.flatMap(type => t.FLIPPED_ALIAS_KEYS[type] ?? type);\n}\n\nexport default function generateAstTypes() {\n  let code = `// NOTE: This file is autogenerated. Do not modify.\n// See packages/babel-types/scripts/generators/ast-types.js for script used.\n\ninterface BaseComment {\n  value: string;\n  start?: number;\n  end?: number;\n  loc?: SourceLocation;\n  // generator will skip the comment if ignore is true\n  ignore?: boolean;\n  type: \"CommentBlock\" | \"CommentLine\";\n}\n\nexport interface CommentBlock extends BaseComment {\n  type: \"CommentBlock\";\n}\n\nexport interface CommentLine extends BaseComment {\n  type: \"CommentLine\";\n}\n\nexport type Comment = CommentBlock | CommentLine;\n\nexport interface SourceLocation {\n  start: {\n    line: number;\n    column: number;\n  };\n\n  end: {\n    line: number;\n    column: number;\n  };\n}\n\ninterface BaseNode {\n  type: Node[\"type\"];\n  leadingComments?: Comment[] | null;\n  innerComments?: Comment[] | null;\n  trailingComments?: Comment[] | null;\n  start?: number | null;\n  end?: number | null;\n  loc?: SourceLocation | null;\n  range?: [number, number];\n  extra?: Record<string, unknown>;\n}\n\nexport type CommentTypeShorthand = \"leading\" | \"inner\" | \"trailing\";\n\nexport type Node = ${t.TYPES.filter(k => !t.FLIPPED_ALIAS_KEYS[k]).sort().join(\" | \")};\\n\\n`;\n  const deprecatedAlias = {};\n\n  for (const type in t.DEPRECATED_KEYS) {\n    deprecatedAlias[t.DEPRECATED_KEYS[type]] = type;\n  }\n\n  for (const type in t.NODE_FIELDS) {\n    const fields = t.NODE_FIELDS[type];\n    const fieldNames = sortFieldNames(Object.keys(t.NODE_FIELDS[type]), type);\n    const struct = [];\n    fieldNames.forEach(fieldName => {\n      const field = fields[fieldName]; // Future / annoying TODO:\n      // MemberExpression.property, ObjectProperty.key and ObjectMethod.key need special cases; either:\n      // - convert the declaration to chain() like ClassProperty.key and ClassMethod.key,\n      // - declare an alias type for valid keys, detect the case and reuse it here,\n      // - declare a disjoint union with, for example, ObjectPropertyBase,\n      //   ObjectPropertyLiteralKey and ObjectPropertyComputedKey, and declare ObjectProperty\n      //   as \"ObjectPropertyBase & (ObjectPropertyLiteralKey | ObjectPropertyComputedKey)\"\n\n      let typeAnnotation = stringifyValidator(field.validate, \"\");\n\n      if (isNullable(field) && !hasDefault(field)) {\n        typeAnnotation += \" | null\";\n      }\n\n      const alphaNumeric = /^\\w+$/;\n      const optional = field.optional ? \"?\" : \"\";\n\n      if (t.isValidIdentifier(fieldName) || alphaNumeric.test(fieldName)) {\n        struct.push(`${fieldName}${optional}: ${typeAnnotation};`);\n      } else {\n        struct.push(`\"${fieldName}\"${optional}: ${typeAnnotation};`);\n      }\n\n      registerParentMaps(type, getNodeTypesFromValidator(field.validate));\n    });\n    code += `export interface ${type} extends BaseNode {\n  type: \"${type}\";\n  ${struct.join(\"\\n  \").trim()}\n}\\n\\n`;\n\n    if (deprecatedAlias[type]) {\n      code += `/**\n * @deprecated Use \\`${type}\\`\n */\nexport interface ${deprecatedAlias[type]} extends BaseNode {\n  type: \"${deprecatedAlias[type]}\";\n  ${struct.join(\"\\n  \").trim()}\n}\\n\\n\n`;\n    }\n  }\n\n  for (const type in t.FLIPPED_ALIAS_KEYS) {\n    const types = t.FLIPPED_ALIAS_KEYS[type];\n    code += `export type ${type} = ${types.map(type => `${type}`).join(\" | \")};\\n`;\n  }\n\n  code += \"\\n\";\n  code += \"export interface Aliases {\\n\";\n\n  for (const type in t.FLIPPED_ALIAS_KEYS) {\n    code += `  ${type}: ${type};\\n`;\n  }\n\n  code += \"}\\n\\n\";\n  code += `export type DeprecatedAliases = ${Object.keys(t.DEPRECATED_KEYS).join(\" | \")}\\n\\n`;\n  code += \"export interface ParentMaps {\\n\";\n  registerParentMaps(\"null\", [...Object.keys(t.DEPRECATED_KEYS)]); // todo: provide a better parent type for Placeholder, currently it acts\n  // as a catch-all parent type for an abstract NodePath, s.t NodePath.parent must\n  // be a Node if type has not been specified\n\n  registerParentMaps(\"Node\", [\"Placeholder\"]);\n  const parentMapsKeys = [...parentMaps.keys()].sort();\n\n  for (const type of parentMapsKeys) {\n    const deduplicated = [...parentMaps.get(type)].sort();\n    code += `  ${type}: ${deduplicated.join(\" | \")};\\n`;\n  }\n\n  code += \"}\\n\\n\";\n  return code;\n}\n\nfunction hasDefault(field) {\n  return field.default != null;\n}\n\nfunction isNullable(field) {\n  return field.optional || hasDefault(field);\n}\n\nfunction sortFieldNames(fields, type) {\n  return fields.sort((fieldA, fieldB) => {\n    const indexA = t.BUILDER_KEYS[type].indexOf(fieldA);\n    const indexB = t.BUILDER_KEYS[type].indexOf(fieldB);\n    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;\n    if (indexA === -1) return 1;\n    if (indexB === -1) return -1;\n    return indexA - indexB;\n  });\n}","map":{"version":3,"names":["t","stringifyValidator","isValueType","parentMaps","Map","Set","registerParentMaps","parent","nodes","node","has","set","get","add","getNodeTypesFromValidator","validator","undefined","each","chainOf","nodeTypes","oneOfNodeTypes","oneOfNodeOrValueTypes","filter","type","flatMap","FLIPPED_ALIAS_KEYS","generateAstTypes","code","TYPES","k","sort","join","deprecatedAlias","DEPRECATED_KEYS","NODE_FIELDS","fields","fieldNames","sortFieldNames","Object","keys","struct","forEach","fieldName","field","typeAnnotation","validate","isNullable","hasDefault","alphaNumeric","optional","isValidIdentifier","test","push","trim","types","map","parentMapsKeys","deduplicated","default","fieldA","fieldB","indexA","BUILDER_KEYS","indexOf","indexB"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/types/scripts/generators/ast-types.js"],"sourcesContent":["import * as t from \"../../lib/index.js\";\nimport stringifyValidator, {\n  isValueType,\n} from \"../utils/stringifyValidator.js\";\n\nconst parentMaps = new Map([[\"File\", new Set([\"null\"])]]);\n\nfunction registerParentMaps(parent, nodes) {\n  for (const node of nodes) {\n    if (!parentMaps.has(node)) {\n      parentMaps.set(node, new Set());\n    }\n    parentMaps.get(node).add(parent);\n  }\n}\n\nfunction getNodeTypesFromValidator(validator) {\n  if (validator === undefined) return [];\n  if (validator.each) {\n    return getNodeTypesFromValidator(validator.each);\n  }\n  if (validator.chainOf) {\n    return getNodeTypesFromValidator(validator.chainOf[1]);\n  }\n  let nodeTypes = [];\n  if (validator.oneOfNodeTypes) {\n    nodeTypes = validator.oneOfNodeTypes;\n  }\n  if (validator.oneOfNodeOrValueTypes) {\n    nodeTypes = validator.oneOfNodeOrValueTypes.filter(\n      type => !isValueType(type)\n    );\n  }\n  return nodeTypes.flatMap(type => t.FLIPPED_ALIAS_KEYS[type] ?? type);\n}\n\nexport default function generateAstTypes() {\n  let code = `// NOTE: This file is autogenerated. Do not modify.\n// See packages/babel-types/scripts/generators/ast-types.js for script used.\n\ninterface BaseComment {\n  value: string;\n  start?: number;\n  end?: number;\n  loc?: SourceLocation;\n  // generator will skip the comment if ignore is true\n  ignore?: boolean;\n  type: \"CommentBlock\" | \"CommentLine\";\n}\n\nexport interface CommentBlock extends BaseComment {\n  type: \"CommentBlock\";\n}\n\nexport interface CommentLine extends BaseComment {\n  type: \"CommentLine\";\n}\n\nexport type Comment = CommentBlock | CommentLine;\n\nexport interface SourceLocation {\n  start: {\n    line: number;\n    column: number;\n  };\n\n  end: {\n    line: number;\n    column: number;\n  };\n}\n\ninterface BaseNode {\n  type: Node[\"type\"];\n  leadingComments?: Comment[] | null;\n  innerComments?: Comment[] | null;\n  trailingComments?: Comment[] | null;\n  start?: number | null;\n  end?: number | null;\n  loc?: SourceLocation | null;\n  range?: [number, number];\n  extra?: Record<string, unknown>;\n}\n\nexport type CommentTypeShorthand = \"leading\" | \"inner\" | \"trailing\";\n\nexport type Node = ${t.TYPES.filter(k => !t.FLIPPED_ALIAS_KEYS[k])\n    .sort()\n    .join(\" | \")};\\n\\n`;\n\n  const deprecatedAlias = {};\n  for (const type in t.DEPRECATED_KEYS) {\n    deprecatedAlias[t.DEPRECATED_KEYS[type]] = type;\n  }\n  for (const type in t.NODE_FIELDS) {\n    const fields = t.NODE_FIELDS[type];\n    const fieldNames = sortFieldNames(Object.keys(t.NODE_FIELDS[type]), type);\n    const struct = [];\n\n    fieldNames.forEach(fieldName => {\n      const field = fields[fieldName];\n      // Future / annoying TODO:\n      // MemberExpression.property, ObjectProperty.key and ObjectMethod.key need special cases; either:\n      // - convert the declaration to chain() like ClassProperty.key and ClassMethod.key,\n      // - declare an alias type for valid keys, detect the case and reuse it here,\n      // - declare a disjoint union with, for example, ObjectPropertyBase,\n      //   ObjectPropertyLiteralKey and ObjectPropertyComputedKey, and declare ObjectProperty\n      //   as \"ObjectPropertyBase & (ObjectPropertyLiteralKey | ObjectPropertyComputedKey)\"\n      let typeAnnotation = stringifyValidator(field.validate, \"\");\n\n      if (isNullable(field) && !hasDefault(field)) {\n        typeAnnotation += \" | null\";\n      }\n\n      const alphaNumeric = /^\\w+$/;\n      const optional = field.optional ? \"?\" : \"\";\n\n      if (t.isValidIdentifier(fieldName) || alphaNumeric.test(fieldName)) {\n        struct.push(`${fieldName}${optional}: ${typeAnnotation};`);\n      } else {\n        struct.push(`\"${fieldName}\"${optional}: ${typeAnnotation};`);\n      }\n\n      registerParentMaps(type, getNodeTypesFromValidator(field.validate));\n    });\n\n    code += `export interface ${type} extends BaseNode {\n  type: \"${type}\";\n  ${struct.join(\"\\n  \").trim()}\n}\\n\\n`;\n\n    if (deprecatedAlias[type]) {\n      code += `/**\n * @deprecated Use \\`${type}\\`\n */\nexport interface ${deprecatedAlias[type]} extends BaseNode {\n  type: \"${deprecatedAlias[type]}\";\n  ${struct.join(\"\\n  \").trim()}\n}\\n\\n\n`;\n    }\n  }\n\n  for (const type in t.FLIPPED_ALIAS_KEYS) {\n    const types = t.FLIPPED_ALIAS_KEYS[type];\n    code += `export type ${type} = ${types\n      .map(type => `${type}`)\n      .join(\" | \")};\\n`;\n  }\n  code += \"\\n\";\n\n  code += \"export interface Aliases {\\n\";\n  for (const type in t.FLIPPED_ALIAS_KEYS) {\n    code += `  ${type}: ${type};\\n`;\n  }\n  code += \"}\\n\\n\";\n  code += `export type DeprecatedAliases = ${Object.keys(\n    t.DEPRECATED_KEYS\n  ).join(\" | \")}\\n\\n`;\n\n  code += \"export interface ParentMaps {\\n\";\n\n  registerParentMaps(\"null\", [...Object.keys(t.DEPRECATED_KEYS)]);\n  // todo: provide a better parent type for Placeholder, currently it acts\n  // as a catch-all parent type for an abstract NodePath, s.t NodePath.parent must\n  // be a Node if type has not been specified\n  registerParentMaps(\"Node\", [\"Placeholder\"]);\n\n  const parentMapsKeys = [...parentMaps.keys()].sort();\n  for (const type of parentMapsKeys) {\n    const deduplicated = [...parentMaps.get(type)].sort();\n    code += `  ${type}: ${deduplicated.join(\" | \")};\\n`;\n  }\n  code += \"}\\n\\n\";\n\n  return code;\n}\n\nfunction hasDefault(field) {\n  return field.default != null;\n}\n\nfunction isNullable(field) {\n  return field.optional || hasDefault(field);\n}\n\nfunction sortFieldNames(fields, type) {\n  return fields.sort((fieldA, fieldB) => {\n    const indexA = t.BUILDER_KEYS[type].indexOf(fieldA);\n    const indexB = t.BUILDER_KEYS[type].indexOf(fieldB);\n    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;\n    if (indexA === -1) return 1;\n    if (indexB === -1) return -1;\n    return indexA - indexB;\n  });\n}\n"],"mappings":"AAAA,OAAO,KAAKA,CAAZ,MAAmB,oBAAnB;AACA,OAAOC,kBAAP,IACEC,WADF,QAEO,gCAFP;AAIA,MAAMC,UAAU,GAAG,IAAIC,GAAJ,CAAQ,CAAC,CAAC,MAAD,EAAS,IAAIC,GAAJ,CAAQ,CAAC,MAAD,CAAR,CAAT,CAAD,CAAR,CAAnB;;AAEA,SAASC,kBAAT,CAA4BC,MAA5B,EAAoCC,KAApC,EAA2C;EACzC,KAAK,MAAMC,IAAX,IAAmBD,KAAnB,EAA0B;IACxB,IAAI,CAACL,UAAU,CAACO,GAAX,CAAeD,IAAf,CAAL,EAA2B;MACzBN,UAAU,CAACQ,GAAX,CAAeF,IAAf,EAAqB,IAAIJ,GAAJ,EAArB;IACD;;IACDF,UAAU,CAACS,GAAX,CAAeH,IAAf,EAAqBI,GAArB,CAAyBN,MAAzB;EACD;AACF;;AAED,SAASO,yBAAT,CAAmCC,SAAnC,EAA8C;EAC5C,IAAIA,SAAS,KAAKC,SAAlB,EAA6B,OAAO,EAAP;;EAC7B,IAAID,SAAS,CAACE,IAAd,EAAoB;IAClB,OAAOH,yBAAyB,CAACC,SAAS,CAACE,IAAX,CAAhC;EACD;;EACD,IAAIF,SAAS,CAACG,OAAd,EAAuB;IACrB,OAAOJ,yBAAyB,CAACC,SAAS,CAACG,OAAV,CAAkB,CAAlB,CAAD,CAAhC;EACD;;EACD,IAAIC,SAAS,GAAG,EAAhB;;EACA,IAAIJ,SAAS,CAACK,cAAd,EAA8B;IAC5BD,SAAS,GAAGJ,SAAS,CAACK,cAAtB;EACD;;EACD,IAAIL,SAAS,CAACM,qBAAd,EAAqC;IACnCF,SAAS,GAAGJ,SAAS,CAACM,qBAAV,CAAgCC,MAAhC,CACVC,IAAI,IAAI,CAACrB,WAAW,CAACqB,IAAD,CADV,CAAZ;EAGD;;EACD,OAAOJ,SAAS,CAACK,OAAV,CAAkBD,IAAI,IAAIvB,CAAC,CAACyB,kBAAF,CAAqBF,IAArB,KAA8BA,IAAxD,CAAP;AACD;;AAED,eAAe,SAASG,gBAAT,GAA4B;EACzC,IAAIC,IAAI,GAAI;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB3B,CAAC,CAAC4B,KAAF,CAAQN,MAAR,CAAeO,CAAC,IAAI,CAAC7B,CAAC,CAACyB,kBAAF,CAAqBI,CAArB,CAArB,EAChBC,IADgB,GAEhBC,IAFgB,CAEX,KAFW,CAEJ,OAnDf;EAqDA,MAAMC,eAAe,GAAG,EAAxB;;EACA,KAAK,MAAMT,IAAX,IAAmBvB,CAAC,CAACiC,eAArB,EAAsC;IACpCD,eAAe,CAAChC,CAAC,CAACiC,eAAF,CAAkBV,IAAlB,CAAD,CAAf,GAA2CA,IAA3C;EACD;;EACD,KAAK,MAAMA,IAAX,IAAmBvB,CAAC,CAACkC,WAArB,EAAkC;IAChC,MAAMC,MAAM,GAAGnC,CAAC,CAACkC,WAAF,CAAcX,IAAd,CAAf;IACA,MAAMa,UAAU,GAAGC,cAAc,CAACC,MAAM,CAACC,IAAP,CAAYvC,CAAC,CAACkC,WAAF,CAAcX,IAAd,CAAZ,CAAD,EAAmCA,IAAnC,CAAjC;IACA,MAAMiB,MAAM,GAAG,EAAf;IAEAJ,UAAU,CAACK,OAAX,CAAmBC,SAAS,IAAI;MAC9B,MAAMC,KAAK,GAAGR,MAAM,CAACO,SAAD,CAApB,CAD8B,CAE9B;MACA;MACA;MACA;MACA;MACA;MACA;;MACA,IAAIE,cAAc,GAAG3C,kBAAkB,CAAC0C,KAAK,CAACE,QAAP,EAAiB,EAAjB,CAAvC;;MAEA,IAAIC,UAAU,CAACH,KAAD,CAAV,IAAqB,CAACI,UAAU,CAACJ,KAAD,CAApC,EAA6C;QAC3CC,cAAc,IAAI,SAAlB;MACD;;MAED,MAAMI,YAAY,GAAG,OAArB;MACA,MAAMC,QAAQ,GAAGN,KAAK,CAACM,QAAN,GAAiB,GAAjB,GAAuB,EAAxC;;MAEA,IAAIjD,CAAC,CAACkD,iBAAF,CAAoBR,SAApB,KAAkCM,YAAY,CAACG,IAAb,CAAkBT,SAAlB,CAAtC,EAAoE;QAClEF,MAAM,CAACY,IAAP,CAAa,GAAEV,SAAU,GAAEO,QAAS,KAAIL,cAAe,GAAvD;MACD,CAFD,MAEO;QACLJ,MAAM,CAACY,IAAP,CAAa,IAAGV,SAAU,IAAGO,QAAS,KAAIL,cAAe,GAAzD;MACD;;MAEDtC,kBAAkB,CAACiB,IAAD,EAAOT,yBAAyB,CAAC6B,KAAK,CAACE,QAAP,CAAhC,CAAlB;IACD,CAzBD;IA2BAlB,IAAI,IAAK,oBAAmBJ,IAAK;AACrC,WAAWA,IAAK;AAChB,IAAIiB,MAAM,CAACT,IAAP,CAAY,MAAZ,EAAoBsB,IAApB,EAA2B;AAC/B,MAHI;;IAKA,IAAIrB,eAAe,CAACT,IAAD,CAAnB,EAA2B;MACzBI,IAAI,IAAK;AACf,uBAAuBJ,IAAK;AAC5B;AACA,mBAAmBS,eAAe,CAACT,IAAD,CAAO;AACzC,WAAWS,eAAe,CAACT,IAAD,CAAO;AACjC,IAAIiB,MAAM,CAACT,IAAP,CAAY,MAAZ,EAAoBsB,IAApB,EAA2B;AAC/B;AACA,CAPM;IAQD;EACF;;EAED,KAAK,MAAM9B,IAAX,IAAmBvB,CAAC,CAACyB,kBAArB,EAAyC;IACvC,MAAM6B,KAAK,GAAGtD,CAAC,CAACyB,kBAAF,CAAqBF,IAArB,CAAd;IACAI,IAAI,IAAK,eAAcJ,IAAK,MAAK+B,KAAK,CACnCC,GAD8B,CAC1BhC,IAAI,IAAK,GAAEA,IAAK,EADU,EAE9BQ,IAF8B,CAEzB,KAFyB,CAElB,KAFf;EAGD;;EACDJ,IAAI,IAAI,IAAR;EAEAA,IAAI,IAAI,8BAAR;;EACA,KAAK,MAAMJ,IAAX,IAAmBvB,CAAC,CAACyB,kBAArB,EAAyC;IACvCE,IAAI,IAAK,KAAIJ,IAAK,KAAIA,IAAK,KAA3B;EACD;;EACDI,IAAI,IAAI,OAAR;EACAA,IAAI,IAAK,mCAAkCW,MAAM,CAACC,IAAP,CACzCvC,CAAC,CAACiC,eADuC,EAEzCF,IAFyC,CAEpC,KAFoC,CAE7B,MAFd;EAIAJ,IAAI,IAAI,iCAAR;EAEArB,kBAAkB,CAAC,MAAD,EAAS,CAAC,GAAGgC,MAAM,CAACC,IAAP,CAAYvC,CAAC,CAACiC,eAAd,CAAJ,CAAT,CAAlB,CA9HyC,CA+HzC;EACA;EACA;;EACA3B,kBAAkB,CAAC,MAAD,EAAS,CAAC,aAAD,CAAT,CAAlB;EAEA,MAAMkD,cAAc,GAAG,CAAC,GAAGrD,UAAU,CAACoC,IAAX,EAAJ,EAAuBT,IAAvB,EAAvB;;EACA,KAAK,MAAMP,IAAX,IAAmBiC,cAAnB,EAAmC;IACjC,MAAMC,YAAY,GAAG,CAAC,GAAGtD,UAAU,CAACS,GAAX,CAAeW,IAAf,CAAJ,EAA0BO,IAA1B,EAArB;IACAH,IAAI,IAAK,KAAIJ,IAAK,KAAIkC,YAAY,CAAC1B,IAAb,CAAkB,KAAlB,CAAyB,KAA/C;EACD;;EACDJ,IAAI,IAAI,OAAR;EAEA,OAAOA,IAAP;AACD;;AAED,SAASoB,UAAT,CAAoBJ,KAApB,EAA2B;EACzB,OAAOA,KAAK,CAACe,OAAN,IAAiB,IAAxB;AACD;;AAED,SAASZ,UAAT,CAAoBH,KAApB,EAA2B;EACzB,OAAOA,KAAK,CAACM,QAAN,IAAkBF,UAAU,CAACJ,KAAD,CAAnC;AACD;;AAED,SAASN,cAAT,CAAwBF,MAAxB,EAAgCZ,IAAhC,EAAsC;EACpC,OAAOY,MAAM,CAACL,IAAP,CAAY,CAAC6B,MAAD,EAASC,MAAT,KAAoB;IACrC,MAAMC,MAAM,GAAG7D,CAAC,CAAC8D,YAAF,CAAevC,IAAf,EAAqBwC,OAArB,CAA6BJ,MAA7B,CAAf;IACA,MAAMK,MAAM,GAAGhE,CAAC,CAAC8D,YAAF,CAAevC,IAAf,EAAqBwC,OAArB,CAA6BH,MAA7B,CAAf;IACA,IAAIC,MAAM,KAAKG,MAAf,EAAuB,OAAOL,MAAM,GAAGC,MAAT,GAAkB,CAAC,CAAnB,GAAuB,CAA9B;IACvB,IAAIC,MAAM,KAAK,CAAC,CAAhB,EAAmB,OAAO,CAAP;IACnB,IAAIG,MAAM,KAAK,CAAC,CAAhB,EAAmB,OAAO,CAAC,CAAR;IACnB,OAAOH,MAAM,GAAGG,MAAhB;EACD,CAPM,CAAP;AAQD"},"metadata":{},"sourceType":"module"}