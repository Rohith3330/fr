{"ast":null,"code":"'use strict';\n\nconst {\n  Node,\n  Block\n} = require('./Node');\n\nconst languages = require('./languages');\n\nconst constants = {\n  ESCAPED_CHAR_REGEX: /^\\\\./,\n  QUOTED_STRING_REGEX: /^(['\"`])((?:\\\\.|[^\\1])+?)(\\1)/,\n  NEWLINE_REGEX: /^\\r*\\n/\n};\n\nconst parse = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  const cst = new Block({\n    type: 'root',\n    nodes: []\n  });\n  const stack = [cst];\n  const name = (options.language || 'javascript').toLowerCase();\n  const lang = languages[name];\n\n  if (typeof lang === 'undefined') {\n    throw new Error(`Language \"${name}\" is not supported by strip-comments`);\n  }\n\n  const {\n    LINE_REGEX,\n    BLOCK_OPEN_REGEX,\n    BLOCK_CLOSE_REGEX\n  } = lang;\n  let block = cst;\n  let remaining = input;\n  let token;\n  let prev;\n  const source = [BLOCK_OPEN_REGEX, BLOCK_CLOSE_REGEX].filter(Boolean);\n  let tripleQuotes = false;\n\n  if (source.every(regex => regex.source === '^\"\"\"')) {\n    tripleQuotes = true;\n  }\n  /**\n   * Helpers\n   */\n\n\n  const consume = function () {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : remaining[0] || '';\n    remaining = remaining.slice(value.length);\n    return value;\n  };\n\n  const scan = function (regex) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';\n    const match = regex.exec(remaining);\n\n    if (match) {\n      consume(match[0]);\n      return {\n        type,\n        value: match[0],\n        match\n      };\n    }\n  };\n\n  const push = node => {\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.push(node);\n\n    if (node.nodes) {\n      stack.push(node);\n      block = node;\n    }\n\n    prev = node;\n  };\n\n  const pop = () => {\n    if (block.type === 'root') {\n      throw new SyntaxError('Unclosed block comment');\n    }\n\n    stack.pop();\n    block = stack[stack.length - 1];\n  };\n  /**\n   * Parse input string\n   */\n\n\n  while (remaining !== '') {\n    // escaped characters\n    if (token = scan(constants.ESCAPED_CHAR_REGEX, 'text')) {\n      push(new Node(token));\n      continue;\n    } // quoted strings\n\n\n    if (block.type !== 'block' && (!prev || !/\\w$/.test(prev.value)) && !(tripleQuotes && remaining.startsWith('\"\"\"'))) {\n      if (token = scan(constants.QUOTED_STRING_REGEX, 'text')) {\n        push(new Node(token));\n        continue;\n      }\n    } // newlines\n\n\n    if (token = scan(constants.NEWLINE_REGEX, 'newline')) {\n      push(new Node(token));\n      continue;\n    } // block comment open\n\n\n    if (BLOCK_OPEN_REGEX && options.block && !(tripleQuotes && block.type === 'block')) {\n      if (token = scan(BLOCK_OPEN_REGEX, 'open')) {\n        push(new Block({\n          type: 'block'\n        }));\n        push(new Node(token));\n        continue;\n      }\n    } // block comment close\n\n\n    if (BLOCK_CLOSE_REGEX && block.type === 'block' && options.block) {\n      if (token = scan(BLOCK_CLOSE_REGEX, 'close')) {\n        token.newline = token.match[1] || '';\n        push(new Node(token));\n        pop();\n        continue;\n      }\n    } // line comment\n\n\n    if (LINE_REGEX && block.type !== 'block' && options.line) {\n      if (token = scan(LINE_REGEX, 'line')) {\n        push(new Node(token));\n        continue;\n      }\n    } // Plain text (skip \"C\" since some languages use \"C\" to start comments)\n\n\n    if (token = scan(/^[a-zABD-Z0-9\\t ]+/, 'text')) {\n      push(new Node(token));\n      continue;\n    }\n\n    push(new Node({\n      type: 'text',\n      value: consume(remaining[0])\n    }));\n  }\n\n  return cst;\n};\n\nmodule.exports = parse;","map":{"version":3,"names":["Node","Block","require","languages","constants","ESCAPED_CHAR_REGEX","QUOTED_STRING_REGEX","NEWLINE_REGEX","parse","input","options","TypeError","cst","type","nodes","stack","name","language","toLowerCase","lang","Error","LINE_REGEX","BLOCK_OPEN_REGEX","BLOCK_CLOSE_REGEX","block","remaining","token","prev","source","filter","Boolean","tripleQuotes","every","regex","consume","value","slice","length","scan","match","exec","push","node","pop","SyntaxError","test","startsWith","newline","line","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/strip-comments/lib/parse.js"],"sourcesContent":["'use strict';\n\nconst { Node, Block } = require('./Node');\nconst languages = require('./languages');\n\nconst constants = {\n  ESCAPED_CHAR_REGEX: /^\\\\./,\n  QUOTED_STRING_REGEX: /^(['\"`])((?:\\\\.|[^\\1])+?)(\\1)/,\n  NEWLINE_REGEX: /^\\r*\\n/\n};\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  const cst = new Block({ type: 'root', nodes: [] });\n  const stack = [cst];\n  const name = (options.language || 'javascript').toLowerCase();\n  const lang = languages[name];\n\n  if (typeof lang === 'undefined') {\n    throw new Error(`Language \"${name}\" is not supported by strip-comments`);\n  }\n\n  const { LINE_REGEX, BLOCK_OPEN_REGEX, BLOCK_CLOSE_REGEX } = lang;\n  let block = cst;\n  let remaining = input;\n  let token;\n  let prev;\n\n  const source = [BLOCK_OPEN_REGEX, BLOCK_CLOSE_REGEX].filter(Boolean);\n  let tripleQuotes = false;\n\n  if (source.every(regex => regex.source === '^\"\"\"')) {\n    tripleQuotes = true;\n  }\n\n  /**\n   * Helpers\n   */\n\n  const consume = (value = remaining[0] || '') => {\n    remaining = remaining.slice(value.length);\n    return value;\n  };\n\n  const scan = (regex, type = 'text') => {\n    const match = regex.exec(remaining);\n    if (match) {\n      consume(match[0]);\n      return { type, value: match[0], match };\n    }\n  };\n\n  const push = node => {\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n    block.push(node);\n    if (node.nodes) {\n      stack.push(node);\n      block = node;\n    }\n    prev = node;\n  };\n\n  const pop = () => {\n    if (block.type === 'root') {\n      throw new SyntaxError('Unclosed block comment');\n    }\n    stack.pop();\n    block = stack[stack.length - 1];\n  };\n\n  /**\n   * Parse input string\n   */\n\n  while (remaining !== '') {\n    // escaped characters\n    if ((token = scan(constants.ESCAPED_CHAR_REGEX, 'text'))) {\n      push(new Node(token));\n      continue;\n    }\n\n    // quoted strings\n    if (block.type !== 'block' && (!prev || !/\\w$/.test(prev.value)) && !(tripleQuotes && remaining.startsWith('\"\"\"'))) {\n      if ((token = scan(constants.QUOTED_STRING_REGEX, 'text'))) {\n        push(new Node(token));\n        continue;\n      }\n    }\n\n    // newlines\n    if ((token = scan(constants.NEWLINE_REGEX, 'newline'))) {\n      push(new Node(token));\n      continue;\n    }\n\n    // block comment open\n    if (BLOCK_OPEN_REGEX && options.block && !(tripleQuotes && block.type === 'block')) {\n      if ((token = scan(BLOCK_OPEN_REGEX, 'open'))) {\n        push(new Block({ type: 'block' }));\n        push(new Node(token));\n        continue;\n      }\n    }\n\n    // block comment close\n    if (BLOCK_CLOSE_REGEX && block.type === 'block' && options.block) {\n      if ((token = scan(BLOCK_CLOSE_REGEX, 'close'))) {\n        token.newline = token.match[1] || '';\n        push(new Node(token));\n        pop();\n        continue;\n      }\n    }\n\n    // line comment\n    if (LINE_REGEX && block.type !== 'block' && options.line) {\n      if ((token = scan(LINE_REGEX, 'line'))) {\n        push(new Node(token));\n        continue;\n      }\n    }\n\n    // Plain text (skip \"C\" since some languages use \"C\" to start comments)\n    if ((token = scan(/^[a-zABD-Z0-9\\t ]+/, 'text'))) {\n      push(new Node(token));\n      continue;\n    }\n\n    push(new Node({ type: 'text', value: consume(remaining[0]) }));\n  }\n\n  return cst;\n};\n\nmodule.exports = parse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}