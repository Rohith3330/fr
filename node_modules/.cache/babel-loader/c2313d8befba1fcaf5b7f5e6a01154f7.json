{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: () => expandApplyAtRules\n});\n\nconst _postcss = /*#__PURE__*/_interopRequireDefault(require(\"postcss\"));\n\nconst _postcssSelectorParser = /*#__PURE__*/_interopRequireDefault(require(\"postcss-selector-parser\"));\n\nconst _generateRules = require(\"./generateRules\");\n\nconst _bigSign = /*#__PURE__*/_interopRequireDefault(require(\"../util/bigSign\"));\n\nconst _escapeClassName = /*#__PURE__*/_interopRequireDefault(require(\"../util/escapeClassName\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */\n\n\nfunction extractClasses(node) {\n  /** @type {Map<string, Set<string>>} */\n  let groups = new Map();\n\n  let container = _postcss.default.root({\n    nodes: [node.clone()]\n  });\n\n  container.walkRules(rule => {\n    (0, _postcssSelectorParser.default)(selectors => {\n      selectors.walkClasses(classSelector => {\n        let parentSelector = classSelector.parent.toString();\n        let classes = groups.get(parentSelector);\n\n        if (!classes) {\n          groups.set(parentSelector, classes = new Set());\n        }\n\n        classes.add(classSelector.value);\n      });\n    }).processSync(rule.selector);\n  });\n  let normalizedGroups = Array.from(groups.values(), classes => Array.from(classes));\n  let classes = normalizedGroups.flat();\n  return Object.assign(classes, {\n    groups: normalizedGroups\n  });\n}\n\nlet selectorExtractor = (0, _postcssSelectorParser.default)(root => root.nodes.map(node => node.toString()));\n/**\n * @param {string} ruleSelectors\n */\n\nfunction extractSelectors(ruleSelectors) {\n  return selectorExtractor.transformSync(ruleSelectors);\n}\n\nfunction extractBaseCandidates(candidates, separator) {\n  let baseClasses = new Set();\n\n  for (let candidate of candidates) {\n    baseClasses.add(candidate.split(separator).pop());\n  }\n\n  return Array.from(baseClasses);\n}\n\nfunction prefix(context, selector) {\n  let prefix = context.tailwindConfig.prefix;\n  return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\n\nfunction* pathToRoot(node) {\n  yield node;\n\n  while (node.parent) {\n    yield node.parent;\n    node = node.parent;\n  }\n}\n/**\n * Only clone the node itself and not its children\n *\n * @param {*} node\n * @param {*} overrides\n * @returns\n */\n\n\nfunction shallowClone(node) {\n  let overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let children = node.nodes;\n  node.nodes = [];\n  let tmp = node.clone(overrides);\n  node.nodes = children;\n  return tmp;\n}\n/**\n * Clone just the nodes all the way to the top that are required to represent\n * this singular rule in the tree.\n *\n * For example, if we have CSS like this:\n * ```css\n * @media (min-width: 768px) {\n *   @supports (display: grid) {\n *     .foo {\n *       display: grid;\n *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n *     }\n *   }\n *\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n *\n *   .baz {\n *     color: orange;\n *   }\n * }\n * ```\n *\n * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:\n *\n * ```css\n * @media (min-width: 768px) {\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n * }\n * ```\n *\n * @param {import('postcss').Node} node\n */\n\n\nfunction nestedClone(node) {\n  for (let parent of pathToRoot(node)) {\n    if (node === parent) {\n      continue;\n    }\n\n    if (parent.type === \"root\") {\n      break;\n    }\n\n    node = shallowClone(parent, {\n      nodes: [node]\n    });\n  }\n\n  return node;\n}\n/**\n * @param {import('postcss').Root} root\n */\n\n\nfunction buildLocalApplyCache(root, context) {\n  /** @type {ApplyCache} */\n  let cache = new Map();\n  let highestOffset = context.layerOrder.user >> 4n;\n  root.walkRules((rule, idx) => {\n    // Ignore rules generated by Tailwind\n    for (let node of pathToRoot(rule)) {\n      var ref;\n\n      if (((ref = node.raws.tailwind) === null || ref === void 0 ? void 0 : ref.layer) !== undefined) {\n        return;\n      }\n    } // Clone what's required to represent this singular rule in the tree\n\n\n    let container = nestedClone(rule);\n\n    for (let className of extractClasses(rule)) {\n      let list = cache.get(className) || [];\n      cache.set(className, list);\n      list.push([{\n        layer: \"user\",\n        sort: BigInt(idx) + highestOffset,\n        important: false\n      }, container]);\n    }\n  });\n  return cache;\n}\n/**\n * @returns {ApplyCache}\n */\n\n\nfunction buildApplyCache(applyCandidates, context) {\n  for (let candidate of applyCandidates) {\n    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n      continue;\n    }\n\n    if (context.classCache.has(candidate)) {\n      context.applyClassCache.set(candidate, context.classCache.get(candidate).map(_ref => {\n        let [meta, rule] = _ref;\n        return [meta, rule.clone()];\n      }));\n      continue;\n    }\n\n    let matches = Array.from((0, _generateRules.resolveMatches)(candidate, context));\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n\n    context.applyClassCache.set(candidate, matches);\n  }\n\n  return context.applyClassCache;\n}\n/**\n * Build a cache only when it's first used\n *\n * @param {() => ApplyCache} buildCacheFn\n * @returns {ApplyCache}\n */\n\n\nfunction lazyCache(buildCacheFn) {\n  let cache = null;\n  return {\n    get: name => {\n      cache = cache || buildCacheFn();\n      return cache.get(name);\n    },\n    has: name => {\n      cache = cache || buildCacheFn();\n      return cache.has(name);\n    }\n  };\n}\n/**\n * Take a series of multiple caches and merge\n * them so they act like one large cache\n *\n * @param {ApplyCache[]} caches\n * @returns {ApplyCache}\n */\n\n\nfunction combineCaches(caches) {\n  return {\n    get: name => caches.flatMap(cache => cache.get(name) || []),\n    has: name => caches.some(cache => cache.has(name))\n  };\n}\n\nfunction extractApplyCandidates(params) {\n  let candidates = params.split(/[\\s\\t\\n]+/g);\n\n  if (candidates[candidates.length - 1] === \"!important\") {\n    return [candidates.slice(0, -1), true];\n  }\n\n  return [candidates, false];\n}\n\nfunction processApply(root, context, localCache) {\n  let applyCandidates = new Set(); // Collect all @apply rules and candidates\n\n  let applies = [];\n  root.walkAtRules(\"apply\", rule => {\n    let [candidates] = extractApplyCandidates(rule.params);\n\n    for (let util of candidates) {\n      applyCandidates.add(util);\n    }\n\n    applies.push(rule);\n  }); // Start the @apply process if we have rules with @apply in them\n\n  if (applies.length === 0) {\n    return;\n  } // Fill up some caches!\n\n\n  let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)]);\n  /**\n  * When we have an apply like this:\n  *\n  * .abc {\n  *    @apply hover:font-bold;\n  * }\n  *\n  * What we essentially will do is resolve to this:\n  *\n  * .abc {\n  *    @apply .hover\\:font-bold:hover {\n  *      font-weight: 500;\n  *    }\n  * }\n  *\n  * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n  * What happens in this function is that we prepend a `.` and escape the candidate.\n  * This will result in `.hover\\:font-bold`\n  * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n  */\n  // TODO: Should we use postcss-selector-parser for this instead?\n\n  function replaceSelector(selector, utilitySelectors, candidate) {\n    let needle = `.${(0, _escapeClassName.default)(candidate)}`;\n    let needles = [...new Set([needle, needle.replace(/\\\\2c /g, \"\\\\,\")])];\n    let utilitySelectorsList = extractSelectors(utilitySelectors);\n    return extractSelectors(selector).map(s => {\n      let replaced = [];\n\n      for (let utilitySelector of utilitySelectorsList) {\n        let replacedSelector = utilitySelector;\n\n        for (const needle of needles) {\n          replacedSelector = replacedSelector.replace(needle, s);\n        }\n\n        if (replacedSelector === utilitySelector) {\n          continue;\n        }\n\n        replaced.push(replacedSelector);\n      }\n\n      return replaced.join(\", \");\n    }).join(\", \");\n  }\n\n  let perParentApplies = new Map(); // Collect all apply candidates and their rules\n\n  for (let apply of applies) {\n    let [candidates] = perParentApplies.get(apply.parent) || [[], apply.source];\n    perParentApplies.set(apply.parent, [candidates, apply.source]);\n    let [applyCandidates1, important] = extractApplyCandidates(apply.params);\n\n    if (apply.parent.type === \"atrule\") {\n      if (apply.parent.name === \"screen\") {\n        const screenType = apply.parent.params;\n        throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates1.map(c => `${screenType}:${c}`).join(\" \")} instead.`);\n      }\n\n      throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);\n    }\n\n    for (let applyCandidate of applyCandidates1) {\n      if ([prefix(context, \"group\"), prefix(context, \"peer\")].includes(applyCandidate)) {\n        // TODO: Link to specific documentation page with error code.\n        throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);\n      }\n\n      if (!applyClassCache.has(applyCandidate)) {\n        throw apply.error(`The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`);\n      }\n\n      let rules = applyClassCache.get(applyCandidate);\n      candidates.push([applyCandidate, important, rules]);\n    }\n  }\n\n  for (const [parent, [candidates1, atApplySource]] of perParentApplies) {\n    let siblings = [];\n\n    for (let [applyCandidate1, important1, rules1] of candidates1) {\n      let potentialApplyCandidates = [applyCandidate1, ...extractBaseCandidates([applyCandidate1], context.tailwindConfig.separator)];\n\n      for (let [meta, node] of rules1) {\n        let parentClasses = extractClasses(parent);\n        let nodeClasses = extractClasses(node); // When we encounter a rule like `.dark .a, .b { … }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`\n        // So we've split them into groups\n\n        nodeClasses = nodeClasses.groups.filter(classList => classList.some(className => potentialApplyCandidates.includes(className))).flat(); // Add base utility classes from the @apply node to the list of\n        // classes to check whether it intersects and therefore results in a\n        // circular dependency or not.\n        //\n        // E.g.:\n        // .foo {\n        //   @apply hover:a; // This applies \"a\" but with a modifier\n        // }\n        //\n        // We only have to do that with base classes of the `node`, not of the `parent`\n        // E.g.:\n        // .hover\\:foo {\n        //   @apply bar;\n        // }\n        // .bar {\n        //   @apply foo;\n        // }\n        //\n        // This should not result in a circular dependency because we are\n        // just applying `.foo` and the rule above is `.hover\\:foo` which is\n        // unrelated. However, if we were to apply `hover:foo` then we _did_\n        // have to include this one.\n\n        nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));\n        let intersects = parentClasses.some(selector => nodeClasses.includes(selector));\n\n        if (intersects) {\n          throw node.error(`You cannot \\`@apply\\` the \\`${applyCandidate1}\\` utility here because it creates a circular dependency.`);\n        }\n\n        let root1 = _postcss.default.root({\n          nodes: [node.clone()]\n        }); // Make sure every node in the entire tree points back at the @apply rule that generated it\n\n\n        root1.walk(node => {\n          node.source = atApplySource;\n        });\n        let canRewriteSelector = node.type !== \"atrule\" || node.type === \"atrule\" && node.name !== \"keyframes\";\n\n        if (canRewriteSelector) {\n          root1.walkRules(rule => {\n            // Let's imagine you have the following structure:\n            //\n            // .foo {\n            //   @apply bar;\n            // }\n            //\n            // @supports (a: b) {\n            //   .bar {\n            //     color: blue\n            //   }\n            //\n            //   .something-unrelated {}\n            // }\n            //\n            // In this case we want to apply `.bar` but it happens to be in\n            // an atrule node. We clone that node instead of the nested one\n            // because we still want that @supports rule to be there once we\n            // applied everything.\n            //\n            // However it happens to be that the `.something-unrelated` is\n            // also in that same shared @supports atrule. This is not good,\n            // and this should not be there. The good part is that this is\n            // a clone already and it can be safely removed. The question is\n            // how do we know we can remove it. Basically what we can do is\n            // match it against the applyCandidate that you want to apply. If\n            // it doesn't match the we can safely delete it.\n            //\n            // If we didn't do this, then the `replaceSelector` function\n            // would have replaced this with something that didn't exist and\n            // therefore it removed the selector altogether. In this specific\n            // case it would result in `{}` instead of `.something-unrelated {}`\n            if (!extractClasses(rule).some(candidate => candidate === applyCandidate1)) {\n              rule.remove();\n              return;\n            } // Strip the important selector from the parent selector if at the beginning\n\n\n            let importantSelector = typeof context.tailwindConfig.important === \"string\" ? context.tailwindConfig.important : null; // We only want to move the \"important\" selector if this is a Tailwind-generated utility\n            // We do *not* want to do this for user CSS that happens to be structured the same\n\n            let isGenerated = parent.raws.tailwind !== undefined;\n            let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;\n            rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate1); // And then re-add it if it was removed\n\n            if (importantSelector && parentSelector !== parent.selector) {\n              rule.selector = `${importantSelector} ${rule.selector}`;\n            }\n\n            rule.walkDecls(d => {\n              d.important = meta.important || important1;\n            });\n          });\n        } // It could be that the node we were inserted was removed because the class didn't match\n        // If that was the *only* rule in the parent, then we have nothing add so we skip it\n\n\n        if (!root1.nodes[0]) {\n          continue;\n        } // Insert it\n\n\n        siblings.push([// Ensure that when we are sorting, that we take the layer order into account\n        { ...meta,\n          sort: meta.sort | context.layerOrder[meta.layer]\n        }, root1.nodes[0]]);\n      }\n    } // Inject the rules, sorted, correctly\n\n\n    let nodes = siblings.sort((_ref2, _ref3) => {\n      let [a] = _ref2;\n      let [z] = _ref3;\n      return (0, _bigSign.default)(a.sort - z.sort);\n    }).map(s => s[1]); // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n\n    parent.after(nodes);\n  }\n\n  for (let apply1 of applies) {\n    // If there are left-over declarations, just remove the @apply\n    if (apply1.parent.nodes.length > 1) {\n      apply1.remove();\n    } else {\n      // The node is empty, drop the full node\n      apply1.parent.remove();\n    }\n  } // Do it again, in case we have other `@apply` rules\n\n\n  processApply(root, context, localCache);\n}\n\nfunction expandApplyAtRules(context) {\n  return root => {\n    // Build a cache of the user's CSS so we can use it to resolve classes used by @apply\n    let localCache = lazyCache(() => buildLocalApplyCache(root, context));\n    processApply(root, context, localCache);\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","expandApplyAtRules","_postcss","_interopRequireDefault","require","_postcssSelectorParser","_generateRules","_bigSign","_escapeClassName","obj","__esModule","default","extractClasses","node","groups","Map","container","root","nodes","clone","walkRules","rule","selectors","walkClasses","classSelector","parentSelector","parent","toString","classes","set","Set","add","processSync","selector","normalizedGroups","Array","from","values","flat","assign","selectorExtractor","map","extractSelectors","ruleSelectors","transformSync","extractBaseCandidates","candidates","separator","baseClasses","candidate","split","pop","prefix","context","tailwindConfig","pathToRoot","shallowClone","overrides","children","tmp","nestedClone","type","buildLocalApplyCache","cache","highestOffset","layerOrder","user","idx","ref","raws","tailwind","layer","undefined","className","list","push","sort","BigInt","important","buildApplyCache","applyCandidates","notClassCache","has","applyClassCache","classCache","meta","matches","resolveMatches","length","lazyCache","buildCacheFn","name","combineCaches","caches","flatMap","some","extractApplyCandidates","params","slice","processApply","localCache","applies","walkAtRules","util","replaceSelector","utilitySelectors","needle","needles","replace","utilitySelectorsList","s","replaced","utilitySelector","replacedSelector","join","perParentApplies","apply","source","applyCandidates1","screenType","error","c","applyCandidate","includes","rules","candidates1","atApplySource","siblings","applyCandidate1","important1","rules1","potentialApplyCandidates","parentClasses","nodeClasses","filter","classList","concat","intersects","root1","walk","canRewriteSelector","remove","importantSelector","isGenerated","indexOf","walkDecls","d","a","z","after","apply1"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/lib/lib/expandApplyAtRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: ()=>expandApplyAtRules\n});\nconst _postcss = /*#__PURE__*/ _interopRequireDefault(require(\"postcss\"));\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _generateRules = require(\"./generateRules\");\nconst _bigSign = /*#__PURE__*/ _interopRequireDefault(require(\"../util/bigSign\"));\nconst _escapeClassName = /*#__PURE__*/ _interopRequireDefault(require(\"../util/escapeClassName\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */ function extractClasses(node) {\n    /** @type {Map<string, Set<string>>} */ let groups = new Map();\n    let container = _postcss.default.root({\n        nodes: [\n            node.clone()\n        ]\n    });\n    container.walkRules((rule)=>{\n        (0, _postcssSelectorParser.default)((selectors)=>{\n            selectors.walkClasses((classSelector)=>{\n                let parentSelector = classSelector.parent.toString();\n                let classes = groups.get(parentSelector);\n                if (!classes) {\n                    groups.set(parentSelector, classes = new Set());\n                }\n                classes.add(classSelector.value);\n            });\n        }).processSync(rule.selector);\n    });\n    let normalizedGroups = Array.from(groups.values(), (classes)=>Array.from(classes));\n    let classes = normalizedGroups.flat();\n    return Object.assign(classes, {\n        groups: normalizedGroups\n    });\n}\nlet selectorExtractor = (0, _postcssSelectorParser.default)((root)=>root.nodes.map((node)=>node.toString()));\n/**\n * @param {string} ruleSelectors\n */ function extractSelectors(ruleSelectors) {\n    return selectorExtractor.transformSync(ruleSelectors);\n}\nfunction extractBaseCandidates(candidates, separator) {\n    let baseClasses = new Set();\n    for (let candidate of candidates){\n        baseClasses.add(candidate.split(separator).pop());\n    }\n    return Array.from(baseClasses);\n}\nfunction prefix(context, selector) {\n    let prefix = context.tailwindConfig.prefix;\n    return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction* pathToRoot(node) {\n    yield node;\n    while(node.parent){\n        yield node.parent;\n        node = node.parent;\n    }\n}\n/**\n * Only clone the node itself and not its children\n *\n * @param {*} node\n * @param {*} overrides\n * @returns\n */ function shallowClone(node, overrides = {}) {\n    let children = node.nodes;\n    node.nodes = [];\n    let tmp = node.clone(overrides);\n    node.nodes = children;\n    return tmp;\n}\n/**\n * Clone just the nodes all the way to the top that are required to represent\n * this singular rule in the tree.\n *\n * For example, if we have CSS like this:\n * ```css\n * @media (min-width: 768px) {\n *   @supports (display: grid) {\n *     .foo {\n *       display: grid;\n *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n *     }\n *   }\n *\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n *\n *   .baz {\n *     color: orange;\n *   }\n * }\n * ```\n *\n * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:\n *\n * ```css\n * @media (min-width: 768px) {\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n * }\n * ```\n *\n * @param {import('postcss').Node} node\n */ function nestedClone(node) {\n    for (let parent of pathToRoot(node)){\n        if (node === parent) {\n            continue;\n        }\n        if (parent.type === \"root\") {\n            break;\n        }\n        node = shallowClone(parent, {\n            nodes: [\n                node\n            ]\n        });\n    }\n    return node;\n}\n/**\n * @param {import('postcss').Root} root\n */ function buildLocalApplyCache(root, context) {\n    /** @type {ApplyCache} */ let cache = new Map();\n    let highestOffset = context.layerOrder.user >> 4n;\n    root.walkRules((rule, idx)=>{\n        // Ignore rules generated by Tailwind\n        for (let node of pathToRoot(rule)){\n            var ref;\n            if (((ref = node.raws.tailwind) === null || ref === void 0 ? void 0 : ref.layer) !== undefined) {\n                return;\n            }\n        }\n        // Clone what's required to represent this singular rule in the tree\n        let container = nestedClone(rule);\n        for (let className of extractClasses(rule)){\n            let list = cache.get(className) || [];\n            cache.set(className, list);\n            list.push([\n                {\n                    layer: \"user\",\n                    sort: BigInt(idx) + highestOffset,\n                    important: false\n                },\n                container, \n            ]);\n        }\n    });\n    return cache;\n}\n/**\n * @returns {ApplyCache}\n */ function buildApplyCache(applyCandidates, context) {\n    for (let candidate of applyCandidates){\n        if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n            continue;\n        }\n        if (context.classCache.has(candidate)) {\n            context.applyClassCache.set(candidate, context.classCache.get(candidate).map(([meta, rule])=>[\n                    meta,\n                    rule.clone()\n                ]));\n            continue;\n        }\n        let matches = Array.from((0, _generateRules.resolveMatches)(candidate, context));\n        if (matches.length === 0) {\n            context.notClassCache.add(candidate);\n            continue;\n        }\n        context.applyClassCache.set(candidate, matches);\n    }\n    return context.applyClassCache;\n}\n/**\n * Build a cache only when it's first used\n *\n * @param {() => ApplyCache} buildCacheFn\n * @returns {ApplyCache}\n */ function lazyCache(buildCacheFn) {\n    let cache = null;\n    return {\n        get: (name)=>{\n            cache = cache || buildCacheFn();\n            return cache.get(name);\n        },\n        has: (name)=>{\n            cache = cache || buildCacheFn();\n            return cache.has(name);\n        }\n    };\n}\n/**\n * Take a series of multiple caches and merge\n * them so they act like one large cache\n *\n * @param {ApplyCache[]} caches\n * @returns {ApplyCache}\n */ function combineCaches(caches) {\n    return {\n        get: (name)=>caches.flatMap((cache)=>cache.get(name) || []),\n        has: (name)=>caches.some((cache)=>cache.has(name))\n    };\n}\nfunction extractApplyCandidates(params) {\n    let candidates = params.split(/[\\s\\t\\n]+/g);\n    if (candidates[candidates.length - 1] === \"!important\") {\n        return [\n            candidates.slice(0, -1),\n            true\n        ];\n    }\n    return [\n        candidates,\n        false\n    ];\n}\nfunction processApply(root, context, localCache) {\n    let applyCandidates = new Set();\n    // Collect all @apply rules and candidates\n    let applies = [];\n    root.walkAtRules(\"apply\", (rule)=>{\n        let [candidates] = extractApplyCandidates(rule.params);\n        for (let util of candidates){\n            applyCandidates.add(util);\n        }\n        applies.push(rule);\n    });\n    // Start the @apply process if we have rules with @apply in them\n    if (applies.length === 0) {\n        return;\n    }\n    // Fill up some caches!\n    let applyClassCache = combineCaches([\n        localCache,\n        buildApplyCache(applyCandidates, context)\n    ]);\n    /**\n   * When we have an apply like this:\n   *\n   * .abc {\n   *    @apply hover:font-bold;\n   * }\n   *\n   * What we essentially will do is resolve to this:\n   *\n   * .abc {\n   *    @apply .hover\\:font-bold:hover {\n   *      font-weight: 500;\n   *    }\n   * }\n   *\n   * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n   * What happens in this function is that we prepend a `.` and escape the candidate.\n   * This will result in `.hover\\:font-bold`\n   * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n   */ // TODO: Should we use postcss-selector-parser for this instead?\n    function replaceSelector(selector, utilitySelectors, candidate) {\n        let needle = `.${(0, _escapeClassName.default)(candidate)}`;\n        let needles = [\n            ...new Set([\n                needle,\n                needle.replace(/\\\\2c /g, \"\\\\,\")\n            ])\n        ];\n        let utilitySelectorsList = extractSelectors(utilitySelectors);\n        return extractSelectors(selector).map((s)=>{\n            let replaced = [];\n            for (let utilitySelector of utilitySelectorsList){\n                let replacedSelector = utilitySelector;\n                for (const needle of needles){\n                    replacedSelector = replacedSelector.replace(needle, s);\n                }\n                if (replacedSelector === utilitySelector) {\n                    continue;\n                }\n                replaced.push(replacedSelector);\n            }\n            return replaced.join(\", \");\n        }).join(\", \");\n    }\n    let perParentApplies = new Map();\n    // Collect all apply candidates and their rules\n    for (let apply of applies){\n        let [candidates] = perParentApplies.get(apply.parent) || [\n            [],\n            apply.source\n        ];\n        perParentApplies.set(apply.parent, [\n            candidates,\n            apply.source\n        ]);\n        let [applyCandidates1, important] = extractApplyCandidates(apply.params);\n        if (apply.parent.type === \"atrule\") {\n            if (apply.parent.name === \"screen\") {\n                const screenType = apply.parent.params;\n                throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates1.map((c)=>`${screenType}:${c}`).join(\" \")} instead.`);\n            }\n            throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);\n        }\n        for (let applyCandidate of applyCandidates1){\n            if ([\n                prefix(context, \"group\"),\n                prefix(context, \"peer\")\n            ].includes(applyCandidate)) {\n                // TODO: Link to specific documentation page with error code.\n                throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);\n            }\n            if (!applyClassCache.has(applyCandidate)) {\n                throw apply.error(`The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`);\n            }\n            let rules = applyClassCache.get(applyCandidate);\n            candidates.push([\n                applyCandidate,\n                important,\n                rules\n            ]);\n        }\n    }\n    for (const [parent, [candidates1, atApplySource]] of perParentApplies){\n        let siblings = [];\n        for (let [applyCandidate1, important1, rules1] of candidates1){\n            let potentialApplyCandidates = [\n                applyCandidate1,\n                ...extractBaseCandidates([\n                    applyCandidate1\n                ], context.tailwindConfig.separator), \n            ];\n            for (let [meta, node] of rules1){\n                let parentClasses = extractClasses(parent);\n                let nodeClasses = extractClasses(node);\n                // When we encounter a rule like `.dark .a, .b { … }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`\n                // So we've split them into groups\n                nodeClasses = nodeClasses.groups.filter((classList)=>classList.some((className)=>potentialApplyCandidates.includes(className))).flat();\n                // Add base utility classes from the @apply node to the list of\n                // classes to check whether it intersects and therefore results in a\n                // circular dependency or not.\n                //\n                // E.g.:\n                // .foo {\n                //   @apply hover:a; // This applies \"a\" but with a modifier\n                // }\n                //\n                // We only have to do that with base classes of the `node`, not of the `parent`\n                // E.g.:\n                // .hover\\:foo {\n                //   @apply bar;\n                // }\n                // .bar {\n                //   @apply foo;\n                // }\n                //\n                // This should not result in a circular dependency because we are\n                // just applying `.foo` and the rule above is `.hover\\:foo` which is\n                // unrelated. However, if we were to apply `hover:foo` then we _did_\n                // have to include this one.\n                nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));\n                let intersects = parentClasses.some((selector)=>nodeClasses.includes(selector));\n                if (intersects) {\n                    throw node.error(`You cannot \\`@apply\\` the \\`${applyCandidate1}\\` utility here because it creates a circular dependency.`);\n                }\n                let root1 = _postcss.default.root({\n                    nodes: [\n                        node.clone()\n                    ]\n                });\n                // Make sure every node in the entire tree points back at the @apply rule that generated it\n                root1.walk((node)=>{\n                    node.source = atApplySource;\n                });\n                let canRewriteSelector = node.type !== \"atrule\" || node.type === \"atrule\" && node.name !== \"keyframes\";\n                if (canRewriteSelector) {\n                    root1.walkRules((rule)=>{\n                        // Let's imagine you have the following structure:\n                        //\n                        // .foo {\n                        //   @apply bar;\n                        // }\n                        //\n                        // @supports (a: b) {\n                        //   .bar {\n                        //     color: blue\n                        //   }\n                        //\n                        //   .something-unrelated {}\n                        // }\n                        //\n                        // In this case we want to apply `.bar` but it happens to be in\n                        // an atrule node. We clone that node instead of the nested one\n                        // because we still want that @supports rule to be there once we\n                        // applied everything.\n                        //\n                        // However it happens to be that the `.something-unrelated` is\n                        // also in that same shared @supports atrule. This is not good,\n                        // and this should not be there. The good part is that this is\n                        // a clone already and it can be safely removed. The question is\n                        // how do we know we can remove it. Basically what we can do is\n                        // match it against the applyCandidate that you want to apply. If\n                        // it doesn't match the we can safely delete it.\n                        //\n                        // If we didn't do this, then the `replaceSelector` function\n                        // would have replaced this with something that didn't exist and\n                        // therefore it removed the selector altogether. In this specific\n                        // case it would result in `{}` instead of `.something-unrelated {}`\n                        if (!extractClasses(rule).some((candidate)=>candidate === applyCandidate1)) {\n                            rule.remove();\n                            return;\n                        }\n                        // Strip the important selector from the parent selector if at the beginning\n                        let importantSelector = typeof context.tailwindConfig.important === \"string\" ? context.tailwindConfig.important : null;\n                        // We only want to move the \"important\" selector if this is a Tailwind-generated utility\n                        // We do *not* want to do this for user CSS that happens to be structured the same\n                        let isGenerated = parent.raws.tailwind !== undefined;\n                        let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;\n                        rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate1);\n                        // And then re-add it if it was removed\n                        if (importantSelector && parentSelector !== parent.selector) {\n                            rule.selector = `${importantSelector} ${rule.selector}`;\n                        }\n                        rule.walkDecls((d)=>{\n                            d.important = meta.important || important1;\n                        });\n                    });\n                }\n                // It could be that the node we were inserted was removed because the class didn't match\n                // If that was the *only* rule in the parent, then we have nothing add so we skip it\n                if (!root1.nodes[0]) {\n                    continue;\n                }\n                // Insert it\n                siblings.push([\n                    // Ensure that when we are sorting, that we take the layer order into account\n                    {\n                        ...meta,\n                        sort: meta.sort | context.layerOrder[meta.layer]\n                    },\n                    root1.nodes[0], \n                ]);\n            }\n        }\n        // Inject the rules, sorted, correctly\n        let nodes = siblings.sort(([a], [z])=>(0, _bigSign.default)(a.sort - z.sort)).map((s)=>s[1]);\n        // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n        parent.after(nodes);\n    }\n    for (let apply1 of applies){\n        // If there are left-over declarations, just remove the @apply\n        if (apply1.parent.nodes.length > 1) {\n            apply1.remove();\n        } else {\n            // The node is empty, drop the full node\n            apply1.parent.remove();\n        }\n    }\n    // Do it again, in case we have other `@apply` rules\n    processApply(root, context, localCache);\n}\nfunction expandApplyAtRules(context) {\n    return (root)=>{\n        // Build a cache of the user's CSS so we can use it to resolve classes used by @apply\n        let localCache = lazyCache(()=>buildLocalApplyCache(root, context));\n        processApply(root, context, localCache);\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}