{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'method-signature-style',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce using a particular method signature syntax',\n      recommended: false\n    },\n    fixable: 'code',\n    messages: {\n      errorMethod: 'Shorthand method signature is forbidden. Use a function property instead.',\n      errorProperty: 'Function property signature is forbidden. Use a method shorthand instead.'\n    },\n    schema: [{\n      enum: ['property', 'method']\n    }]\n  },\n  defaultOptions: ['property'],\n\n  create(context, _ref) {\n    let [mode] = _ref;\n    const sourceCode = context.getSourceCode();\n\n    function getMethodKey(node) {\n      let key = sourceCode.getText(node.key);\n\n      if (node.computed) {\n        key = `[${key}]`;\n      }\n\n      if (node.optional) {\n        key = `${key}?`;\n      }\n\n      if (node.readonly) {\n        key = `readonly ${key}`;\n      }\n\n      return key;\n    }\n\n    function getMethodParams(node) {\n      let params = '()';\n\n      if (node.params.length > 0) {\n        const openingParen = util.nullThrows(sourceCode.getTokenBefore(node.params[0], util.isOpeningParenToken), 'Missing opening paren before first parameter');\n        const closingParen = util.nullThrows(sourceCode.getTokenAfter(node.params[node.params.length - 1], util.isClosingParenToken), 'Missing closing paren after last parameter');\n        params = sourceCode.text.substring(openingParen.range[0], closingParen.range[1]);\n      }\n\n      if (node.typeParameters != null) {\n        const typeParams = sourceCode.getText(node.typeParameters);\n        params = `${typeParams}${params}`;\n      }\n\n      return params;\n    }\n\n    function getMethodReturnType(node) {\n      return node.returnType == null ? // if the method has no return type, it implicitly has an `any` return type\n      // we just make it explicit here so we can do the fix\n      'any' : sourceCode.getText(node.returnType.typeAnnotation);\n    }\n\n    function getDelimiter(node) {\n      const lastToken = sourceCode.getLastToken(node);\n\n      if (lastToken && (util.isSemicolonToken(lastToken) || util.isCommaToken(lastToken))) {\n        return lastToken.value;\n      }\n\n      return '';\n    }\n\n    function isNodeParentModuleDeclaration(node) {\n      if (!node.parent) {\n        return false;\n      }\n\n      if (node.parent.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration) {\n        return true;\n      }\n\n      if (node.parent.type === utils_1.AST_NODE_TYPES.Program) {\n        return false;\n      }\n\n      return isNodeParentModuleDeclaration(node.parent);\n    }\n\n    return Object.assign(Object.assign({}, mode === 'property' && {\n      TSMethodSignature(methodNode) {\n        if (methodNode.kind !== 'method') {\n          return;\n        }\n\n        const parent = methodNode.parent;\n        const members = (parent === null || parent === void 0 ? void 0 : parent.type) === utils_1.AST_NODE_TYPES.TSInterfaceBody ? parent.body : (parent === null || parent === void 0 ? void 0 : parent.type) === utils_1.AST_NODE_TYPES.TSTypeLiteral ? parent.members : [];\n        const duplicatedKeyMethodNodes = members.filter(element => element.type === utils_1.AST_NODE_TYPES.TSMethodSignature && element !== methodNode && getMethodKey(element) === getMethodKey(methodNode));\n        const isParentModule = isNodeParentModuleDeclaration(methodNode);\n\n        if (duplicatedKeyMethodNodes.length > 0) {\n          if (isParentModule) {\n            context.report({\n              node: methodNode,\n              messageId: 'errorMethod'\n            });\n          } else {\n            context.report({\n              node: methodNode,\n              messageId: 'errorMethod',\n\n              *fix(fixer) {\n                const methodNodes = [methodNode, ...duplicatedKeyMethodNodes].sort((a, b) => a.range[0] < b.range[0] ? -1 : 1);\n                const typeString = methodNodes.map(node => {\n                  const params = getMethodParams(node);\n                  const returnType = getMethodReturnType(node);\n                  return `(${params} => ${returnType})`;\n                }).join(' & ');\n                const key = getMethodKey(methodNode);\n                const delimiter = getDelimiter(methodNode);\n                yield fixer.replaceText(methodNode, `${key}: ${typeString}${delimiter}`);\n\n                for (const node of duplicatedKeyMethodNodes) {\n                  const lastToken = sourceCode.getLastToken(node);\n\n                  if (lastToken) {\n                    const nextToken = sourceCode.getTokenAfter(lastToken);\n\n                    if (nextToken) {\n                      yield fixer.remove(node);\n                      yield fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], '');\n                    }\n                  }\n                }\n              }\n\n            });\n          }\n\n          return;\n        }\n\n        if (isParentModule) {\n          context.report({\n            node: methodNode,\n            messageId: 'errorMethod'\n          });\n        } else {\n          context.report({\n            node: methodNode,\n            messageId: 'errorMethod',\n            fix: fixer => {\n              const key = getMethodKey(methodNode);\n              const params = getMethodParams(methodNode);\n              const returnType = getMethodReturnType(methodNode);\n              const delimiter = getDelimiter(methodNode);\n              return fixer.replaceText(methodNode, `${key}: ${params} => ${returnType}${delimiter}`);\n            }\n          });\n        }\n      }\n\n    }), mode === 'method' && {\n      TSPropertySignature(propertyNode) {\n        var _a;\n\n        const typeNode = (_a = propertyNode.typeAnnotation) === null || _a === void 0 ? void 0 : _a.typeAnnotation;\n\n        if ((typeNode === null || typeNode === void 0 ? void 0 : typeNode.type) !== utils_1.AST_NODE_TYPES.TSFunctionType) {\n          return;\n        }\n\n        context.report({\n          node: propertyNode,\n          messageId: 'errorProperty',\n          fix: fixer => {\n            const key = getMethodKey(propertyNode);\n            const params = getMethodParams(typeNode);\n            const returnType = getMethodReturnType(typeNode);\n            const delimiter = getDelimiter(propertyNode);\n            return fixer.replaceText(propertyNode, `${key}${params}: ${returnType}${delimiter}`);\n          }\n        });\n      }\n\n    });\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","fixable","messages","errorMethod","errorProperty","schema","enum","defaultOptions","create","context","mode","sourceCode","getSourceCode","getMethodKey","node","key","getText","computed","optional","readonly","getMethodParams","params","length","openingParen","nullThrows","getTokenBefore","isOpeningParenToken","closingParen","getTokenAfter","isClosingParenToken","text","substring","range","typeParameters","typeParams","getMethodReturnType","returnType","typeAnnotation","getDelimiter","lastToken","getLastToken","isSemicolonToken","isCommaToken","value","isNodeParentModuleDeclaration","parent","utils_1","TSModuleDeclaration","Program","TSMethodSignature","methodNode","kind","members","TSInterfaceBody","body","TSTypeLiteral","duplicatedKeyMethodNodes","filter","element","isParentModule","report","messageId","fix","fixer","methodNodes","sort","a","b","typeString","map","join","delimiter","replaceText","nextToken","remove","replaceTextRange","TSPropertySignature","propertyNode","typeNode","_a","TSFunctionType"],"sources":["../../src/rules/method-signature-style.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}