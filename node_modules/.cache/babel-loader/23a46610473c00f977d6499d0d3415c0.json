{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _esutils = _interopRequireDefault(require(\"esutils\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Converts JSX Spread arguments into Object Spread, avoiding Babel's helper or Object.assign injection.\n * Input:\n * \t <div a=\"1\" {...b} />\n * Output:\n *   <div {...{ a: \"1\", ...b }} />\n * ...which Babel converts to:\n *   h(\"div\", { a: \"1\", ...b })\n */\n\n\nvar _default = _ref => {\n  let {\n    types: t\n  } = _ref;\n\n  // converts a set of JSXAttributes to an Object.assign() call\n  function convertAttributesAssign(attributes) {\n    const args = [];\n\n    for (let i = 0, current; i < attributes.length; i++) {\n      const node = attributes[i];\n\n      if (t.isJSXSpreadAttribute(node)) {\n        // the first attribute is a spread, avoid copying all other attributes onto it\n        if (i === 0) {\n          args.push(t.objectExpression([]));\n        }\n\n        current = null;\n        args.push(node.argument);\n      } else {\n        const name = getAttributeName(node);\n        const value = getAttributeValue(node);\n\n        if (!current) {\n          current = t.objectExpression([]);\n          args.push(current);\n        }\n\n        current.properties.push(t.objectProperty(name, value));\n      }\n    }\n\n    return t.callExpression(t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")), args);\n  } // Converts a JSXAttribute to the equivalent ObjectExpression property\n\n\n  function convertAttributeSpread(node) {\n    if (t.isJSXSpreadAttribute(node)) {\n      return t.spreadElement(node.argument);\n    }\n\n    const name = getAttributeName(node);\n    const value = getAttributeValue(node);\n    return t.inherits(t.objectProperty(name, value), node);\n  } // Convert a JSX attribute name to an Object expression property name\n\n\n  function getAttributeName(node) {\n    if (t.isJSXNamespacedName(node.name)) {\n      return t.stringLiteral(node.name.namespace.name + \":\" + node.name.name.name);\n    }\n\n    if (_esutils.default.keyword.isIdentifierNameES6(node.name.name)) {\n      return t.identifier(node.name.name);\n    }\n\n    return t.stringLiteral(node.name.name);\n  } // Convert a JSX attribute value to a JavaScript expression value\n\n\n  function getAttributeValue(node) {\n    let value = node.value || t.booleanLiteral(true);\n\n    if (t.isJSXExpressionContainer(value)) {\n      value = value.expression;\n    } else if (t.isStringLiteral(value)) {\n      value.value = value.value.replace(/\\n\\s+/g, \" \"); // \"raw\" JSXText should not be used from a StringLiteral because it needs to be escaped.\n\n      if (value.extra && value.extra.raw) {\n        delete value.extra.raw;\n      }\n    }\n\n    return value;\n  }\n\n  return {\n    name: \"transform-jsx-spread\",\n    visitor: {\n      JSXOpeningElement(path, state) {\n        const useSpread = state.opts.useSpread === true;\n        const hasSpread = path.node.attributes.some(attr => t.isJSXSpreadAttribute(attr)); // ignore JSX Elements without spread or with lone spread:\n\n        if (!hasSpread || path.node.attributes.length === 1) return;\n\n        if (useSpread) {\n          path.node.attributes = [t.jsxSpreadAttribute(t.objectExpression(path.node.attributes.map(convertAttributeSpread)))];\n        } else {\n          path.node.attributes = [t.jsxSpreadAttribute(convertAttributesAssign(path.node.attributes))];\n        }\n      }\n\n    }\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["exports","__esModule","default","_esutils","_interopRequireDefault","require","obj","_default","types","t","convertAttributesAssign","attributes","args","i","current","length","node","isJSXSpreadAttribute","push","objectExpression","argument","name","getAttributeName","value","getAttributeValue","properties","objectProperty","callExpression","memberExpression","identifier","convertAttributeSpread","spreadElement","inherits","isJSXNamespacedName","stringLiteral","namespace","keyword","isIdentifierNameES6","booleanLiteral","isJSXExpressionContainer","expression","isStringLiteral","replace","extra","raw","visitor","JSXOpeningElement","path","state","useSpread","opts","hasSpread","some","attr","jsxSpreadAttribute","map","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/preset-modules/lib/plugins/transform-jsx-spread/index.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _esutils = _interopRequireDefault(require(\"esutils\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Converts JSX Spread arguments into Object Spread, avoiding Babel's helper or Object.assign injection.\n * Input:\n * \t <div a=\"1\" {...b} />\n * Output:\n *   <div {...{ a: \"1\", ...b }} />\n * ...which Babel converts to:\n *   h(\"div\", { a: \"1\", ...b })\n */\nvar _default = ({\n  types: t\n}) => {\n  // converts a set of JSXAttributes to an Object.assign() call\n  function convertAttributesAssign(attributes) {\n    const args = [];\n\n    for (let i = 0, current; i < attributes.length; i++) {\n      const node = attributes[i];\n\n      if (t.isJSXSpreadAttribute(node)) {\n        // the first attribute is a spread, avoid copying all other attributes onto it\n        if (i === 0) {\n          args.push(t.objectExpression([]));\n        }\n\n        current = null;\n        args.push(node.argument);\n      } else {\n        const name = getAttributeName(node);\n        const value = getAttributeValue(node);\n\n        if (!current) {\n          current = t.objectExpression([]);\n          args.push(current);\n        }\n\n        current.properties.push(t.objectProperty(name, value));\n      }\n    }\n\n    return t.callExpression(t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")), args);\n  } // Converts a JSXAttribute to the equivalent ObjectExpression property\n\n\n  function convertAttributeSpread(node) {\n    if (t.isJSXSpreadAttribute(node)) {\n      return t.spreadElement(node.argument);\n    }\n\n    const name = getAttributeName(node);\n    const value = getAttributeValue(node);\n    return t.inherits(t.objectProperty(name, value), node);\n  } // Convert a JSX attribute name to an Object expression property name\n\n\n  function getAttributeName(node) {\n    if (t.isJSXNamespacedName(node.name)) {\n      return t.stringLiteral(node.name.namespace.name + \":\" + node.name.name.name);\n    }\n\n    if (_esutils.default.keyword.isIdentifierNameES6(node.name.name)) {\n      return t.identifier(node.name.name);\n    }\n\n    return t.stringLiteral(node.name.name);\n  } // Convert a JSX attribute value to a JavaScript expression value\n\n\n  function getAttributeValue(node) {\n    let value = node.value || t.booleanLiteral(true);\n\n    if (t.isJSXExpressionContainer(value)) {\n      value = value.expression;\n    } else if (t.isStringLiteral(value)) {\n      value.value = value.value.replace(/\\n\\s+/g, \" \"); // \"raw\" JSXText should not be used from a StringLiteral because it needs to be escaped.\n\n      if (value.extra && value.extra.raw) {\n        delete value.extra.raw;\n      }\n    }\n\n    return value;\n  }\n\n  return {\n    name: \"transform-jsx-spread\",\n    visitor: {\n      JSXOpeningElement(path, state) {\n        const useSpread = state.opts.useSpread === true;\n        const hasSpread = path.node.attributes.some(attr => t.isJSXSpreadAttribute(attr)); // ignore JSX Elements without spread or with lone spread:\n\n        if (!hasSpread || path.node.attributes.length === 1) return;\n\n        if (useSpread) {\n          path.node.attributes = [t.jsxSpreadAttribute(t.objectExpression(path.node.attributes.map(convertAttributeSpread)))];\n        } else {\n          path.node.attributes = [t.jsxSpreadAttribute(convertAttributesAssign(path.node.attributes))];\n        }\n      }\n\n    }\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"AAAA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,QAAQ,GAAGC,sBAAsB,CAACC,OAAO,CAAC,SAAD,CAAR,CAArC;;AAEA,SAASD,sBAAT,CAAgCE,GAAhC,EAAqC;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACL,UAAX,GAAwBK,GAAxB,GAA8B;IAAEJ,OAAO,EAAEI;EAAX,CAArC;AAAwD;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,QAAQ,GAAG,QAET;EAAA,IAFU;IACdC,KAAK,EAAEC;EADO,CAEV;;EACJ;EACA,SAASC,uBAAT,CAAiCC,UAAjC,EAA6C;IAC3C,MAAMC,IAAI,GAAG,EAAb;;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,OAAhB,EAAyBD,CAAC,GAAGF,UAAU,CAACI,MAAxC,EAAgDF,CAAC,EAAjD,EAAqD;MACnD,MAAMG,IAAI,GAAGL,UAAU,CAACE,CAAD,CAAvB;;MAEA,IAAIJ,CAAC,CAACQ,oBAAF,CAAuBD,IAAvB,CAAJ,EAAkC;QAChC;QACA,IAAIH,CAAC,KAAK,CAAV,EAAa;UACXD,IAAI,CAACM,IAAL,CAAUT,CAAC,CAACU,gBAAF,CAAmB,EAAnB,CAAV;QACD;;QAEDL,OAAO,GAAG,IAAV;QACAF,IAAI,CAACM,IAAL,CAAUF,IAAI,CAACI,QAAf;MACD,CARD,MAQO;QACL,MAAMC,IAAI,GAAGC,gBAAgB,CAACN,IAAD,CAA7B;QACA,MAAMO,KAAK,GAAGC,iBAAiB,CAACR,IAAD,CAA/B;;QAEA,IAAI,CAACF,OAAL,EAAc;UACZA,OAAO,GAAGL,CAAC,CAACU,gBAAF,CAAmB,EAAnB,CAAV;UACAP,IAAI,CAACM,IAAL,CAAUJ,OAAV;QACD;;QAEDA,OAAO,CAACW,UAAR,CAAmBP,IAAnB,CAAwBT,CAAC,CAACiB,cAAF,CAAiBL,IAAjB,EAAuBE,KAAvB,CAAxB;MACD;IACF;;IAED,OAAOd,CAAC,CAACkB,cAAF,CAAiBlB,CAAC,CAACmB,gBAAF,CAAmBnB,CAAC,CAACoB,UAAF,CAAa,QAAb,CAAnB,EAA2CpB,CAAC,CAACoB,UAAF,CAAa,QAAb,CAA3C,CAAjB,EAAqFjB,IAArF,CAAP;EACD,CA9BG,CA8BF;;;EAGF,SAASkB,sBAAT,CAAgCd,IAAhC,EAAsC;IACpC,IAAIP,CAAC,CAACQ,oBAAF,CAAuBD,IAAvB,CAAJ,EAAkC;MAChC,OAAOP,CAAC,CAACsB,aAAF,CAAgBf,IAAI,CAACI,QAArB,CAAP;IACD;;IAED,MAAMC,IAAI,GAAGC,gBAAgB,CAACN,IAAD,CAA7B;IACA,MAAMO,KAAK,GAAGC,iBAAiB,CAACR,IAAD,CAA/B;IACA,OAAOP,CAAC,CAACuB,QAAF,CAAWvB,CAAC,CAACiB,cAAF,CAAiBL,IAAjB,EAAuBE,KAAvB,CAAX,EAA0CP,IAA1C,CAAP;EACD,CAzCG,CAyCF;;;EAGF,SAASM,gBAAT,CAA0BN,IAA1B,EAAgC;IAC9B,IAAIP,CAAC,CAACwB,mBAAF,CAAsBjB,IAAI,CAACK,IAA3B,CAAJ,EAAsC;MACpC,OAAOZ,CAAC,CAACyB,aAAF,CAAgBlB,IAAI,CAACK,IAAL,CAAUc,SAAV,CAAoBd,IAApB,GAA2B,GAA3B,GAAiCL,IAAI,CAACK,IAAL,CAAUA,IAAV,CAAeA,IAAhE,CAAP;IACD;;IAED,IAAIlB,QAAQ,CAACD,OAAT,CAAiBkC,OAAjB,CAAyBC,mBAAzB,CAA6CrB,IAAI,CAACK,IAAL,CAAUA,IAAvD,CAAJ,EAAkE;MAChE,OAAOZ,CAAC,CAACoB,UAAF,CAAab,IAAI,CAACK,IAAL,CAAUA,IAAvB,CAAP;IACD;;IAED,OAAOZ,CAAC,CAACyB,aAAF,CAAgBlB,IAAI,CAACK,IAAL,CAAUA,IAA1B,CAAP;EACD,CAtDG,CAsDF;;;EAGF,SAASG,iBAAT,CAA2BR,IAA3B,EAAiC;IAC/B,IAAIO,KAAK,GAAGP,IAAI,CAACO,KAAL,IAAcd,CAAC,CAAC6B,cAAF,CAAiB,IAAjB,CAA1B;;IAEA,IAAI7B,CAAC,CAAC8B,wBAAF,CAA2BhB,KAA3B,CAAJ,EAAuC;MACrCA,KAAK,GAAGA,KAAK,CAACiB,UAAd;IACD,CAFD,MAEO,IAAI/B,CAAC,CAACgC,eAAF,CAAkBlB,KAAlB,CAAJ,EAA8B;MACnCA,KAAK,CAACA,KAAN,GAAcA,KAAK,CAACA,KAAN,CAAYmB,OAAZ,CAAoB,QAApB,EAA8B,GAA9B,CAAd,CADmC,CACe;;MAElD,IAAInB,KAAK,CAACoB,KAAN,IAAepB,KAAK,CAACoB,KAAN,CAAYC,GAA/B,EAAoC;QAClC,OAAOrB,KAAK,CAACoB,KAAN,CAAYC,GAAnB;MACD;IACF;;IAED,OAAOrB,KAAP;EACD;;EAED,OAAO;IACLF,IAAI,EAAE,sBADD;IAELwB,OAAO,EAAE;MACPC,iBAAiB,CAACC,IAAD,EAAOC,KAAP,EAAc;QAC7B,MAAMC,SAAS,GAAGD,KAAK,CAACE,IAAN,CAAWD,SAAX,KAAyB,IAA3C;QACA,MAAME,SAAS,GAAGJ,IAAI,CAAC/B,IAAL,CAAUL,UAAV,CAAqByC,IAArB,CAA0BC,IAAI,IAAI5C,CAAC,CAACQ,oBAAF,CAAuBoC,IAAvB,CAAlC,CAAlB,CAF6B,CAEsD;;QAEnF,IAAI,CAACF,SAAD,IAAcJ,IAAI,CAAC/B,IAAL,CAAUL,UAAV,CAAqBI,MAArB,KAAgC,CAAlD,EAAqD;;QAErD,IAAIkC,SAAJ,EAAe;UACbF,IAAI,CAAC/B,IAAL,CAAUL,UAAV,GAAuB,CAACF,CAAC,CAAC6C,kBAAF,CAAqB7C,CAAC,CAACU,gBAAF,CAAmB4B,IAAI,CAAC/B,IAAL,CAAUL,UAAV,CAAqB4C,GAArB,CAAyBzB,sBAAzB,CAAnB,CAArB,CAAD,CAAvB;QACD,CAFD,MAEO;UACLiB,IAAI,CAAC/B,IAAL,CAAUL,UAAV,GAAuB,CAACF,CAAC,CAAC6C,kBAAF,CAAqB5C,uBAAuB,CAACqC,IAAI,CAAC/B,IAAL,CAAUL,UAAX,CAA5C,CAAD,CAAvB;QACD;MACF;;IAZM;EAFJ,CAAP;AAkBD,CA7FD;;AA+FAX,OAAO,CAACE,OAAR,GAAkBK,QAAlB;AACAiD,MAAM,CAACxD,OAAP,GAAiBA,OAAO,CAACE,OAAzB"},"metadata":{},"sourceType":"script"}