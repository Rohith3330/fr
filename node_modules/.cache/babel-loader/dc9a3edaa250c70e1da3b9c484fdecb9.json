{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils = require(\"../../utils\");\n\nclass Matcher {\n  constructor(_patterns, _settings, _micromatchOptions) {\n    this._patterns = _patterns;\n    this._settings = _settings;\n    this._micromatchOptions = _micromatchOptions;\n    this._storage = [];\n\n    this._fillStorage();\n  }\n\n  _fillStorage() {\n    /**\r\n     * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).\r\n     * So, before expand patterns with brace expansion into separated patterns.\r\n     */\n    const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);\n\n    for (const pattern of patterns) {\n      const segments = this._getPatternSegments(pattern);\n\n      const sections = this._splitSegmentsIntoSections(segments);\n\n      this._storage.push({\n        complete: sections.length <= 1,\n        pattern,\n        segments,\n        sections\n      });\n    }\n  }\n\n  _getPatternSegments(pattern) {\n    const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\n    return parts.map(part => {\n      const dynamic = utils.pattern.isDynamicPattern(part, this._settings);\n\n      if (!dynamic) {\n        return {\n          dynamic: false,\n          pattern: part\n        };\n      }\n\n      return {\n        dynamic: true,\n        pattern: part,\n        patternRe: utils.pattern.makeRe(part, this._micromatchOptions)\n      };\n    });\n  }\n\n  _splitSegmentsIntoSections(segments) {\n    return utils.array.splitWhen(segments, segment => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));\n  }\n\n}\n\nexports.default = Matcher;","map":{"version":3,"names":["Object","defineProperty","exports","value","utils","require","Matcher","constructor","_patterns","_settings","_micromatchOptions","_storage","_fillStorage","patterns","pattern","expandPatternsWithBraceExpansion","segments","_getPatternSegments","sections","_splitSegmentsIntoSections","push","complete","length","parts","getPatternParts","map","part","dynamic","isDynamicPattern","patternRe","makeRe","array","splitWhen","segment","hasGlobStar","default"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/fast-glob/out/providers/matchers/matcher.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nclass Matcher {\r\n    constructor(_patterns, _settings, _micromatchOptions) {\r\n        this._patterns = _patterns;\r\n        this._settings = _settings;\r\n        this._micromatchOptions = _micromatchOptions;\r\n        this._storage = [];\r\n        this._fillStorage();\r\n    }\r\n    _fillStorage() {\r\n        /**\r\n         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).\r\n         * So, before expand patterns with brace expansion into separated patterns.\r\n         */\r\n        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);\r\n        for (const pattern of patterns) {\r\n            const segments = this._getPatternSegments(pattern);\r\n            const sections = this._splitSegmentsIntoSections(segments);\r\n            this._storage.push({\r\n                complete: sections.length <= 1,\r\n                pattern,\r\n                segments,\r\n                sections\r\n            });\r\n        }\r\n    }\r\n    _getPatternSegments(pattern) {\r\n        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\r\n        return parts.map((part) => {\r\n            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);\r\n            if (!dynamic) {\r\n                return {\r\n                    dynamic: false,\r\n                    pattern: part\r\n                };\r\n            }\r\n            return {\r\n                dynamic: true,\r\n                pattern: part,\r\n                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)\r\n            };\r\n        });\r\n    }\r\n    _splitSegmentsIntoSections(segments) {\r\n        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));\r\n    }\r\n}\r\nexports.default = Matcher;\r\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,KAAK,GAAGC,OAAO,CAAC,aAAD,CAArB;;AACA,MAAMC,OAAN,CAAc;EACVC,WAAW,CAACC,SAAD,EAAYC,SAAZ,EAAuBC,kBAAvB,EAA2C;IAClD,KAAKF,SAAL,GAAiBA,SAAjB;IACA,KAAKC,SAAL,GAAiBA,SAAjB;IACA,KAAKC,kBAAL,GAA0BA,kBAA1B;IACA,KAAKC,QAAL,GAAgB,EAAhB;;IACA,KAAKC,YAAL;EACH;;EACDA,YAAY,GAAG;IACX;AACR;AACA;AACA;IACQ,MAAMC,QAAQ,GAAGT,KAAK,CAACU,OAAN,CAAcC,gCAAd,CAA+C,KAAKP,SAApD,CAAjB;;IACA,KAAK,MAAMM,OAAX,IAAsBD,QAAtB,EAAgC;MAC5B,MAAMG,QAAQ,GAAG,KAAKC,mBAAL,CAAyBH,OAAzB,CAAjB;;MACA,MAAMI,QAAQ,GAAG,KAAKC,0BAAL,CAAgCH,QAAhC,CAAjB;;MACA,KAAKL,QAAL,CAAcS,IAAd,CAAmB;QACfC,QAAQ,EAAEH,QAAQ,CAACI,MAAT,IAAmB,CADd;QAEfR,OAFe;QAGfE,QAHe;QAIfE;MAJe,CAAnB;IAMH;EACJ;;EACDD,mBAAmB,CAACH,OAAD,EAAU;IACzB,MAAMS,KAAK,GAAGnB,KAAK,CAACU,OAAN,CAAcU,eAAd,CAA8BV,OAA9B,EAAuC,KAAKJ,kBAA5C,CAAd;IACA,OAAOa,KAAK,CAACE,GAAN,CAAWC,IAAD,IAAU;MACvB,MAAMC,OAAO,GAAGvB,KAAK,CAACU,OAAN,CAAcc,gBAAd,CAA+BF,IAA/B,EAAqC,KAAKjB,SAA1C,CAAhB;;MACA,IAAI,CAACkB,OAAL,EAAc;QACV,OAAO;UACHA,OAAO,EAAE,KADN;UAEHb,OAAO,EAAEY;QAFN,CAAP;MAIH;;MACD,OAAO;QACHC,OAAO,EAAE,IADN;QAEHb,OAAO,EAAEY,IAFN;QAGHG,SAAS,EAAEzB,KAAK,CAACU,OAAN,CAAcgB,MAAd,CAAqBJ,IAArB,EAA2B,KAAKhB,kBAAhC;MAHR,CAAP;IAKH,CAbM,CAAP;EAcH;;EACDS,0BAA0B,CAACH,QAAD,EAAW;IACjC,OAAOZ,KAAK,CAAC2B,KAAN,CAAYC,SAAZ,CAAsBhB,QAAtB,EAAiCiB,OAAD,IAAaA,OAAO,CAACN,OAAR,IAAmBvB,KAAK,CAACU,OAAN,CAAcoB,WAAd,CAA0BD,OAAO,CAACnB,OAAlC,CAAhE,CAAP;EACH;;AA5CS;;AA8CdZ,OAAO,CAACiC,OAAR,GAAkB7B,OAAlB"},"metadata":{},"sourceType":"script"}